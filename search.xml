<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>helloworld</title>
    <url>/2020/04/19/helloworld/</url>
    <content><![CDATA[<p>hello word</p>
]]></content>
      <tags>
        <tag>test, good</tag>
      </tags>
  </entry>
  <entry>
    <title>Android驱动开发与移植实战详解</title>
    <url>/2020/04/19/B008P686RA/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android驱动开发与移植实战详解<br>作者信息： 作者: 李骏 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>李骏、陈小玉编著的《Android驱动开发与移植实战详解》分为18章，依次讲解了Android系统的基本知识， Linux内核的基本知识，分析了Android系统的源码，深入分析HAL层的基本知识，GoldFish下的驱动、MSM内核和驱动、OMAP内核和驱动、显示系统驱动、输入系统驱动、振动器系统驱动、音频系统驱动和视频输出系统驱动，多媒体框架，传感器系统、照相机系统、Wi-Fi系统、蓝牙系统、GPS系统和电话系统的知识。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章　迅猛发展的Android系统</span><br><span class="line">第2章　简要分析Linux内核</span><br><span class="line">第3章　开始分析Android源码</span><br><span class="line">第4章　驱动移植</span><br><span class="line">第5章　深入详解HAL层</span><br><span class="line">第6章　常见的驱动平台</span><br><span class="line">第7章　输入系统驱动</span><br><span class="line">第8章　电话系统驱动</span><br><span class="line">第9章　显示系统驱动</span><br><span class="line">第10章　音频系统驱动</span><br><span class="line">第11章　视频输出系统驱动</span><br><span class="line">第12章　振动器系统驱动</span><br><span class="line">第13章　Android多媒体插件框架</span><br><span class="line">第14章　Camera照相机驱动</span><br><span class="line">第15章　传感器系统驱动</span><br><span class="line">第16章　Wi-Fi系统、蓝牙系统和GPS系统</span><br><span class="line">第17章　振动器驱动和警报器驱动</span><br><span class="line">第18章　光系统驱动和电池系统驱动</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B008P686RA/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B008P686RA&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51OjeqA76yL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Security Cookbook</title>
    <url>/2020/04/19/1782167161/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android Security Cookbook<br>作者信息： 作者: Keith Makan [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: ANDROID DEVELOPMENT TOOLS 2: ENGAGING WITH APPLICATION SECURITY 3: ANDROID SECURITY ASSESSMENT TOOLS 4: EXPLOITING APPLICATIONS 5: PROTECTING APPLICATIONS 6: REVERSE ENGINEERING APPLICATIONS 7: SECURE NETWORKING 8: NATIVE EXPLOITATION AND ANALYSIS 9: ENCRYPTION AND DEVELOPING DEVICE ADMINISTRATION POLICIES</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/1782167161/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=1782167161&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51GqWi7cTKL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Development Tools for Eclipse</title>
    <url>/2020/04/19/1782161104/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android Development Tools for Eclipse<br>作者信息： 作者: Sanjay Shah [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Chapter 1: Installing Eclipse, ADT, and SDK</span><br><span class="line">Introducing the Android platform</span><br><span class="line">What is Android?</span><br><span class="line">Preparing for Android development</span><br><span class="line">Linking the Android SDK to the Eclipse</span><br><span class="line">Summary</span><br><span class="line">Chapter 2: Important Features of the IDE</span><br><span class="line">Project explorer</span><br><span class="line">Code editor</span><br><span class="line">Graphical user interface designer</span><br><span class="line">Properties window</span><br><span class="line">Debugging pane</span><br><span class="line">Dalvik Debug Monitor Server (DDMS)</span><br><span class="line">SDK manager</span><br><span class="line">Android virtual device manager</span><br><span class="line">Running the Application</span><br><span class="line">Getting help</span><br><span class="line">Summary</span><br><span class="line">Chapter 3: Creating a New Android Project</span><br><span class="line">Creating a new Android application project</span><br><span class="line">String resources</span><br><span class="line">Using the graphical layout designer</span><br><span class="line">The XML layout code editor</span><br><span class="line">Widget interactions through the source code editor</span><br><span class="line">Toast message</span><br><span class="line">Running the application on the emulator</span><br><span class="line">Running the application on an Android device</span><br><span class="line">Summary</span><br><span class="line">Chapter 4: Incorporating Multimedia Elements</span><br><span class="line">Adding a TableLayout</span><br><span class="line">Adding the image resources</span><br><span class="line">Adding ImageView</span><br><span class="line">Adding ImageButtons</span><br><span class="line">Assigning the widget’s ID</span><br><span class="line">ImageButtons and handling event</span><br><span class="line">Adding audio</span><br><span class="line">Adding another screen in the app</span><br><span class="line">Adding HTML to WebView</span><br><span class="line">Intent and Activity</span><br><span class="line">The final product run and test</span><br><span class="line">Summary</span><br><span class="line">Chapter 5: Adding RadioButton, CheckBox, Menu, and Preferences</span><br><span class="line">Creating a new project</span><br><span class="line">Adding a RadioGroup, RadioButton, and a TextField</span><br><span class="line">Adding a CheckBox</span><br><span class="line">Adding a menu</span><br><span class="line">Defining the Strings</span><br><span class="line">Defining the Preference screen</span><br><span class="line">Hook up</span><br><span class="line">Run the application</span><br><span class="line">Summary</span><br><span class="line">Chapter 6: Handling Multiple Screen Types</span><br><span class="line">Using wrap_content and match_parent</span><br><span class="line">Fragment</span><br><span class="line">Running the application</span><br><span class="line">Optimizing for tablet</span><br><span class="line">Persisting the state information during the state transition</span><br><span class="line">Summary</span><br><span class="line">Chapter 7: Adding an External Library</span><br><span class="line">Creating an account at the AdMob website</span><br><span class="line">Running the application</span><br><span class="line">Summary</span><br><span class="line">Chapter 8: Signing and Distributing APK</span><br><span class="line">APK – Android package</span><br><span class="line">Preparing for release</span><br><span class="line">Using the Eclipse ADT for release</span><br><span class="line">Publishing to Google Play</span><br><span class="line">Summary</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/1782161104/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=1782161104&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/418EVZWHByL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Database Programming</title>
    <url>/2020/04/19/1849518122/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android Database Programming<br>作者信息： 作者: Jason Wei [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: STORING DATA ON ANDROID</span><br><span class="line">2: USING A SQLITE DATABASE</span><br><span class="line">3: SQLITE QUERIES</span><br><span class="line">4: USING CONTENT PROVIDERS</span><br><span class="line">5: QUERYING THE CONTACTS TABLE</span><br><span class="line">6: BINDING TO THE UI</span><br><span class="line">7: ANDROID DATABASES IN PRACTICE</span><br><span class="line">8: EXPLORING EXTERNAL DATABASES</span><br><span class="line">9: COLLECTING AND STORING DATA</span><br><span class="line">10: BRINGING IT TOGETHER</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/1849518122/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=1849518122&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51DEhDlWh7L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Android(卷1)</title>
    <url>/2020/04/19/B005K70V8E/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 深入理解Android(卷1)<br>作者信息： 作者: 邓凡平 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《深入理解Android(卷1)》：结合实际应用开发需求，以情景分析的方式有针对性地对Android的源代码进行了十分详尽的剖析，深刻揭示Android系统的工作原理。机锋网、51CTO、开源中国社区等专业技术网站一致鼎力推荐！<br>在Android领域，无论是从事上层的应用开发.还是从事底层的系统级开发，如果想成为一名优秀的开发者，通过深入探究Android的源代码来了解Android的实现原理与工作机制也许是唯一的捷径。Android Framework是Android系统的基石，也是Android的核心之一，对于上层的应用开发者而言，深入理解它的工作原理是十分有必要的。Java世界是如何通过Zygote创建的？Handler和Looper是如何工作的？Binder的工作原理是什么？Audio系统和Surface系统的工作流程是怎<br>样的？Vold、Rild、MediaScanner等是如何实现<br>的？<br>这些内容是每一位从事Android应用开发的程序员都需要学习和掌握的。<br>《深入理解Android(卷1)》用情景分析的方式对Android的源代码进行了有针对性的分析，不仅全面而详细地分析了Framework层的工作机制和实现原理，而且还涉及Native层和Application层的重要内容。每一个功能模块的分析都从实际的使用场景和具体的问题入手，每一个知识点都力求做到把实现原理讲清楚，把工作机制说明白，尽量深入.竭力避免泛泛而谈。除此之外，《深入理解Android(卷1)》在重要章节还精心设计了“拓展思考”的内容，旨在进一步激发读者学习和研究Android源代码的兴趣。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 阅读前的准备工作 &#x2F; 1</span><br><span class="line">1.1 系统架构 &#x2F; 2</span><br><span class="line">1.1.1 Android系统架构 &#x2F; 2</span><br><span class="line">1.1.2 本书的架构 &#x2F; 3</span><br><span class="line">1.2 搭建开发环境 &#x2F; 4</span><br><span class="line">1.2.1 下载源码 &#x2F; 4</span><br><span class="line">1.2.2 编译源码 &#x2F; 6</span><br><span class="line">1.3 工具介绍 &#x2F; 8</span><br><span class="line">1.3.1 Source Insight介绍 &#x2F; 8</span><br><span class="line">1.3.3 Busybox的使用 &#x2F; 11</span><br><span class="line">1.4 本章小结 &#x2F; 12</span><br><span class="line">第2章 深入理解JNI &#x2F; 13</span><br><span class="line">2.1 JNI概述 &#x2F; 14</span><br><span class="line">2.2 学习JNI的实例：MediaScanner &#x2F; 15</span><br><span class="line">2.3 Java层的MediaScanner分析 &#x2F; 16</span><br><span class="line">2.3.1 加载JNI库 &#x2F; 16</span><br><span class="line">2.3.2 Java的native函数和总结 &#x2F; 17</span><br><span class="line">2.4 JNI层MediaScanner的分析 &#x2F; 17</span><br><span class="line">2.4.1 注册JNI函数 &#x2F; 18</span><br><span class="line">2.4.2 数据类型转换 &#x2F; 22</span><br><span class="line">2.4.3 JNIEnv介绍 &#x2F; 24</span><br><span class="line">2.4.4 通过JNIEnv操作jobject &#x2F; 25</span><br><span class="line">2.4.5 jstring介绍 &#x2F; 27</span><br><span class="line">2.4.6 JNI类型签名介绍 &#x2F; 28</span><br><span class="line">2.4.7 垃圾回收 &#x2F; 29</span><br><span class="line">2.4.8 JNI中的异常处理 &#x2F; 32</span><br><span class="line">2.5 本章小结 &#x2F; 32</span><br><span class="line">第3章 深入理解init &#x2F; 33</span><br><span class="line">3.1 概述 &#x2F; 34</span><br><span class="line">3.2 init分析 &#x2F; 34</span><br><span class="line">3.2.1 解析配置文件 &#x2F; 38</span><br><span class="line">3.2.2 解析service &#x2F; 42</span><br><span class="line">3.2.3 init控制service &#x2F; 48</span><br><span class="line">3.2.4 属性服务 &#x2F; 52</span><br><span class="line">3.3 本章小结 &#x2F; 60</span><br><span class="line">第4章 深入理解zygote &#x2F; 61</span><br><span class="line">4.1 概述 &#x2F; 62</span><br><span class="line">4.2 zygote分析 &#x2F; 62</span><br><span class="line">4.2.1 AppRuntime分析 &#x2F; 63</span><br><span class="line">4.2.2 Welcome to Java World &#x2F; 68</span><br><span class="line">4.2.3 关于zygote的总结 &#x2F; 74</span><br><span class="line">4.3 SystemServer分析 &#x2F; 74</span><br><span class="line">4.3.1 SystemServer的诞生 &#x2F; 74</span><br><span class="line">4.3.2 SystemServer的重要使命 &#x2F; 77</span><br><span class="line">4.3.3 关于 SystemServer的总结 &#x2F; 83</span><br><span class="line">4.4 zygote的分裂  &#x2F; 84</span><br><span class="line">4.4.1 ActivityManagerService发送请求 &#x2F; 84</span><br><span class="line">4.4.2 有求必应之响应请求 &#x2F; 86</span><br><span class="line">4.4.3  关于zygote分裂的总结 &#x2F; 88</span><br><span class="line">4.5 拓展思考 &#x2F; 88</span><br><span class="line">4.5.1 虚拟机heapsize的限制 &#x2F; 88</span><br><span class="line">4.5.2 开机速度优化 &#x2F; 89</span><br><span class="line">4.5.3 Watchdog分析 &#x2F; 90</span><br><span class="line">4.6 本章小结 &#x2F; 93</span><br><span class="line">第5章 深入理解常见类 &#x2F; 95</span><br><span class="line">5.1 概述 &#x2F; 96</span><br><span class="line">5.2 以“三板斧”揭秘RefBase、sp和wp &#x2F; 96</span><br><span class="line">5.2.1 第一板斧——初识影子对象 &#x2F; 96</span><br><span class="line">5.2.2 第二板斧——由弱生强 &#x2F; 103</span><br><span class="line">5.2.3 第三板斧——破解生死魔咒 &#x2F; 106</span><br><span class="line">5.2.4 轻量级的引用计数控制类LightRefBase &#x2F; 108</span><br><span class="line">5.2.5 题外话-三板斧的来历 &#x2F; 109</span><br><span class="line">5.3 Thread类及常用同步类分析 &#x2F; 109</span><br><span class="line">5.3.1 一个变量引发的思考 &#x2F; 109</span><br><span class="line">5.3.2 常用同步类 &#x2F; 114</span><br><span class="line">5.4 Looper和Handler类分析 &#x2F; 121</span><br><span class="line">5.4.1 Looper类分析 &#x2F; 122</span><br><span class="line">5.4.2 Handler分析 &#x2F; 124</span><br><span class="line">5.4.3 Looper和Handler的同步关系 &#x2F; 127</span><br><span class="line">5.4.4 HandlerThread介绍 &#x2F; 129</span><br><span class="line">5.5 本章小结 &#x2F; 129</span><br><span class="line">第6章 深入理解Binder &#x2F; 130</span><br><span class="line">6.1 概述 &#x2F; 131</span><br><span class="line">6.2 庖丁解MediaServer &#x2F; 132</span><br><span class="line">6.2.1 MediaServer的入口函数 &#x2F; 132</span><br><span class="line">6.2.2 独一无二的ProcessState &#x2F; 133</span><br><span class="line">6.2.3 时空穿越魔术-defaultServiceManager &#x2F; 134</span><br><span class="line">6.2.4 注册MediaPlayerService &#x2F; 142</span><br><span class="line">6.2.5 秋风扫落叶-StartThread Pool和join Thread Pool分析 &#x2F; 149</span><br><span class="line">6.2.6 你彻底明白了吗 &#x2F; 152</span><br><span class="line">6.3 服务总管ServiceManager &#x2F; 152</span><br><span class="line">6.3.1 ServiceManager的原理 &#x2F; 152</span><br><span class="line">6.3.2 服务的注册 &#x2F; 155</span><br><span class="line">6.3.3 ServiceManager存在的意义 &#x2F; 158</span><br><span class="line">6.4 MediaPlayerService和它的Client &#x2F; 158</span><br><span class="line">6.4.1 查询ServiceManager &#x2F; 158</span><br><span class="line">6.4.2 子承父业 &#x2F; 159</span><br><span class="line">6.5 拓展思考 &#x2F; 162</span><br><span class="line">6.5.1 Binder和线程的关系 &#x2F; 162</span><br><span class="line">6.5.2 有人情味的讣告 &#x2F; 163</span><br><span class="line">6.5.3 匿名Service &#x2F; 165</span><br><span class="line">6.6 学以致用 &#x2F; 166</span><br><span class="line">6.6.1 纯Native的Service &#x2F; 166</span><br><span class="line">6.6.2 扶得起的“阿斗”（aidl） &#x2F; 169</span><br><span class="line">6.7 本章小结 &#x2F; 172</span><br><span class="line">第7章 深入理解Audio系统 &#x2F; 173</span><br><span class="line">7.1 概述 &#x2F; 174</span><br><span class="line">7.2 AudioTrack的破解 &#x2F; 174</span><br><span class="line">7.2.1 用例介绍 &#x2F; 174</span><br><span class="line">7.2.2 AudioTrack（Java空间）分析 &#x2F; 179</span><br><span class="line">7.2.3 AudioTrack（Native空间）分析 &#x2F; 188</span><br><span class="line">7.2.4 关于AudioTrack的总结 &#x2F; 200</span><br><span class="line">7.3 AudioFlinger的破解 &#x2F; 200</span><br><span class="line">7.3.1 AudioFlinger的诞生 &#x2F; 200</span><br><span class="line">7.3.2 通过流程分析AudioFlinger &#x2F; 204</span><br><span class="line">7.3.3 audio_track_cblk_t分析 &#x2F; 230</span><br><span class="line">7.3.4 关于AudioFlinger的总结 &#x2F; 234</span><br><span class="line">7.4 AudioPolicyService的破解 &#x2F; 234</span><br><span class="line">7.4.1 AudioPolicyService的创建 &#x2F; 235</span><br><span class="line">7.4.2 重回AudioTrack &#x2F; 245</span><br><span class="line">7.4.3 声音路由切换实例分析 &#x2F; 251</span><br><span class="line">7.4.4 关于AudioPolicy的总结 &#x2F; 262</span><br><span class="line">7.5 拓展思考 &#x2F; 262</span><br><span class="line">7.5.1 DuplicatingThread破解 &#x2F; 262</span><br><span class="line">7.5.2 题外话 &#x2F; 270</span><br><span class="line">7.6 本章小结 &#x2F; 272</span><br><span class="line">第8章 深入理解Surface系统 &#x2F; 273</span><br><span class="line">8.1 概述 &#x2F; 275</span><br><span class="line">8.2 一个Activity的显示 &#x2F; 275</span><br><span class="line">8.2.1 Activity的创建 &#x2F; 275</span><br><span class="line">8.2.2 Activity的UI绘制 &#x2F; 294</span><br><span class="line">8.2.3 关于Activity的总结 &#x2F; 296</span><br><span class="line">8.3 初识Surface &#x2F; 297</span><br><span class="line">8.3.1 和Surface有关的流程总结 &#x2F; 297</span><br><span class="line">8.3.2 Surface之乾坤大挪移 &#x2F; 298</span><br><span class="line">8.3.3 乾坤大挪移的JNI层分析 &#x2F; 303</span><br><span class="line">8.3.4 Surface和画图 &#x2F; 307</span><br><span class="line">8.3.5 初识Surface小结 &#x2F; 309</span><br><span class="line">8.4 深入分析Surface &#x2F; 310</span><br><span class="line">8.4.1 与Surface相关的基础知识介绍 &#x2F; 310</span><br><span class="line">8.4.2 SurfaceComposerClient分析 &#x2F; 315</span><br><span class="line">8.4.3 SurfaceControl分析 &#x2F; 320</span><br><span class="line">8.4.4 writeToParcel和Surface对象的创建 &#x2F; 331</span><br><span class="line">8.4.5 lockCanvas和unlockCanvasAndPost分析 &#x2F; 335</span><br><span class="line">8.4.6 GraphicBuffer介绍 &#x2F; 344</span><br><span class="line">8.4.7 深入分析Surface的总结 &#x2F; 353</span><br><span class="line">8.5 SurfaceFlinger分析 &#x2F; 353</span><br><span class="line">8.5.1 SurfaceFlinger的诞生 &#x2F; 354</span><br><span class="line">8.5.2 SF工作线程分析 &#x2F; 359</span><br><span class="line">8.5.3 Transaction分析 &#x2F; 368</span><br><span class="line">8.5.4 关于SurfaceFlinger的总结 &#x2F; 376</span><br><span class="line">8.6 拓展思考 &#x2F; 377</span><br><span class="line">8.6.1 Surface系统的CB对象分析 &#x2F; 377</span><br><span class="line">8.6.2 ViewRoot的你问我答 &#x2F; 384</span><br><span class="line">8.6.3 LayerBuffer分析 &#x2F; 385</span><br><span class="line">8.7 本章小结 &#x2F; 394</span><br><span class="line">第9章 深入理解Vold和Rild &#x2F; 395</span><br><span class="line">9.1 概述 &#x2F; 396</span><br><span class="line">9.2 Vold的原理与机制分析 &#x2F; 396</span><br><span class="line">9.2.1 Netlink和Uevent介绍 &#x2F; 397</span><br><span class="line">9.2.2 初识Vold &#x2F; 399</span><br><span class="line">9.2.3 NetlinkManager模块分析 &#x2F; 400</span><br><span class="line">9.2.4 VolumeManager模块分析 &#x2F; 408</span><br><span class="line">9.2.5 CommandListener模块分析 &#x2F; 414</span><br><span class="line">9.2.6 Vold实例分析 &#x2F; 417</span><br><span class="line">9.2.7 关于Vold的总结 &#x2F; 428</span><br><span class="line">9.3 Rild的原理与机制分析 &#x2F; 428</span><br><span class="line">9.3.1 初识Rild &#x2F; 430</span><br><span class="line">9.3.2 RIL_startEventLoop分析 &#x2F; 432</span><br><span class="line">9.3.3 RIL_Init分析 &#x2F; 437</span><br><span class="line">9.3.4 RIL_register分析 &#x2F; 444</span><br><span class="line">9.3.5 关于Rild main函数的总结 &#x2F; 447</span><br><span class="line">9.3.6 Rild实例分析 &#x2F; 447</span><br><span class="line">9.3.7 关于Rild的总结 &#x2F; 459</span><br><span class="line">9.4 拓展思考 &#x2F; 459</span><br><span class="line">9.4.1 嵌入式系统的存储知识介绍 &#x2F; 459</span><br><span class="line">9.4.2 Rild和Phone的改进探讨 &#x2F; 462</span><br><span class="line">9.5 本章小结 &#x2F; 463</span><br><span class="line">第10章 深入理解MediaScanner &#x2F; 464</span><br><span class="line">10.1 概述 &#x2F; 465</span><br><span class="line">10.2 android.process.media分析 &#x2F; 465</span><br><span class="line">10.2.1 MSR模块分析 &#x2F; 466</span><br><span class="line">10.2.2 MSS模块分析 &#x2F; 467</span><br><span class="line">10.2.3 android.process.media媒体扫描工作的流程总结 &#x2F; 471</span><br><span class="line">10.3 MediaScanner分析 &#x2F; 472</span><br><span class="line">10.3.1 Java层分析 &#x2F; 472</span><br><span class="line">10.3.2 JNI层分析 &#x2F; 476</span><br><span class="line">10.3.3 PVMediaScanner分析 &#x2F; 479</span><br><span class="line">10.3.4 关于MediaScanner的总结 &#x2F; 485</span><br><span class="line">10.4 拓展思考 &#x2F; 486</span><br><span class="line">10.4.1 MediaScannerConnection介绍 &#x2F; 486</span><br><span class="line">10.4.2 我问你答 &#x2F; 487</span><br><span class="line">10.5 本章小结 &#x2F; 488</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B005K70V8E/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B005K70V8E&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41VF-7JYhcL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Android:卷2</title>
    <url>/2020/04/19/B008RVQMBK/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 深入理解Android:卷2<br>作者信息： 作者: 邓凡平 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《深入理解Android:卷2》编辑推荐：经典畅销书《深入理解Android：卷I》姊妹篇，51CTO移动开发频道和开源中国社区一致鼎力推荐！从系统设计者的角度对Java Framework包含的重要模块和服务的源代码进行细致剖析，深刻揭示其实现原理和工作机制。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">第1章 搭建Android源码工作环境</span><br><span class="line">1.1 Android系统架构</span><br><span class="line">1.2 搭建开发环境</span><br><span class="line">1.2.1 下载源码</span><br><span class="line">1.2.2 编译源码</span><br><span class="line">1.2.3 利用Eclipse调试system_process</span><br><span class="line">1.3 本章小结</span><br><span class="line">第2章 深入理解Java Binder和MessageQueue</span><br><span class="line">2.1 概述</span><br><span class="line">2.2 Java层中的Binder架构分析</span><br><span class="line">2.2.1 Binder架构总览</span><br><span class="line">2.2.2 初始化Java层Binder框架</span><br><span class="line">2.2.3 addService实例分析</span><br><span class="line">2.2.4 Java层Binder架构总结</span><br><span class="line">2.3 心系两界的MessageQueue</span><br><span class="line">2.3.1 MessageQueue的创建</span><br><span class="line">2.3.2 提取消息</span><br><span class="line">2.3.3 nativePollOnce函数分析</span><br><span class="line">2.3.4 MessageQueue总结</span><br><span class="line">2.4 本章小结</span><br><span class="line">第3章 深入理解SystemServer</span><br><span class="line">3.1 概述</span><br><span class="line">3.2 SystemServer分析</span><br><span class="line">3.2.1 main函数分析</span><br><span class="line">3.2.2 Service群英会</span><br><span class="line">3.3 EntropyService分析</span><br><span class="line">3.4 DropBoxManagerService分析</span><br><span class="line">3.4.1 DBMS构造函数分析</span><br><span class="line">3.4.2 dropbox日志文件的添加</span><br><span class="line">3.4.3 DBMS和settings数据库</span><br><span class="line">3.5 DiskStatsService和DeviceStorageMonitorService分析</span><br><span class="line">3.5.1 DiskStatsService分析</span><br><span class="line">3.5.2 DeviceStorageManagerService分析</span><br><span class="line">3.6 SamplingProfilerService分析</span><br><span class="line">3.6.1 SamplingProfilerService构造函数分析</span><br><span class="line">3.6.2 SamplingProfilerIntegration分析</span><br><span class="line">3.7 ClipboardService分析</span><br><span class="line">3.7.1 复制数据到剪贴板</span><br><span class="line">3.7.2 从剪切板粘贴数据</span><br><span class="line">3.7.3 CBS中的权限管理</span><br><span class="line">3.8 本章小结</span><br><span class="line">第4章 深入理解PackageManagerService</span><br><span class="line">4.1 概述</span><br><span class="line">4.2 初识PackageManagerService</span><br><span class="line">4.3 PKMS的main函数分析</span><br><span class="line">4.3.1 构造函数分析之前期准备工作</span><br><span class="line">4.3.2 构造函数分析之扫描Package</span><br><span class="line">4.3.3 构造函数分析之扫尾工作</span><br><span class="line">4.3.4 PKMS构造函数总结</span><br><span class="line">4.4 APK Installation分析</span><br><span class="line">4.4.1 adb install分析</span><br><span class="line">4.4.2 pm分析</span><br><span class="line">4.4.3 installPackageWithVerification函数分析</span><br><span class="line">4.4.4 APK 安装流程总结</span><br><span class="line">4.4.5 Verification介绍</span><br><span class="line">4.5 queryIntentActivities分析</span><br><span class="line">4.5.1 Intent及IntentFilter介绍</span><br><span class="line">4.5.2 Activity信息的管理</span><br><span class="line">4.5.3 Intent 匹配查询分析</span><br><span class="line">4.5.4 queryIntentActivities总结</span><br><span class="line">4.6 installd及UserManager介绍</span><br><span class="line">4.6.1 installd介绍</span><br><span class="line">4.6.2 UserManager介绍</span><br><span class="line">4.7 本章学习指导</span><br><span class="line">4.8 本章小结</span><br><span class="line">第5章 深入理解PowerManagerService</span><br><span class="line">5.1 概述</span><br><span class="line">5.2 初识PowerManagerService</span><br><span class="line">5.2.1 PMS构造函数分析</span><br><span class="line">5.2.2 init分析</span><br><span class="line">5.2.3 systemReady分析</span><br><span class="line">5.2.4 BootComplete处理</span><br><span class="line">5.2.5 初识PowerManagerService总结</span><br><span class="line">5.3 PMS WakeLock分析</span><br><span class="line">5.3.1 WakeLock客户端分析</span><br><span class="line">5.3.2 PMS acquireWakeLock分析</span><br><span class="line">5.3.3 Power类及LightService类介绍</span><br><span class="line">5.3.4 WakeLock总结</span><br><span class="line">5.4 userActivity及Power按键处理分析</span><br><span class="line">5.4.1 userActivity分析</span><br><span class="line">5.4.2 Power按键处理分析</span><br><span class="line">5.5 BatteryService及BatteryStatsService分析</span><br><span class="line">5.5.1 BatteryService分析</span><br><span class="line">5.5.2 BatteryStatsService分析</span><br><span class="line">5.5.3 BatteryService及BatteryStatsService总结</span><br><span class="line">5.6 本章学习指导</span><br><span class="line">5.7 本章小结</span><br><span class="line">第6章 深入理解ActivityManagerService</span><br><span class="line">6.1 概述</span><br><span class="line">6.2 初识ActivityManagerService</span><br><span class="line">6.2.1 ActivityManagerService的main函数分析</span><br><span class="line">6.2.2 AMS的 setSystemProcess分析</span><br><span class="line">6.2.3 AMS的 installSystemProviders函数分析</span><br><span class="line">6.2.4 AMS的 systemReady分析</span><br><span class="line">6.2.5 初识ActivityManagerService总结</span><br><span class="line">6.3 startActivity分析</span><br><span class="line">6.3.1 从am说起</span><br><span class="line">6.3.2 AMS的startActivityAndWait函数分析</span><br><span class="line">6.3.3 startActivityLocked分析</span><br><span class="line">6.4 Broadcast和BroadcastReceiver分析</span><br><span class="line">6.4.1 registerReceiver流程分析</span><br><span class="line">6.4.2 sendBroadcast流程分析</span><br><span class="line">6.4.3 BROADCAST_INTENT_MSG消息处理函数</span><br><span class="line">6.4.4 应用进程处理广播分析</span><br><span class="line">6.4.5 广播处理总结</span><br><span class="line">6.5 startService之按图索骥</span><br><span class="line">6.5.1 Service知识介绍</span><br><span class="line">6.5.2 startService流程图</span><br><span class="line">6.6 AMS中的进程管理</span><br><span class="line">6.6.1 Linux进程管理介绍</span><br><span class="line">6.6.2 关于Android中的进程管理的介绍</span><br><span class="line">6.6.3 AMS进程管理函数分析</span><br><span class="line">6.6.4 AMS进程管理总结</span><br><span class="line">6.7 App的 Crash处理</span><br><span class="line">6.7.1 应用进程的Crash处理</span><br><span class="line">6.7.2 AMS的handleApplicationCrash分析</span><br><span class="line">6.7.3 AppDeathRecipient binderDied分析</span><br><span class="line">6.7.4 App的Crash处理总结</span><br><span class="line">6.8 本章学习指导</span><br><span class="line">6.9 本章小结</span><br><span class="line">第7章 深入理解ContentProvider</span><br><span class="line">7.1 概述</span><br><span class="line">7.2 MediaProvider的启动及创建</span><br><span class="line">7.2.1 Context的getContentResolver函数分析</span><br><span class="line">7.2.2 MediaStore.Image.Media的query函数分析</span><br><span class="line">7.2.3 MediaProvider的启动及创建总结</span><br><span class="line">7.3 SQLite创建数据库分析</span><br><span class="line">7.3.1 SQLite及SQLiteDatabase家族</span><br><span class="line">7.3.2 MediaProvider创建数据库分析</span><br><span class="line">7.3.3 SQLiteDatabase创建数据库的分析总结</span><br><span class="line">7.4 Cursor 的query函数的实现分析</span><br><span class="line">7.4.1 提取query关键点</span><br><span class="line">7.4.2 MediaProvider 的query分析</span><br><span class="line">7.4.3 query关键点分析</span><br><span class="line">7.4.4 Cursor query实现分析总结</span><br><span class="line">7.5 Cursor close函数实现分析</span><br><span class="line">7.5.1 客户端close的分析</span><br><span class="line">7.5.2 服务端close的分析</span><br><span class="line">7.5.3 finalize函数分析</span><br><span class="line">7.5.4 Cursor close函数总结</span><br><span class="line">7.6 ContentResolver openAssetFileDescriptor函数分析</span><br><span class="line">7.6.1 openAssetFileDescriptor之客户端调用分析</span><br><span class="line">7.6.2 ContentProvider的 openTypedAssetFile函数分析</span><br><span class="line">7.6.3 跨进程传递文件描述符的探讨</span><br><span class="line">7.6.4 openAssetFileDescriptor函数分析总结</span><br><span class="line">7.7 本章学习指导</span><br><span class="line">7.8 本章小结</span><br><span class="line">第8章 深入理解ContentService和AccountManagerService</span><br><span class="line">8.1 概述</span><br><span class="line">8.2 数据更新通知机制分析</span><br><span class="line">8.2.1 初识ContentService</span><br><span class="line">8.2.2 ContentResovler 的registerContentObserver分析</span><br><span class="line">8.2.3 ContentResolver的 notifyChange分析</span><br><span class="line">8.2.4 数据更新通知机制总结和深入探讨</span><br><span class="line">8.3 AccountManagerService分析</span><br><span class="line">8.3.1 初识AccountManagerService</span><br><span class="line">8.3.2 AccountManager addAccount分析</span><br><span class="line">8.3.3 AccountManagerService的分析总结</span><br><span class="line">8.4 数据同步管理SyncManager分析</span><br><span class="line">8.4.1 初识SyncManager</span><br><span class="line">8.4.2 ContentResolver 的requestSync分析</span><br><span class="line">8.4.3 数据同步管理SyncManager分析总结</span><br><span class="line">8.5 本章学习指导</span><br><span class="line">8.6 本章小结</span><br><span class="line">“深入理解Android”系列书籍的规划路线图</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B008RVQMBK/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B008RVQMBK&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51PaYUBQyGL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>疯狂Android讲义(第2版)</title>
    <url>/2020/04/19/B00BSXRLR8/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 疯狂Android讲义(第2版)<br>作者信息： 作者: 李刚 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《疯狂Android讲义(第2版)》第一版荣获“电子工业出版社最畅销图书奖”；累计印刷10次，销售码洋二百余万，是Android学习、开发人员必备之选。<br>1．知识全面，覆盖面广<br>《疯狂Android讲义(第2版)》深入阐述了Android应用开发的Activity、Service、BroadcastReceiver与ContentProvider四大组件，并详细介绍了Android全部图形界面组件的功能和用法，Android各种资源的管理与用法，Android图形、图像处理，事件处理，Android输入/输出处理，视频/视频等多媒体开发，OpenGL-ES开发，网络通信，传感器和GPS开发等内容，全面覆盖Android官方指南，在某些内容上更加具体、深入。<br>2．内容实际，实用性强<br>《疯狂Android讲义(第2版)》并不局限于枯燥的理论介绍，而是采用了“项目驱动”的方式来讲授知识点，《疯狂Android讲义(第2版)》近百个实例，几乎每个知识点都可找到对应的参考实例。《疯狂Android讲义(第2版)》最后还提供了“疯狂连连看”、“电子拍卖系统Android客户端”两个应用，具有极高的参考价值。<br>3．讲解详细，上手容易<br>《疯狂Android讲义(第2版)》保持了“疯狂Java体系”的一贯风格：操作步骤详细、编程思路清晰，语言平实。只要读者有一定的Java编程基础，阅读《疯狂Android讲义(第2版)》将可以很轻松地上手Android应用开发；学习完《疯狂Android讲义(第2版)》最后的两个案例后，读者即可完全满足实际企业中Android应用开发的要求。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 Android应用与开发环境</span><br><span class="line">1.1 Android的发展和历史</span><br><span class="line">1.1.1 Android的发展和简介</span><br><span class="line">1.1.2 Android平台架构及特性</span><br><span class="line">1.2 搭建Android开发环境</span><br><span class="line">1.2.1 下载和安装Android SDK</span><br><span class="line">1.2.2 安装运行、调试环境</span><br><span class="line">1.2.3 安装Eclipse和ADT插件</span><br><span class="line">1.3 Android常用开发工具的用法</span><br><span class="line">1.3.1 在命令行创建、删除和 浏览AVD</span><br><span class="line">1.3.2 使用Android模拟器 （Emulator）</span><br><span class="line">1.3.3 使用DDMS进行调试</span><br><span class="line">1.3.4 Android Debug Bridge （ADB）的用法</span><br><span class="line">1.3.5 使用DX编译Android应用</span><br><span class="line">1.3.6 使用Android Asset Packaging Tool（AAPT）打包资源</span><br><span class="line">1.3.7 使用mksdcard管理虚拟SD卡</span><br><span class="line">1.4 开始第一个Android应用</span><br><span class="line">1.4.1 使用Eclipse开发第一个 Android应用</span><br><span class="line">1.4.2 通过ADT运行Android应用</span><br><span class="line">1.5 Android应用结构分析</span><br><span class="line">1.5.1 创建一个Android应用</span><br><span class="line">1.5.2 自动生成的R.java</span><br><span class="line">1.5.3 res目录说明</span><br><span class="line">1.5.4 Android应用的清单文件：AndroidManifest.xml</span><br><span class="line">1.5.5 应用程序权限说明</span><br><span class="line">1.6 Android应用的基本组件介绍</span><br><span class="line">1.6.1 Activity和View</span><br><span class="line">1.6.2Service</span><br><span class="line">1.6.3 BroadcastReceiver</span><br><span class="line">1.6.4 ContentProvider</span><br><span class="line">1.6.5 Intent和IntentFilter</span><br><span class="line">1.7 签名Android应用程序</span><br><span class="line">1.7.1 在Eclipse中对Android 应用签名</span><br><span class="line">1.7.2 使用命令对APK包签名</span><br><span class="line">1.8 本章小结</span><br><span class="line">第2章 Android应用的界面编程</span><br><span class="line">2.1 界面编程与视图（View）组件</span><br><span class="line">2.1.1 视图组件与容器组件</span><br><span class="line">2.1.2 使用XML布局文件控制UI 界面</span><br><span class="line">2.1.3 在代码中控制UI界面</span><br><span class="line">2.1.4 使用XML布局文件和Java 代码混合控制UI界面</span><br><span class="line">2.1.5 开发自定义View</span><br><span class="line">2.2 第1组UI组件：布局管理器</span><br><span class="line">2.2.1 线性布局</span><br><span class="line">2.2.2 表格布局</span><br><span class="line">2.2.3 帧布局</span><br><span class="line">2.2.4 相对布局</span><br><span class="line">2.2.5 Android 4.0新增的网格布局</span><br><span class="line">2.2.6 绝对布局</span><br><span class="line">2.3 第2组UI组件：TextView 及其子类</span><br><span class="line">2.3.1 文本框（TextView）与编辑框（EditText）的功能和用法</span><br><span class="line">2.3.2 EditText的功能与用法</span><br><span class="line">2.3.3 按钮（Button）组件的 功能和用法</span><br><span class="line">2.3.4 使用9Patch图片作为按 钮背景</span><br><span class="line">2.3.5 单选按钮（RadioButton）与 复选框（CheckBox）的功能与 用法</span><br><span class="line">2.3.6 状态开关按钮（ToggleButton）与 开关（Switch）的功能与用法</span><br><span class="line">2.3.7 时钟（AnalogClock和 DigitalClock）的功能与用法</span><br><span class="line">2.3.8 计时器（Chronometer）</span><br><span class="line">2.4 第3组UI组件：ImageView 及其子类</span><br><span class="line">2.5 第4组UI组件：AdapterView 及子类</span><br><span class="line">2.5.1 列表视图（ListView）和 ListActivity</span><br><span class="line">2.5.2 Adapter接口及实现类</span><br><span class="line">2.5.3 自动完成文本框（AutoCompleteTextView）的功能和用法</span><br><span class="line">2.5.4 网格视图（GridView） 功能和用法</span><br><span class="line">2.5.5 可展开的列表组件（ExpandableListView）</span><br><span class="line">2.5.6 Spinner的功能和用法</span><br><span class="line">2.5.7 画廊视图（Gallery）的 功能和用法</span><br><span class="line">2.5.8 AdapterViewFlipper的 功能与用法</span><br><span class="line">2.5.9StackView的功能与用法</span><br><span class="line">2.6 第5组UI组件：ProgressBar 及其子类</span><br><span class="line">2.6.1 进度条（ProgressBar）的 功能与用法</span><br><span class="line">2.6.2 拖动条（SeekBar）的 功能和用法</span><br><span class="line">2.6.3 星级评分条（RatingBar）的 功能和用法</span><br><span class="line">2.7 第6组UI组件：ViewAnimator 及其子类</span><br><span class="line">2.7.1 ViewSwitcher的功能与用法</span><br><span class="line">2.7.2 图像切换器（ImageSwitcher）的 功能与用法</span><br><span class="line">2.7.3 文本切换器（TextSwitcher）的 功能与用法</span><br><span class="line">2.7.4 ViewFlipper的功能与用法</span><br><span class="line">2.8 各种杂项组件</span><br><span class="line">2.8.1 使用Toast显示提示信息框</span><br><span class="line">2.8.2 日历视图（CalendarView） 组件的功能和用法</span><br><span class="line">2.8.3 日期、时间选择器（DatePicker和 TimePicker）的功能和用法</span><br><span class="line">2.8.4 数值选择器（NumberPicker）的 功能与用法</span><br><span class="line">2.8.5 搜索框（SearchView）的功能与用法</span><br><span class="line">2.8.6 选项卡（TabHost）的功能和用法</span><br><span class="line">2.8.7 滚动视图（ScrollView）的 功能和用法</span><br><span class="line">2.8.8 Notification的功能与用法</span><br><span class="line">2.9 对话框</span><br><span class="line">2.9.1 使用AlertDialog创建对话框</span><br><span class="line">2.9.2 对话框风格的窗口</span><br><span class="line">2.9.3 使用PopupWindow</span><br><span class="line">2.9.4 使用DatePickerDialog、TimePickerDialog</span><br><span class="line">2.9.5 使用ProgressDialog创建 进度对话框</span><br><span class="line">2.10 菜单</span><br><span class="line">2.10.1 选项菜单和子菜单 （SubMenu）</span><br><span class="line">2.10.2 使用监听器来监听菜单事件</span><br><span class="line">2.10.3 创建复选菜单项和 单选菜单项</span><br><span class="line">2.10.4 设置与菜单项关联的Activity</span><br><span class="line">2.10.5 上下文菜单</span><br><span class="line">2.10.6 使用XML文件定义菜单</span><br><span class="line">2.10.7 使用PopupMenu创建 弹出式菜单</span><br><span class="line">2.11 使用活动条（ActionBar）</span><br><span class="line">2.11.1 启用ActionBar</span><br><span class="line">2.11.2 使用ActionBar显示 选项菜单</span><br><span class="line">2.11.3 启用程序图标导航</span><br><span class="line">2.11.4 添加Action View</span><br><span class="line">2.11.5 使用ActionBar实现Tab 导航</span><br><span class="line">2.11.6 使用ActionBar实现下拉式导航</span><br><span class="line">2.12 本章小结</span><br><span class="line">第3章 Android的事件处理</span><br><span class="line">3.1 Android事件处理概述</span><br><span class="line">3.2 基于监听的事件处理</span><br><span class="line">3.2.1 监听的处理模型</span><br><span class="line">3.2.2 事件和事件监听器</span><br><span class="line">3.2.3 内部类作为事件监听器类</span><br><span class="line">3.2.4 外部类作为事件监听器类</span><br><span class="line">3.2.5 Activity本身作为事件监听器</span><br><span class="line">3.2.6 匿名内部类作为事件监听器类</span><br><span class="line">3.2.7 直接绑定到标签</span><br><span class="line">3.3 基于回调的事件处理</span><br><span class="line">3.3.1 回调机制与监听机制</span><br><span class="line">3.3.2 基于回调的事件传播</span><br><span class="line">3.3.3 重写onTouchEvent方法 响应触摸屏事件</span><br><span class="line">3.4 响应的系统设置的事件</span><br><span class="line">3.4.1 Configuration类简介</span><br><span class="line">3.4.2 重写onConfigurationChanged 响应系统设置更改</span><br><span class="line">3.5 Handler消息传递机制</span><br><span class="line">3.5.1 Handler类简介</span><br><span class="line">3.5.2 Handler、Loop、MessageQueue的 工作原理</span><br><span class="line">3.6 异步任务（AsyncTask）</span><br><span class="line">3.7 本章小结</span><br><span class="line">第4章 深入理解Activity与 Fragment</span><br><span class="line">4.1 建立、配置和使用Activity</span><br><span class="line">4.1.1 Activity</span><br><span class="line">4.1.2 配置Activity</span><br><span class="line">4.1.3 启动、关闭Activity</span><br><span class="line">4.1.4 使用Bundle在Activity之间 交换数据</span><br><span class="line">4.1.5 启动其他Activity并返回结果</span><br><span class="line">4.2 Activity的回调机制</span><br><span class="line">4.3 Activity的生命周期与加载模式</span><br><span class="line">4.3.1 Activity的生命周期演示</span><br><span class="line">4.3.2 Activity与Servlet的相似性与 区别</span><br><span class="line">4.3.3 Activity的4种加载模式</span><br><span class="line">4.4 Fragment详解</span><br><span class="line">4.4.1 Fragment概述及其设计哲学</span><br><span class="line">4.4.2 创建Fragment</span><br><span class="line">4.4.3 Fragment与Activity通信</span><br><span class="line">4.4.4 Fragment管理与Fragment 事务</span><br><span class="line">4.5 Fragment的生命周期</span><br><span class="line">4.6 本章小结</span><br><span class="line">第5章 使用Intent和IntentFilter 进行通信</span><br><span class="line">5.1 Intent对象详解</span><br><span class="line">5.1.1 使用Intent启动系统组件</span><br><span class="line">5.2 Intent的属性及intent—filter配置</span><br><span class="line">5.2.1 Component属性</span><br><span class="line">5.2.2 Action、Category属性与 intent—filter配置</span><br><span class="line">5.2.3 指定Action、Category调用系统Activity</span><br><span class="line">5.2.4 Data、Type属性与intent—filter 配置</span><br><span class="line">5.2.5 Extra属性</span><br><span class="line">5.2.6 Flag属性</span><br><span class="line">5.3 使用Intent创建Tab页面</span><br><span class="line">5.4 本章小结</span><br><span class="line">第6章 Android应用的资源</span><br><span class="line">6.1 资源的类型及存储方式</span><br><span class="line">6.1.1 资源的类型以及存储方式</span><br><span class="line">6.1.2 使用资源</span><br><span class="line">6.2 使用字符串、颜色、尺寸资源</span><br><span class="line">6.2.1 颜色值的定义</span><br><span class="line">6.2.2 定义字符串、颜色、尺寸 资源文件</span><br><span class="line">6.2.3 使用字符串、颜色、尺寸 资源</span><br><span class="line">6.3 数组（Array）资源</span><br><span class="line">6.4 使用（Drawable）资源</span><br><span class="line">6.4.1 图片资源</span><br><span class="line">6.4.2 StateListDrawable资源</span><br><span class="line">6.4.3 LayerDrawable资源</span><br><span class="line">6.4.4 ShapeDrawable资源</span><br><span class="line">6.4.5 ClipDrawable资源</span><br><span class="line">6.4.6 AnimationDrawable资源</span><br><span class="line">6.5 属性动画（Property Animation）资源</span><br><span class="line">6.6 使用原始XML资源</span><br><span class="line">6.6.1 定义原始XML资源</span><br><span class="line">6.6.2 使用原始XML文件</span><br><span class="line">6.7 使用布局（Layout）资源</span><br><span class="line">6.8 使用菜单（Menu）资源</span><br><span class="line">6.9 样式（Style）和主题（Theme） 资源</span><br><span class="line">6.9.1 样式资源</span><br><span class="line">6.9.2 主题资源</span><br><span class="line">6.10 属性（Attribute）资源</span><br><span class="line">6.11 使用原始资源</span><br><span class="line">6.12 国际化和资源自适应</span><br><span class="line">6.12.1 Java国际化的思路</span><br><span class="line">6.12.2 Java支持的语言和国家</span><br><span class="line">6.12.3 完成程序国际化</span><br><span class="line">6.12.4 为Android应用提供国际化资源</span><br><span class="line">6.12.5 国际化Android应用</span><br><span class="line">6.13 自适应不同屏幕的资源</span><br><span class="line">6.14 本章小结</span><br><span class="line">第7章 图形与图像处理</span><br><span class="line">7.1 使用简单图片</span><br><span class="line">7.1.1 使用Drawable对象</span><br><span class="line">7.1.2 Bitmap和BitmapFactory</span><br><span class="line">7.2 绘图</span><br><span class="line">7.2.1 Android绘图基础：Canvas、 Paint等</span><br><span class="line">7.2.2 Path类</span><br><span class="line">7.2.3 绘制游戏动画</span><br><span class="line">7.3 图形特效处理</span><br><span class="line">7.3.1 使用Matrix控制变换</span><br><span class="line">7.3.2 使用drawBitmapMesh 扭曲图像</span><br><span class="line">7.3.3 使用Shader填充图形</span><br><span class="line">7.4 逐帧（Frame）动画</span><br><span class="line">7.4.1 AnimationDrawable与 逐帧动画</span><br><span class="line">7.5 补间（Tween）动画</span><br><span class="line">7.5.1 Tween动画与Interpolator</span><br><span class="line">7.5.2 位置、大小、旋转度、 透明度改变的补间动画</span><br><span class="line">7.5.3 自定义补间动画</span><br><span class="line">7.6 属性动画</span><br><span class="line">7.6.1 属性动画的API</span><br><span class="line">7.6.2 使用属性动画</span><br><span class="line">7.7 使用SurfaceView实现动画</span><br><span class="line">7.7.1SurfaceView的绘图机制</span><br><span class="line">7.8 本章小结</span><br><span class="line">第8章 Android数据存储与IO</span><br><span class="line">8.1 使用SharedPreferences</span><br><span class="line">8.1.1 SharedPreferences与 Editor简介</span><br><span class="line">8.1.2 SharedPreferences的存储位置和格式</span><br><span class="line">8.1.3 读、写其他应用SharedPreferences</span><br><span class="line">8.2 File存储</span><br><span class="line">8.2.1 openFileOutput和 openFileInput</span><br><span class="line">8.2.2 读写SD卡上的文件</span><br><span class="line">8.3 SQLite数据库</span><br><span class="line">8.3.1 SQLiteDatabase简介</span><br><span class="line">8.3.2 创建数据库和表</span><br><span class="line">8.3.3 使用SQL语句操作SQLite数据库</span><br><span class="line">8.3.4 使用sqlite3工具</span><br><span class="line">8.3.5 使用特定方法操作SQLite数据库</span><br><span class="line">8.3.6 事务</span><br><span class="line">8.3.7 SQLiteOpenHelper类</span><br><span class="line">8.4 手势（Gesture）</span><br><span class="line">8.4.1 手势检测</span><br><span class="line">8.4.2 增加手势</span><br><span class="line">8.4.3 识别用户的手势</span><br><span class="line">8.5 自动朗读（TTS）</span><br><span class="line">8.6 本章小结</span><br><span class="line">……</span><br><span class="line">第9章 使用ContentProvider实现数据共享</span><br><span class="line">第10章Service与BroadcastReceiver</span><br><span class="line">第11章 多媒体应用开发</span><br><span class="line">第12章 OpenGL与3D应用开发</span><br><span class="line">第13章 Android网络应用</span><br><span class="line">第14章 管理Android手机桌面</span><br><span class="line">第15章 传感器应用开发</span><br><span class="line">第16章 GPS应用开发</span><br><span class="line">第17章 使用Google Map服务</span><br><span class="line">第18章 疯狂连连看</span><br><span class="line">第19章 电子拍卖系统</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00BSXRLR8/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00BSXRLR8&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51l5mtBBasL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android安全机制解析与应用实践</title>
    <url>/2020/04/19/B00CHGXA48/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android安全机制解析与应用实践<br>作者信息： 作者: 吴倩 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Android安全机制解析与应用实践》编辑推荐：原理分析透彻，结合Android系统源代码，从应用层、应用框架层、硬件抽象层、系统内核层等多角度剖析了Android的安全机制和实现原理，以及安全机制中存在的不足和潜在风险。<br>实用性强，不仅介绍了各种常用的实用分析工具、安全风险分析方法、安全策略，而且还针对Android在各种应用领域可能出现的安全问题给出了解决方案。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">推荐序</span><br><span class="line">前言</span><br><span class="line">第一部分 准备篇</span><br><span class="line">第1章 Android基础／2</span><br><span class="line">1.1 Android系统架构／2</span><br><span class="line">1.1.1 Linux内核层／3</span><br><span class="line">1.1.2 硬件抽象层／4</span><br><span class="line">1.1.3 系统运行库层／5</span><br><span class="line">1.1.4 应用程序框架层／7</span><br><span class="line">1.1.5 应用层／7</span><br><span class="line">1.2 应用程序组件／8</span><br><span class="line">1.3 Android系统启动／10</span><br><span class="line">1.3.1 Linux系统启动／10</span><br><span class="line">1.3.2 Android应用系统启动／15</span><br><span class="line">1.4 Android系统升级／17</span><br><span class="line">1.4.1 Android数据线升级／17</span><br><span class="line">1.4.2 AndroidSD卡升级／17</span><br><span class="line">1.4.3 Android在线升级／18</span><br><span class="line">1.5 本章小结／18</span><br><span class="line">第2章 Android安全模型／19</span><br><span class="line">2.1 Linux安全模型／20</span><br><span class="line">2.1.1 用户与权限／21</span><br><span class="line">2.1.2 进程与内存空间／24</span><br><span class="line">2.2 Android安全机制／26</span><br><span class="line">2.2.1 进程沙箱／26</span><br><span class="line">2.2.2 应用权限／28</span><br><span class="line">2.2.3 进程通信／29</span><br><span class="line">2.2.4 内存管理／32</span><br><span class="line">2.2.5 Android系统分区及加载／35</span><br><span class="line">2.2.6 应用程序签名／36</span><br><span class="line">2.3 Android开发工具提供的安全性机制／37</span><br><span class="line">2.4 本章小结／38</span><br><span class="line">第二部分 原理篇</span><br><span class="line">第3章 Android安全机制源代码分析／40</span><br><span class="line">3.1 文件系统权限的代码实现／41</span><br><span class="line">3.2 进程通信机制的代码实现／44</span><br><span class="line">3.2.1 匿名共享内存／44</span><br><span class="line">3.2.2 Binder机制／50</span><br><span class="line">3.3 Android应用程序安全机制／56</span><br><span class="line">3.3.1 Android应用程序权限机制的源代码分析／56</span><br><span class="line">3.3.2 应用程序签名机制实现的源代码分析／62</span><br><span class="line">3.4 本章小结／65</span><br><span class="line">第4章 Android安全性分析／66</span><br><span class="line">4.1 Android系统安全分析／66</span><br><span class="line">4.1.1 Linux内核／66</span><br><span class="line">4.1.2 系统库／67</span><br><span class="line">4.1.3 Dalvik虚拟机／67</span><br><span class="line">4.2 Android应用安全分析／68</span><br><span class="line">4.2.1 应用程序权限／68</span><br><span class="line">4.2.2 应用程序安装／69</span><br><span class="line">4.2.3 网络浏览器／70</span><br><span class="line">4.2.4 数据库与SQL注入／70</span><br><span class="line">4.2.5 软件更新／71</span><br><span class="line">4.3 硬件安全分析／72</span><br><span class="line">4.4 恶意软件／72</span><br><span class="line">4.4.1 Linux恶意软件／73</span><br><span class="line">4.4.2 Android恶意软件／74</span><br><span class="line">4.5 安全风险与漏洞／75</span><br><span class="line">4.5.1 已知安全风险／75</span><br><span class="line">4.5.2 潜在安全漏洞／76</span><br><span class="line">4.6 本章小结／76</span><br><span class="line">第5章 Android实用安全分析工具／78</span><br><span class="line">5.1 实用分析方法／78</span><br><span class="line">5.1.1 Linux系统信息分析／79</span><br><span class="line">5.1.2 Android应用信息分析／86</span><br><span class="line">5.2 实用分析工具／92</span><br><span class="line">5.2.1 Android系统调试工具／92</span><br><span class="line">5.2.2 dumpsys工具／103</span><br><span class="line">5.2.3 应用程序分析工具／104</span><br><span class="line">5.3 专业分析工具与技术／107</span><br><span class="line">5.3.1 常用逻辑分析工具与技术／107</span><br><span class="line">5.3.2 常用物理分析工具与技术／108</span><br><span class="line">5.4 本章小结／110</span><br><span class="line">第三部分 实践篇</span><br><span class="line">第6章 SEAndroid—增强Android安全性／114</span><br><span class="line">6.1 内核安全风险与增强策略／114</span><br><span class="line">6.2 SEAndroid概述／114</span><br><span class="line">6.3 SEAndroid编译与安装／115</span><br><span class="line">6.3.1 源代码获取／115</span><br><span class="line">6.3.2 源代码结构／116</span><br><span class="line">6.3.3 源代码编译和安装／118</span><br><span class="line">6.4 SEAndroid安全策略概述／124</span><br><span class="line">6.4.1 seapp_contexts文件／125</span><br><span class="line">6.4.2 property_contexts文件／125</span><br><span class="line">6.4.3 mac_permissions.xml文件／126</span><br><span class="line">6.5 SEAndroid兼容性测试工具／127</span><br><span class="line">6.6 SEAndroid的权限限制策略／127</span><br><span class="line">6.6.1 强制限制的权限模型／128</span><br><span class="line">6.6.2 安装时MAC／128</span><br><span class="line">6.6.3 权限取消／128</span><br><span class="line">6.6.4 权限标签传播／129</span><br><span class="line">6.6.5 SEAndroid的其他类与权限策略／129</span><br><span class="line">6.7 本章小结／129</span><br><span class="line">第7章 Android加密文件系统／130</span><br><span class="line">7.1 加密文件系统概述／130</span><br><span class="line">7.2 加密算法介绍／131</span><br><span class="line">7.2.1 AES加密算法／131</span><br><span class="line">7.2.2 加密模式／131</span><br><span class="line">7.3 加密文件系统源代码分析／133</span><br><span class="line">7.3.1 Linux内核的dm—crypt／134</span><br><span class="line">7.3.2 Android的vold／138</span><br><span class="line">7.3.3 工作流程分析／145</span><br><span class="line">7.4 加密文件系统配置／148</span><br><span class="line">7.4.1 块设备选取与配置／148</span><br><span class="line">7.4.2 init.rc配置／149</span><br><span class="line">7.5 本章小结／150</span><br><span class="line">第8章 Android应用安全实用解决方案／151</span><br><span class="line">8.1 安全风险控制策略／151</span><br><span class="line">8.2 应用权限控制／154</span><br><span class="line">8.2.1 权限控制策略／154</span><br><span class="line">8.2.2 权限定义和运用／156</span><br><span class="line">8.3 应用程序签名／159</span><br><span class="line">8.3.1 数字签名基础知识／160</span><br><span class="line">8.3.2 数字签名算法／160</span><br><span class="line">8.3.3 数字签名使用方式／163</span><br><span class="line">8.3.4 应用程序签名的实现／164</span><br><span class="line">8.4 静态代码分析／166</span><br><span class="line">8.5 防火墙／168</span><br><span class="line">8.6 数据存储加密／170</span><br><span class="line">8.7 应用程序组件开发的安全要点／172</span><br><span class="line">8.7.1 私有组件与公有组件／172</span><br><span class="line">8.7.2 Activity安全／173</span><br><span class="line">8.7.3 Service安全／174</span><br><span class="line">8.7.4 ContentProvider安全／175</span><br><span class="line">8.7.5 BroadcastReceiver安全／180</span><br><span class="line">8.7.6 Intent安全／182</span><br><span class="line">8.7.7 Binder安全／184</span><br><span class="line">8.8 本章小结／185</span><br><span class="line">第9章 Android的无线通信安全／186</span><br><span class="line">9.1 无线移动通信的安全威胁与防范／186</span><br><span class="line">9.1.1 语音通信的空口加密与明文传输／187</span><br><span class="line">9.1.2 短信与彩信的存储转发机制／188</span><br><span class="line">9.1.3 传统的搭线窃听与合法监控／189</span><br><span class="line">9.1.4 端到端的通信安全机制／189</span><br><span class="line">9.2 Android的无线移动电话系统／190</span><br><span class="line">9.2.1 无线移动电话系统的结构／190</span><br><span class="line">9.2.2 无线移动电话系统的RIL层实现／190</span><br><span class="line">9.2.3 无线移动电话系统的应用层框架／193</span><br><span class="line">9.3 加密短信和彩信收发／196</span><br><span class="line">9.3.1 普通短信与彩信的收发流程／196</span><br><span class="line">9.3.2 短信与彩信的数字加密处理／208</span><br><span class="line">9.3.3 加密短信与彩信的传输处理／210</span><br><span class="line">9.3.4 加密短信与彩信的存储与调阅／210</span><br><span class="line">9.4 加密实时语音通信／214</span><br><span class="line">9.4.1 AT命令与电话建立流程／214</span><br><span class="line">9.4.2 Android音频系统的电话部分／216</span><br><span class="line">9.4.3 电话状态下音频通道的设置／217</span><br><span class="line">9.4.4 电话音频加密处理／218</span><br><span class="line">9.5 本章小结／222</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00CHGXA48/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00CHGXA48&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41avuf%2BTD-L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Hacker’s Handbook</title>
    <url>/2020/04/19/111860864X/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android Hacker’s Handbook<br>作者信息： 作者: Joshua J. Drake [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Introduction xxv</span><br><span class="line">Chapter 1 Looking at the Ecosystem 1</span><br><span class="line">Understanding Android’s Roots 1</span><br><span class="line">Company History 2</span><br><span class="line">Version History 2</span><br><span class="line">Examining the Device Pool 4</span><br><span class="line">Open Source, Mostly 7</span><br><span class="line">Understanding Android Stakeholders 7</span><br><span class="line">Google 8</span><br><span class="line">Hardware Vendors 10</span><br><span class="line">Carriers 12</span><br><span class="line">Developers 13</span><br><span class="line">Users 14</span><br><span class="line">Grasping Ecosystem Complexities 15</span><br><span class="line">Fragmentation 16</span><br><span class="line">Compatibility 17</span><br><span class="line">Update Issues 18</span><br><span class="line">Security versus Openness 21</span><br><span class="line">Public Disclosures 22</span><br><span class="line">Summary 23</span><br><span class="line">Chapter 2 Android Security Design and Architecture 25</span><br><span class="line">Understanding Android System Architecture 25</span><br><span class="line">Understanding Security Boundaries and Enforcement 27</span><br><span class="line">Android’s Sandbox 27</span><br><span class="line">Android Permissions 30</span><br><span class="line">Looking Closer at the Layers 34</span><br><span class="line">Android Applications 34</span><br><span class="line">The Android Framework 39</span><br><span class="line">The Dalvik Virtual Machine 40</span><br><span class="line">User-Space Native Code 41</span><br><span class="line">The Kernel 49</span><br><span class="line">Complex Security, Complex Exploits 55</span><br><span class="line">Summary 56</span><br><span class="line">Chapter 3 Rooting Your Device 57</span><br><span class="line">Understanding the Partition Layout 58</span><br><span class="line">Determining the Partition Layout 59</span><br><span class="line">Understanding the Boot Process 60</span><br><span class="line">Accessing Download Mode 61</span><br><span class="line">Locked and Unlocked Boot Loaders 62</span><br><span class="line">Stock and Custom Recovery Images 63</span><br><span class="line">Rooting with an Unlocked Boot Loader 65</span><br><span class="line">Rooting with a Locked Boot Loader 68</span><br><span class="line">Gaining Root on a Booted System 69</span><br><span class="line">NAND Locks, Temporary Root, and Permanent Root 70</span><br><span class="line">Persisting a Soft Root 71</span><br><span class="line">History of Known Attacks 73</span><br><span class="line">Kernel: Wunderbar&#x2F;asroot 73</span><br><span class="line">Recovery: Volez 74</span><br><span class="line">Udev: Exploid 74</span><br><span class="line">Adbd: RageAgainstTheCage 75</span><br><span class="line">Zygote: Zimperlich and Zysploit 75</span><br><span class="line">Ashmem: KillingInTheNameOf and psneuter 76</span><br><span class="line">Vold: GingerBreak 76</span><br><span class="line">PowerVR: levitator 77</span><br><span class="line">Libsysutils: zergRush 78</span><br><span class="line">Kernel: mempodroid 78</span><br><span class="line">File Permission and Symbolic Link–Related Attacks 79</span><br><span class="line">Adb Restore Race Condition 79</span><br><span class="line">Exynos4: exynos-abuse 80</span><br><span class="line">Diag: lit &#x2F; diaggetroot 81</span><br><span class="line">Summary 81</span><br><span class="line">Chapter 4 Reviewing Application Security 83</span><br><span class="line">Common Issues 83</span><br><span class="line">App Permission Issues 84</span><br><span class="line">Insecure Transmission of Sensitive Data 86</span><br><span class="line">Insecure Data Storage 87</span><br><span class="line">Information Leakage Through Logs 88</span><br><span class="line">Unsecured IPC Endpoints 89</span><br><span class="line">Case Study: Mobile Security App 91</span><br><span class="line">Profi ling 91</span><br><span class="line">Static Analysis 93</span><br><span class="line">Dynamic Analysis 109</span><br><span class="line">Attack 117</span><br><span class="line">Case Study: SIP Client 120</span><br><span class="line">Enter Drozer 121</span><br><span class="line">Discovery 121</span><br><span class="line">Snarfing 122</span><br><span class="line">Injection 124</span><br><span class="line">Summary 126</span><br><span class="line">Chapter 5 Understanding Android’s Attack Surface 129</span><br><span class="line">An Attack Terminology Primer 130</span><br><span class="line">Attack Vectors 130</span><br><span class="line">Attack Surfaces 131</span><br><span class="line">Classifying Attack Surfaces 133</span><br><span class="line">Surface Properties 133</span><br><span class="line">Classification Decisions 134</span><br><span class="line">Remote Attack Surfaces 134</span><br><span class="line">Networking Concepts 134</span><br><span class="line">Networking Stacks 139</span><br><span class="line">Exposed Network Services 140</span><br><span class="line">Mobile Technologies 142</span><br><span class="line">Client-side Attack Surface 143</span><br><span class="line">Google Infrastructure 148</span><br><span class="line">Physical Adjacency 154</span><br><span class="line">Wireless Communications 154</span><br><span class="line">Other Technologies 161</span><br><span class="line">Local Attack Surfaces 161</span><br><span class="line">Exploring the File System 162</span><br><span class="line">Finding Other Local Attack Surfaces 163</span><br><span class="line">Physical Attack Surfaces 168</span><br><span class="line">Dismantling Devices 169</span><br><span class="line">USB 169</span><br><span class="line">Other Physical Attack Surfaces 173</span><br><span class="line">Third-Party Modifi cations 174</span><br><span class="line">Summary 174</span><br><span class="line">Chapter 6 Finding Vulnerabilities with Fuzz Testing 177</span><br><span class="line">Fuzzing Background 177</span><br><span class="line">Identifying a Target 179</span><br><span class="line">Crafting Malformed Inputs 179</span><br><span class="line">Processing Inputs 180</span><br><span class="line">Monitoring Results 181</span><br><span class="line">Fuzzing on Android 181</span><br><span class="line">Fuzzing Broadcast Receivers 183</span><br><span class="line">Identifying a Target 183</span><br><span class="line">Generating Inputs 184</span><br><span class="line">Delivering Inputs 185</span><br><span class="line">Monitoring Testing 185</span><br><span class="line">Fuzzing Chrome for Android 188</span><br><span class="line">Selecting a Technology to Target 188</span><br><span class="line">Generating Inputs 190</span><br><span class="line">Processing Inputs 192</span><br><span class="line">Monitoring Testing 194</span><br><span class="line">Fuzzing the USB Attack Surface 197</span><br><span class="line">USB Fuzzing Challenges 198</span><br><span class="line">Selecting a Target Mode 198</span><br><span class="line">Generating Inputs 199</span><br><span class="line">Processing Inputs 201</span><br><span class="line">Monitoring Testing 202</span><br><span class="line">Summary 204</span><br><span class="line">Chapter 7 Debugging and Analyzing Vulnerabilities 205</span><br><span class="line">Getting All Available Information 205</span><br><span class="line">Choosing a Toolchain 207</span><br><span class="line">Debugging with Crash Dumps 208</span><br><span class="line">System Logs 208</span><br><span class="line">Tombstones 209</span><br><span class="line">Remote Debugging 211</span><br><span class="line">Debugging Dalvik Code 212</span><br><span class="line">Debugging an Example App 213</span><br><span class="line">Showing Framework Source Code 215</span><br><span class="line">Debugging Existing Code 217</span><br><span class="line">Debugging Native Code 221</span><br><span class="line">Debugging with the NDK 222</span><br><span class="line">Debugging with Eclipse 226</span><br><span class="line">Debugging with AOSP 227</span><br><span class="line">Increasing Automation 233</span><br><span class="line">Debugging with Symbols 235</span><br><span class="line">Debugging with a Non-AOSP Device 241</span><br><span class="line">Debugging Mixed Code 243</span><br><span class="line">Alternative Debugging Techniques 243</span><br><span class="line">Debug Statements 243</span><br><span class="line">On-Device Debugging 244</span><br><span class="line">Dynamic Binary Instrumentation 245</span><br><span class="line">Vulnerability Analysis 246</span><br><span class="line">Determining Root Cause 246</span><br><span class="line">Judging Exploitability 260</span><br><span class="line">Summary 261</span><br><span class="line">Chapter 8 Exploiting User Space Software 263</span><br><span class="line">Memory Corruption Basics 263</span><br><span class="line">Stack Buffer Overfl ows 264</span><br><span class="line">Heap Exploitation 268</span><br><span class="line">A History of Public Exploits 275</span><br><span class="line">GingerBreak 275</span><br><span class="line">zergRush 279</span><br><span class="line">mempodroid 283</span><br><span class="line">Exploiting the Android Browser 284</span><br><span class="line">Understanding the Bug 284</span><br><span class="line">Controlling the Heap 287</span><br><span class="line">Summary 290</span><br><span class="line">Chapter 9 Return Oriented Programming 291</span><br><span class="line">History and Motivation 291</span><br><span class="line">Separate Code and Instruction Cache 292</span><br><span class="line">Basics of ROP on ARM 294</span><br><span class="line">ARM Subroutine Calls 295</span><br><span class="line">Combining Gadgets into a Chain 297</span><br><span class="line">Identifying Potential Gadgets 299</span><br><span class="line">Case Study: Android 4.0.1 Linker 300</span><br><span class="line">Pivoting the Stack Pointer 301</span><br><span class="line">Executing Arbitrary Code from a New Mapping 303</span><br><span class="line">Summary 308</span><br><span class="line">Chapter 10 Hacking and Attacking the Kernel 309</span><br><span class="line">Android’s Linux Kernel 309</span><br><span class="line">Extracting Kernels 310</span><br><span class="line">Extracting from Stock Firmware 311</span><br><span class="line">Extracting from Devices 314</span><br><span class="line">Getting the Kernel from a Boot Image 315</span><br><span class="line">Decompressing the Kernel 316</span><br><span class="line">Running Custom Kernel Code 316</span><br><span class="line">Obtaining Source Code 316</span><br><span class="line">Setting Up a Build Environment 320</span><br><span class="line">Confi guring the Kernel 321</span><br><span class="line">Using Custom Kernel Modules 322</span><br><span class="line">Building a Custom Kernel 325</span><br><span class="line">Creating a Boot Image 329</span><br><span class="line">Booting a Custom Kernel 331</span><br><span class="line">Debugging the Kernel 336</span><br><span class="line">Obtaining Kernel Crash Reports 337</span><br><span class="line">Understanding an Oops 338</span><br><span class="line">Live Debugging with KGDB 343</span><br><span class="line">Exploiting the Kernel 348</span><br><span class="line">Typical Android Kernels 348</span><br><span class="line">Extracting Addresses 350</span><br><span class="line">Case Studies 352</span><br><span class="line">Summary 364</span><br><span class="line">Chapter 11 Attacking the Radio Interface Layer 367</span><br><span class="line">Introduction to the RIL 368</span><br><span class="line">RIL Architecture 368</span><br><span class="line">Smartphone Architecture 369</span><br><span class="line">The Android Telephony Stack 370</span><br><span class="line">Telephony Stack Customization 371</span><br><span class="line">The RIL Daemon (rild) 372</span><br><span class="line">The Vendor-RIL API 374</span><br><span class="line">Short Message Service (SMS) 375</span><br><span class="line">Sending and Receiving SMS Messages 376</span><br><span class="line">SMS Message Format 376</span><br><span class="line">Interacting with the Modem 379</span><br><span class="line">Emulating the Modem for Fuzzing 379</span><br><span class="line">Fuzzing SMS on Android 382</span><br><span class="line">Summary 390</span><br><span class="line">Chapter 12 Exploit Mitigations 391</span><br><span class="line">Classifying Mitigations 392</span><br><span class="line">Code Signing 392</span><br><span class="line">Hardening the Heap 394</span><br><span class="line">Protecting Against Integer Overfl ows 394</span><br><span class="line">Preventing Data Execution 396</span><br><span class="line">Address Space Layout Randomization 398</span><br><span class="line">Protecting the Stack 400</span><br><span class="line">Format String Protections 401</span><br><span class="line">Read-Only Relocations 403</span><br><span class="line">Sandboxing 404</span><br><span class="line">Fortifying Source Code 405</span><br><span class="line">Access Control Mechanisms 407</span><br><span class="line">Protecting the Kernel 408</span><br><span class="line">Pointer and Log Restrictions 409</span><br><span class="line">Protecting the Zero Page 410</span><br><span class="line">Read-Only Memory Regions 410</span><br><span class="line">Other Hardening Measures 411</span><br><span class="line">Summary of Exploit Mitigations 414</span><br><span class="line">Disabling Mitigation Features 415</span><br><span class="line">Changing Your Personality 416</span><br><span class="line">Altering Binaries 416</span><br><span class="line">Tweaking the Kernel 417</span><br><span class="line">Overcoming Exploit Mitigations 418</span><br><span class="line">Overcoming Stack Protections 418</span><br><span class="line">Overcoming ASLR 418</span><br><span class="line">Overcoming Data Execution Protections 419</span><br><span class="line">Overcoming Kernel Protections 419</span><br><span class="line">Looking to the Future 420</span><br><span class="line">Official Projects Underway 420</span><br><span class="line">Community Kernel Hardening Efforts 420</span><br><span class="line">A Bit of Speculation 422</span><br><span class="line">Summary 422</span><br><span class="line">Chapter 13 Hardware Attacks 423</span><br><span class="line">Interfacing with Hardware Devices 424</span><br><span class="line">UART Serial Interfaces 424</span><br><span class="line">I2C, SPI, and One-Wire Interfaces 428</span><br><span class="line">JTAG 431</span><br><span class="line">Finding Debug Interfaces 443</span><br><span class="line">Identifying Components 456</span><br><span class="line">Getting Specifi cations 456</span><br><span class="line">Difficulty Identifying Components 457</span><br><span class="line">Intercepting, Monitoring, and Injecting Data 459</span><br><span class="line">USB 459</span><br><span class="line">I2C, SPI, and UART Serial Interfaces 463</span><br><span class="line">Stealing Secrets and Firmware 469</span><br><span class="line">Accessing Firmware Unobtrusively 469</span><br><span class="line">Destructively Accessing the Firmware 471</span><br><span class="line">What Do You Do with a Dump? 474</span><br><span class="line">Pitfalls 479</span><br><span class="line">Custom Interfaces 479</span><br><span class="line">Binary&#x2F;Proprietary Data 479</span><br><span class="line">Blown Debug Interfaces 480</span><br><span class="line">Chip Passwords 480</span><br><span class="line">Boot Loader Passwords, Hotkeys, and Silent Terminals 480</span><br><span class="line">Customized Boot Sequences 481</span><br><span class="line">Unexposed Address Lines 481</span><br><span class="line">Anti-Reversing Epoxy 482</span><br><span class="line">Image Encryption, Obfuscation, and Anti-Debugging 482</span><br><span class="line">Summary 482</span><br><span class="line">Appendix A Tool Catalog 485</span><br><span class="line">Development Tools 485</span><br><span class="line">Android SDK 485</span><br><span class="line">Android NDK 486</span><br><span class="line">Eclipse 486</span><br><span class="line">ADT Plug-In 486</span><br><span class="line">ADT Bundle 486</span><br><span class="line">Android Studio 487</span><br><span class="line">Firmware Extraction and Flashing Tools 487</span><br><span class="line">Binwalk 487</span><br><span class="line">fastboot 487</span><br><span class="line">Samsung 488</span><br><span class="line">NVIDIA 489</span><br><span class="line">LG 489</span><br><span class="line">HTC 489</span><br><span class="line">Motorola 490</span><br><span class="line">Native Android Tools 491</span><br><span class="line">BusyBox 491</span><br><span class="line">setpropex 491</span><br><span class="line">SQLite 491</span><br><span class="line">strace 492</span><br><span class="line">Hooking and Instrumentation Tools 492</span><br><span class="line">ADBI Framework 492</span><br><span class="line">ldpreloadhook 492</span><br><span class="line">XPosed Framework 492</span><br><span class="line">Cydia Substrate 493</span><br><span class="line">Static Analysis Tools 493</span><br><span class="line">Smali and Baksmali 493</span><br><span class="line">Androguard 493</span><br><span class="line">apktool 494</span><br><span class="line">dex2jar 494</span><br><span class="line">jad 494</span><br><span class="line">JD-GUI 495</span><br><span class="line">JEB 495</span><br><span class="line">Radare2 495</span><br><span class="line">IDA Pro and Hex-Rays Decompiler 496</span><br><span class="line">Application Testing Tools 496</span><br><span class="line">Drozer (Mercury) Framework 496</span><br><span class="line">iSEC Intent Sniffer and Intent Fuzzer 496</span><br><span class="line">Hardware Hacking Tools 496</span><br><span class="line">Segger J-Link 497</span><br><span class="line">JTAGulator 497</span><br><span class="line">OpenOCD 497</span><br><span class="line">Saleae 497</span><br><span class="line">Bus Pirate 497</span><br><span class="line">GoodFET 497</span><br><span class="line">Total Phase Beagle USB 498</span><br><span class="line">Facedancer21 498</span><br><span class="line">Total Phase Beagle I2C 498</span><br><span class="line">Chip Quik 498</span><br><span class="line">Hot air gun 498</span><br><span class="line">Xeltek SuperPro 498</span><br><span class="line">IDA 499</span><br><span class="line">Appendix B Open Source Repositories 501</span><br><span class="line">Google 501</span><br><span class="line">AOSP 501</span><br><span class="line">Gerrit Code Review 502</span><br><span class="line">SoC Manufacturers 502</span><br><span class="line">AllWinner 503</span><br><span class="line">Intel 503</span><br><span class="line">Marvell 503</span><br><span class="line">MediaTek 504</span><br><span class="line">Nvidia 504</span><br><span class="line">Texas Instruments 504</span><br><span class="line">Qualcomm 505</span><br><span class="line">Samsung 505</span><br><span class="line">OEMs 506</span><br><span class="line">ASUS 506</span><br><span class="line">HTC 507</span><br><span class="line">LG 507</span><br><span class="line">Motorola 507</span><br><span class="line">Samsung 508</span><br><span class="line">Sony Mobile 508</span><br><span class="line">Upstream Sources 508</span><br><span class="line">Others 509</span><br><span class="line">Custom Firmware 509</span><br><span class="line">Linaro 510</span><br><span class="line">Replicant 510</span><br><span class="line">Code Indexes 510</span><br><span class="line">Individuals 510</span><br><span class="line">Appendix C References 511</span><br><span class="line">Index 523</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/111860864X/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=111860864X&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51lQ0m9W5SL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 2.3应用开发实战</title>
    <url>/2020/04/19/B00539ZCH4/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android 2.3应用开发实战<br>作者信息： 作者: 林城 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Android 2.3应用开发实战》全面介绍Android OS操作环境，包括SDK2.3 版最新内容，丰富的范例程序详解Android应用开发，便于读者决速掌握，每一章的主题都安排进阶学习，满足不同读者的阅读需求。<br>Google Android 2.3版本（Gingerbread）提升了许多移动设备的新功能，如陀螺仪可以检测移动方向；针对手机钱包功能的开发，提供了支持近距离无线通讯技术（Near Field Communication，NFC）；同时提供了多相机镜头的移动相机以及会话启动协议（Session Initiation Protocol，SIP）Stack的VolP网络电话功能。<br>《Android 2.3应用开发实战》以Android系统架构和应用基本原理介绍开发Android应用程序，读者可学习Android 2.3提供的开发方法，同时了解Android操作系统的架构和原理；编写Android应用程序不仅需要了解ava语言，对Android系统架构和对象类也要充分熟悉，才能开发出优秀的程序。<br>《Android 2.3应用开发实战》详解Android开发环境、应用开发平台、活动程序Act Mty、意图方法Intent、Widget、Layout~布局、Menu菜单、SQ Lite、Ser、，ice服务程序、应用程序国际化、Web View、App Widget、GPS定位和Google Maps、音频和视频、2D绘图E]3D OpenGL绘图、Su rface View、动态壁纸、蓝牙通信、触控、感应检测、Android 2.3特性、照相机、VolP等内容。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 拓展android市场的java应用</span><br><span class="line">1.1android来了</span><br><span class="line">1.2android操作系统结构</span><br><span class="line">1.3oesf扩增功能</span><br><span class="line">1.4android-windows开发环境</span><br><span class="line">1.5在androidmarket销售你的应用软件</span><br><span class="line">第2章 安装androidsdk开发环境</span><br><span class="line">2.1androidsdk开发环境</span><br><span class="line">2.2安装androidsdk开发环境</span><br><span class="line">2.3安装androidsdk前必要的软件</span><br><span class="line">2.4更新到新版本android开发工具adt</span><br><span class="line">2.5删除android开发工具adt</span><br><span class="line">2.6android-“helloworld!”验证</span><br><span class="line">第3章 androidsdk开发平台应用</span><br><span class="line">3.1androidsdk开发平台应用</span><br><span class="line">3.2android仿真器</span><br><span class="line">3.3android仿真器专用sd存储卡</span><br><span class="line">3.4android系统调试工具-adb</span><br><span class="line">3.5android调试监控服务系统ddms</span><br><span class="line">第4章  认识android基本单元-活动程序activity</span><br><span class="line">4.1android应用程序组成</span><br><span class="line">4.2执行状态迁移的生命周期(lifecycle)</span><br><span class="line">4.3精通活动程序-activity的控制功能</span><br><span class="line">第5章 活动程序activity的切换-意图方法intent</span><br><span class="line">5.1活动程序activity和意图方法intent</span><br><span class="line">5.2建立chatactivities应用程序</span><br><span class="line">5.3chatactivities应用程序实现</span><br><span class="line">5.4标准意图方法intent</span><br><span class="line">……</span><br><span class="line">第6章 android应用程序的widget创作套件</span><br><span class="line">第7章 android应用程序的layout窗体布局</span><br><span class="line">第8章 android应用程序的menu菜单</span><br><span class="line">第9章 android数据存储和数据公开-sqlite</span><br><span class="line">第10章 认识service服务程序</span><br><span class="line">第11章 android应用程序国际化</span><br><span class="line">第12章 android的web视图-webview</span><br><span class="line">第13章 android常驻程序-appwidget</span><br><span class="line">第14章 android应用程序gps位置和googlemaps</span><br><span class="line">第15章 android音频和视频</span><br><span class="line">第16章 android2d绘图和3dopengl绘图</span><br><span class="line">第17章 android高速描绘-surfaceview</span><br><span class="line">第18章 android动态壁纸-livewallpaper</span><br><span class="line">第19章 android蓝牙通信-bluetooth</span><br><span class="line">第20章 android触控屏幕-gesture</span><br><span class="line">第21章 android感应检测-sensor</span><br><span class="line">第22章 androidos2.3姜饼报到</span><br><span class="line">第23章 android手机必备的照相机</span><br><span class="line">第24章 设计android网络电话voip-sip</span><br><span class="line">附录aa ndroid应用程序范例光盘使用说明</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00539ZCH4/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00539ZCH4&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51W31xY4lZL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android技术内幕:系统卷</title>
    <url>/2020/04/19/B0053WMHF6/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android技术内幕:系统卷<br>作者信息： 作者: 杨丰盛 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Android技术内幕:系统卷》编辑推荐：完全立足于Android系统源代码，深入解析Android内核的架构设计与实现原理，透彻分析Android内核层、硬件抽象层和系统运行库层的各功能模块的底层机制。《Android技术内幕:系统卷》适合所有的高级Android应用开发工程师、Android系统开发工程师、Android移植工程师、Android系统架构师和所有对Android源码实现感兴趣的读者。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">第1章  准备工作 &#x2F;1</span><br><span class="line">1.1  深入认识Android &#x2F;2</span><br><span class="line">1.1.1  Android的系统构架 &#x2F;2</span><br><span class="line">1.1.2  Android的初始化流程 &#x2F;5</span><br><span class="line">1.1.3  各个层次之间的相互关系 &#x2F;8</span><br><span class="line">1.1.4  Android系统开发（移植）和应用开发 &#x2F;11</span><br><span class="line">1.2  获取和编译Android的源码 &#x2F;13</span><br><span class="line">1.2.1  环境配置 &#x2F;13</span><br><span class="line">1.2.2  获取Android源码 &#x2F;14</span><br><span class="line">1.2.3  编译Android的源码及其工具包 &#x2F;16</span><br><span class="line">1.2.4  运行Android系统 &#x2F;21</span><br><span class="line">1.3  开发环境搭建 &#x2F;23</span><br><span class="line">1.3.1  应用开发环境搭建 &#x2F;23</span><br><span class="line">1.3.2  源码开发环境搭建 &#x2F;26</span><br><span class="line">1.4  Android源码结构 &#x2F;32</span><br><span class="line">1.5  小结 &#x2F;33</span><br><span class="line">第2章  Android的内核机制和结构剖析 &#x2F;34</span><br><span class="line">2.1  Linux与Android的关系 &#x2F;35</span><br><span class="line">2.1.1  为什么会选择Linux &#x2F;35</span><br><span class="line">2.1.2  Android不是Linux &#x2F;35</span><br><span class="line">2.2  Android对Linux内核的改动 &#x2F;37</span><br><span class="line">2.2.1  Goldfish &#x2F;37</span><br><span class="line">2.2.2  YAFFS2 &#x2F;38</span><br><span class="line">2.2.3  蓝牙 &#x2F;39</span><br><span class="line">2.2.4  调度器（Scheduler）&#x2F;39</span><br><span class="line">2.2.5  Android新增的驱动 &#x2F;40</span><br><span class="line">2.2.6  电源管理 &#x2F;41</span><br><span class="line">2.2.7  杂项 &#x2F;41</span><br><span class="line">2.3  Android对Linux内核的增强 &#x2F;42</span><br><span class="line">2.3.1  Alarm（硬件时钟）&#x2F;43</span><br><span class="line">2.3.2  Ashmem（匿名内存共享）&#x2F;46</span><br><span class="line">2.3.3  Low Memory Killer（低内存管理）&#x2F;52</span><br><span class="line">2.3.4  Logger（日志设备）&#x2F;56</span><br><span class="line">2.3.5  Android PMEM &#x2F;65</span><br><span class="line">2.3.6  switch &#x2F;79</span><br><span class="line">2.3.7  Timed GPIO &#x2F;88</span><br><span class="line">2.3.8  Android Ram Console &#x2F;94</span><br><span class="line">2.4  小结 &#x2F;99</span><br><span class="line">第3章  Android的IPC机制–Binder &#x2F;100</span><br><span class="line">3.1  Binder概述 &#x2F;101</span><br><span class="line">3.1.1  为什么选择Binder &#x2F;101</span><br><span class="line">3.1.2  初识Binder &#x2F;102</span><br><span class="line">3.2  Binder驱动的原理和实现 &#x2F;102</span><br><span class="line">3.2.1  Binder驱动的原理 &#x2F;102</span><br><span class="line">3.2.2  Binder驱动的实现 &#x2F;103</span><br><span class="line">3.3  Binder的构架与实现 &#x2F;132</span><br><span class="line">3.3.1  Binder的系统构架 &#x2F;132</span><br><span class="line">3.3.2  Binder的机制和原理 &#x2F;133</span><br><span class="line">3.4  小结 &#x2F;150</span><br><span class="line">第4章  电源管理 &#x2F;151</span><br><span class="line">4.1  电源管理概述 &#x2F;152</span><br><span class="line">4.2  电源管理结构 &#x2F;152</span><br><span class="line">4.3  Android的电源管理机制 &#x2F;153</span><br><span class="line">4.4  Android电源管理机制的实现 &#x2F;154</span><br><span class="line">4.5  小结 &#x2F;187</span><br><span class="line">第5章  驱动的工作原理及实现机制 &#x2F;188</span><br><span class="line">5.1  显示驱动（Framebuffer）&#x2F;189</span><br><span class="line">5.1.1  Framebuffer的工作原理 &#x2F;189</span><br><span class="line">5.1.2  Framebuffer的构架 &#x2F;190</span><br><span class="line">5.1.3  Framebuffer驱动的实现机制 &#x2F;190</span><br><span class="line">5.2  视频驱动（V4L和V4L2）&#x2F;201</span><br><span class="line">5.2.1  V4L2介绍 &#x2F;201</span><br><span class="line">5.2.2  V4L2的原理和构架 &#x2F;201</span><br><span class="line">5.2.3  V4L2的实现 &#x2F;202</span><br><span class="line">5.3  音频驱动（OSS和ALSA）&#x2F;208</span><br><span class="line">5.3.1  OSS与ALSA介绍 &#x2F;208</span><br><span class="line">5.3.2  OSS的构架与实现 &#x2F;209</span><br><span class="line">5.3.3  ALSA的构架与实现 &#x2F;213</span><br><span class="line">5.4  MTD驱动 &#x2F;214</span><br><span class="line">5.4.1  MTD驱动的功能 &#x2F;214</span><br><span class="line">5.4.2  MTD驱动的构架 &#x2F;215</span><br><span class="line">5.4.3  MTD驱动的原理及实现 &#x2F;215</span><br><span class="line">5.5  Event输入设备驱动 &#x2F;223</span><br><span class="line">5.5.1  Input的系统构架 &#x2F;223</span><br><span class="line">5.5.2  Event输入驱动的构架 &#x2F;224</span><br><span class="line">5.5.3  Event输入驱动的原理 &#x2F;224</span><br><span class="line">5.5.4  Event输入驱动的实现 &#x2F;225</span><br><span class="line">5.6  蓝牙驱动（Bluetooth）&#x2F;235</span><br><span class="line">5.6.1  Bluetooth驱动的构架 &#x2F;235</span><br><span class="line">5.6.2  BlueZ的原理及实现 &#x2F;237</span><br><span class="line">5.7  WLAN驱动（Wi-Fi）&#x2F;244</span><br><span class="line">5.7.1  WLAN构架 &#x2F;244</span><br><span class="line">5.7.2  Wi-Fi驱动的实现原理 &#x2F;245</span><br><span class="line">5.8  小结 &#x2F;245</span><br><span class="line">第6章  原生库的原理及实现 &#x2F;246</span><br><span class="line">6.1  系统C库（Bionic Libc）&#x2F;247</span><br><span class="line">6.1.1  Bionic Libc功能概述 &#x2F;247</span><br><span class="line">6.1.2  Bionic Libc实现原理 &#x2F;248</span><br><span class="line">6.2  功能库 &#x2F;258</span><br><span class="line">6.2.1  WebKit构架与实现 &#x2F;258</span><br><span class="line">6.2.2  多媒体框架与实现 &#x2F;275</span><br><span class="line">6.2.3  Android SQLite框架及原理 &#x2F;285</span><br><span class="line">6.3  扩展库 &#x2F;289</span><br><span class="line">6.3.1  Skia底层库分析 &#x2F;289</span><br><span class="line">6.3.2  OpenGL底层库分析 &#x2F;299</span><br><span class="line">6.3.3  Android-OpenSSL实现及运用 &#x2F;306</span><br><span class="line">6.3.4  FreeType及Font Engine Manager &#x2F;317</span><br><span class="line">6.3.5  FreeType结构体系和渲染流程 &#x2F;317</span><br><span class="line">6.4  原生服务 &#x2F;328</span><br><span class="line">6.4.1  AudioFlinger实现 &#x2F;328</span><br><span class="line">6.4.2  SurfaceFlinger实现 &#x2F;341</span><br><span class="line">6.5  小结 &#x2F;353</span><br><span class="line">第7章  硬件抽象层的原理与实现 &#x2F;354</span><br><span class="line">7.1  硬件抽象层的实现原理 &#x2F;355</span><br><span class="line">7.1.1  Android HAL构架 &#x2F;355</span><br><span class="line">7.1.2  Android HAL的实现 &#x2F;357</span><br><span class="line">7.2  Android Overlay构架与实现 &#x2F;361</span><br><span class="line">7.2.1  Android Overlay系统构架 &#x2F;361</span><br><span class="line">7.2.2  Overlay HAL框架与实现 &#x2F;362</span><br><span class="line">7.2.3  Overlay与SurfaceFinger &#x2F;369</span><br><span class="line">7.3  Android Camera 构架与实现 &#x2F;375</span><br><span class="line">7.3.1  Android Camera系统构架 &#x2F;375</span><br><span class="line">7.3.2  Camera HAL框架与实现 &#x2F;377</span><br><span class="line">7.3.3  Camera本地实现 &#x2F;385</span><br><span class="line">7.4  Android Audio HAL实现 &#x2F;394</span><br><span class="line">7.4.1  Audio HAL框架 &#x2F;395</span><br><span class="line">7.4.2  Android默认的Audio HAL实现 &#x2F;398</span><br><span class="line">7.4.3  DUMP功能的Audio HAL实现 &#x2F;400</span><br><span class="line">7.4.4  基于A2dp的蓝牙音频设备HAL实现 &#x2F;402</span><br><span class="line">7.4.5  模拟器上的Audio HAL实现 &#x2F;403</span><br><span class="line">7.5  Android RIL实现 &#x2F;404</span><br><span class="line">7.5.1  Android RIL构架 &#x2F;404</span><br><span class="line">7.5.2  radiooptiongs实现 &#x2F;407</span><br><span class="line">7.5.3  libril库实现 &#x2F;409</span><br><span class="line">7.5.4  reference-ril库实现 &#x2F;415</span><br><span class="line">7.5.5  RILD守护进程实现 &#x2F;418</span><br><span class="line">7.5.6  request流程分析 &#x2F;423</span><br><span class="line">7.5.7  response流程分析 &#x2F;427</span><br><span class="line">7.6  Android Sensor HAL实现 &#x2F;434</span><br><span class="line">7.6.1  Android Sensor构建 &#x2F;434</span><br><span class="line">7.6.2  Sensor HAL接口 &#x2F;435</span><br><span class="line">7.6.3  Sensor HAL实现 &#x2F;438</span><br><span class="line">7.7  Android WIFI HAL实现 &#x2F;441</span><br><span class="line">7.7.1  Android WIFI系统构架 &#x2F;441</span><br><span class="line">7.7.2  wpa_supplicant框架 &#x2F;442</span><br><span class="line">7.7.3  WIFI HAL实现 &#x2F;444</span><br><span class="line">7.8  Android蓝牙本地实现 &#x2F;447</span><br><span class="line">7.8.1  Android蓝牙构架 &#x2F;447</span><br><span class="line">7.8.2  BlueZ结构体系 &#x2F;448</span><br><span class="line">7.8.3  BlueZ适配层 &#x2F;452</span><br><span class="line">7.9  Android 定位实现 &#x2F;453</span><br><span class="line">7.9.1  定位系统构架 &#x2F;453</span><br><span class="line">7.9.2  GPS HAL实现 &#x2F;454</span><br><span class="line">7.10  Android Power HAL实现 &#x2F;459</span><br><span class="line">7.11  Android Vibrator HAL实现 &#x2F;461</span><br><span class="line">7.12  小结 &#x2F;462</span><br><span class="line">第8章  Dalvik虚拟机的构架、原理与实现 &#x2F;463</span><br><span class="line">8.1  Dalvik虚拟机概述 &#x2F;464</span><br><span class="line">8.1.1  什么是Dalvik虚拟机 &#x2F;464</span><br><span class="line">8.1.2  Dalvik虚拟机的功能 &#x2F;464</span><br><span class="line">8.1.3  Dalvik虚拟机与Java虚拟机的区别 &#x2F;465</span><br><span class="line">8.2  Dalvik构架与实现 &#x2F;466</span><br><span class="line">8.2.1  Dalvik系统构架 &#x2F;466</span><br><span class="line">8.2.2  dx和dexdump工具 &#x2F;468</span><br><span class="line">8.2.3  .dex文件格式解析 &#x2F;470</span><br><span class="line">8.2.4  Dalvik内部机制 &#x2F;487</span><br><span class="line">8.2.5  Dalvik进程管理 &#x2F;492</span><br><span class="line">8.2.6  Dalvik内存管理 &#x2F;501</span><br><span class="line">8.2.7  Dalvik加载器 &#x2F;509</span><br><span class="line">8.2.8  Dalvik解释器 &#x2F;517</span><br><span class="line">8.2.9  Dalvik JIT &#x2F;519</span><br><span class="line">8.3  JNI的构架与实现 &#x2F;523</span><br><span class="line">8.3.1  JNI构架 &#x2F;523</span><br><span class="line">8.3.2  JNI实现 &#x2F;524</span><br><span class="line">8.4  小结 &#x2F;526</span><br><span class="line">第9章  Android 核心库 &#x2F;527</span><br><span class="line">9.1  Android核心库简介 &#x2F;528</span><br><span class="line">9.2  Android系统API &#x2F;529</span><br><span class="line">9.2.1  android包 &#x2F;529</span><br><span class="line">9.2.2  android资源包 &#x2F;529</span><br><span class="line">9.2.3  ApiCheck机制 &#x2F;529</span><br><span class="line">9.3  小结 &#x2F;532</span><br><span class="line">后记 &#x2F;533</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0053WMHF6/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0053WMHF6&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51Qv5p7cRDL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android基础教程(第3版•修订版)</title>
    <url>/2020/04/19/B00550OMMC/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android基础教程(第3版•修订版)<br>作者信息： 作者: Ed Burnette [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目　录</span><br><span class="line">第一部　分Android简介</span><br><span class="line">第1章　快速入门　2</span><br><span class="line">1.1　安装工具　2</span><br><span class="line">1.1.1　Java 5.0+　2</span><br><span class="line">1.1.2 Eclipse　3</span><br><span class="line">1.1.3　AndroidSDK启动程序软件包　4</span><br><span class="line">1.1.4　AndroidSDK组件　4</span><br><span class="line">1.1.5　Eclipse插件　5</span><br><span class="line">1.2　创建第一个程序　7</span><br><span class="line">1.3　在模拟器上运行程序　8</span><br><span class="line">1.3.1　创建一个AVD　8</span><br><span class="line">1.3.2　再试一次　10</span><br><span class="line">1.4　在手机上运行程序　10</span><br><span class="line">1.5　快速阅读指南　11</span><br><span class="line">第2章　基本概念　12</span><br><span class="line">2.1　Android的系统架构　12</span><br><span class="line">2.1.1　Linux内核　13</span><br><span class="line">2.1.2　本机库　13</span><br><span class="line">2.1.3　Android运行时　14</span><br><span class="line">2.1.4　应用程序框架　15</span><br><span class="line">2.1.5　应用程序和小部件　15</span><br><span class="line">2.2　它还活着　16</span><br><span class="line">2.2.1　进程不等于应用程序　17</span><br><span class="line">2.2.2　应用程序生命周期　17</span><br><span class="line">2.3　构建块　19</span><br><span class="line">2.3.1　活动　19</span><br><span class="line">2.3.2　意图　19</span><br><span class="line">2.3.3　服务　19</span><br><span class="line">2.3.4　内容提供者　20</span><br><span class="line">2.4　使用资源　20</span><br><span class="line">2.5　安全性　20</span><br><span class="line">2.6　快速阅读指南　21</span><br><span class="line">第二部分 Android基础知识</span><br><span class="line">第3章　设计用户界面　24</span><br><span class="line">3.1　数独游戏简介　24</span><br><span class="line">3.2　声明性设计　25</span><br><span class="line">3.3　创建启动界面　26</span><br><span class="line">3.4　使用替代资源　33</span><br><span class="line">3.5　实现About对话框　35</span><br><span class="line">3.6　应用主题　39</span><br><span class="line">3.7　添加菜单　41</span><br><span class="line">3.8　添加设置　42</span><br><span class="line">3.9　开始新游戏　44</span><br><span class="line">3.10　调试程序　45</span><br><span class="line">3.10.1　利用日志消息调试程序　46</span><br><span class="line">3.10.2　利用调试器调试程序　47</span><br><span class="line">3.11　退出游戏　47</span><br><span class="line">3.12　快速阅读指南　47</span><br><span class="line">第4章　绘制2D图形　49</span><br><span class="line">4.1　Android图形基础　49</span><br><span class="line">4.1.1　Color类　49</span><br><span class="line">4.1.2　Paint类　50</span><br><span class="line">4.1.3　Canvas类　50</span><br><span class="line">4.1.4　Path类　51</span><br><span class="line">4.1.5　Drawable类　52</span><br><span class="line">4.2　在数独程序中添加图形　53</span><br><span class="line">4.2.1　开始游戏　54</span><br><span class="line">4.2.2　定义Game类　54</span><br><span class="line">4.2.3　定义PuzzleView类　56</span><br><span class="line">4.2.4　绘制游戏盘面　57</span><br><span class="line">4.2.5　绘制数字　60</span><br><span class="line">4.3　处理输入　61</span><br><span class="line">4.3.1　定义和更新选定区域　61</span><br><span class="line">4.3.2　输入数字　63</span><br><span class="line">4.3.3　增加提示　64</span><br><span class="line">4.3.4　抖动屏幕　65</span><br><span class="line">4.4　其他问题　66</span><br><span class="line">4.4.1　创建软键盘　66</span><br><span class="line">4.4.2　实现游戏逻辑　71</span><br><span class="line">4.4.3　其他功能　73</span><br><span class="line">4.5　更多改进　74</span><br><span class="line">4.6　快速阅读指南　75</span><br><span class="line">第5章　多媒体　76</span><br><span class="line">5.1　播放音频　76</span><br><span class="line">5.2　播放视频　81</span><br><span class="line">5.3　为数独游戏配上音乐　85</span><br><span class="line">5.4　快速阅读指南　88</span><br><span class="line">第6章　存储本地数据　89</span><br><span class="line">6.1　为数独游戏添加选项　89</span><br><span class="line">6.2　继续玩前一个游戏　91</span><br><span class="line">6.3　记住当前位置　92</span><br><span class="line">6.4　访问内部文件系统　94</span><br><span class="line">6.5　访问SD卡　95</span><br><span class="line">6.6　快速阅读指南　96</span><br><span class="line">第三部分　高级主题</span><br><span class="line">第7章　互联的世界　98</span><br><span class="line">7.1　通过意图实现浏览　99</span><br><span class="line">7.2　利用视图打开网页　102</span><br><span class="line">7.3　JavaScript与Java通信　106</span><br><span class="line">7.4　使用Web服务　112</span><br><span class="line">7.5　快速阅读指南　122</span><br><span class="line">第8章　定位与环境感知　124</span><br><span class="line">8.1　位置，位置，位置　124</span><br><span class="line">8.1.1　我在哪里　125</span><br><span class="line">8.1.2　更新位置　127</span><br><span class="line">8.1.3　模拟说明　130</span><br><span class="line">8.2　充分利用传感器　130</span><br><span class="line">8.2.1　了解传感器　130</span><br><span class="line">8.2.2　解析传感器的读数　131</span><br><span class="line">8.2.3　模拟说明　132</span><br><span class="line">8.3　地图功能　133</span><br><span class="line">8.3.1　嵌入MapView　133</span><br><span class="line">8.3.2　准备就绪　136</span><br><span class="line">8.3.3　模拟说明　137</span><br><span class="line">8.4　快速阅读指南　137</span><br><span class="line">第9章　SQL实战　138</span><br><span class="line">9.1　SQLite简介　138</span><br><span class="line">9.2　SQL基础　139</span><br><span class="line">9.2.1　DDL语句　140</span><br><span class="line">9.2.2　修改语句　140</span><br><span class="line">9.2.3　查询语句　140</span><br><span class="line">9.3　你好，数据库　141</span><br><span class="line">9.3.1　使用SQLiteOpenHelper　142</span><br><span class="line">9.3.2　定义主程序　143</span><br><span class="line">9.3.3　添加一行　145</span><br><span class="line">9.3.4　运行一个查询　145</span><br><span class="line">9.3.5　显示查询结果　146</span><br><span class="line">9.4　数据绑定　147</span><br><span class="line">9.5　使用ContentProvider　150</span><br><span class="line">9.5.1　更改主程序　152</span><br><span class="line">9.5.2　添加一行　152</span><br><span class="line">9.5.3　运行一个查询　152</span><br><span class="line">9.6　实现ContentProvider　153</span><br><span class="line">9.7　快速阅读指南　154</span><br><span class="line">第10 章　利用OpenGL实现3D图形　155</span><br><span class="line">10.1　理解3D图形　155</span><br><span class="line">10.2　OpenGL简介　156</span><br><span class="line">10.3　构建一个OpenGL程序　157</span><br><span class="line">10.4　渲染场景　158</span><br><span class="line">10.5　构建一个模型　162</span><br><span class="line">10.6　光线、相机　165</span><br><span class="line">10.7　动作　166</span><br><span class="line">10.8　应用纹理　167</span><br><span class="line">10.9　透明效果　169</span><br><span class="line">10.10　测量平滑度　170</span><br><span class="line">10.11　快速阅读指南　171</span><br><span class="line">第四部分　下一代产品</span><br><span class="line">第11章　多点触控　174</span><br><span class="line">11.1　多点触控概述　174</span><br><span class="line">11.2　创建触控示例　176</span><br><span class="line">11.3　了解触控事件　178</span><br><span class="line">11.4　设置图像变换　180</span><br><span class="line">11.5　实现拖动动作　181</span><br><span class="line">11.6　实现捏压缩放动作　182</span><br><span class="line">11.6.1　两个点之间的距离　183</span><br><span class="line">11.6.2　两个点的中点　183</span><br><span class="line">11.7　快速阅读指南　184</span><br><span class="line">第12章　主界面　185</span><br><span class="line">12.1　Hello，Widget　185</span><br><span class="line">12.1.1　创建第一个小部件程序　185</span><br><span class="line">12.1.2　调用所有小部件　187</span><br><span class="line">12.1.3　拉伸以适合屏幕尺寸　188</span><br><span class="line">12.1.4　使用和扩展　189</span><br><span class="line">12.1.5　运行小部件　189</span><br><span class="line">12.1.6　最新进展　190</span><br><span class="line">12.1.7　快乐之旅　192</span><br><span class="line">12.2　动态壁纸　192</span><br><span class="line">12.2.1　创建壁纸项目　193</span><br><span class="line">12.2.2　服务简介　195</span><br><span class="line">12.2.3　创建一个绘图引擎　196</span><br><span class="line">12.2.4　重用OpenGL代码　197</span><br><span class="line">12.2.5　创建和销毁引擎　198</span><br><span class="line">12.2.6　管理Surface　199</span><br><span class="line">12.2.7　可视化壁纸　201</span><br><span class="line">12.2.8　响应用户的输入　201</span><br><span class="line">12.3　快速阅读指南　203</span><br><span class="line">第13章　一次编写，到处测试　204</span><br><span class="line">13.1　启动模拟器　204</span><br><span class="line">13.2　创建适用于多个版本的程序　205</span><br><span class="line">13.3　AndroidAPI的发展　206</span><br><span class="line">13.4　大量错误　212</span><br><span class="line">13.5　各种屏幕尺寸　213</span><br><span class="line">13.6　在SD卡上安装程序　214</span><br><span class="line">13.7　快速阅读指南　215</span><br><span class="line">第14章　发布到AndroidMarket　216</span><br><span class="line">14.1　准备工作　216</span><br><span class="line">14.2　签名　217</span><br><span class="line">14.3　发布　218</span><br><span class="line">14.4　更新　219</span><br><span class="line">14.5　结语　220</span><br><span class="line">第五部分　附录</span><br><span class="line">附录A　Java与Android：语言及其API　222</span><br><span class="line">附录B　参考书目　226</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00550OMMC/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00550OMMC&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51xJ9pQNajL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>细说Android 4.0 NDK编程</title>
    <url>/2020/04/19/B008N08IY4/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 细说Android 4.0 NDK编程<br>作者信息： 作者: 王家林 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《细说Android 4.0 NDK编程》力求从多个技术角度将移动互联网智能终端软件开发的重点、难点及解决方法呈现给读者，使读者通过系统的学习，可以在移动互联网迅猛发展的浪潮中自由遨游。《细说Android 4.0 NDK编程》适合从事Android开发的人员阅读。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 Android 4.0开发环境搭建和测试</span><br><span class="line">1.1 下载所需要的软件</span><br><span class="line">1.2 安装所需要的软件</span><br><span class="line">1.3 第一个Android 4.0程序</span><br><span class="line">1.4 剖析Android 4.0程序的组织结构</span><br><span class="line">1.5 Android4.0模拟器无3G信号的解决方案</span><br><span class="line">第2章 使用C语言编程</span><br><span class="line">2.1 下载并安装C语言交叉编译工具链</span><br><span class="line">2.2 第一个C语言程序</span><br><span class="line">2.3 在Android上安装、授权、运行C语言程序</span><br><span class="line">2.4 采用动态链接的方式生成可执行文件并在Android上安装、授权、运行C程序</span><br><span class="line">2.5 解决采用动态链接方式生成的可执行文件执行时的“Segmentation fault”问题</span><br><span class="line">第3章 搭建Android NDK开发环境并开发第一个Android NDK程序</span><br><span class="line">3.1 下载Windows下开发Android NDK所需的软件</span><br><span class="line">3.2 安装Windows下Android NDK开发环境</span><br><span class="line">3.3 配置Cygwin</span><br><span class="line">3.4 开发第一个Android NDK程序</span><br><span class="line">第4章 Android NDK中的代码调用</span><br><span class="line">4.1 NDK与JNI的关系</span><br><span class="line">4.2 JNI中的JavaVM与JNIEnv对象</span><br><span class="line">4.3 Android NDK中Java通过JNI调用C的步骤</span><br><span class="line">4.4 本地C代码调用Java中的Method</span><br><span class="line">4.5 本地C代码获得Java对象的属性值</span><br><span class="line">4.6 多个类中有本地C代码的调用</span><br><span class="line">4.7 Java、Dalvik VM、C∕C++的运行机制与流程</span><br><span class="line">4.8 Java中分配线程调用C∕C++函数</span><br><span class="line">第5章 NDK的架构∕设计模式及NDK与软∕硬件整合、云计算</span><br><span class="line">5.1 NDK的架构图及思考</span><br><span class="line">5.2 Facade设计模式剖析</span><br><span class="line">5.3 Facade设计模式在JNI中的应用</span><br><span class="line">5.4 Facade设计模式在NDK中的应用</span><br><span class="line">5.5 NDK的优势与不足</span><br><span class="line">5.6 NDK与软顾件整合</span><br><span class="line">5.7 NDK与云计算</span><br><span class="line">附录A Android UI编程</span><br><span class="line">附录B 如何成为Android高手V2.0：结合云计算和智能终端、软∕硬件整合</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B008N08IY4/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B008N08IY4&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51jCV5oJb0L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵程序设计丛书:Android平板电脑编程基础教程</title>
    <url>/2020/04/19/B008AK5YDU/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 图灵程序设计丛书:Android平板电脑编程基础教程<br>作者信息： 作者: Robbie Matthews [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《图灵程序设计丛书:Android平板电脑编程基础教程》通过大量示例项目，全面介绍Android平板电脑编程，协助你创建一系列有趣的Android应用程序，既包括实用程序，又涵盖好玩的游戏。最重要的是，它从基础知识讲起，就算没有任何Android经验，只要你从头开始阅读，也能读懂。通过阅读《图灵程序设计丛书:Android平板电脑编程基础教程》，你将学到：触摸屏环境编程；在应用程序中使用传感器及其提供的数据；开发Android平板电脑游戏；用多种语言编写Android平板电脑应用程序；将Android智能手机应用程序迁移到Android平板电脑。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 Android入门</span><br><span class="line">1.1 我的便携式编程之路</span><br><span class="line">1.2 Android横空出世</span><br><span class="line">1.3 准备好计算机</span><br><span class="line">1.3.1 搭建开发环境</span><br><span class="line">1.3.2 创建模拟器实例</span><br><span class="line">1.3.3 设置路径</span><br><span class="line">1.4 编写第一个Android程序</span><br><span class="line">1.5 如果你害怕Java</span><br><span class="line">1.6 Java简介</span><br><span class="line">1.6.1 Java的基本结构</span><br><span class="line">1.6.2 基本数据类型</span><br><span class="line">1.6.3 流程控制</span><br><span class="line">1.6.4 对象</span><br><span class="line">1.6.5 构造函数、初始化块和重载</span><br><span class="line">1.6.6 何时释放对象</span><br><span class="line">1.6.7 字符串处理</span><br><span class="line">1.6.8 包</span><br><span class="line">1.6.9 列表和映射</span><br><span class="line">1.6.10 泛型</span><br><span class="line">1.6.11 继承和接口</span><br><span class="line">1.6.12 注解</span><br><span class="line">1.6.13 其他内容</span><br><span class="line">1.7 总结</span><br><span class="line">第2章 Android的工作原理</span><br><span class="line">2.1 Android程序的基本结构</span><br><span class="line">2.2 意图简介</span><br><span class="line">2.2.1 意图过滤器</span><br><span class="line">2.2.2 常见意图</span><br><span class="line">2.2.3 结束活动</span><br><span class="line">2.3 Android与Linux</span><br><span class="line">2.4 总结</span><br><span class="line">第3章 Android平板电脑的功能</span><br><span class="line">3.1 大量传感器</span><br><span class="line">3.2 光线、相机和操作</span><br><span class="line">3.3 浏览网页</span><br><span class="line">3.3.1 管理资产</span><br><span class="line">3.3.2 WebView的强大功能</span><br><span class="line">3.4 你的个人通讯录：管理联系人</span><br><span class="line">3.4.1 访问联系人</span><br><span class="line">3.4.2 列表简介</span><br><span class="line">3.4.3 访问联系人信息的其他方式</span><br><span class="line">3.5 个人经验分享：收发数据</span><br><span class="line">3.5.1 补充内容：选项菜单</span><br><span class="line">3.5.2 发送电子邮件</span><br><span class="line">3.6 喧闹的音画世界：管理多媒体文件</span><br><span class="line">3.7 总结</span><br><span class="line">第4章 超越Java：Python编程</span><br><span class="line">4.1 为何使用另一种语言</span><br><span class="line">4.2 准备</span><br><span class="line">4.3 管理脚本</span><br><span class="line">4.3.1 Help！ I Need Somebody</span><br><span class="line">4.3.2 Python帮助</span><br><span class="line">4.3.3 Facade是什么</span><br><span class="line">4.3.4 再谈意图</span><br><span class="line">4.3.5 使用意图的不同方式</span><br><span class="line">4.3.6 用户交互</span><br><span class="line">4.3.7 事件</span><br><span class="line">4.3.8 多媒体文件</span><br><span class="line">4.3.9 控制手机</span><br><span class="line">4.3.10 我身处何方</span><br><span class="line">4.3.11 电池</span><br><span class="line">4.3.12 让设备处于唤醒状态</span><br><span class="line">4.3.13 编辑技巧</span><br><span class="line">4.3.14 联系人和电话号码</span><br><span class="line">4.3.15 SQL</span><br><span class="line">4.3.16 其他接口</span><br><span class="line">4.4 总结</span><br><span class="line">第5章 多媒体播放器</span><br><span class="line">5.1 片段</span><br><span class="line">5.1.1 片段是什么</span><br><span class="line">5.1.2 研究示例</span><br><span class="line">5.1.3 操作栏</span><br><span class="line">5.1.4 片段管理器</span><br><span class="line">5.2 多媒体播放器</span><br><span class="line">5.2.1 以列表方式显示游标的内容</span><br><span class="line">5.2.2 查询多媒体文件</span><br><span class="line">5.2.3 响应单击</span><br><span class="line">5.2.4 再谈操作栏</span><br><span class="line">5.2.5 菜单</span><br><span class="line">5.2.6 获取多媒体文件的URI</span><br><span class="line">5.2.7 播放多媒体文件</span><br><span class="line">5.2.8 各种多媒体</span><br><span class="line">5.2.9 对话框</span><br><span class="line">5.2.10 修改文件列表的游标</span><br><span class="line">5.2.11 高级多媒体播放</span><br><span class="line">5.2.12 显示进度</span><br><span class="line">5.2.13 控制进度</span><br><span class="line">5.3 总结</span><br><span class="line">第6章 资源管理器</span><br><span class="line">6.1 文件资源管理器剖析</span><br><span class="line">6.1.1 使用ListActivity</span><br><span class="line">6.1.2 资源</span><br><span class="line">6.1.3 创建自定义列表适配器</span><br><span class="line">6.1.4 填充</span><br><span class="line">6.1.5 填充列表</span><br><span class="line">6.1.6 获取有关文件的信息</span><br><span class="line">6.1.7 MIME类型</span><br><span class="line">6.1.8 获悉文件的日期信息</span><br><span class="line">6.1.9 入乡随俗</span><br><span class="line">6.1.10 设置首选项</span><br><span class="line">6.1.11 读取首选项</span><br><span class="line">6.1.12 排序技巧</span><br><span class="line">6.1.13 活动本身</span><br><span class="line">6.1.14 对用户选择列表项做出响应</span><br><span class="line">6.1.15 OnCreate方法</span><br><span class="line">6.1.16 另一个菜单</span><br><span class="line">6.1.17 响应上下文菜单</span><br><span class="line">6.1.18 对话框</span><br><span class="line">6.1.19 一些清理工作</span><br><span class="line">6.1.20 改进</span><br><span class="line">6.2 总结</span><br><span class="line">第7章 联系人管理器</span><br><span class="line">7.1 完全不同的领域</span><br><span class="line">7.1.1 最终创建的应用程序</span><br><span class="line">7.1.2 指示牌剖析</span><br><span class="line">7.1.3 获悉视图何时可用</span><br><span class="line">7.1.4 改进空间</span><br><span class="line">7.1.5 向后兼容性</span><br><span class="line">7.1.6 列表处理</span><br><span class="line">7.1.7 保存列表</span><br><span class="line">7.1.8 重用库</span><br><span class="line">7.1.9 导入和导出</span><br><span class="line">7.1.10 有关对话框的最后说明</span><br><span class="line">7.2 管理联系人</span><br><span class="line">7.2.1 Loader</span><br><span class="line">7.2.2 启动Loader</span><br><span class="line">7.2.3 Loader的工作原理</span><br><span class="line">7.2.4 为何使用Loader</span><br><span class="line">7.2.5 搜索栏</span><br><span class="line">7.2.6 联系人详细信息</span><br><span class="line">7.2.7 编辑数据</span><br><span class="line">7.2.8 添加电话号码</span><br><span class="line">7.2.9 修改电话号码类型</span><br><span class="line">7.2.10 删除数据</span><br><span class="line">7.3 总结</span><br><span class="line">第8章 定位</span><br><span class="line">8.1 位置管理器</span><br><span class="line">8.1.1 位置提供器</span><br><span class="line">8.1.2 BAT3PGps</span><br><span class="line">8.1.3 一个操作位置管理器的类</span><br><span class="line">8.1.4 位置</span><br><span class="line">8.2 应用程序本身</span><br><span class="line">8.2.1 指南针</span><br><span class="line">8.2.2 方位和距离</span><br><span class="line">8.3 到达目的地了吗</span><br><span class="line">8.3.1 叫醒服务</span><br><span class="line">8.3.2 服务</span><br><span class="line">8.3.3 通知</span><br><span class="line">8.3.4 接近提醒</span><br><span class="line">8.3.5 “接近提醒”的优点和缺点</span><br><span class="line">8.4 目的地列表</span><br><span class="line">8.4.1 这是什么地方</span><br><span class="line">8.4.2 接下来怎么办</span><br><span class="line">8.5 总结</span><br><span class="line">第9章 游戏编程</span><br><span class="line">9.1 线程</span><br><span class="line">9.1.1 Java线程</span><br><span class="line">9.1.2 Android线程</span><br><span class="line">9.2 移动的点</span><br><span class="line">9.2.1 SurfaceView</span><br><span class="line">9.2.2 使用SurfaceHolder</span><br><span class="line">9.2.3 Handler</span><br><span class="line">9.2.4 使用Handler</span><br><span class="line">9.2.5 运行游戏</span><br><span class="line">9.2.6 处理输入</span><br><span class="line">9.2.7 自定义字体</span><br><span class="line">9.2.8 资产是什么</span><br><span class="line">9.2.9 字体示例</span><br><span class="line">9.2.10 另一种创建菜单的方式</span><br><span class="line">9.3 进入三维领域</span><br><span class="line">9.3.1 一个盒子</span><br><span class="line">9.3.2 其他进程间通信方式</span><br><span class="line">9.4 总结</span><br><span class="line">第10章 提醒</span><br><span class="line">10.1 闹钟</span><br><span class="line">10.1.1 PendingIntent</span><br><span class="line">10.1.2 停止闹钟</span><br><span class="line">10.1.3 匹配的PendingIntent</span><br><span class="line">10.2 发送短信</span><br><span class="line">10.3 语音合成</span><br><span class="line">10.4 SQLite</span><br><span class="line">10.4.1 创建SQLite数据库</span><br><span class="line">10.4.2 获取数据库</span><br><span class="line">10.4.3 使用数据库</span><br><span class="line">10.5 示例应用程序</span><br><span class="line">10.5.1 使用该应用程序</span><br><span class="line">10.5.2 联系人</span><br><span class="line">10.5.3 设置闹钟</span><br><span class="line">10.5.4 闹钟列表</span><br><span class="line">10.5.5 检查TTS</span><br><span class="line">10.5.6 改进该应用程序</span><br><span class="line">10.6 总结</span><br><span class="line">第11章 其他</span><br><span class="line">11.1 定时器</span><br><span class="line">11.2 在后台执行任务</span><br><span class="line">11.3 下载管理器</span><br><span class="line">11.4 动画</span><br><span class="line">11.4.1 定义动画</span><br><span class="line">11.4.2 竟然明目张胆地插值</span><br><span class="line">11.4.3 加载动画</span><br><span class="line">11.5 USB</span><br><span class="line">11.5.1 USB编程</span><br><span class="line">11.5.2 响应USB事件</span><br><span class="line">11.6 总结</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B008AK5YDU/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B008AK5YDU&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51RCqkYtb-L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android编程入门很简单</title>
    <url>/2020/04/19/B008V46UGU/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android编程入门很简单<br>作者信息： 作者: 王勇 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Android编程入门很简单(8.7小时多媒体教学视频)》是一本与众不同的Android学习读物，是一本化繁为简，把抽象问题具体化，把复杂问题简单化的书。《Android编程入门很简单(8.7小时多媒体教学视频)》避免出现云山雾罩、晦涩难懂的讲解，代之以轻松活泼、由浅入深的剖析。这必将使得阅读《Android编程入门很简单(8.7小时多媒体教学视频)》的读者少走弯路，快速上手，从而建立学习Android开发的信心。《Android编程入门很简单(8.7小时多媒体教学视频)》配带1张光盘，收录了《Android编程入门很简单(8.7小时多媒体教学视频)》重点内容的教学视频和《Android编程入门很简单(8.7小时多媒体教学视频)》涉及的所有源代码。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1篇入门必备</span><br><span class="line">第1章初识Android</span><br><span class="line">1.1手机发展简史</span><br><span class="line">1.1.1手机发展的里程碑</span><br><span class="line">1.1.2Android的各个版本</span><br><span class="line">1.2开放手机联盟</span><br><span class="line">1.2.1开放手机联盟的目的</span><br><span class="line">1.2.2分工合作</span><br><span class="line">1.3Android中的个人英雄主义</span><br><span class="line">1.3.1第一届挑战赛冠军介绍</span><br><span class="line">1.3.2第二届挑战赛冠军介绍</span><br><span class="line">1.3.3Androidmarket</span><br><span class="line">1.4Android平台</span><br><span class="line">1.4.1Android体系结构</span><br><span class="line">1.4.2熟悉的开发工具</span><br><span class="line">1.4.3合理的学习曲线</span><br><span class="line">1.5小结</span><br><span class="line">第2章搭建你的开发环境</span><br><span class="line">2.1配置前的准备工作</span><br><span class="line">2.1.1 Android支持的操作系统</span><br><span class="line">2.1.2准备“四大法宝”</span><br><span class="line">2.2安装并配置JDK</span><br><span class="line">2.2.1 安装JDK</span><br><span class="line">2.2.2配置JDK</span><br><span class="line">2.3安装并配置Eclipse</span><br><span class="line">2.3.1 运行Eclipse</span><br><span class="line">2.3.2 了解Eclipse</span><br><span class="line">2.4安装并配置Android SDK</span><br><span class="line">2.4.1 下载Android SDK</span><br><span class="line">2.4.2配置SDK</span><br><span class="line">2.5下载ADT</span><br><span class="line">2.5.1 下载ADT</span><br><span class="line">2.5.2 为Eclipse设置SDK路径</span><br><span class="line">2.6新建模拟器</span><br><span class="line">2.6.1 新建AVD</span><br><span class="line">2.6.2运行模拟器</span><br><span class="line">2.7真机测试</span><br><span class="line">2.7.1安装手机驱动</span><br><span class="line">2.7.2设置手机</span><br><span class="line">2.8 小结</span><br><span class="line">第3章创建第一个程序——helloworld</span><br><span class="line">3.1新建第一个程序</span><br><span class="line">3.1.1新建工程</span><br><span class="line">3.1.2运行程序</span><br><span class="line">3.2认识HelloWodd</span><br><span class="line">3.2.1 首识Android工程</span><br><span class="line">3.2.2认识布局文件</span><br><span class="line">3.2.3认识值文件</span><br><span class="line">3.2.4认识R文件</span><br><span class="line">3.2.5认识注册文件</span><br><span class="line">3.3调试程序</span><br><span class="line">3.3.1 增加断点</span><br><span class="line">3.3.2开始调试</span><br><span class="line">3.3.3单步调试</span><br><span class="line">3.4更多示例程序</span><br><span class="line">3.4.1 导入Samples</span><br><span class="line">3.4.2经典范例</span><br><span class="line">3.5 小结</span><br><span class="line">第4章使用Android工具</span><br><span class="line">4.1使用DDMS</span><br><span class="line">4.1.1 认识DDMS</span><br><span class="line">4.1.2使用进程</span><br><span class="line">4.1.3使用文件浏览器</span><br><span class="line">4.1.4使用模拟器控制</span><br><span class="line">4.1.5 使用日志</span><br><span class="line">4.1.6使用Screen Capture捕捉设备屏幕</span><br><span class="line">4.2 使用Android调试桥</span><br><span class="line">4.2.1使用ADB</span><br><span class="line">4.2.2显示连接到计算机的设备</span><br><span class="line">4.2.3针对特定设备操作</span><br><span class="line">4.2.4启动和停止ADB</span><br><span class="line">4.2.5使用ADB操作文件和apk</span><br><span class="line">4.2.6使用ADB shell</span><br><span class="line">4.3 使用AAPT</span><br><span class="line">4.3.1使用ADT导出签名程序</span><br><span class="line">4.3.2使用命令行生成签名apk文件</span><br><span class="line">4.4小结</span><br><span class="line">第2篇界面开发</span><br><span class="line">第5章探索界面ui元素</span><br><span class="line">5.1认识Android视图、Widget以及布局</span><br><span class="line">5.2必须了解的Widget组件</span><br><span class="line">5.2.1 使用可滚动的文本控件——TextView</span><br><span class="line">5.2.2 TextView中的一些功能</span><br><span class="line">5.2.3 使用可滚动的视图——ScrollView</span><br><span class="line">5.2.4文字的编辑</span><br><span class="line">5.2.5 使用按钮——Button</span><br><span class="line">5.2.6实例——计算器</span><br><span class="line">5.2.7 使用图片按钮——ImageButton</span><br><span class="line">5.2.8 使用复选框——CheckBox</span><br><span class="line">5.2.9实例——请同意本协议</span><br><span class="line">5.2.10 使用单选框——RadioGroup</span><br><span class="line">5.2.11 实例——请选择性别</span><br><span class="line">5.2.12使用下拉列表框——Spinner</span><br><span class="line">5.2.13实例——请选择工作年限</span><br><span class="line">5.2.14实例——动态修改Spinner项</span><br><span class="line">5.2.15 使用进度条——ProgressBar</span><br><span class="line">5.2.16实例——动态修改进度条</span><br><span class="line">5.2.17使用拖动条——SeekBar</span><br><span class="line">5.2.1 8实例——简单使用SeekBar</span><br><span class="line">5.2.19使用图片视图——ImageView</span><br><span class="line">5.2.20实例——ImageView的重叠效果</span><br><span class="line">5.2.21 使用网格视图——GridView</span><br><span class="line">5.2.22实例——通过宫格视图展示相应的应用</span><br><span class="line">5.2.23 使用消息提醒——Toast</span><br><span class="line">5.2.24实例——Toast的4种实现</span><br><span class="line">5.3使用列表视图（ListView&amp;ExpandableListView）</span><br><span class="line">5.3.1 使用列表——ListView</span><br><span class="line">5.3.2通过实例学习列表</span><br><span class="line">5.3.3 使用可扩展列表——EXpalldableListView</span><br><span class="line">5.3.4实例——简单使用ExpandableListView</span><br><span class="line">5.3.5实例——深入使用可扩展列表</span><br><span class="line">5.4使用菜单——Menu</span><br><span class="line">5.4.1 Menu的使用</span><br><span class="line">5.4.2通过实例学习使用Menu</span><br><span class="line">5.5小结</span><br><span class="line">第6章使用程序资源</span><br><span class="line">6.1资源的意义</span><br><span class="line">6.1.1什么是资源</span><br><span class="line">6.1.2怎样存储资源</span><br><span class="line">6.I.3怎样添加资源</span><br><span class="line">6.1.4资源的种类</span><br><span class="line">6.1.5怎样访问资源</span><br><span class="line">6.2使用资源</span><br><span class="line">6.2.1 使用资源管理器</span><br><span class="line">6.2.2使用String资源</span><br><span class="line">6.2.3实例——彩虹和太极</span><br><span class="line">6.2.4使用String数组资源</span><br><span class="line">6.2.5使用Color资源</span><br><span class="line">6.2.6使用Dimension资源</span><br><span class="line">6.2.7使用Drawble资源</span><br><span class="line">6.2.8使用样式</span><br><span class="line">6.2.9使用主题</span><br><span class="line">6.3 小结</span><br><span class="line">第7章设计界面布局</span><br><span class="line">7.1创建界面</span><br><span class="line">7.1.1 使用xml资源创建布局</span><br><span class="line">7.1.2使用代码创建布局</span><br><span class="line">7.2使用布局类</span><br><span class="line">7.2.1使用绝对布局</span><br><span class="line">7.2.2使用线性布局</span><br><span class="line">7.2.3使用框架布局</span><br><span class="line">7.2.4使用表格布局</span><br><span class="line">7.2.5使用关系布局</span><br><span class="line">7.3使用其他布局容器</span><br><span class="line">7.3.1 使用TabActivity</span><br><span class="line">7.3.2 自定义TabHost</span><br><span class="line">7.3.3 使用对话框</span><br><span class="line">7.3.4使用滑动抽屉</span><br><span class="line">7.4 小结</span><br><span class="line">第3篇功能实现</span><br><span class="line">第8章Android应用程序组成</span><br><span class="line">8.1深入理解Activity</span><br><span class="line">8.1.1使用Intent连接Activity</span><br><span class="line">8.1.2 Activity的生命周期</span><br><span class="line">……</span><br><span class="line">第9章Android中的数据存储</span><br><span class="line">第10章绚丽的多媒体技术</span><br><span class="line">第11章Android网上冲浪</span><br><span class="line">第12章Android地图服务</span><br><span class="line">第4篇项目案例开发</span><br><span class="line">第13章联系人助手</span><br><span class="line">第14章个人轨迹跟踪器</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B008V46UGU/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B008V46UGU&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41s7vg5CSUL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 4编程入门经典:开发智能手机与平板电脑应用</title>
    <url>/2020/04/19/B00AAOA5LA/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android 4编程入门经典:开发智能手机与平板电脑应用<br>作者信息： 作者: 李伟梦 (Wei-Meng Lee) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Android 4编程入门经典:开发智能手机与平板电脑应用》编辑推荐：Android4的问世，标志着Google将Android操作系统的大旗插到了智能手机和平板电脑的阵营中。《Android 4编程入门经典:开发智能手机与平板电脑应用》将教会您成功开发Android应用程序所需的一切。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 Android编程入门</span><br><span class="line">1.1 Android简介</span><br><span class="line">1.1.1 Android版本</span><br><span class="line">1.1.2 Android功能</span><br><span class="line">1.1.3 Android架构</span><br><span class="line">1.1.4市场上的Android设备</span><br><span class="line">1.1.5 AndroidMarket</span><br><span class="line">1.1.6 Android开发社区</span><br><span class="line">1.2获得所需工具</span><br><span class="line">1.2.1 Android SDK</span><br><span class="line">1.2.2安装Android SDK工具</span><br><span class="line">1.2.3配置Android SDK Manager</span><br><span class="line">1.2.4 Eclipse</span><br><span class="line">1.2.5 Android开发工具</span><br><span class="line">1.2.6创建Android虚拟设备（AVD）</span><br><span class="line">1.3创建第一个Android应用程序</span><br><span class="line">1.4 Android应用程序剖析</span><br><span class="line">1.5本章小结</span><br><span class="line">第2章 活动、碎片和意图</span><br><span class="line">2.1理解活动</span><br><span class="line">2.1.1如何对活动应用样式和主题</span><br><span class="line">2.1.2隐藏活动标题</span><br><span class="line">2.1.3显示对话框窗口</span><br><span class="line">2.1.4显示进度对话框</span><br><span class="line">2.1.5显示更复杂的进度对话框</span><br><span class="line">2.2使用意图链接活动</span><br><span class="line">2.2.1解决意图筛选器的冲突</span><br><span class="line">2.2.2从意图返回结果</span><br><span class="line">2.2.3使用意图对象传递数据</span><br><span class="line">2.3碎片</span><br><span class="line">2.3.1动态添加碎片</span><br><span class="line">2.3.2碎片的生命周期</span><br><span class="line">2.3.3碎片之间进行交互</span><br><span class="line">2.4使用意图调用内置应用程序</span><br><span class="line">2.4.1理解意图对象</span><br><span class="line">2.4.2使用意图筛选器</span><br><span class="line">2.4.3添加类别</span><br><span class="line">2.5显示通知</span><br><span class="line">2.6本章小结</span><br><span class="line">第3章 Android用户界面</span><br><span class="line">3.1 了解屏幕的构成</span><br><span class="line">3.1.1视图和视图组</span><br><span class="line">3.1.2 LinearLayout</span><br><span class="line">3.1.3 AbsoluteLayout</span><br><span class="line">3.1.4 TableLayout</span><br><span class="line">3.1.5 RelativeLayout</span><br><span class="line">3.1.6 FrameLayout</span><br><span class="line">3.1.7 ScrollView</span><br><span class="line">3.2适应显示方向</span><br><span class="line">3.2.1锚定视图</span><br><span class="line">3.2.2调整大小和重新定位</span><br><span class="line">3.3管理屏幕方向的变化</span><br><span class="line">3.3.1配置改变时保持状态信息</span><br><span class="line">3.3.2检测方向改变</span><br><span class="line">3.3.3控制活动的方向</span><br><span class="line">3.4使用Action Bar</span><br><span class="line">3.4.1 向Action Bar添加动作项</span><br><span class="line">3.4.2定制动作项和应用程序图标</span><br><span class="line">3.5 以编程方式创建用户界面</span><br><span class="line">3.6侦听用户界面通知</span><br><span class="line">3.6.1重写活动中定义的方法</span><br><span class="line">3.6.2为视图注册事件</span><br><span class="line">3.7本章小结</span><br><span class="line">第4章 使用视图设计用户界面</span><br><span class="line">4.1基本视图</span><br><span class="line">4.1.1 TextView视图</span><br><span class="line">4.1.2 Button、ImageButton、EditText、CheckBox、ToggleButton、RadioButton和RadioGroup视图</span><br><span class="line">4.1.3 ProgressBar视图</span><br><span class="line">4.1.4 AutoCompleteTextView视图</span><br><span class="line">4.2选取器视图</span><br><span class="line">4.2.1 TimePicker视图</span><br><span class="line">4.2.2 DatePicker视图</span><br><span class="line">4.3使用列表视图显示长列表</span><br><span class="line">4.3.1 ListView视图</span><br><span class="line">4.3.2使用Spinner视图</span><br><span class="line">4.4了解特殊碎片</span><br><span class="line">4.4.1使用ListFragment</span><br><span class="line">4.4.2使用DialogFragment</span><br><span class="line">4.4.3使用PreferenceFragment</span><br><span class="line">4.5 本章小结</span><br><span class="line">第5章 使用视图显示图片和菜单</span><br><span class="line">5.1使用图像视图显示图片</span><br><span class="line">5.1.1 Gallery和ImageView视图</span><br><span class="line">5.1.2 ImageSwitcher</span><br><span class="line">5.1.3 GridView</span><br><span class="line">5.2将菜单和视图一起使用</span><br><span class="line">5.2.1创建辅助方法</span><br><span class="line">5.2.2选项菜单</span><br><span class="line">5.2.3上下文菜单</span><br><span class="line">5.3其他一些视图</span><br><span class="line">5.3.1 AnalogClock和DigitalClock视图</span><br><span class="line">5.3.2 WebView</span><br><span class="line">5.4本章小结</span><br><span class="line">第6章 数据持久化</span><br><span class="line">6.1保存和加载用户首选项</span><br><span class="line">6.1.1使用活动访问首选项</span><br><span class="line">6.1.2通过编程检索和修改首选项值</span><br><span class="line">6.1.3修改首选项文件的默认名称</span><br><span class="line">6.2将数据持久化到文件中</span><br><span class="line">6.2.1保存到内部存储器</span><br><span class="line">6.2.2保存到外部存储器（SD卡）</span><br><span class="line">6.2.3选择最佳存储选项</span><br><span class="line">6.2.4使用静态资源</span><br><span class="line">6.3创建和使用数据库</span><br><span class="line">6.3.1创建DBAdapter辅助类</span><br><span class="line">6.3.2以编程方式使用数据库</span><br><span class="line">6.3.3预创建数据库</span><br><span class="line">6.4本章小结</span><br><span class="line">第7章 内容提供者</span><br><span class="line">7.1在Android中共享数据</span><br><span class="line">7.2使用内容提供者</span><br><span class="line">7.2.1预定义查询字符串常量</span><br><span class="line">7.2.2投影</span><br><span class="line">7.2.3筛选</span><br><span class="line">7.2.4排序</span><br><span class="line">7.3创建自己的内容提供者</span><br><span class="line">7.4使用内容提供者</span><br><span class="line">……</span><br><span class="line">第8章 消息传递</span><br><span class="line">第9章 基于位置的服务</span><br><span class="line">第10章 联网</span><br><span class="line">第11章 开发Android服务</span><br><span class="line">第12章 发布Android应用程序</span><br><span class="line">附录A 使用Eclipse进行Android开发</span><br><span class="line">附录B 使用Android模拟器</span><br><span class="line">附录C 练习答案</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00AAOA5LA/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00AAOA5LA&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51Q8qjjnlXL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>移动应用UI设计模式</title>
    <url>/2020/04/19/B00AMAI1AO/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 移动应用UI设计模式<br>作者信息： 作者: 尼尔 (Theresa Neil) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《移动应用UI设计模式》面向的读者是创建移动应用的产品经理、设计师和开发者。无论是针对某一移动操作系统设计一款简单的应用，还是开发应用于市场上所有操作系统的移动应用，《移动应用UI设计模式》都能为行业内的人员提供帮助。另外，《移动应用UI设计模式》还可以作为智能手机及其应用爱好者的参考读物，书中400 多张的应用设计截图能极大地开阔你的视野。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 导航</span><br><span class="line">1.1主要导航模式</span><br><span class="line">1.1.1跳板式</span><br><span class="line">1.1.2列表菜单式</span><br><span class="line">1.1.3选项卡式</span><br><span class="line">1.1.4陈列馆式</span><br><span class="line">1.1.5仪表式</span><br><span class="line">1.1.6隐喻式</span><br><span class="line">1.1.7超级菜单式</span><br><span class="line">1.2次级导航模式</span><br><span class="line">1.2.1页面轮盘式</span><br><span class="line">1.2.2图片轮盘式</span><br><span class="line">1.2.3扩展列表式</span><br><span class="line">第2章 表单</span><br><span class="line">2.1登录表单</span><br><span class="line">2.2注册表单</span><br><span class="line">2.3核对表单</span><br><span class="line">2.4计算表单</span><br><span class="line">2.5搜索表单</span><br><span class="line">2.6多步骤表单</span><br><span class="line">2.7长表单</span><br><span class="line">第3章 表格和列表</span><br><span class="line">3.1基本表格</span><br><span class="line">3.2无表头表格</span><br><span class="line">3.3固定列表格的表格</span><br><span class="line">3.4带有内容总览和数据的表格</span><br><span class="line">3.5行分组表格</span><br><span class="line">3.6级联式列表</span><br><span class="line">3.7带有视觉指示器的表格</span><br><span class="line">3.8可编辑表格</span><br><span class="line">第4章 搜索、分类和过滤</span><br><span class="line">4.1搜索</span><br><span class="line">4.1.1显性搜索</span><br><span class="line">4.1.2自动补全搜索</span><br><span class="line">4.1.3动态搜索</span><br><span class="line">4.1.4范围搜索</span><br><span class="line">4.1.5保存搜索记录并显示最近搜索内容</span><br><span class="line">4.1.6搜索表单</span><br><span class="line">4.1.7搜索结果／浏览结果</span><br><span class="line">4.2分类</span><br><span class="line">4.2.1屏内分类</span><br><span class="line">4.2.2分类排序选择器</span><br><span class="line">4.2.3分类表单</span><br><span class="line">4.3过滤</span><br><span class="line">4.3.1屏内过滤</span><br><span class="line">4.3.2过滤容器</span><br><span class="line">4.3.3过滤对话框</span><br><span class="line">4.3.4过滤表单</span><br><span class="line">第5章 工具</span><br><span class="line">5.1工具栏</span><br><span class="line">5.2选项菜单</span><br><span class="line">5.3调用动作按钮</span><br><span class="line">5.4情境工具</span><br><span class="line">5.5内联操作</span><br><span class="line">5.6多状态按钮</span><br><span class="line">5.7批量操作102</span><br><span class="line">第6章 图表</span><br><span class="line">6.1带过滤器的图表</span><br><span class="line">6.2带预览窗口的图表</span><br><span class="line">6.3总览加数据式图表</span><br><span class="line">6.4数据点细节图</span><br><span class="line">6.5详细信息图</span><br><span class="line">6.6缩放图表</span><br><span class="line">6.7数据透视表</span><br><span class="line">6.8火花谱线图</span><br><span class="line">第7章 视觉吸引</span><br><span class="line">7.1对话框</span><br><span class="line">7.2提示</span><br><span class="line">7.3使用向导</span><br><span class="line">7.4视频演示</span><br><span class="line">7.5幻灯片133</span><br><span class="line">7.6首次使用引导</span><br><span class="line">7.7持续视觉吸引</span><br><span class="line">7.8可发现的视觉吸引</span><br><span class="line">第8章 反馈与功能可见性</span><br><span class="line">8.1反馈</span><br><span class="line">8.2出错信息</span><br><span class="line">8.3确认</span><br><span class="line">8.4系统状态</span><br><span class="line">8.5功能可见性</span><br><span class="line">8.5.1触摸</span><br><span class="line">8.5.2滑动</span><br><span class="line">8.5.3拖曳</span><br><span class="line">第9章 帮助</span><br><span class="line">9.1使用说明</span><br><span class="line">9.2界面元素说明</span><br><span class="line">9.3使用向导</span><br><span class="line">第10章 反模式</span><br><span class="line">10.1标新立异</span><br><span class="line">10.2隐喻错位</span><br><span class="line">10.2.1控制错位</span><br><span class="line">10.2.2图标错位</span><br><span class="line">10.2.3心理模型错位</span><br><span class="line">10.3愚蠢的对话框</span><br><span class="line">10.4图表垃圾</span><br><span class="line">10.5按钮海</span><br><span class="line">附录</span><br><span class="line">关于作者</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00AMAI1AO/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00AMAI1AO&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51ZmgrB6wBL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android的设计与实现(卷1)</title>
    <url>/2020/04/19/B00CJ368JS/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android的设计与实现(卷1)<br>作者信息： 作者: 杨云君 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Android的设计与实现(卷1)》编辑推荐：从源代码角度，系统、深入、透彻剖析Android系统框架层（Framework）的设计思想和实现原理，为Android应用工程师和系统工程师解决各种难题提供了原理性的指导！资深Android内核专家亲自执笔，Lordhong等数位资深专家和安卓巴士等专业社区联袂推荐。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">第一部分 基础篇</span><br><span class="line">第1章 Android体系结构及源代码阅读环境搭建</span><br><span class="line">1.1 Android发展过程</span><br><span class="line">1.2 Android体系结构</span><br><span class="line">1.2.1 静态视角的体系结构</span><br><span class="line">1.2.2 动态视角的体系结构</span><br><span class="line">1.3 Android源码下载和编译</span><br><span class="line">1.3.1 搭建开发环境</span><br><span class="line">1.3.2 下载Android上层系统源代码</span><br><span class="line">1.3.3 下载指定模块源码</span><br><span class="line">1.3.4 下载 Android Linux Kernel源码</span><br><span class="line">1.3.5 编译Android上层系统源码</span><br><span class="line">1.3.6 编译指定模块源码</span><br><span class="line">1.4 Android源码结构</span><br><span class="line">1.5 Android源码开发工具的配置和使用</span><br><span class="line">1.5.1 配置Android SDK</span><br><span class="line">1.5.2 用Eclipse开发和调试源代码</span><br><span class="line">1.5.3 用Source Insight阅读源代码</span><br><span class="line">1.6 NDK开发环境配置</span><br><span class="line">1.7 本章小结</span><br><span class="line">第2章 框架基础JNI</span><br><span class="line">2.1 JNI在Android系统中所处的位置</span><br><span class="line">2.2 JNI框架层实例分析</span><br><span class="line">2.2.1 Log系统Java层分析</span><br><span class="line">2.2.2 Log系统的JNI层</span><br><span class="line">2.2.3 Log系统的JNI方法注册</span><br><span class="line">2.3 JNI总管：JNIEnv</span><br><span class="line">2.4 在Java中调用JNI实现方法</span><br><span class="line">2.4.1 Java数据类型与JNI数据类型转换</span><br><span class="line">2.4.2 JNI方法命名规则</span><br><span class="line">2.4.3 JNI方法签名规则</span><br><span class="line">2.5 JNI操作Java对象</span><br><span class="line">2.5.1 访问Java对象</span><br><span class="line">2.5.2 操作成员变量（域）和方法</span><br><span class="line">2.5.3 全局引用、弱全局引用和局部引用</span><br><span class="line">2.6 JNI异常处理</span><br><span class="line">2.7 JNI应用层实例分析</span><br><span class="line">2.7.1 Java层分析</span><br><span class="line">2.7.2 JNI层代码和异常处理</span><br><span class="line">2.8 本章小结</span><br><span class="line">第二部分 启动篇</span><br><span class="line">第3章 Android启动过程的底层实现</span><br><span class="line">3.1 Android正常模式启动流程</span><br><span class="line">3.2 Kernel启动过程</span><br><span class="line">3.2.1 内核引导阶段</span><br><span class="line">3.2.2 内核启动阶段</span><br><span class="line">3.3 init进程的执行过程</span><br><span class="line">3.4 init.rc文件解析过程</span><br><span class="line">3.4.1 Android初始化语言</span><br><span class="line">3.4.2 init.rc的内容</span><br><span class="line">3.4.3 解析配置文件</span><br><span class="line">3.4.4 解析Service</span><br><span class="line">3.4.5 解析Action</span><br><span class="line">3.5 触发并启动Action和Service</span><br><span class="line">3.5.1 触发Action</span><br><span class="line">3.5.2 执行Action</span><br><span class="line">3.5.3 启动Service</span><br><span class="line">3.5.4 init对属性服务的处理</span><br><span class="line">3.6 init循环监听处理事件</span><br><span class="line">3.7 本章小结</span><br><span class="line">第4章 Android 启动过程的上层实现</span><br><span class="line">4.1 第一个Dalvik虚拟机zygote</span><br><span class="line">4.1.1 zygote的配置</span><br><span class="line">4.1.2 如何执行zygote服务程序</span><br><span class="line">4.2 ZygoteInit的启动过程</span><br><span class="line">4.2.1 创建Dalvik虚拟机</span><br><span class="line">4.2.2 注册JNI方法</span><br><span class="line">4.2.3 开启Java世界</span><br><span class="line">4.3 ZygoteInit开启Java世界的五部分工作</span><br><span class="line">4.3.1 注册zygote的Socket</span><br><span class="line">4.3.2 预加载Class资源和Resource资源</span><br><span class="line">4.3.3 启动system_server进程</span><br><span class="line">4.3.4 执行MethodAndArgsCalle的run方法</span><br><span class="line">4.3.5 执行runSelectLoopMode方法</span><br><span class="line">4.4 zygote处理Home启动请求</span><br><span class="line">4.5 本章小结</span><br><span class="line">第三部分 Binder篇</span><br><span class="line">第5章 Binder在Native框架层的实现</span><br><span class="line">5.1 Binder与C／S体系结构概述</span><br><span class="line">5.2 servicemanager进程的启动过程</span><br><span class="line">5.2.1 初始化Binder通信环境</span><br><span class="line">5.2.2 注册上下文管理者</span><br><span class="line">5.2.3 等待接收并处理IPC通信请求</span><br><span class="line">5.3 Server的启动和Service的注册过程</span><br><span class="line">5.3.1 创建ProcessState对象</span><br><span class="line">5.3.2 获取servicemanager的代理对象</span><br><span class="line">5.3.3 注册Service</span><br><span class="line">5.3.4 Server进程开启线程池</span><br><span class="line">5.4 Client端使用服务代理对象</span><br><span class="line">5.5 服务代理与服务通信</span><br><span class="line">5.6 本章小结</span><br><span class="line">第6章 Binder在Java框架层的实现</span><br><span class="line">6.1 Java系统服务的创建过程</span><br><span class="line">6.1.1 创建JavaBBinderHolder对象</span><br><span class="line">6.1.2 JavaBBinder的作用</span><br><span class="line">6.1.3 gBinderOffsets结构体解析</span><br><span class="line">6.2 Java系统服务的注册过程</span><br><span class="line">6.2.1 调用BinderInternal.getContextObject方法</span><br><span class="line">6.2.2 调用ServiceManagerNative.asInterface方法</span><br><span class="line">6.2.3 调用ServiceManagerProxy.addService方法注册服务</span><br><span class="line">6.3 Client端获取服务代理</span><br><span class="line">6.3.1 获取服务的BinderProxy</span><br><span class="line">6.3.2 构造服务的Proxy对象</span><br><span class="line">6.3.3 构造服务管理者对象</span><br><span class="line">6.4 Client端调用Java系统服务的方法</span><br><span class="line">6.5 统一的通信接口AIDL</span><br><span class="line">6.5.1AIDL实例</span><br><span class="line">6.5.2AIDL语法</span><br><span class="line">6.5.3处理自定义数据类型的传递</span><br><span class="line">6.6 本章小结</span><br><span class="line">第四部分 消息通信篇</span><br><span class="line">第7章 线程消息通信与异步处理</span><br><span class="line">7.1 什么是Looper线程</span><br><span class="line">7.2 第一步：Looper线程准备阶段</span><br><span class="line">7.2.1 创建Java层的Looper对象</span><br><span class="line">7.2.2 创建Java层的MessageQueue—对象</span><br><span class="line">7.2.3 创建Native层的NativeMessageQueue和Looper对象</span><br><span class="line">7.2.4 NativeMessageQueue关联到MessageQueue</span><br><span class="line">7.3 第二步：创建消息处理器并发送消息</span><br><span class="line">7.3.1 Handler的创建和初始化</span><br><span class="line">7.3.2 Message的创建和初始化</span><br><span class="line">7.3.3 消息的发送过程</span><br><span class="line">7.4 第三步：Looper线程循环阶段</span><br><span class="line">7.4.1 记录并获取当前线程身份信息</span><br><span class="line">7.4.2 循环监听消息</span><br><span class="line">7.4.3 分发消息到处理器</span><br><span class="line">7.4.4 回收消息并更新消息池</span><br><span class="line">7.5 异步任务类AsyncTask</span><br><span class="line">7.5.1 AsyncTask的实现</span><br><span class="line">7.5.2 AsyncTask的执行</span><br><span class="line">7.6 本章小结</span><br><span class="line">第五部分 Package Manager篇</span><br><span class="line">第8章 Package Manager 的机制与实现</span><br><span class="line">8.1 Package Manager体系结构</span><br><span class="line">8.1.1 三层体系结构</span><br><span class="line">8.1.2 三层之间的关系</span><br><span class="line">8.2 PackageManagerService的启动过程</span><br><span class="line">8.2.1 创建并初始化Settings对象</span><br><span class="line">8.2.2 获取系统默认配置</span><br><span class="line">8.2.3 启动PackageHandler</span><br><span class="line">8.2.4 创建data目录并初始化UserManager</span><br><span class="line">8.2.5 解析系统permission和feature信息</span><br><span class="line">8.2.6 解析packages文件</span><br><span class="line">8.2.7 dexopt优化判定</span><br><span class="line">8.2.8 启动FileObserver监控APK文件的目录</span><br><span class="line">8.2.9 调用scanDirLI方法扫描并安装APK包</span><br><span class="line">8.2.10 更新packages文件</span><br><span class="line">8.3 PackageManagerService启动过程使用的核心组件</span><br><span class="line">8.3.1 Java层的Installer</span><br><span class="line">8.3.2 Installd中的命令</span><br><span class="line">8.4 本章小结</span><br><span class="line">第9章 APK的安装过程</span><br><span class="line">9.1 通过scanDirLI方法安装APK</span><br><span class="line">9.1.1 创建PackageParser</span><br><span class="line">9.1.2 解析AndroidManifest.xml文件</span><br><span class="line">9.1.3 过滤PackageParser.Package类型的pkg对象</span><br><span class="line">9.1.4 解析和安装pkg</span><br><span class="line">9.2 使用adb命令安装应用程序</span><br><span class="line">9.2.1 通过消息机制安装指定的APK</span><br><span class="line">9.2.2 调用handleStartCopy方法处理安装操作</span><br><span class="line">9.2.3 调用handleReturnCode方法处理返回结果</span><br><span class="line">9.3 本章小结</span><br><span class="line">第六部分 Activity Manager篇</span><br><span class="line">第10章 Activity Manager的机制与实现</span><br><span class="line">10.1 Activity Manager概述</span><br><span class="line">10.2 ActivityManagerService在系统启动阶段的主要工作</span><br><span class="line">10.3 第一阶段：启动ActivityManagerService</span><br><span class="line">10.3.1 启动AThread线程</span><br><span class="line">10.3.2 创建ActivityThread对象</span><br><span class="line">10.3.3 创建ActivityStack类</span><br><span class="line">10.3.4 调用startRunning方法</span><br><span class="line">10.4 第二阶段：调用setSystemProcess方法</span><br><span class="line">10.4.1 查询并处理ApplicationInfo</span><br><span class="line">10.4.2 创建并初始化ProcessRecord</span><br><span class="line">10.5 第三阶段：调用install—SystemProviders方法</span><br><span class="line">10.5.1 查询Content Provider</span><br><span class="line">10.5.2 安装Content Provider</span><br><span class="line">10.6 第四阶段：调用systemReady方法</span><br><span class="line">10.6.1 发送ACTION_PRE_BOOT_COMPLETED广播</span><br><span class="line">10.6.2 清理预启动的非persistent进程</span><br><span class="line">10.6.3 读取Settings配置</span><br><span class="line">10.6.4 运行Runnable回调接口</span><br><span class="line">10.6.5 启动persistent应用程序和Home</span><br><span class="line">10.7 本章小结</span><br><span class="line">第11章 应用程序Activity的启动和调度</span><br><span class="line">11.1 启动应用程序Activity时在Client端的执行流程</span><br><span class="line">11.2 启动应用程序Activity时在Server端的执行流程</span><br><span class="line">11.2.1 预启动</span><br><span class="line">11.2.2 暂停</span><br><span class="line">11.2.3 启动应用程序进程</span><br><span class="line">11.2.4 加载应用程序Activity</span><br><span class="line">11.2.5 显示Activity</span><br><span class="line">11.2.6 Activity Idle状态的处理过程</span><br><span class="line">11.2.7 停止源Activity</span><br><span class="line">11.3 本章小结</span><br><span class="line">第12章 Activity Manager进程 管理</span><br><span class="line">12.1 LRU weight机制</span><br><span class="line">12.2 OOM adj机制</span><br><span class="line">12.2.1 更新OOM adj值</span><br><span class="line">12.2.2 OOM adj的计算过程</span><br><span class="line">12.3 Low Memory Killer机制</span><br><span class="line">12.3.1 OOM adj等级和最小内存阈值</span><br><span class="line">12.3.2 LM Killer机制的实现</span><br><span class="line">12.4 本章小结</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00CJ368JS/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00CJ368JS&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41cs4mMwXGL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 3D游戏案例开发大全</title>
    <url>/2020/04/19/B00CZ3PGP4/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android 3D游戏案例开发大全<br>作者信息： 作者: 吴亚峰 于复兴 杜化美 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>9大完整案例全面讲解了Android平台下3D游戏的开发技术,国际象棋人机对弈、疯狂的石头、3D坦克对战、快乐小球,3D推箱子、3D抽方块、炫动方块、3D乒乓锦标赛、3D极品桌球7大典型游戏类别  棋牌类游戏、物理引擎游戏、蓝牙对战游戏、竞速类游戏、益智类游戏、休闲类游戏、体育竞技类游戏两大版本渲染技术：OpenGL ES 1.x和OpenGL ES 2.0</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目　录 </span><br><span class="line"></span><br><span class="line"> 第1章　千里之行始于足下——Android平台简介及开发环境的使用　1 1.1　Android的来龙去脉　1 1.2　掀起Android的盖头来　2 1.2.1　选择Android的理由　2 1.2.2　Android的应用程序框架　3 1.3　Android开发环境的搭建　5 1.3.1　SDK的下载及安装　5 1.3.2　Eclipse集成开发环境的搭建　6 1.3.3　虚拟设备的创建与模拟器的运行　8 1.3.4　Eclipse与真机的连接　11 1.3.5　导入并运行Android程序　12 1.3.6　Android程序的监控与调试　12 1.4　小结　14</span><br><span class="line"></span><br><span class="line"> 第2章　棋牌类3D游戏——国际象棋人机对弈　15 2.1　游戏背景及功能概述　15 2.1.1　背景概述　15 2.1.2　功能简介　16 2.2　游戏的策划和准备工作　18 2.2.1　游戏的策划　18 2.2.2　游戏的准备工作　19 2.3　游戏的架构　21 2.3.1　各个类简要介绍　21 2.3.2　游戏框架简介　23 2.4　主控制类——GJXQActivity类的开发　24 2.5　辅助界面相关类　28 2.5.1　欢迎界面类WelcomeView　29 2.5.2　菜单界面类MenuView　31 2.5.3　设置界面类SetView　34 2.5.4　帮助界面类HelpView　38 2.5.5　关于界面类AboutView　40 2.6　游戏界面相关类　41 2.6.1　操控动作类Action　41 2.6.2　操控动作类型类ActionType　42 2.6.3　顶点数据管理者VertexDataManager　42 2.6.4　纹理图数据管理者PicDataManager　44 2.6.5　游戏界面GameSurfaceView　45 2.6.6　动作队列执行线程DoActionThread　52 2.7　相关工具类　60 2.7.1　模型加载类LoadUtil　60 2.7.2　国际象棋规则类ChessRuleUtil　63 2.7.3　机器自动走棋类RobotAutoUtil　68 2.7.4　包围盒工具类AABB3Util　74 2.7.5　拾取相关计算类IntersectantUtil　75 2.8　游戏的优化与改进　78</span><br><span class="line"></span><br><span class="line"> 第3章　物理引擎3D游戏——疯狂的石头　79 3.1　游戏背景及功能介绍　79 3.1.1　游戏背景概述　79 3.1.2　游戏功能介绍　79 3.2　游戏的策划及准备工作　81 3.2.1　游戏的策划　81 3.2.2　游戏开发前的准备工作　81 3.3　游戏的架构　82 3.3.1　各个类的简要介绍　83 3.3.2　游戏框架简介　85 3.4　主控制类MyActivity　86 3.5　2D界面类　90 3.5.1　欢迎界面类　90 3.5.2　父类界面RootView　92 3.5.3　主菜单界面MainMenuView　92 3.5.4　2D界面绘制类DrawCurrView　96 3.5.5　选关界面 SelectView　97 3.5.6　帮助界面 HelpView　100 3.6　工具类　101 3.6.1　图片工具类PicLoadUtil　101 3.6.2　坐标转换工具类From2DTo3DUtil　102 3.6.3　声音工具类 SoundUtil　103 3.6.4　数据存储工具类SharedPreferencesUtil　104 3.6.5　静态数据工具类Constant　105 3.7　刚体类及刚体纹理类　109 3.7.1　创建刚体的工具类Box2DUtil　110 3.7.2　小球类 Ball　114 3.7.3　平面矩形纹理类TextureRectangular　119 3.7.4　长方体类 Rec　121 3.7.5　齿轮纹理类 ChiLun　125 3.7.6　木桶类 MuTong　126 3.7.7　木桶纹理Texture_MuTong　127 3.8　游戏界面相关类　131 3.8.1　游戏界面 GameView　131 3.8.2　碰撞监听工具类CollisionAction　136 3.8.3　移动控制线程ChangeThread　138 3.9　游戏的优化与改进　139</span><br><span class="line"></span><br><span class="line"> 第4章　蓝牙对战游戏——3D坦克对战　140 4.1　游戏背景及功能概述　140 4.1.1　背景概述　140 4.1.2　功能介绍　141 4.2　游戏的策划及准备工作　143 4.2.1　游戏的策划　143 4.2.2　Android平台下游戏的准备工作　143 4.3　游戏的架构　146 4.3.1　各个类简要介绍　146 4.3.2　游戏框架简介　149 4.4　公共类　150 4.4.1　主控制类MainActivity　150 4.4.2　子弹类BulletTextureByVertex　162 4.4.3　地板类Floor　166 4.4.4　矮墙类LowWall　168 4.5　蓝牙相关类　170 4.5.1　后台服务类MyService　170 4.5.2　显示设备的Activity类MyDeviceListActivity　176 4.6　2D界面相关类　178 4.6.1　主菜单界面类MainView　179 4.6.2　声音控制工具类SoundUtil　183 4.6.3　设置界面类SettingView　184 4.6.4　蓝牙界面类BuleView　188 4.7　游戏界面相关类　191 4.7.1　游戏界面类MySurfaceView　191 4.7.2　点数据处理类BNPoint　209 4.7.3　子弹类Bullet　210 4.7.4　子弹走线程类BulletGoThread　213 4.7.5　执行动作线程类DoActionThread　215 4.8　游戏的优化与改进　219</span><br><span class="line"></span><br><span class="line"> 第5章　竞速类游戏——快乐小球　221 5.1　游戏背景及功能概述　221 5.1.1　游戏背景概述　221 5.1.2　功能介绍　221 5.2　游戏的策划及准备工作　223 5.2.1　游戏的策划　223 5.2.2　Android平台下游戏的开发准备工作　223 5.3　游戏的架构　225 5.3.1　各个类简要介绍　225 5.3.2　游戏框架简介　228 5.4　公共类RadioBallActivity　229 5.5　辅助界面相关类　234 5.5.1　欢迎界面类WelcomeView　235 5.5.2　2D界面的父类MySFView　237 5.5.3　主菜单界面类MenuView　238 5.5.4　音效设置界面类SoundView　240 5.5.5　帮助界面类HelpView　243 5.5.6　历史界面类HistoryView　245 5.6　游戏界面相关类　248 5.6.1　小球类 Ball　248 5.6.2　小球线程类BallThread　251 5.6.3　管道类GuanDao　253 5.6.4　简单赛道类SaiDao　256 5.6.5　赛道类SaiDaoYC　257 5.6.6　玻璃类 BoLi　257 5.6.7　油桶上下面的圆类Circle　259 5.6.8　油桶的侧面类CircleSider　261 5.6.9　油桶类YuanZhu　264 5.6.10　集装箱类Container　265 5.6.11　立方体类LiFangTi　267 5.6.12　纹理矩形类TextureRect　269 5.6.13　物体控制类WuTiForControl　270 5.6.14　地图类 MapData　271 5.6.15　正方形类 Rectangular　272 5.6.16　立方体类 Cube　273 5.6.17　立方体组类 CubeGroup　274 5.6.18　立方体组的线程控制类CubeThread　276 5.6.19　游戏界面类MySurfaceView　277 5.7　游戏的优化与改进　285</span><br><span class="line"></span><br><span class="line"> 第6章　益智类游戏——3D推箱子　286 6.1　游戏背景及功能概述　286 6.1.1　游戏背景概述　286 6.1.2　游戏功能简介　286 6.2　游戏的策划和准备工作　289 6.2.1　游戏的策划　290 6.2.2　游戏开发的准备工作　290 6.3　游戏的架构　293 6.3.1　各个类简要介绍　293 6.3.2　游戏框架简介　296 6.4　主控制类——TXZActivity类的开发　297 6.5　辅助界面相关类　301 6.5.1　欢迎界面类TXZWelcomeView　301 6.5.2　菜单界面类TXZMenuView　304 6.5.3　设置界面类TXZSetView　313 6.5.4　选关界面类TXZSelectView　317 6.5.5　帮助界面类TXZHelpView　322 6.6　游戏界面相关类　326 6.6.1　顶点数据管理者VertexDataManager　326 6.6.2　纹理图数据管理者PicDataManager　331 6.6.3　游戏界面TXZGameSurfaceView　332 6.6.4　动作队列执行线程TXZDoActionThread　344 6.7　相关工具类　347 6.7.1　箱子排序类CompareDis　347 6.7.2　记录关卡工具类SharedPreferencesUtil　348 6.7.3　声音加载类SoundUtil　349 6.8　游戏的优化与改进　350</span><br><span class="line"></span><br><span class="line"> 第7章　物理引擎类游戏——3D抽方块　351 7.1　游戏背景及功能概述　351 7.1.1　游戏背景概述　351 7.1.2　游戏功能介绍　351 7.2　游戏的策划及准备工作　353 7.2.1　游戏的策划　353 7.2.2　Android平台下游戏的准备工作　354 7.3　游戏的架构　356 7.3.1　各个类简要介绍　356 7.3.2　游戏框架简介　358 7.4　主控制类JengaMeActivity　359 7.5　2D界面相关类　361 7.5.1　欢迎界面类SplashScreenView　362 7.5.2　主菜单类MenuView　364 7.5.3　帮助界面HelpView　365 7.5.4　设置界面OptionMenu　367 7.5.5　记录界面RecordView　369 7.5.6　游戏结束界面EndMenu　371 7.5.7　图片资源数据存储转换工具类InPutStreamTobyte　372 7.6　辅助工具类的开发　373 7.6.1　交互工具类IntersectantUtil　373 7.6.2　数据库工具类SQLiteUtil　374 7.6.3　声音工具类SoundUil　376 7.6.4　自定义工具类SYSUtil　379 7.6.5　着色器工具类ShaderUtil　379 7.7　游戏界面相关类　382 7.7.1　木块类MyCube　382 7.7.2　桌面类TexFloor　384 7.7.3　纹理矩形类TextureRect　387 7.7.4　触控点类BNPoint　387 7.7.5　向量类MyVector3f　388 7.7.6　着色器管理类ShaderManager　389 7.7.7　包围盒类AABB3　390 7.7.8　游戏界面类MySurfaceView　396 7.8　该游戏中的着色器　410 7.9　游戏的优化与改进　412</span><br><span class="line"></span><br><span class="line"> 第8章　休闲类游戏——炫动方块　414 8.1　游戏背景及功能概述　414 8.1.1　游戏背景概述　414 8.1.2　游戏功能介绍　414 8.2　游戏的策划及准备工作　416 8.2.1　游戏的策划　416 8.2.2　Android 平台下游戏的准备工作　416 8.3　游戏的架构　419 8.3.1　各个类简要介绍　419 8.3.2　游戏框架简介　423 8.4　公共类HitCubeActivity　424 8.5　辅助界面相关类　427 8.5.1　3D界面的父类MyGLSurfaceView　427 8.5.2　主菜单界面类MenuView　428 8.5.3　选关卡界面类ContView　432 8.5.4　游戏音效设置界面类SoundView　435 8.5.5　游戏失败界面类LoseView　438 8.5.6　按钮六边形类ButtonGraph　440 8.5.7　菜单界面按钮的线程类MenuButtonThread　442 8.5.8　星星类Star　444 8.5.9　星星类线程类StarThread　446 8.6　游戏界面相关类　447 8.6.1　小球运动线程类BallThread　447 8.6.2　砖块类Cube　451 8.6.3　砖块的碰撞检测类CubeHit　452 8.6.4　砖块信息类CubeInfo　455 8.6.5　管道类GuanDao　456 8.6.6　管道线程类GuanDaoThread　460 8.6.7　线条类Line　461 8.6.8　墙壁类Wall　463 8.6.9　墙壁线程类WallThread　466 8.6.10　碰撞反射的工具类ReflectUtil　467 8.6.11　沙漏矩形类TextureRectShaLou　468 8.6.12　沙漏线程类ShaLouThread　469 8.6.13　游戏界面绘制类MySurfaceView　470 8.7　游戏中着色器的开发　483 8.7.1　纹理的着色器　483 8.7.2　按钮的着色器　484 8.7.3　管道的着色器　486 8.7.4　水波纹的着色器　487 8.7.5　沙漏的着色器　488 8.8　游戏的优化与改进　490</span><br><span class="line"></span><br><span class="line"> 第9章　体育竞技类游戏——3D乒乓球锦标赛　491 9.1　游戏背景及功能概述　491 9.1.1　游戏背景概述　491 9.1.2　游戏功能简介　491 9.2　游戏的策划和准备工作　493 9.2.1　游戏的策划　494 9.2.2　游戏开发的准备工作　494 9.3　游戏的架构　495 9.3.1　游戏的总体架构　495 9.3.2　游戏的类架构　496 9.4　公共类　499 9.4.1　主控制类MainActivity　499 9.4.2　声音振动控制类SoundAndShakeUtil　503 9.5　主界面相关类　505 9.5.1　主界面类MainMenuView　505 9.5.2　主界面物体类　514 9.6　游戏界面相关类　515 9.6.1　游戏界面类GameSurfaceView　515 9.6.2　乒乓球类GameBall　526 9.6.3　乒乓球台类GameTable　528 9.6.4　游戏房间类GameRoom　530 9.6.5　飘扬的旗帜类GameFlyFlag　531 9.6.6　球拍控制类GameBatContorl　532 9.7　人工智能与物理引擎相关类　535 9.7.1　物理世界模拟线程BallForContorl　536 9.7.2　人工智能计算辅助类CalculateUtil　548 9.8　录像功能模块相关类　553 9.8.1　录像基本数据类FrameData　553 9.8.2　录像播放线程类PlayVideoThread　554 9.8.3　录像功能辅助工具类VideoUtil　555 9.9　游戏中的着色器　556 9.9.1　普通纹理着色器　556 9.9.2　球台阴影着色器　557 9.9.3　飘扬的旗帜着色器　559 9.10　游戏的优化与改进　560</span><br><span class="line"></span><br><span class="line"> 第10章　体育竞技类游戏——3D极品桌球　561 10.1　游戏背景及功能概述　561 10.1.1　游戏背景概述　561 10.1.2　游戏功能介绍　561 10.2　游戏的策划及准备工作　563 10.2.1　游戏的策划　563 10.2.2　Android平台下游戏的准备工作　564 10.3　游戏的架构　566 10.3.1　各个类简要介绍　566 10.3.2　游戏框架简介　570 10.4　公共类MyActivity　571 10.5　辅助界面相关类　581 10.5.1　欢迎界面类WelcomeView　581 10.5.2　主菜单界面类MainMenuView　583 10.5.3　声音控制界面类SoundControlView　586 10.5.4　帮助界面类HelpView　587 10.5.5　积分榜界面类HighScoreView　591 10.6　游戏界面相关类　594 10.6.1　球类BallDingDian　594 10.6.2　球运动控制类BallKongZhi　599 10.6.3　小地图类MiniMap　606 10.6.4　球走线程类BallGoThread　607 10.6.5　移动摄像机的线程类MoveCameraThread　613 10.6.6　提示消息的线程类RegulationTimeThread　614 10.6.7　虚拟按钮监听线程类ThreadKey　615 10.6.8　墙壁类Qiang　617 10.6.9　进度条的百分比类Percentage　621 10.6.10　圆面类Circle　623 10.6.11　球杆侧面类CueSide　627 10.6.12　游戏界面绘制类MySurfaceView　630 10.7　相关工具类　637 10.7.1　数据库相关类DBUtil　637 10.7.2　图片处理工具类PicLoadUtil　640 10.7.3　倒计时类Timer　641 10.7.4　声音控制类SoundSwitchButton　643 10.8　游戏中着色器的开发　644 10.8.1　纹理着色器　644 10.8.2　阴影着色器　645 10.9　游戏的优化与改进　648</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00CZ3PGP4/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00CZ3PGP4&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51X-NLfkFHL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Arduino机器人权威指南</title>
    <url>/2020/04/19/B00J0E11BY/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Arduino机器人权威指南<br>作者信息： 作者: John-David Warren（约翰-戴维.沃伦） [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Arduino机器人权威指南》(外版书名《Arduino Robotics》)是目前使用Arduino做机器人的最权威指导图书，在国内人工智能领域是唯一一本。其姊妹篇《Arduino从基础到实践》之前问世时就受到创客们的一致好评。无论你是只会摆弄Arduino的初学者，还是一个制作小工具的专家，《Arduino机器人权威指南》都会帮助你制作出意想不到的机器人作品。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目    录 </span><br><span class="line"></span><br><span class="line"> 第1章 基础 1 1.1 电学 2 1.1.1 电模拟 3 1.1.2 电的基础知识 4 1.1.3 电路 6 1.1.4 电信号测量 7 1.1.5 万用表 7 1.1.6 电压测量 8 1.1.7 电流强度测量 9 1.1.8 电容测量 9 1.1.9 电阻测量 10 1.1.10 使用欧姆定律计算电阻功率 11 1.1.11 示波器 12 1.1.12 负载 13 1.1.13 电路连接 14 1.2 电子学 15 1.2.1 半导体 16 1.2.2 技术手册 17 1.2.3 集成电路 18 1.2.4 通孔元件 19 1.3 Arduino初级读本 20 1.3.1 Arduino变体 21 1.3.2 Arduino集成开发环境 24 1.3.3 草稿 24 1.3.4 信号 28 1.4 构建电路 38 1.4.1 电路设计 38 1.4.2 原理图 39 1.4.3 原型 41 1.5 搭建机器人 47 1.5.1 硬件 47 1.5.2 材料 49 1.5.3 工作区域 50 1.6 总结 51 第2章 基于Arduino的机器人 52 2.1 Arduino接口 52 2.1.1 继电器 53 2.1.2 晶体管 59 2.1.3 电机控制器的接口 66 2.2 用户控制 69 2.2.1 连线（有线）控制 70 2.2.2 红外控制（IR） 70 2.2.3 无线电控制系统 71 2.3 传感器导航 74 2.3.1 接触式感知 75 2.3.2 距离和反射式感知 75 2.3.3 方向（定位） 78 2.3.4 非自主传感器 81 2.4 总结 84 第3章 让机器人动起来 85 3.1 电机 85 3.1.1 有刷直流电机（永久磁铁型） 86 3.1.2 无刷直流电机 87 3.1.3 步进电机 88 3.1.4 齿轮减速电机 90 3.1.5 伺服舵机 91 3.1.6 线性制动器 92 3.1.7 功率计算 93 3.1.8 驱动 93 3.1.9 寻找合适的电机 94 3.2 H桥 95 3.2.1 产生制动 96 3.2.2 实现 97 3.2.3 H桥集成电路 100 3.2.4 更改PWM频率 101 3.2.5 反电动势 103 3.2.6 电流检测 105 3.2.7 基于H桥的商品（电机控制器） 106 3.3 电池 109 3.3.1 镍镉电池（NiCad） 110 3.3.2 镍氢电池（NiMH） 110 3.3.3 锂聚合物电池（LiPo） 111 3.3.4 铅酸蓄电池 112 3.3.5 充电 114 3.4 材料 115 3.4.1 木材 115 3.4.2 金属 116 3.4.3 螺栓和螺母 116 3.4.4 塑料 117 3.4.5 链条和链轮齿 117 3.4.6 车轮 118 3.5 总结 118 第4章 莱纳斯寻线机器人 120 4.1 莱纳斯的零件清单 121 4.2 如何使莱纳斯工作 123 4.2.1 轨道 123 4.3 制作红外传感器电路板 124 4.4 改装成连续旋转的伺服舵机 132 4.4.1 方法1：带有外部速度控制器的直接直流驱动 132 4.4.2 方法2：带有内部电机驱动电路的伺服脉冲驱动 135 4.5 合适的驱动轮 137 4.6 制作框架 141 4.7 制作连接 146 4.8 电池安装 147 4.8.1 安装电源开关 148 4.9 加载代码 148 4.10 制作轨道 155 4.11 测试 156 4.12 附加组件 157 4.12.1 LED指示灯 157 4.12.2 喷漆 159 4.12.3 添加速度调节器（电位器） 162 4.13 总结 164 第5章 墙追踪机器人Wally 166 5.1 如何让Wally工作 167 5.2 Wally的零件清单 169 5.3 电机控制器 171 5.3.1 高侧开关 171 5.3.2 低侧开关 171 5.3.3 电路制作 173 5.4 制作框架 178 5.5 安装传感器 182 5.6 安装电池和电源开关 185 5.6.1 电源开关安装 186 5.7 代码 187 5.7.1 代码目标 189 5.8 总结 198 第6章 制作PCB板 199 6.1 PCB基础 199 6.2 你需要什么来开始 200 6.3 电路设计 202 6.3.1 搜索开源设计 203 6.3.2 制作你自己的设计 204 6.3.3 使用Eagle原理图编辑器工作 207 6.3.4 使用Eagle电路板编辑器工作 211 6.4 转印设计 219 6.4.1 让我们制作一块Arduino克隆板——Jduino 219 6.4.2 开始转印 221 6.5 腐蚀 227 6.5.1 测量腐蚀液 227 6.5.2 腐蚀（方法1） 228 6.5.3 腐蚀（方法2） 230 6.5.4 清除墨粉 232 6.6 钻孔 234 6.7 焊接 235 6.7.1 制作Arduino克隆板 235 6.7.2 制作BJT H-桥 238 6.8 测试 240 6.9 总结 243 第7章 昆虫机器人 244 7.1 通过Arduino读取开关 245 7.2 如何使昆虫机器人工作 246 7.2.1 天线传感器 246 7.2.2 碰撞传感器 247 7.3 昆虫机器人的零件清单 247 7.4 电机 249 7.4.1 改装伺服舵机 249 7.4.2 控制伺服舵机 251 7.4.3 将脉冲值转换为角度值 252 7.4.4 将车轮安装到伺服舵机 253 7.5 制作框架 255 7.5.1 标记有机玻璃 255 7.5.2 切割有机玻璃 256 7.5.3 安装电机 258 7.5.4 安装脚轮 258 7.5.5 安装Arduino 260 7.5.6 安装电池 260 7.6 制作传感器 262 7.6.1 前置天线传感器 262 7.6.2 后置碰撞传感器 263 7.7 制作连线 266 7.8 加载代码 267 7.8.1 创建一个延迟 267 7.8.2 变量 268 7.8.3 代码 269 7.9 制作一顶帽子 277 7.10 总结 280 第8章 探险者机器人 281 8.1 如何使探险者机器人工作 282 8.1.1 R&#x2F;C控制 282 8.1.2 强大的电机 283 8.1.3 电流检测 283 8.1.4 启动视频 283 8.1.5 启动Xbee 284 8.2 探险者机器人的零件清单 284 8.3 制作框架 286 8.3.1 规格 286 8.3.2 添加电池支架 287 8.3.3 切割底部框架支架 289 8.3.4 切割顶部框架支架 289 8.3.5 切割和弯曲主框架板 290 8.3.6 添加横杆和安装脚轮 291 8.3.7 有机玻璃甲板（任选） 293 8.4 制作电机控制器 293 8.4.1 电流检测和限流 293 8.4.2 H桥设计 294 8.5 设置Arduino 298 8.5.1 连接H桥 299 8.6 设置Xbee 300 8.6.1 测试Xbee 302 8.7 添加摄像头 303 8.7.1 二自由度云台 304 8.7.2 制作第一个支架 305 8.7.3 制作第二个支架 306 8.8 加载代码 307 8.9 总结 316 第9章 机器船 318 9.1 开场白 319 9.2 机器船的零件清单 319 9.2.1 聚苯乙烯泡沫塑料 321 9.2.2 环氧树脂 322 9.2.3 手套 323 9.2.4 玻璃纤维布 323 9.2.5 胶水 324 9.2.6 泡沫塑料切割机和美工刀 325 9.2.7 杂项 325 9.3 机器船设计 325 9.4 组装机器船 327 9.4.1 模板 327 9.4.2 将模板胶合到EPS&#x2F; XPS板上 329 9.4.3 切出分段 330 9.4.4 把分段胶合在一起 332 9.4.5 插入泡沫锚 333 9.4.6 涂层 334 9.4.7 涂抹成品 335 9.4.8 鳍 336 9.4.9 上色 336 9.4.10 甲板 336 9.4.11 完成组装 337 9.5 推进装置 338 9.5.1 底板 340 9.5.2 枢轴 340 9.5.3 管子 341 9.5.4 舵角 342 9.5.5 电机 343 9.5.6 舵机 344 9.5.7 推杆 344 9.6 电子设备 344 9.6.1 系统的核心——ArduPilot PCB 345 9.6.2 GPS模块 346 9.6.3 电子调速器（ESC） 346 9.6.4 电机 347 9.6.5 舵机 347 9.6.6 电池组 347 9.6.7 安装电子设备 348 9.7 软件和任务规划 351 9.7.1 GPS接收器 351 9.7.2 软件 352 9.7.3 安装软件 372 9.7.4 任务规划 377 9.8 全部放在一起 380 9.8.1 集成系统 381 9.8.2 船，欢呼吧！ 383 9.9 故障排除 383 9.9.1 电机&#x2F;螺旋桨的推力不够 384 9.9.2 电机不启动 385 9.10 总结 385 第10章 草地机器人400 386 10.1 如何使草地机器人400工作 387 10.1.1 割草机甲板 388 10.1.2 大容量电池 388 10.1.3 钢框架 389 10.1.4 卸料斗 389 10.1.5 充气轮胎 390 10.1.6 前灯 390 10.1.7 失效保护 390 10.2 工具和零件列表 391 10.2.1 割草机 391 10.2.2 零件清单 391 10.3 轮子 392 10.3.1 前脚轮 393 10.3.2 后驱动轮 393 10.3.3 安装链轮 394 10.4 框架 395 10.5 传动系统 402 10.5.1 安装电机支架 403 10.5.2 安装链条 406 10.6 电机控制器 408 10.6.1 选购一个电机控制器 408 10.6.2 散热风扇 410 10.6.3 电机控制器反馈 411 10.7 Arduino 413 10.7.1 固定好连接以防行驶颠簸 413 10.8 失效保护 417 10.8.1 无线电遥控拨动开关 418 10.8.2 功率继电器 420 10.8.3 避免无线电遥控本身的失效保护 421 10.9 连接电路 422 10.10 代码 423 10.11 美化和添加附件 429 10.11.1 喷漆 429 10.11.2 前灯 430 10.11.3 卸料斗 430 10.11.4 割草机安全开关 432 10.12 总结 432 第11章 赛格威机器人 434 11.1 如何使赛格威机器人工作 435 11.1.1 惯性测量单元 435 11.1.2 转向和增益 436 11.1.3 啮合器 436 11.2 赛格威机器人的零件清单 436 11.3 选择合适的传感器 438 11.3.1 3.3V电源 439 11.3.2 加速度计 440 11.3.3 陀螺仪 442 11.3.4 陀螺仪和加速度计的总结 443 11.3.5 角度滤波 444 11.4 制作惯性测量单元适配板 445 11.5 选择电机 446 11.5.1 卸掉电力制动器 448 11.5.2 电机安装位置 450 11.6 选择电机控制器 451 11.6.1 SoftwareSerial库 452 11.6.2 Sabertooth控制器的简化串口 453 11.7 电池 454 11.7.1 密封铅酸蓄电池 455 11.7.2 充电 456 11.7.3 12V供电 456 11.8 框架 456 11.8.1 框架设计 458 11.8.2 制作框架 458 11.9 输入装置 462 11.9.1 转向 462 11.9.2 增益 462 11.9.3 啮合器 463 11.9.4 水平启动 463 11.9.5 安装输入装置到框架上 463 11.10 安装电子设备 467 11.10.1 焊接输入装置 470 11.10.2 连接线路 470 11.11 分析代码 471 11.11.1 sample_accel()函数 472 11.11.2 sample_gyro()函数 473 11.11.3 检查角度读数 474 11.11.4 calculate_angle() 函数 475 11.11.5 read_pots()函数 476 11.11.6 auto_level()函数 477 11.11.7 update_motor_speed() 函数 479 11.11.8 time_stamp()函数 482 11.11.9 serial_print_stuff()函数 482 11.11.10 完整代码 484 11.12 测试 491 11.13 总结 493 11.14 参考资料 493 第12章 格斗机器人 494 12.1 机器人格斗的诞生 496 12.1.1 格斗机器人的规章制度 496 12.1.2 没有价格限制 497 12.2 格斗机器人零件清单 498 12.3 输入控制 500 12.3.1 Fly Sky CT-6：32美元、5通道、2.4GHz无线控制器备选方案 501 12.4 电子设备 504 12.4.1 Arduino 504 12.4.2 电机控制器 505 12.5 框架 507 12.5.1 是买，还是做 508 12.5.2 改装轮子 509 12.5.3 制作框架 510 12.6 传动系统 513 12.6.1 齿轮传动装置 514 12.6.2 链条张力调整螺母 515 12.7 电池 520 12.8 安装电子设备 522 12.8.1 保护好你的大脑 522 12.8.2 连接线路 524 12.9 代码 526 12.10 盔甲 532 12.11 武器 534 12.12 附加信息 540 12.13 总结 541 第13章 其他控制方式 542 13.1 用Processing来解码信号 543 13.2 其他控制方式所用零件清单 543 13.3 选择输入设备 544 13.4 Processing必备文件 545 13.5 遵照协议 546 13.6 检查Processing的代码 546 13.6.1 代码解析 549 13.6.2 测试Processing 551 13.7 检查Arduino的代码 553 13.8 总结 560</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00J0E11BY/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00J0E11BY&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51cUlogYvbL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android编程权威指南</title>
    <url>/2020/04/19/B00J4DXWDG/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android编程权威指南<br>作者信息： 作者: 菲利普斯 (Brian Hardy) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Amazon榜首畅销书<br>全面覆盖Android开发知识点<br>全真示例、循循善诱、轻松上手</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 Android应用初体验</span><br><span class="line">1.1 应用基础</span><br><span class="line">1.2 创建Android项目</span><br><span class="line">1.3 Eclipse工作区导航</span><br><span class="line">1.4 用户界面设计</span><br><span class="line">1.4.1 视图层级结构</span><br><span class="line">1.4.2 组件属性</span><br><span class="line">1.4.3 创建字符串资源</span><br><span class="line">1.4.4 预览界面布局</span><br><span class="line">1.5 从布局XML到视图对象</span><br><span class="line">1.6 组件的实际应用</span><br><span class="line">1.6.1 类包组织导入</span><br><span class="line">1.6.2 引用组件</span><br><span class="line">1.6.3 设置监听器</span><br><span class="line">1.7 使用模拟器运行应用</span><br><span class="line">1.8 Android编译过程</span><br><span class="line">第2章 Android与MVC设计模式</span><br><span class="line">2.1 创建新类</span><br><span class="line">2.2 Android与MVC设计模式</span><br><span class="line">2.3 更新视图层</span><br><span class="line">2.4 更新控制层</span><br><span class="line">2.5 在设备上运行应用</span><br><span class="line">2.5.1 连接设备</span><br><span class="line">2.5.2 配置设备用于应用开发</span><br><span class="line">2.6 添加图标资源</span><br><span class="line">2.6.1 向项目中添加资源</span><br><span class="line">2.6.2 在XML文件中引用资源</span><br><span class="line">2.7 关于挑战练习</span><br><span class="line">2.8 挑战练习一：为TextView添加监听器</span><br><span class="line">2.9 挑战练习二：添加后退按钮</span><br><span class="line">2.10 挑战练习三：从按钮到图标按钮</span><br><span class="line">第3章 Activity的生命周期</span><br><span class="line">3.1 日志跟踪理解Activity生命周期</span><br><span class="line">3.1.1 输出日志信息</span><br><span class="line">3.1.2 使用 LogCat</span><br><span class="line">3.2 设备旋转与Activity生命周期</span><br><span class="line">3.3 设备旋转前保存数据</span><br><span class="line">3.4 再探Activity生命周期</span><br><span class="line">3.5 深入学习：测试onSaveInstanceState—（Bundle）方法</span><br><span class="line">3.6 深入学习：日志记录的级别与方法</span><br><span class="line">第4章 Android应用的调试</span><br><span class="line">4.1 DDMS应用调试透视图</span><br><span class="line">4.2 异常与栈跟踪</span><br><span class="line">4.2.1 诊断应用异常</span><br><span class="line">4.2.2 记录栈跟踪日志</span><br><span class="line">4.2.3 设置断点</span><br><span class="line">4.2.4 使用异常断点</span><br><span class="line">4.3 文件浏览器</span><br><span class="line">4.4 Android特有的调试工具</span><br><span class="line">4.4.1 使用Android Lint</span><br><span class="line">4.4.2 R类的问题</span><br><span class="line">第5章 第二个activity</span><br><span class="line">5.1 创建第二个activity</span><br><span class="line">5.1.1 创建新布局</span><br><span class="line">5.1.2 创建新的activity子类</span><br><span class="line">5.1.3 在manifest配置文件中声明activity</span><br><span class="line">5.1.4 为QuizActivity添加cheat按钮</span><br><span class="line">5.2 启动activity</span><br><span class="line">5.3 activity间的数据传递</span><br><span class="line">5.3.1 使用intent extra</span><br><span class="line">5.3.2 从子activity获取返回结果</span><br><span class="line">5.4 activity的使用与管理</span><br><span class="line">5.5 挑战练习</span><br><span class="line">第6章 Android SDK版本与兼容</span><br><span class="line">6.1 Android SDK版本</span><br><span class="line">6.2 Android编程与兼容性问题</span><br><span class="line">6.2.1 全新的系统版本——Honeycomb</span><br><span class="line">6.2.2 SDK最低版本</span><br><span class="line">6.2.3 SDK目标版本</span><br><span class="line">6.2.4 SDK编译版本</span><br><span class="line">6.2.5 安全添加新版本API中的代码</span><br><span class="line">6.3 使用Android开发者文档</span><br><span class="line">6.4 挑战练习：报告编译版本</span><br><span class="line">第7章 UI fragment与fragment管理器</span><br><span class="line">7.1 UI设计的灵活性需求</span><br><span class="line">7.2 fragment的引入</span><br><span class="line">7.3 着手开发CriminalIntent</span><br><span class="line">7.3.1 创建新项目</span><br><span class="line">7.3.2 fragment与支持库</span><br><span class="line">7.3.3 创建Crime类</span><br><span class="line">7.4 托管UI fragment</span><br><span class="line">7.4.1 fragment的生命周期</span><br><span class="line">7.4.2 托管的两种方式</span><br><span class="line">7.4.3 定义容器视图</span><br><span class="line">7.5 创建UI fragment</span><br><span class="line">7.5.1 定义CrimeFragment的布局</span><br><span class="line">7.5.2 创建CrimeFragment类</span><br><span class="line">7.6 添加UI fragment到FragmentManager</span><br><span class="line">7.6.1 fragment事务</span><br><span class="line">7.6.2 FragmentManager与fragment生命周期</span><br><span class="line">7.7 activity使用fragment的理由</span><br><span class="line">7.8 深入学习：Honeycomb、ICS、Jelly Bean以及更高版本系统上的应用开发</span><br><span class="line">第8章 使用布局与组件创建用户界面</span><br><span class="line">8.1 升级Crime类</span><br><span class="line">8.2 更新布局</span><br><span class="line">8.3 生成并使用组件</span><br><span class="line">8.4 深入探讨XML布局属性</span><br><span class="line">8.4.1 样式、主题及主题属性</span><br><span class="line">8.4.2 dp、sp以及屏幕像素密度</span><br><span class="line">8.4.3 Android开发设计原则</span><br><span class="line">8.4.4 布局参数</span><br><span class="line">8.4.5 边距与内边距</span><br><span class="line">8.5 使用图形布局工具</span><br><span class="line">8.5.1 添加新组件</span><br><span class="line">8.5.2 属性视图中编辑组件属性</span><br><span class="line">8.5.3 在框架视图中重新组织组件</span><br><span class="line">8.5.4 更新子组件的布局参数</span><br><span class="line">8.5.5 android：layout_weight属性的工作原理</span><br><span class="line">8.5.6 图形布局工具使用总结</span><br><span class="line">8.5.7 组件ID与多种布局</span><br><span class="line">8.6 挑战练习：日期格式化</span><br><span class="line">第9章 使用ListFragment显示列表</span><br><span class="line">9.1 更新CriminalIntent应用的模型层</span><br><span class="line">9.2 创建ListFragment</span><br><span class="line">9.3 使用抽象activity托管fragment</span><br><span class="line">9.3.1 通用的fragment托管布局</span><br><span class="line">9.3.2 抽象activity类</span><br><span class="line">9.4 ListFragment、ListView及ArrayAdapter</span><br><span class="line">9.4.1 创建ArrayAdapter(T)类实例</span><br><span class="line">9.4.2 响应列表项的点击事件</span><br><span class="line">9.5 定制列表项</span><br><span class="line">9.5.1 创建列表项布局</span><br><span class="line">9.5.2 创建adapter子类</span><br><span class="line">第10章 使用fragment argument</span><br><span class="line">10.1 从fragment中启动activity</span><br><span class="line">10.1.1 附加extra信息</span><br><span class="line">10.1.2 获取extra信息</span><br><span class="line">10.1.3 使用Crime数据更新CrimeFragment视图</span><br><span class="line">10.1.4 直接获取extra信息方式的缺点</span><br><span class="line">10.2 fragment argument</span><br><span class="line">10.2.1 附加argument给fragment</span><br><span class="line">10.2.2 获取argument</span><br><span class="line">10.3 重新加载显示列表项</span><br><span class="line">10.4 通过fragment获取返回结果</span><br><span class="line">第11章 使用ViewPager</span><br><span class="line">11.1 创建CrimePagerActivity</span><br><span class="line">11.1.1 以代码的方式定义并产生布局</span><br><span class="line">11.1.2 ViewPager与Pager—Adapter</span><br><span class="line">11.1.3 整合配置并使用CrimePagerActivity</span><br><span class="line">11.1.4 FragmentStatePager—Adapter与Fragment—PagerAdapter</span><br><span class="line">11.2 深入学习：ViewPager的工作原理</span><br><span class="line">第12章 对话框</span><br><span class="line">12.1 创建DialogFragment</span><br><span class="line">12.1.1 显示DialogFragment</span><br><span class="line">12.1.2 设置对话框的显示内容</span><br><span class="line">12.2 fragment间的数据传递</span><br><span class="line">12.2.1 传递数据给DatePicker—Fragment</span><br><span class="line">12.2.2 返回数据给CrimeFragment</span><br><span class="line">12.3 挑战练习：更多对话框</span><br><span class="line">第13章 使用MediaPlayer播放音频</span><br><span class="line">13.1 添加资源</span><br><span class="line">13.2 定义HelloMoonFragment布局文件</span><br><span class="line">13.3 创建HelloMoonFragment</span><br><span class="line">13.4 使用布局fragment</span><br><span class="line">13.5 音频播放</span><br><span class="line">13.6 挑战练习：暂停音频播放</span><br><span class="line">13.7 深入学习：播放视频</span><br><span class="line">13.8 挑战练习：在HelloMoon应用中播放视频</span><br><span class="line">第14章 fragment的保留</span><br><span class="line">14.1 保留fragment实例</span><br><span class="line">14.2 设备旋转与保留的fragment</span><br><span class="line">14.3 保留的fragment：一切都完美了吗</span><br><span class="line">14.4 设备旋转处理与onSaveInstance—State（Bundle）方法</span><br><span class="line">14.5 深入学习：fragment引入前的设备旋转问题</span><br><span class="line">第15章 应用本地化</span><br><span class="line">15.1 本地化资源</span><br><span class="line">15.2 配置修饰符</span><br><span class="line">15.2.1 可用资源优先级排定</span><br><span class="line">15.2.2 多重配置修饰符</span><br><span class="line">15.2.3 寻找最匹配的资源</span><br><span class="line">15.3 更多资源使用原则及控制</span><br><span class="line">15.3.1 资源命名</span><br><span class="line">15.3.2 资源目录结构</span><br><span class="line">15.4 测试备选资源</span><br><span class="line">第16章 操作栏</span><br><span class="line">16.1 选项菜单</span><br><span class="line">16.1.1 在XML文件中定义选项菜单</span><br><span class="line">16.1.2 创建选项菜单</span><br><span class="line">16.1.3 响应菜单项选择</span><br><span class="line">16.2 实现层级式导航</span><br><span class="line">16.2.1 启用应用图标的导航功能</span><br><span class="line">16.2.2 响应向上按钮</span><br><span class="line">16.3 可选菜单项</span><br><span class="line">16.3.1 创建可选菜单XML文件</span><br><span class="line">16.3.2 切换菜单项标题</span><br><span class="line">16.3.3 “还有个问题”</span><br><span class="line">16.4 挑战练习：用于列表的空视图</span><br><span class="line">第17章 存储与加载本地文件</span><br><span class="line">17.1 CriminalIntent应用的数据存取</span><br><span class="line">17.1.1 保存crime数据到JSON文件</span><br><span class="line">17.1.2 从文件中读取crime数据</span><br><span class="line">17.2 挑战练习：使用外部存储</span><br><span class="line">17.3 深入学习：Android文件系统与Java I／O</span><br><span class="line">第18章 上下文菜单与上下文操作模式</span><br><span class="line">18.1 定义上下文菜单资源</span><br><span class="line">18.2 实施浮动上下文菜单</span><br><span class="line">18.2.1 创建上下文菜单</span><br><span class="line">18.2.2 为上下文菜单登记视图</span><br><span class="line">18.2.3 响应菜单项选择</span><br><span class="line">18.3 实施上下文操作模式</span><br><span class="line">18.3.1 实现列表视图的多选操作</span><br><span class="line">18.3.2 列表视图中的操作模式回调方法</span><br><span class="line">18.3.3 改变已激活视图的显示背景</span><br><span class="line">18.3.4 实现其他视图的上下文操作模式</span><br><span class="line">18.4 兼容性问题：回退还是复制</span><br><span class="line">18.5 挑战练习：在CrimeFragment视图中删除crime记录</span><br><span class="line">18.6 深入学习：ActionBarSherlock</span><br><span class="line">18.7 挑战练习：使用ActionBarSherlock</span><br><span class="line">18.7.1 CriminalIntent应用中ABS的基本整合</span><br><span class="line">18.7.2 ABS的深度整合</span><br><span class="line">18.7.3 ABS的完全整合</span><br><span class="line">第19章 相机Ⅰ：取景器</span><br><span class="line">19.1 创建Fragment布局</span><br><span class="line">19.2 创建CrimeCameraFragment</span><br><span class="line">19.3 创建CrimeCameraActivity</span><br><span class="line">19.4 使用相机API</span><br><span class="line">19.4.1 打开并释放相机</span><br><span class="line">19.4.2 SurfaceView、Surface—Holder与Surface</span><br><span class="line">19.4.3 确定预览界面大小</span><br><span class="line">19.4.4 启动CrimeCamera—Activity</span><br><span class="line">19.5 深入学习：以命令行的方式运行activity</span><br><span class="line">第20章 相机Ⅱ：拍摄并处理照片</span><br><span class="line">20.1 拍摄照片</span><br><span class="line">20.1.1 实现相机回调方法</span><br><span class="line">20.1.2 设置图片尺寸大小</span><br><span class="line">20.2 返回数据给CrimeFragment</span><br><span class="line">20.2.1 以接收返回值的方式启动CrimeCameraActivity</span><br><span class="line">20.2.2 在CrimeCameraFragment中设置返回值</span><br><span class="line">20.2.3 在CrimeFragment中获取照片文件名</span><br><span class="line">20.3 更新模型层</span><br><span class="line">20.3.1 新增Photo类</span><br><span class="line">20.3.2 为Crime添加photo属性</span><br><span class="line">20.3.3 设置photo属性</span><br><span class="line">20.4 更新CrimeFragment的视图</span><br><span class="line">20.4.1 添加ImageView组件</span><br><span class="line">20.4.2 图像处理</span><br><span class="line">20.5 在DialogFragment中显示大图片</span><br><span class="line">20.6 挑战练习：Crime照片的显示方向</span><br><span class="line">20.7 挑战练习：删除照片</span><br><span class="line">20.8 深入学习：Android代码的废弃处理</span><br><span class="line">第21章 隐式intent</span><br><span class="line">21.1 添加按钮组件</span><br><span class="line">21.2 添加嫌疑人信息至模型层</span><br><span class="line">21.3 使用格式化字符串</span><br><span class="line">21.4 使用隐式intent</span><br><span class="line">21.4.1 典型隐式intent的组成</span><br><span class="line">21.4.2 发送陋习报告</span><br><span class="line">21.4.3 获取联系人信息</span><br><span class="line">21.4.4 检查可以响应的activity</span><br><span class="line">21.5 挑战练习：又一个隐式intent</span><br><span class="line">第22章 Master—Detail用户界面</span><br><span class="line">22.1 增加布局灵活性</span><br><span class="line">22.1.1 修改SingleFragment—Activity</span><br><span class="line">22.1.2 创建包含两个fragment容器的布局</span><br><span class="line">22.1.3 使用别名资源</span><br><span class="line">22.2 Activity：fragment的托管者</span><br><span class="line">22.3 深入学习：设备屏幕尺寸的确定</span><br><span class="line">第23章 深入学习intent和任务</span><br><span class="line">23.1 创建NerdLauncher项目</span><br><span class="line">23.2 解析隐式intent</span><br><span class="line">23.3 在运行时创建显式intent</span><br><span class="line">23.4 任务与后退栈</span><br><span class="line">23.5 使用NerdLauncher应用作为设备主屏幕</span><br><span class="line">23.6 挑战练习：应用图标与任务重排</span><br><span class="line">23.7 进程与任务</span><br><span class="line">第24章 样式与include标签的使用</span><br><span class="line">24.1 创建RemoteControl项目</span><br><span class="line">24.1.1 编码实现RemoteControl—Activity</span><br><span class="line">24.1.2 创建RemoteControl—Fragment</span><br><span class="line">24.2 使用样式消除重复代码</span><br><span class="line">24.3 完善布局定义</span><br><span class="line">24.4 深入学习：使用include与merge标签</span><br><span class="line">24.5 挑战练习：样式的继承</span><br><span class="line">第25章 XML Drawable与9—Patches</span><br><span class="line">25.1 XML drawable</span><br><span class="line">25.2 state list drawable</span><br><span class="line">25.3 layer list与inset drawable</span><br><span class="line">25.4 使用9—patch图像</span><br><span class="line">第26章 HTTP与后台任务</span><br><span class="line">26.1 创建PhotoGallery应用</span><br><span class="line">26.2 网络连接基本</span><br><span class="line">26.3 使用AsyncTask在后台线程上运行代码</span><br><span class="line">26.4 线程与主线程</span><br><span class="line">26.5 获取Flickr XML数据</span><br><span class="line">26.6 从AsyncTask回到主线程</span><br><span class="line">26.7 深入学习：再探AsyncTask</span><br><span class="line">26.8 挑战练习：分页</span><br><span class="line">第27章 Looper、Handler与HandlerThread</span><br><span class="line">27.1 设置GridView以显示图片</span><br><span class="line">27.2 批量下载缩略图</span><br><span class="line">27.3 与主线程通信</span><br><span class="line">27.4 创建并启动后台线程</span><br><span class="line">27.5 Message与message Handler</span><br><span class="line">27.5.1 消息的剖析</span><br><span class="line">27.5.2 Handler的剖析</span><br><span class="line">27.5.3 使用handler</span><br><span class="line">27.5.4 传递handler</span><br><span class="line">27.6 深入学习：AsyncTask与Thread</span><br><span class="line">27.7 挑战练习：预加载以及缓存</span><br><span class="line">第28章 搜索</span><br><span class="line">28.1 搜索Flickr网站</span><br><span class="line">28.2 搜索对话框</span><br><span class="line">28.2.1 创建搜索界面</span><br><span class="line">28.2.2 可搜索的activity</span><br><span class="line">28.2.3 物理搜索键</span><br><span class="line">28.2.4 搜索的工作原理</span><br><span class="line">28.2.5 启动模式与新的intent</span><br><span class="line">28.2.6 使用shared preferences实现轻量级数据存储</span><br><span class="line">28.3 在Android 3.0以后版本的设备上使用SearchView</span><br><span class="line">28.4 挑战练习</span><br><span class="line">第29章 后台服务</span><br><span class="line">29.1 创建IntentService</span><br><span class="line">29.2 服务的作用</span><br><span class="line">29.3 查找最新返回结果</span><br><span class="line">29.4 使用AlarmManager延迟运行服务</span><br><span class="line">29.4.1 PendingIntent</span><br><span class="line">29.4.2 使用PendingIntent管理定时器</span><br><span class="line">29.5 控制定时器</span><br><span class="line">29.6 通知信息</span><br><span class="line">29.7 深入学习：服务细节内容</span><br><span class="line">29.7.1 服务的能与不能</span><br><span class="line">29.7.2 服务的生命周期</span><br><span class="line">29.7.3 non—sticky服务</span><br><span class="line">29.7.4 sticky服务</span><br><span class="line">29.7.5 绑定服务</span><br><span class="line">第30章 broadcast Intent</span><br><span class="line">30.1 随设备重启而重启的定时器</span><br><span class="line">30.1.1 配置文件中的broadcast receiver</span><br><span class="line">30.1.2 如何使用receiver</span><br><span class="line">30.2 过滤前台通知消息</span><br><span class="line">30.2.1 发送broadcast intent</span><br><span class="line">30.2.2 动态broadcast receiver</span><br><span class="line">30.2.3 使用私有权限</span><br><span class="line">30.2.4 使用ordered broadcast接收结果</span><br><span class="line">30.3 receiver与长时运行任务</span><br><span class="line">第31章 网页浏览</span><br><span class="line">31.1 最后一段Flickr数据</span><br><span class="line">31.2 简单方式：使用隐式intent</span><br><span class="line">31.3 较难方式：使用WebView</span><br><span class="line">31.3.1 使用WebChromeClient优化WebView的显示</span><br><span class="line">31.3.2 处理WebView的设备旋转问题</span><br><span class="line">31.4 深入学习：注入JavaScript对象</span><br><span class="line">第32章 定制视图与触摸事件</span><br><span class="line">32.1 创建DragAndDraw项目</span><br><span class="line">32.1.1 创建DragAndDraw—Activity</span><br><span class="line">32.1.2 创建DragAndDraw—Fragment</span><br><span class="line">32.2 创建定制视图</span><br><span class="line">32.3 处理触摸事件</span><br><span class="line">32.4 onDraw（…）方法内的图形绘制</span><br><span class="line">32.5 挑战练习：设备旋转问题</span><br><span class="line">第33章 跟踪设备的地理位置</span><br><span class="line">33.1 启动RunTracker项目</span><br><span class="line">33.1.1 创建RunActivity</span><br><span class="line">33.1.2 创建RunFragment</span><br><span class="line">33.2 地理位置与LocationManager</span><br><span class="line">33.3 接收定位数据更新broadcast</span><br><span class="line">33.4 使用定位数据刷新UI显示</span><br><span class="line">33.5 快速定位：最近一次地理位置</span><br><span class="line">33.6 在物理和虚拟设备上测试地理位置定位</span><br><span class="line">第34章 使用SQLite本地数据库</span><br><span class="line">34.1 在数据库中存储旅程和地理位置信息</span><br><span class="line">34.2 查询数据库中的旅程列表</span><br><span class="line">34.3 使用CursorAdapter显示旅程列表</span><br><span class="line">34.4 创建新旅程</span><br><span class="line">34.5 管理现有旅程</span><br><span class="line">34.6 挑战练习：识别当前跟踪的旅程</span><br><span class="line">第35章 使用Loader加载异步数据</span><br><span class="line">35.1 Loader与LoaderManager</span><br><span class="line">35.2 在RunTracker应用中使用Loader</span><br><span class="line">35.3 加载旅程列表</span><br><span class="line">35.4 加载单个旅程</span><br><span class="line">35.5 加载旅程的最近一次地理位置</span><br><span class="line">第36章 使用地图</span><br><span class="line">36.1 添加Maps API给RunTracker应用</span><br><span class="line">36.1.1 使用物理设备测试地图</span><br><span class="line">36.1.2 安装使用Google Play services SDK</span><br><span class="line">36.1.3 获取Google Maps API key</span><br><span class="line">36.1.4 更新RunTracker应用的manifest配置文件</span><br><span class="line">36.2 在地图上显示用户的地理位置</span><br><span class="line">36.3 显示旅程路线</span><br><span class="line">36.4 为旅程添加开始和结束地图标注</span><br><span class="line">36.5 挑战练习：实时数据更新</span><br><span class="line">第37章 编后语</span><br><span class="line">37.1 终极挑战</span><br><span class="line">37.2 关于我们</span><br><span class="line">37.3 致谢</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00J4DXWDG/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00J4DXWDG&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41t7tXYPaCL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Practical C++ Programming</title>
    <url>/2020/04/19/0596004192/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Practical C++ Programming<br>作者信息： 作者: Steve Oualline [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Preface  Part I. The Basics  1. What Is C++?  A Brief History of C++  C++ Organization  How to Learn C++  2. The Basics of Program Writing  Programs from Conception to Execution  Creating a Real Program  Getting Help in Unix  Getting Help in an IDE Programming Exercises  3. Style  Comments  C++ Code  Naming Style  Coding Religion  Indentation and Code Format  Clarity Simplicity  Consistency and Organization  Further Reading Summary  4. Basic Declarations and Expressions  Basic Program Structure  Simple Expressions  The std::cout Output Object Variables and Storage  Variable Declarations  Assignment Statements  Floating-Point Numbers  Floating-Point Divide Versus Integer Divide  Characters  Wide Characters  Boolean Type Programming Exercises  Answers to Chapter Questions  5. Arrays, Qualifiers, and Reading Numbers  Arrays  Strings  Reading Data Initializing Variables  Multidimensional Arrays  C-Style Strings Types of Integers  Types of Floats  Constant and Reference Declarations  Qualifiers  Hexadecimal and Octal Constants Operators for Performing Shortcuts  Side Effects  Programming Exercises  Answers to Chapter Questions  6. Decision and Control Statements  if Statement  else Statement  How Not to Use std::strcmp  Looping Statements  while Statement  break Statement continue Statement  The Assignment Anywhere Side Effect  Programming Exercises  Answers to Chapter Questions  7. The Programming Process  Setting Up Your Work Area  The Specification Code Design  The Prototype  The Makefile  Testing  Debugging Maintenance  Revisions  Electronic Archaeology  Mark Up the Program  Use the Debugger  Use the Text Editor as a Browser Add Comments  Programming Exercises  Part II. Simple Programming 8. More Control Statements  for Statement  switch Statement switch, break, and continue  Programming Exercises  Answers to Chapter Questions  9. Variable Scope and Functions  Scope and Storage Class  Namespaces  Functions  Summary of Parameter Types Recursion  Structured Programming Basics  Real-World Programming Programming Exercises  Answers to Chapter Questions  10. The C++ Preprocessor  define Statement  Conditional Compilation include Files  Parameterized Macros  Advanced Features Summary  Programming Exercises  Answers to Chapter Questions 11. Bit Operations  Bit Operators  The AND Operator (&amp;)  Bitwise OR (|)  The Bitwise Exclusive OR (^)  The Ones Complement Operator (NOT) (~)  The Left and Right Shift Operators (&gt;)  Setting, Clearing, and Testing Bits  Bitmapped Graphics  Programming Exercises  Answers to Chapter Questions  Part III. Advanced Types and Classes  12. Advanced Types  Structures  Unions  typedef  enum Type  Bit Members or Packed Structures  Arrays of Structures Programming Exercises  Answers to Chapter Questions  13. Simple Classes  Stacks  Improved Stack  Using a Class  Introduction to Constructors and Destructors  Automatically Generated Member Functions  Shortcuts  Style  Structures Versus Classes  Programming Exercises  14. More on Classes  Friends  Constant Functions  Constant Members  Static Member Variables  Static Member Functions  The Meaning of static  Programming Exercises 15. Simple Pointers  const Pointers  Pointers and Printing Pointers and Arrays  The reinterpret_cast  Pointers and Structures Command-Line Arguments  Programming Exercises  Answers to Chapter Questions  Part IV. Advanced Programming Concepts  16. File Input&#x2F;Output  C++ File I&#x2F;O  Conversion Routines  Binary and ASCII Files  The End-of-Line Puzzle  Binary I&#x2F;O  Buffering Problems Unbuffered I&#x2F;O  Designing File Formats  C-Style I&#x2F;O Routines C-Style Conversion Routines  C-Style Binary I&#x2F;O  C- Versus C++- Style I&#x2F;O  Programming Exercises  Answers to Chapter Questions 17. Debugging and Optimization  Code Reviews  Serial Debugging Going Through the Output  Interactive Debuggers  Debugging a Binary Search  Interactive Debugging Tips and Tricks  Runtime Errors  Optimization  How to Optimize  Case Study: Inline Functions Versus Normal Functions  Case Study: Optimizing a Color-Rendering Algorithm  Programming Exercises  Answers to Chapter Questions  18. Operator Overloading  Creating a Simple Fixed-Point Class  Operator Functions  Operator Member Functions  Warts Full Definition of the Fixed-Point Class  Programming Exercises Answers to Chapter Questions  19. Floating Point  Floating-Point Format  Floating Addition&#x2F;Subtraction  Multiplication and Division  Overflow and Underflow  Roundoff Error  Accuracy Minimizing Roundoff Error  Determining Accuracy  Precision and Speed  Power Series  Programming Exercises  20. Advanced Pointers  Pointers, Structures, and Classes  delete Operator Linked Lists  Ordered Linked Lists  Doubly Linked Lists  Trees Printing a Tree  The Rest of the Program  Data Structures for a Chess Program  Programming Exercises  Answers to Chapter Questions 21. Advanced Classes  Derived Classes  Virtual Functions Virtual Classes  Function Hiding in Derived Classes  Constructors and Destructors in Derived Classes  The dynamic_cast Operator Summary  Programming Exercises  Answers to Chapter Questions Part V. Other Language Features  22. Exceptions  Adding Exceptions to the Stack Class  Exceptions Versus assert  Programming Exercises 23. Modular Programming  Modules  Public and Private  The extern Storage Class  Headers  The Body of the Module  A Program to Use Infinite Arrays  The Makefile for Multiple Files  Using the Infinite Array  Dividing a Task into Modules  Module Design Guidelines  Programming Exercises  24. Templates  What Is a Template?  Templates: The Hard Way  Templates: The C++ Way Function Specialization  Class Templates  Class Specialization Implementation Details  Advanced Features  Summary  Programming Exercises  25. Standard Template Library  STL Basics  Class List-A Set of Students  Creating a Waiting List with the STL List Storing Grades in a STL Map  Putting It All Together  Practical Considerations When Using the STL  Getting More Information Exercises  26. Program Design  Design Goals  Design Factors Design Principles  Coding  Objects  Real-World Design  echniques  Conclusion  27. Putting It All Together  Requirements Code Design  Coding  Functional Description  Testing  Revisions A Final Warning  Program Files  Programming Exercises  28. From C to C++  K&amp;R-Style Functions  struct  malloc and free  Turning Structures into Classes  setjmp and longjmp  Mixing C and C++ Code Summary  Programming Exercise  29. C++’s Dustier Corners  do&#x2F;while goto  The ? : Construct  The Comma Operator  Overloading the (  ) Operator  Pointers to Members  The asm Statement  The mutable Qualifier  Run Time Type Identification  Trigraphs  Answers to Chapter Questions  30. Programming Adages  General  Design Declarations  switch Statement  Preprocessor  Style  Compiling The Ten Commandments for C++ Programmers  Final Note  Answers to Chapter Questions  Part VI. Appendixes  A. ASCII Table  B. Ranges C. Operator Precedence Rules  D. Computing Sine Using a Power Series E. Resources Index</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/0596004192/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=0596004192&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51-74apQumL._SL500_PIsitb-sticker-arrow-big,TopRight,35,-73_OU28_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>C程序设计语言(第2版•新版)</title>
    <url>/2020/04/19/B0011425T8/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C程序设计语言(第2版•新版)<br>作者信息： 作者: 克尼汉 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《C程序设计语言(第2版•新版)》讲述深入浅出，配合典型例证，通俗易懂，实用性强，适合作为大专院校计算机专业或非计算机专业的C语言教材，也可以作为从事计算机相关软硬件开发的技术人员的参考书。《C程序设计语言(第2版•新版)》原著即为C语言的设计者之一Dennis M.Ritchie和著名的计算机科学家Brian W.Kernighan合著的一本介绍C语言的权威经典著作。我们现在见到的大量论述C语言程序设计的教材和专著均以此书为蓝本。原著第1版中介绍的C语言成为后来广泛使用的C语言版本——标准C的基础。人们熟知的“hello,world”程序就是由《C程序设计语言(第2版•新版)》首次引入的，现在，这一程序已经成为所有程序设计语言入门的第一课。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">出版者的话</span><br><span class="line">专家指导委员会</span><br><span class="line">中文版序</span><br><span class="line">译者序</span><br><span class="line">校译者简介</span><br><span class="line">序</span><br><span class="line">第1版序</span><br><span class="line">引言</span><br><span class="line">第1章 导言</span><br><span class="line">1.1 入门</span><br><span class="line">1.2 变量与算术表态式</span><br><span class="line">1.3 for语句</span><br><span class="line">1.4 符号常量</span><br><span class="line">1.5 字符输入&#x2F;输出</span><br><span class="line">1.5.1 文件复制</span><br><span class="line">1.5.2 字符计算</span><br><span class="line">1.5.3 行计数</span><br><span class="line">1.5.4 单词计数</span><br><span class="line">1.6 数组</span><br><span class="line">1.7 函数</span><br><span class="line">1.8 参数——传值调用</span><br><span class="line">1.9 字符数组</span><br><span class="line">1.10 外部变量与作用域</span><br><span class="line">第2章 类型、运算符与表达式</span><br><span class="line">2.1 变量名</span><br><span class="line">2.2 数据类型及长度</span><br><span class="line">2.3 常量</span><br><span class="line">2.4 声明</span><br><span class="line">2.5 算术运算符</span><br><span class="line">2.6 关系运算符与逻辑运算符</span><br><span class="line">2.7 类型转换</span><br><span class="line">2.8 自增运算符与自减运算符</span><br><span class="line">2.9 按位运算符</span><br><span class="line">2.10 赋值运算符与表达式</span><br><span class="line">2.11 条件表达式</span><br><span class="line">2.12 运算符优先级与求值次序</span><br><span class="line">第3章 控制流</span><br><span class="line">3.1 语句与程序块</span><br><span class="line">3.2 if-else语句</span><br><span class="line">3.3 else-if语句</span><br><span class="line">3.4 switch语句</span><br><span class="line">3.5 whil循环与for特环</span><br><span class="line">3.6 do-while循环</span><br><span class="line">3.7 break语句与continue语句</span><br><span class="line">3.8 goto语句与标号</span><br><span class="line">第4章 涵数与程序结构</span><br><span class="line">……</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0011425T8/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0011425T8&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51Ji2QHyMRL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>CPrimerPlus(中文版)(第5版)</title>
    <url>/2020/04/19/B001171NQ6/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： CPrimerPlus(中文版)(第5版)<br>作者信息： 作者: 普拉塔 (Prata S.) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《C Primer Plus(中文版)(第5版)》全面讲述了C语言编程的相关概念和知识。《C Primer Plus(中文版)(第5版)》适合希望系统学习C语言的读者，也适用于精通其他编程语言并希望进一步掌握和巩固C编程技术的程序员。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 概览</span><br><span class="line">1.1 C语言的起源</span><br><span class="line">1.2 使用C语言的理由</span><br><span class="line">1.3 C语言的发展方向</span><br><span class="line">1.4 计算机工作的基本原理</span><br><span class="line">1.5 高级计算机语言和编译器</span><br><span class="line">1.6 使用C语言的7个步骤</span><br><span class="line">1.7 编程机制</span><br><span class="line">1.8 语言标准</span><br><span class="line">1.9 本书的组织结构</span><br><span class="line">1.10 本书体例</span><br><span class="line">1.11 总结</span><br><span class="line">1.12 复习题</span><br><span class="line">1.13 编程练习</span><br><span class="line">第2章 C语言概述</span><br><span class="line">2.1 C语言的一个简单实例</span><br><span class="line">2.2 实例说明</span><br><span class="line">2.3 一个简单程序的结构</span><br><span class="line">2.4 使程序可读的技巧</span><br><span class="line">2.5 更进一步</span><br><span class="line">2.6 多个函数</span><br><span class="line">2.7 调试</span><br><span class="line">2.8 关键字和保留标识符</span><br><span class="line">2.9 关键概念</span><br><span class="line">2.10 总结</span><br><span class="line">2.11 复习题</span><br><span class="line">2.12 编程练习</span><br><span class="line">第3章 数据和C</span><br><span class="line">3.1 示例程序</span><br><span class="line">3.2 变量与常量数据</span><br><span class="line">3.3 数据：数据类型关键字</span><br><span class="line">3.4 C数据类型</span><br><span class="line">3.5 使用数据类型</span><br><span class="line">3.6 参数和易犯的错误</span><br><span class="line">3.7 另一个例子：转义序列</span><br><span class="line">3.8 关键概念</span><br><span class="line">3.9 总结</span><br><span class="line">3.10 复习题</span><br><span class="line">3.11 编程练习</span><br><span class="line">第4章 字符串和格式化输入&#x2F;输出</span><br><span class="line">4.1 前导程序</span><br><span class="line">4.2 字符串简介</span><br><span class="line">4.3 常量和C预处理器</span><br><span class="line">4.4 研究和利用printf（）和scanf（）</span><br><span class="line">4.5 关键概念</span><br><span class="line">4.6 总结</span><br><span class="line">4.7 复习题</span><br><span class="line">4.8 编程练习</span><br><span class="line">第5章 运算符、表达式和语句</span><br><span class="line">5.1 循环简介</span><br><span class="line">5.2 基本运算符</span><br><span class="line">5.3 其他运算符</span><br><span class="line">5.4 表达式和语句</span><br><span class="line">5.5 类型转换</span><br><span class="line">5.6 带有参数的函数</span><br><span class="line">5.7 一个示例程序</span><br><span class="line">5.8 关键概念</span><br><span class="line">5.9 总结</span><br><span class="line">5.10 复习题</span><br><span class="line">5.11 编程练习</span><br><span class="line">第6章 C控制语句：循环</span><br><span class="line">6.1 再探while循环</span><br><span class="line">6.2 while语句</span><br><span class="line">6.4 不确定循环与计数循环</span><br><span class="line">6.5 for循环</span><br><span class="line">6.6 更多赋值运算符：+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;和%&#x3D;</span><br><span class="line">6.7 逗号运算符</span><br><span class="line">6.8 退出条件循环：do while</span><br><span class="line">6.9 选择哪种循环</span><br><span class="line">6.10 嵌套循环</span><br><span class="line">6.11 数组</span><br><span class="line">6.12 使用函数返回值的循环例子</span><br><span class="line">6.13 关键概念</span><br><span class="line">6.14 总结</span><br><span class="line">6.15 复习题</span><br><span class="line">6.16 编程练习</span><br><span class="line">第7章 C控制语句：分支和跳转</span><br><span class="line">7.1 if语句</span><br><span class="line">7.2 在if语句中添加else关键字</span><br><span class="line">7.3 获得逻辑性</span><br><span class="line">7.4 一个统计字数的程序</span><br><span class="line">7.5 条件运算符?:</span><br><span class="line">7.6 循环辅助手段：continue和break</span><br><span class="line">7.7 多重选择：switch和break</span><br><span class="line">7.8 goto语句</span><br><span class="line">7.9 关键概念</span><br><span class="line">7.10 总结</span><br><span class="line">7.11 复习题</span><br><span class="line">7.12 编程练习</span><br><span class="line">第8章 字符输入&#x2F;输出和输入确认</span><br><span class="line">8.1 单字符I&#x2F;O：getchar（）和putchar（）</span><br><span class="line">8.2 缓冲区</span><br><span class="line">8.3 终止键盘输入</span><br><span class="line">8.5 创建一个更友好的用户界面</span><br><span class="line">8.6 输入确认</span><br><span class="line">8.7 菜单浏览</span><br><span class="line">8.8 关键概念</span><br><span class="line">8.9 总结</span><br><span class="line">8.10 复习题</span><br><span class="line">8.11 编程练习</span><br><span class="line">第9章 函数</span><br><span class="line">9.1 函数概述</span><br><span class="line">9.2 ANSI C的函数原型</span><br><span class="line">9.3 递归</span><br><span class="line">9.4 多源代码文件程序的编译</span><br><span class="line">9.5 地址运算符：&amp;</span><br><span class="line">9.6 改变调用函数中的变量</span><br><span class="line">9.7 指针简介</span><br><span class="line">9.8 关键概念</span><br><span class="line">9.9 总结</span><br><span class="line">9.10 复习题</span><br><span class="line">9.11 编程练习</span><br><span class="line">第10章 数组和指针</span><br><span class="line">10.1 数组</span><br><span class="line">10.2 多维数组</span><br><span class="line">10.3 指针和数组</span><br><span class="line">10.4 函数、数组和指针</span><br><span class="line">10.5 指针操作</span><br><span class="line">10.6 保护数组内容</span><br><span class="line">10.7 指针和多维数组</span><br><span class="line">10.8 变长数组（VLA）</span><br><span class="line">10.9 复合文字</span><br><span class="line">10.10 关键概念</span><br><span class="line">10.11 总结</span><br><span class="line">10.12 复习题</span><br><span class="line">10.13 编程练习</span><br><span class="line">第11章 字符串和字符串函数</span><br><span class="line">11.1 字符串表示和字符串I&#x2F;O</span><br><span class="line">11.2 字符串输入</span><br><span class="line">11.3 字符串输出</span><br><span class="line">11.4 自定义字符串输入&#x2F;输出函数</span><br><span class="line">11.5 字符串函数</span><br><span class="line">11.6 字符串例子：字符串排序</span><br><span class="line">11.7 ctype.h字符函数和字符串</span><br><span class="line">11.8 命令行参数</span><br><span class="line">11.9 把字符串转换为数字</span><br><span class="line">11.10 关键概念</span><br><span class="line">11.11 总结</span><br><span class="line">11.12 复习题</span><br><span class="line">11.13 编程练习</span><br><span class="line">第12章 存储类、链接和内存管理</span><br><span class="line">12.1 存储类</span><br><span class="line">12.2 存储类说明符</span><br><span class="line">12.3 存储类和函数</span><br><span class="line">12.4 随机数函数和静态变量</span><br><span class="line">12.5 掷骰子</span><br><span class="line">12.6 分配内存：malloc（）和free（）</span><br><span class="line">12.7 ANSI C的类型限定词</span><br><span class="line">12.8 关键概念</span><br><span class="line">12.9 总结</span><br><span class="line">12.10 复习题</span><br><span class="line">12.11 编程练习</span><br><span class="line">第13章 文件输入&#x2F;输出</span><br><span class="line">13.1 和文件进行通信</span><br><span class="line">13.2 标准I&#x2F;O</span><br><span class="line">13.3 一个简单的文件压缩程序</span><br><span class="line">13.4 文件I&#x2F;O：fprintf ( )、fscanf ( )、fgets ( )和fputs ( )函数</span><br><span class="line">13.5 随机存取：fseek（）和ftell（）函数</span><br><span class="line">13.6 标准I&#x2F;O内幕</span><br><span class="line">13.7 其他标准I&#x2F;O函数</span><br><span class="line">13.8 关键概念</span><br><span class="line">13.9 总结</span><br><span class="line">13.10 复习题</span><br><span class="line">13.11 编程练习</span><br><span class="line">第14章 结构和其他数据形式</span><br><span class="line">14.1 示例问题：创建图书目录</span><br><span class="line">14.2 建立结构声明</span><br><span class="line">14.3 定义结构变量</span><br><span class="line">14.4 结构数组</span><br><span class="line">14.5 嵌套结构</span><br><span class="line">14.6 指向结构的指针</span><br><span class="line">14.7 向函数传递结构信息</span><br><span class="line">14.8 把结构内容保存到文件中</span><br><span class="line">14.9 结构：下一步是什么</span><br><span class="line">14.10 联合简介</span><br><span class="line">14.11 枚举类型</span><br><span class="line">14.12 typedef简介</span><br><span class="line">14.13 奇特的声明</span><br><span class="line">14.14 函数和指针</span><br><span class="line">14.15 关键概念</span><br><span class="line">14.16 总结</span><br><span class="line">14.17 复习题</span><br><span class="line">14.18 编程练习</span><br><span class="line">第15章 位操作</span><br><span class="line">15.1 二进制数、位和字节</span><br><span class="line">15.2 其他基数</span><br><span class="line">15.3 C的位运算符</span><br><span class="line">15.4 位字段</span><br><span class="line">15.5 关键概念</span><br><span class="line">15.6 总结</span><br><span class="line">15.7 复习题</span><br><span class="line">15.8 编程练习</span><br><span class="line">第16章 C预处理器和C库</span><br><span class="line">16.1 翻译程序的第一步</span><br><span class="line">16.2 明显常量：#define</span><br><span class="line">16.3 在#define中使用参数</span><br><span class="line">16.4 宏，还是函数</span><br><span class="line">16.5 文件包含：＃include</span><br><span class="line">16.6 其他指令</span><br><span class="line">16.7 内联函数</span><br><span class="line">16.8 C库</span><br><span class="line">16.9 数学库</span><br><span class="line">16.10 通用工具库</span><br><span class="line">16.11 诊断库</span><br><span class="line">16.12 string.h库中的memcpy（）和memmove（）</span><br><span class="line">16.13 可变参数：stdarg.h</span><br><span class="line">16.14 关键概念</span><br><span class="line">16.15 总结</span><br><span class="line">16.16 复习题</span><br><span class="line">16.17 编程练习</span><br><span class="line">第17章 高级数据表示</span><br><span class="line">17.1 研究数据表示</span><br><span class="line">17.2 从数组到链表</span><br><span class="line">17.3 抽象数据类型（ADT）</span><br><span class="line">17.4 队列ADT</span><br><span class="line">17.5 用队列进行模拟</span><br><span class="line">17.6 链表与数组</span><br><span class="line">17.7 二叉搜索树</span><br><span class="line">17.8 其他说明</span><br><span class="line">17.9 关键概念</span><br><span class="line">17.10 总结</span><br><span class="line">17.11 复习题</span><br><span class="line">17.12 编程练习</span><br><span class="line">附录A 复习题答案</span><br><span class="line">附录B 参考资料</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001171NQ6/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001171NQ6&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41HCQw7RnZL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构C++语言描述:应用标准模板库STL(第2版)</title>
    <url>/2020/04/19/B0011AIYWO/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 数据结构C++语言描述:应用标准模板库STL(第2版)<br>作者信息： 作者: 福特 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一章   数据结构入门</span><br><span class="line">第二章   对象设计技术</span><br><span class="line">第三章   算法概述</span><br><span class="line">第四章   向量容器</span><br><span class="line">第五章   指针和动态内存</span><br><span class="line">第六章   表容器和迭代器</span><br><span class="line">第七章   栈</span><br><span class="line">第八章   队列和优先级队列</span><br><span class="line">第九章   链表</span><br><span class="line">第十章   二叉树</span><br><span class="line">第十一章    关联容器</span><br><span class="line">第十二章    高级关联结构</span><br><span class="line">第十三章    继承和抽象类</span><br><span class="line">第十四章    堆、2进制文件和位组</span><br><span class="line">第十五章    递归算法</span><br><span class="line">第十六章    图</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0011AIYWO/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0011AIYWO&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51PVeCEEJcL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C专家编程ExpertCProgrammingDeepCSecrets</title>
    <url>/2020/04/19/B0012NIW9K/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C专家编程ExpertCProgrammingDeepCSecrets<br>作者信息： 作者: Peter Van Der Linden [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《C专家编程Expert C Programming Deep C Secrets》撷取了几十个实例，细致、深入地讲解了C的历史、语言特性、声明、数组、指针、链接、运行时、内存以及分析了如何进一步学习C++等问题。《C专家编程Expert C Programming Deep C Secrets》是一本ANSIC编程语言的高级读本。它适用于已经编写过C程序的人，以及那些想迅速获取一些专家观点和技巧的人。专家级的C编程指南展示优秀C程序员的编程技巧。即使你读过AndyKoneig的《C陷阱与缺陷》，你还是应该看看PeterVanDerLinden的书。我想，他们两人的书称都应该千方百计的搞到，如获至宝地捧读。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 C：穿越时空的迷雾</span><br><span class="line">1.1 C语言的史前阶段</span><br><span class="line">1.2 C语言的早期体验</span><br><span class="line">1.3 标准I&#x2F;O库和C预处理器</span><br><span class="line">1.4 K&amp;R C</span><br><span class="line">1.5 今日之ANSI C</span><br><span class="line">1.6 它很棒，但它符合标准吗</span><br><span class="line">1.7 编译限制</span><br><span class="line">1.8 ANSI C标准的结构</span><br><span class="line">1.9 阅读ANSI C标准，寻找乐趣和裨益</span><br><span class="line">1.10 “安静的改变”究竟有多少安静</span><br><span class="line">1.11 轻松一下——由编译器定义的Pragmas效果 </span><br><span class="line"></span><br><span class="line"> 第2章 这不是Bug，而是语言特性 2.1 这关语言特性何事，在Fortran里这就是Bug呀 2.2 多做之过 2.3 误做之过 2.4 少做之过 2.5 轻松一下——有些特性确实就是Bug 2.6 参考文献</span><br><span class="line"></span><br><span class="line"> 第3章 分析C语言的声明 3.1 只有编译器才会喜欢的语法 3.2 声明是如何形成的 3.3 优先级规则 3.4 通过图表分析C语言的声明 3.5 typedef可以成为你的朋友 3.6 typedef int x[10]和#define x int[10]的区别 3.7 typedef struct foo&#123; … foo; &#125;的含义 3.8 理解所有分析过程的代码段 3.9 轻松一下——驱动物理实体的软件</span><br><span class="line"></span><br><span class="line"> 第4章 令人震惊的事实：数组和指针并不相同 4.1 数组并非指针 4.2 我的代码为什么无法运行 4.3 什么是声明，什么是定义 4.4 使声明与定义相匹配 4.5 数组和指针的其他区别 4.6 轻松一下——回文的乐趣</span><br><span class="line"></span><br><span class="line"> 第5章 对链接的思考 5.1 函数库、链接和载入 5.2 动态链接的优点 5.3 函数库链接的5个特殊秘密 5.4 警惕Interpositioning 5.5 产生链接器报告文件 5.6 轻松一下——看看谁在说话：挑战Turing测验</span><br><span class="line"></span><br><span class="line"> 第6章 运动的诗章：运行时数据结构 6.1 a.out及其传说 6.2 段 6.3 操作系统在a.out文件里干了些什么 6.4 C语言运行时系统在a.out里干了些什么 6.5 当函数被调用时发生了什么：过程活动记录 6.6 auto和static关键字 6.7 控制线程 6.8 setjmp和longjmp 6.9 UNIX中的堆栈段 6.10 MS-DOS中的堆栈段 6.11 有用的C语言工具 6.12 轻松一下——卡耐基-梅隆大学的编程难题 6.13 只适用于高级学员阅读的材料</span><br><span class="line"></span><br><span class="line"> 第7章 对内存的思考 7.1 Intel 80x86系列 7.2 Intel 80x86内存模型以及它的工作原理 7.3 虚拟内存 7.4 Cache存储器 7.5 数据段和堆 7.6 内存泄漏 7.7 总线错误 7.8 轻松一下——“Thing King”和“页面游戏”</span><br><span class="line"></span><br><span class="line"> 第8章 为什么程序员无法分清万圣节和圣诞节 8.1 Portzebie度量衡系统 8.2 根据位模式构筑图形 8.3 在等待时类型发生了变化 8.4 原型之痛 8.5 原型在什么地方会失败 8.6 不需要按回车键就能得到一个字符 8.7 用C语言实现有限状态机 8.8 软件比硬件更困难 8.9 如何进行强制类型转换，为何要进行类型强制转换 8.10 轻松一下——国际C语言混乱代码大赛</span><br><span class="line"></span><br><span class="line"> 第9章 再论数组 9.1 什么时候数组与指针相同 9.2 为什么会发生混淆 9.3 为什么C语言把数组形参当作指针 9.4 数组片段的下标 9.5 数组和指针可交换性的总结 9.6 C语言的多维数组 9.7 轻松一下——软件&#x2F;硬件平衡</span><br><span class="line"></span><br><span class="line"> 第10章 再论指针 10.1 多维数组的内存布局 10.2 指针数组就是Iliffe向量 10.3 在锯齿状数组上使用指针 10.4 向函数传递一个一维数组 10.5 使用指针向函数传递一个多维数组 10.6 使用指针从函数返回一个数组 10.7 使用指针创建和使用动态数组 10.8 轻松一下——程序检验的限制</span><br><span class="line"></span><br><span class="line"> 第11章 你懂得C，所以C++不在话下 11.1 初识OOP 11.2 抽象——取事物的本质特性 11.3 封装——把相关的类型、数据和函数组合在一起 11.4 展示一些类——用户定义类型享有和预定义类型一样的权限 11.5 访问控制 11.6 声明 11.7 如何调用成员函数 11.8 继承——复用已经定义的操作 11.9 多重继承——从两个或更多的基类派生 11.10 重载——作用于不同类型的同一操作具有相同的名字 11.11 C++如何进行操作符重载 11.12 C++的输入&#x2F;输出(I&#x2F;O) 11.13 多态——运行时绑定 11.14 解释 11.15 C++如何表现多态 11.16 新奇玩意——多态 11.17 C++的其他要点 11.18 如果我的目标是那里，我不会从这里起步 11.19 它或许过于复杂，但却是惟一可行的方案 11.20 轻松一下——死亡计算机协会 11.21 更多阅读材料 附录A 程序员工作面试的秘密 附录B 术语表</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0012NIW9K/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0012NIW9K&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51qZ6V0I-UL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>C陷阱与缺陷</title>
    <url>/2020/04/19/B0012UMPBY/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C陷阱与缺陷<br>作者信息： 作者: 凯尼格 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《C陷阱与缺陷》适合有一定经验的C程序员阅读学习，即便你是C编程高手，《C陷阱与缺陷》也应该成为你的案头必备书籍。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第0章  导读</span><br><span class="line">第1章  词法“陷阱”</span><br><span class="line">1.1 &#x3D;不同于&#x3D;&#x3D;</span><br><span class="line">1.2 &amp;和|不同于&amp;&amp;和||</span><br><span class="line">1.3 词法分析中的“贪心法”</span><br><span class="line">1.4 整型常量</span><br><span class="line">1.5 字符与字符串 </span><br><span class="line"></span><br><span class="line"> 第2章 语法“陷阱” 2.1 理解函数声明 2.2 运算符的优先级问题 2.3 注意作为语句结束标志的分号 2.4 switch语句 2.5 函数调用 2.6 “悬挂”else引发的问题</span><br><span class="line"></span><br><span class="line"> 第3章 语义“陷阱” 3.1 指针与数组 3.2 非数组的指针 3.3 作为参数的数组声明 3.4 避免“举隅法” 3.5 空指针并非空字符串 3.6 边界计算与不对称边界 3.7 求值顺序 3.8 运算符&amp;&amp;、||和！ 3.9 整数溢出 3.10 为函数main提供返回值</span><br><span class="line"></span><br><span class="line"> 第4章 连接 4.1 什么是连接器 4.2 声明与定义 4.3 命名冲突与static修饰符 4.4 形参、实参与返回值 4.5 检查外部类型 4.6 头文件</span><br><span class="line"></span><br><span class="line"> 第5章 库函数 5.1 返回整数的getchar函数 5.2 更新顺序文件 5.3 缓冲输出与内存分配 5.4 使用ernlo检测错误 5.5 库函数signal</span><br><span class="line"></span><br><span class="line"> 第6章 预处理器 6.1 不能忽视宏定义中的空格 6.2 宏并不是函数 6.3 宏并不是语句 6.4 宏并不是类型定义</span><br><span class="line"></span><br><span class="line"> 第7章 可移植性缺陷 7.1 应对C语言标准变更 7.2 标识符名称的限制 7.3 整数的大小 7.4 字符是有符号整数还是无符号整数 7.5 移位运算符 7.6 内存位置0 7.7 除法运算时发生的截断 7.8 随机数的大小 7.9 大小写转换 7.10 首先释放，然后重新分配 7.11 可移植性问题的一个例子 第8章 建议与答案 8.1 建议 8.2 答案 附录A：PRINTF，VARARGS与STDARG 附录B：Koenig和Moo夫妇访谈</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0012UMPBY/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0012UMPBY&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41LBoZy0vyL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>C和指针PointersOnC</title>
    <url>/2020/04/19/B00163LU68/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C和指针PointersOnC<br>作者信息： 作者: Kenneth A.Reek [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《C和指针 Pointers On C》适合C语言初学者和初级C程序员阅读，也可作为计算机专业学生学习C语言的参考。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 快速上手</span><br><span class="line">1.1 简介</span><br><span class="line">1.1.1 空白和注释</span><br><span class="line">1.1.2 预处理指令</span><br><span class="line">1.1.3 main函数</span><br><span class="line">1.1.4 read_column_numbers函数</span><br><span class="line">1.1.5 rearrange函数</span><br><span class="line">1.2 补充说明</span><br><span class="line">1.3 编译</span><br><span class="line">1.4 总结</span><br><span class="line">1.5 警告的总结</span><br><span class="line">1.6 编程提示的总结</span><br><span class="line">1.7 问题</span><br><span class="line">1.8 编程练习</span><br><span class="line">第2章 基本概念</span><br><span class="line">2.1 环境</span><br><span class="line">2.1.1 翻译</span><br><span class="line">2.1.2 执行</span><br><span class="line">2.2 词法规则</span><br><span class="line">2.2.1 字符</span><br><span class="line">2.2.2 注释</span><br><span class="line">2.2.3 自由形式的源代码</span><br><span class="line">2.2.4 标识符</span><br><span class="line">2.2.5 程序的形式</span><br><span class="line">2.3 程序风格</span><br><span class="line">2.4 总结</span><br><span class="line">2.5 警告的总结</span><br><span class="line">2.6 编程提示的总结</span><br><span class="line">2.7 问题</span><br><span class="line">2.8 编程练习</span><br><span class="line">第3章 数据</span><br><span class="line">第4章 语句</span><br><span class="line">第5章 操作符和表达式</span><br><span class="line">第6章 指针</span><br><span class="line">第7章 函数</span><br><span class="line">第8章 数组</span><br><span class="line">第9章 字符串、字符和字节</span><br><span class="line">第10章 结构和联合</span><br><span class="line">第11章 动态内存分配</span><br><span class="line">第12章 使用结构和指针</span><br><span class="line">第13章 高级指针话题</span><br><span class="line">第14章 预处理器</span><br><span class="line">第15章 输入&#x2F;输出函数</span><br><span class="line">第16章 标准函数库</span><br><span class="line">第17章 经典抽象数据类型</span><br><span class="line">第18章 运行时环境</span><br><span class="line">附录 部分问题答案</span><br><span class="line">索引</span><br><span class="line">参考文献</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00163LU68/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00163LU68&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51xeRugQnbL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言入门经典(第4版)</title>
    <url>/2020/04/19/B0017XICV8/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C语言入门经典(第4版)<br>作者信息： 作者: 霍顿 (Ivor Horton) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《C语言入门经典(第4版)》是编程语言先驱者Ivor Horton的经典之作，是C语言方面最畅销的图书品种之一。《C语言入门经典(第4版)》集综合性、实用性为一体，是学习C语言的优秀入门教材，在世界范围内广受欢迎，口碑极佳。书中除了讲解C程序设计语言，还广泛介绍了作为一名C程序设计人员应该掌握的必要知识，并提供了大量的实用性很强的编程实例。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 C语言编程.</span><br><span class="line">1.1 创建C程序</span><br><span class="line">1.1.1 编辑</span><br><span class="line">1.1.2 编译</span><br><span class="line">1.1.3 链接</span><br><span class="line">1.1.4 执行</span><br><span class="line">1.2 创建第一个程序</span><br><span class="line">1.3 编辑第一个程序</span><br><span class="line">1.4 处理错误</span><br><span class="line">1.5 剖析一个简单的程序</span><br><span class="line">1.5.1 注释</span><br><span class="line">1.5.2 预处理指令</span><br><span class="line">1.5.3 定义main()函数</span><br><span class="line">1.5.4 关键字</span><br><span class="line">1.5.5 函数体</span><br><span class="line">1.5.6 输出信息</span><br><span class="line">1.5.7 参数</span><br><span class="line">1.5.8 控制符</span><br><span class="line">1.6 用C语言开发程序</span><br><span class="line">1.7 函数及模块化编程</span><br><span class="line">1.8 常见错误</span><br><span class="line">1.9 要点</span><br><span class="line">1.10 小结</span><br><span class="line">1.11 习题</span><br><span class="line">第2章 编程初步</span><br><span class="line">第3章 条件判断</span><br><span class="line">第4章 循环</span><br><span class="line">第5章 数组</span><br><span class="line">第6章 字符串和文本的应用</span><br><span class="line">第7章 指针</span><br><span class="line">第8章 程序的结构</span><br><span class="line">第9章 函数再探</span><br><span class="line">第10章 基本输入和输出操作</span><br><span class="line">第11章 结构化数据</span><br><span class="line">第12章 处理文件</span><br><span class="line">第13章 支持功能</span><br><span class="line">附录</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0017XICV8/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0017XICV8&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41oAl9BEkkL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>你必须知道的495个C语言问题</title>
    <url>/2020/04/19/B001P5HR4Q/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 你必须知道的495个C语言问题<br>作者信息： 作者: 朱群英 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《你必须知道的495个C语言问题》结构清晰，讲解透彻，是各高校相关专业C语言课程很好的教学参考书，也是各层次C程序员的优秀实践指南。全球C语言程序员集体智慧的结晶；Amazon全五星图书；权威解答495个最常遇到的C语言问题。C是一门简洁精妙的语言，掌握基本语法容易，真正能够自如运用，就不那么简单了。你难免会遇到各种各样的问题，有些可能让你百思不得其解，甚至翻遍图书馆，也找不到问题的答案。《你必须知道的495个C语言问题》的出版填补了这一空白。许多知识点的阐述都是其他资料中所没有的，弥足珍贵。涵盖C99标准。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 声明和初始化</span><br><span class="line">基本类型</span><br><span class="line">1.1 我该如何决定使用哪种整数类型？</span><br><span class="line">1.2 为什么不精确定义标准类型的大小？</span><br><span class="line">1.3 因为C语言没有精确定义类型的大小，所以我一般都用typedef定义int16和int32。然后根据实际的机器环境把它们定义为int、short、long等类型。这样看来，所有的问题都解决了，是吗？</span><br><span class="line">1.4 新的64位机上的64位类型是什么样的？</span><br><span class="line">指针声明</span><br><span class="line">1.5 这样的声明有什么问题？char p1, p2; 我在使用p2的时候报错了。 1.6 我想声明一个指针，并为它分配一些空间，但却不行。这样的代码有什么问题？char p; p&#x3D;malloc（10）; 声明风格 1.7 怎样声明和定义全局变量和函数最好？ 1.8 如何在C中实现不透明（抽象）数据类型？ 1.9 如何生成“半全局变量”，就是那种只能被部分源文件中的部分函数访问的变量？ 存储类型 1.10 同一个静态（static）函数或变量的所有声明都必须包含static存储类型吗？ 1.11 extern在函数声明中是什么意思？ 1.12 关键字auto到底有什么用途？ 类型定义（typedef） 1.13 对于用户定义类型，typedef 和#define有什么区别？ 1.14 我似乎不能成功定义一个链表。我试过typedef struct&#123;char item; NODEPTR next;&#125; NODEPTR; 但是编译器报了错误信息。难道在C语言中结构不能包含指向自己的指针吗？ 1.15 如何定义一对相互引用的结构？ 1.16 Struct&#123; &#125; x1;和typedef struct&#123; &#125; x2; 这两个声明有什么区别？ 1.17 “typedef int（funcptr）（）;”是什么意思？</span><br><span class="line">const 限定词</span><br><span class="line">1.18 我有这样一组声明：typedef char charp; const charp p; 为什么是p而不是它指向的字符为const？ 1.19 为什么不能像下面这样在初始式和数组维度值中使用const值？const int n&#x3D;5; int a[n]; 1.20 const char p、char const p和char const p有什么区别？</span><br><span class="line">复杂的声明</span><br><span class="line">1.21 怎样建立和理解非常复杂的声明？例如定义一个包含N个指向返回指向字符的指针的函数的指针的数组？</span><br><span class="line">1.22 如何声明返回指向同类型函数的指针的函数？我在设计一个状态机，用函数表示每种状态，每个函数都会返回一个指向下一个状态的函数的指针。可我找不到任何方法来声明这样的函数——感觉我需要一个返回指针的函数，返回的指针指向的又是返回指针的函数，如此往复，以至无穷。</span><br><span class="line">数组大小</span><br><span class="line">1.23 能否声明和传入数组大小一致的局部数组，或者由其他参数指定大小的参数数组？</span><br><span class="line">1.24 我在一个文件中定义了一个extern数组，然后在另一个文件中使用，为什么sizeof取不到数组的大小？</span><br><span class="line">声明问题</span><br><span class="line">1.25 函数只定义了一次，调用了一次，但编译器提示非法重声明了。</span><br><span class="line">1.26 main的正确定义是什么？void main正确吗？</span><br><span class="line">1.27 我的编译器总在报函数原型不匹配的错误，可我觉得没什么问题。这是为什么？</span><br><span class="line">1.28 文件中的第一个声明就报出奇怪的语法错误，可我看没什么问题。这是为什么？</span><br><span class="line">1.29 为什么我的编译器不允许我定义大数组，如double array[256][256]？</span><br><span class="line">命名空间</span><br><span class="line">1.30 如何判断哪些标识符可以使用，哪些被保留了？</span><br><span class="line">初始化</span><br><span class="line">1.31 对于没有显式初始化的变量的初始值可以作怎样的假定？如果一个全局变量初始值为“零”，它可否作为空指针或浮点零？</span><br><span class="line">1.32 下面的代码为什么不能编译？ intf（）&#123;char a[]&#x3D;“Hello, world!”;&#125;</span><br><span class="line">1.33 下面的初始化有什么问题？编译器提示“invalid initializers ”或其他信息。char p&#x3D;malloc（10）; 1.34 char a[]&#x3D; “string literal”;和char p&#x3D;“string literal”; 初始化有什么区别？当我向p[i] 赋值的时候，我的程序崩溃了。</span><br><span class="line">1.35 char a&#123;[3]&#125;&#x3D; “abc”; 是否合法？</span><br><span class="line">1.36 我总算弄清楚函数指针的声明方法了，但怎样才能初始化呢？</span><br><span class="line">1.37 能够初始化联合吗？ </span><br><span class="line"></span><br><span class="line"> 第2章 结构、联合和枚举 结构声明 2.1 struct x1&#123; &#125;;和typedef struct&#123; &#125;x2; 有什么不同？ 2.2 这样的代码为什么不对？struct x&#123; &#125;; x thestruct; 2.3 结构可以包含指向自己的指针吗？ 2.4 在C语言中用什么方法实现抽象数据类型最好？ 2.5 在C语言中是否有模拟继承等面向对象程序设计特性的好方法？ 2.6 为什么声明extern f（struct x *p）; 给我报了一个晦涩难懂的警告信息？ 2.7 我遇到这样声明结构的代码：struct name &#123;int namelen; char namestr[1];&#125;;然后又使用一些内存分配技巧使namestr数组用起来好像有多个元素，namelen记录了元素个数。它是怎样工作的？这样是合法的和可移植的吗？ 2.8 我听说结构可以赋给变量也可以对函数传入和传出。为什么K&amp;R1却明确说明不能这样做？ 2.9 为什么不能用内建的&#x3D;&#x3D;和!&#x3D;操作符比较结构？ 2.10 结构传递和返回是如何实现的？ 2.11 如何向接受结构参数的函数传入常量值？怎样创建无名的中间的常量结构值？ 2.12 怎样从&#x2F;向数据文件读&#x2F;写结构？ 结构填充 2.13 为什么我的编译器在结构中留下了空洞？这导致空间浪费而且无法与外部数据文件进行“二进制”读写。能否关掉填充，或者控制结构域的对齐方式？ 2.14 为什么sizeof返回的值大于结构大小的期望值，是不是尾部有填充？ 2.15 如何确定域在结构中的字节偏移量？ 2.16 怎样在运行时用名字访问结构中的域？ 2.17 C语言中有和Pascal的with等价的语句吗？ 2.18 既然数组名可以用作数组的基地址，为什么对结构不能这样？ 2.19 程序运行正确，但退出时却“core dump ”（核心转储）了，怎么回事？ 联合 2.20 结构和联合有什么区别？ 2.21 有办法初始化联合吗？ 2.22 有没有一种自动方法来跟踪联合的哪个域在使用？ 枚举 2.23 枚举和一组预处理的#define有什么不同？ 2.24 枚举可移植吗？ 2.25 有什么显示枚举值符号的容易方法吗？ 位域 2.26 一些结构声明中的这些冒号和数字是什么意思？ 2.27 为什么人们那么喜欢用显式的掩码和位操作而不直接声明位域？</span><br><span class="line"></span><br><span class="line"> 第3章 表达式 求值顺序 3.1 为什么这样的代码不行？a[i]&#x3D; i++; 3.2 使用我的编译器，下面的代码int i&#x3D; 7; printf（&quot;%d\n&quot;, i++ * i++）; 打印出49。不管按什么顺序计算，难道不该是56吗？ 3.3 对于代码int i&#x3D;3; i&#x3D;i++; 不同编译器给出不同的i值，有的为3，有的为4，哪个是正确的？ 3.4 有这样一个巧妙的表达式：a^&#x3D; b^&#x3D; a^&#x3D; b; 它不需要临时变量就可以交换a和b的值。 3.5 可否用显式括号来强制执行我所需要的计算顺序并控制相关的副作用？就算括号不行，操作符优先级是否能够控制计算顺序呢？ 3.6 可是&amp;&amp;和||操作符呢？我看到过类似while（（c &#x3D; getchar（）） !&#x3D; EOF &amp;&amp; c !&#x3D; ‘\n&#39;）的代码 3.7 是否可以安全地认为，一旦&amp;&amp;和||左边的表达式已经决定了整个表达式的结果，则右边的表达式不会被求值？ 3.8 为什么表达式printf（&quot;%d %d&quot;, f1（）, f2（））; 先调用了f2？我觉得逗号表达式应该确保从左到右的求值顺序。 3.9 怎样才能理解复杂表达式并避免写出未定义的表达式？“序列点”是什么？ 3.10 在a[i] &#x3D; i++;中，如果不关心a[]的哪一个分量会被写入，这段代码就没有问题，i也的确会增加1，对吗？ 3.11 人们总是说i&#x3D;i++的行为是未定义的。可我刚刚在一个ANSI编译器上尝试过，其结果正如我所期望的。 3.12 我不想学习那些复杂的规则，怎样才能避免这些未定义的求值顺序问题呢？ 其他的表达式问题 3.13 ++i和i++有什么区别？ 3.14 如果我不使用表达式的值，那我应该用i++还是++i来做自增呢？ 3.15 我要检查一个数是不是在另外两个数之间，为什么if（a b c）不行？ 3.16 为什么如下的代码不对？int a&#x3D;1000, b&#x3D;1000; long int c&#x3D;a * b; 3.17 为什么下面的代码总是给出0？double degC, degF; degC&#x3D; 5.0 &#x2F; 9 * （degF - 32）; 3.18 需要根据条件把一个复杂的表达式赋给两个变量中的一个。可以用下面这样的代码吗？（（condition） ？ a : b）&#x3D; complicated_expression; 3.19 我有些代码包含这样的表达式。a ？ b&#x3D;c : d 有些编译器可以接受，有些却不能。为什么？ 保护规则 3.20 “semantics of‘’change in ANSI C”的警告是什么意思？ 3.21 “无符号保护”和“值保护”规则的区别在哪里？</span><br><span class="line"></span><br><span class="line"> 第4章 指针 基本的指针应用 4.1 指针到底有什么好处？ 4.2 我想声明一个指针并为它分配一些空间，但却不行。这些代码有什么问题呢？char p; p &#x3D;malloc（10）; 4.3 p++自增p还是p所指向的变量？ 指针操作 4.4 我用指针操作int数组的时候遇到了麻烦。 4.5 我有一个char 型指针碰巧指向一些int型变量，我想跳过它们。为什么（（int ）p）++; 这样的代码不行？ 4.6 为什么不能对void 指针进行算术操作？ 4.7 我有些解析外部结构的代码，但是它却崩溃了，显示出了“unaligned access”（未对齐的访问）的信息。这是什么意思？ 作为函数参数的指针 4.8 我有个函数，它应该接受并初始化一个指针：void f（int ip）&#123; static int dummy &#x3D; 5; ip &#x3D; &amp;dummy;&#125;但是当我如下调用时：int ip; f（ip）; 调用者的指针没有任何变化。 4.9 能否用void 通用指针作为参数，使函数模拟按引用传递参数？ 48 4.10 我有一个函数extern intf（int ）; ，它接受指向int型的指针。我怎样用引用方式传入一个常数？调用f（&amp;5）;似乎不行。 4.11 C语言可以“按引用传参”吗？ 其他指针问题 4.12 我看到了用指针调用函数的不同语法形式。到底怎么回事？ 4.13 通用指针类型是什么？当我把函数指针赋向void 类型的时候，编译通不过。 4.14 怎样在整型和指针之间进行转换？能否暂时把整数放入指针变量中，或者相反？ 4.15 我怎样把一个int变量转换为char *型？我试了类型转换，但是不行。</span><br><span class="line"></span><br><span class="line"> 第5章 空指针 空指针和空指针常量 5.1 臭名昭著的空指针到底是什么？ 5.2 怎样在程序里获得一个空指针？ 5.3 用缩写的指针比较“if（p）”检查空指针是否有效？如果空指针的内部表达不是0会怎样？ NULL 宏 5.4 NULL是什么，它是怎么定义的？ 5.5 在使用非零位模式作为空指针的内部表示的机器上，NULL 是如何定义的？ 5.6 如果NULL定义成#define NULL（（char ）0） ，不就可以向函数传入不加转换的NULL 了吗？ 5.7 我的编译器提供的头文件中定义的NULL为0L。为什么？ 5.8 NULL可以合法地用作函数指针吗？ 5.9 如果NULL和0作为空指针常量是等价的，那我到底该用哪一个呢？ 5.10 但是如果NULL的值改变了，比如在使用非零内部空指针的机器上，用NULL（而不是0） 不是更好吗？ 5.11 我曾经使用过一个编译器，不使用NULL就不能编译。 5.12 我用预处理宏#define Nullptr（type）（type ）0帮助创建正确类型的空指针。 回顾 5.13 这有点奇怪：NULL可以确保是0，但空（null）指针却不一定？ 5.14 为什么有那么多关于空指针的疑惑？为什么这些问题如此频繁地出现？ 5.15 有没有什么简单点儿的办法理解所有这些与空指针有关的东西呢？ 5.16 考虑到有关空指针的所有这些困惑，要求它们的内部表示都必须为0不是更简单吗？ 5.17 说真的，真有机器用非零空指针吗，或者不同类型用不同的表示？ 地址0上到底有什么？ 5.18 运行时的整数值0转换为指针以后一定是空指针吗？ 5.19 如何访问位于机器地址0处的中断向量？如果我将指针值设为0，编译器可能会自动将它转换为非零的空指针内部表示。 5.20 运行时的“null pointer assignment”错误是什么意思？应该怎样捕捉它？</span><br><span class="line"></span><br><span class="line"> 第6章 数组和指针 数组和指针的基本关系 6.1 我在一个源文件中定义了char a[6]，在另一个源文件中声明了extern char a。为什么不行？ 6.2 可是我听说char a[]和char a是等价的。是这样的吗？ 6.3 那么，在C语言中“指针和数组等价”到底是什么意思？ 6.4 既然它们这么不同，那为什么作为函数形参的数组和指针声明可以互换呢？ 数组不能被赋值 6.5 为什么不能这样向数组赋值？extern char getpass（）; char str[10]; str&#x3D;getpass（&quot;Enter password:“）; 6.6 既然不能向数组赋值，那这段代码为什么可以呢？int f（char str[]）&#123; if（str[0] &#x3D;&#x3D; ‘\0&#39;） str&#x3D;&quot;none”;&#125; 6.7 如果你不能给它赋值，那么数组如何能成为左值呢？ 回顾 6.8 现实地讲，数组和指针的区别是什么？ 6.9 有人跟我讲，数组不过是常指针。这样讲准确吗？ 6.10 我还是很困惑。到底指针是一种数组，还是数组是一种指针？ 6.11 我看到一些“搞笑”的代码，包含5[“abcdef”]这样的“表达式”。这为什么是合法的C语言表达式呢？ 数组的指针 6.12 既然数组引用会退化为指针，如果array是数组，那么array和&amp;array又有什么区别呢？ 6.13 如何声明一个数组的指针？ 动态数组分配 6.14 如何在运行时设定数组的大小？怎样才能避免固定大小的数组？ 6.15 我如何声明大小和传入的数组一样的局部数组？ 6.16 如何动态分配多维数组？ 6.17 有个很好的窍门，如果我这样写：int realarray[10]; int array &#x3D; &amp;realarray[-1]; 我就可以把“array”当作下标从1 开始的数组。 函数和多维数组 6.18 当我向一个接受指针的指针的函数传入二维数组的时候，编译器报错了。 6.19 我怎样编写接受编译时宽度未知的二维数组的函数？ 6.20 我怎样在函数参数传递时混用静态和动态多维数组？ 数组的大小 6.21 当数组是函数的参数时，为什么sizeof不能正确报告数组的大小？ 6.22 如何在一个文件中判断声明为extern的数组的大小（例如，数组定义和大小在另一个文件中）？sizeof操作符似乎不行。 6.23 sizeof返回的大小是以字节计算的，怎样才能判断数组中有多少个元素呢？ 第7章 内存分配 第8章　字符和字符串 第9章　布尔表达式和变量 第10章　C预处理器 第11章　ANSI&#x2F;ISO标准C 第12章　标准输入输出库 第13章　库函数 第14章　浮点运算 第15章　可变参数列表 第16　章 奇怪的问题 第17章　风格 第18章　工具和资源 第19章　系统依赖 第20章　杂项 术语表 参考文献</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001P5HR4Q/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001P5HR4Q&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51Kujz2BweL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>Android应用开发揭秘</title>
    <url>/2020/04/19/B0033UX10A/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android应用开发揭秘<br>作者信息： 作者: 杨丰盛 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Android应用开发揭秘》：Android应用开发揭秘Windows操作系统的诞生成就了微软的霸主地位，也造就了PC时代的繁荣。然而，以Android和iPhone手机为代表的智能移动设备的发明却敲响了PC时代的丧钟!移动互联网时代(3G时代)已经来临，谁会成为这些移动设备上的主宰?毫无疑问，它就是Android——PC时代的Windows!移动互联网还是一个新生的婴儿，各种移动设备上的操作系统群雄争霸!与Sym‘Dian、i P}lone OS、Wiridows Mobile相比，Androjd有着天生的优势一完全开放和免费，对广大开发者和手机厂商而言，这是何等的诱人!此外，在Google和以其为首的Android手机联盟的大力支持和推广下，Android不仅得到了全球开发者社区的关注，而且一大批世界一流的手机厂商都已经或准备采用Android。拥抱Android开发。拥抱移动开发的未来!如果你在思考下面这些问题，也许本书就是你想要的！Android开发与传统的J2ME开发有何相似与不同？如何通过Shared Preferences、Files、Network和SQLite等方式高效实现Android数据的存储？又如何通过Content Providers轻松地实现Androld数据的共享？如何使用Open Core、MediaPlayer、MediaRecorder方便快速地开发出包含音频和视频等流媒体的丰富多媒体应用？如何利用Android 2.0新增的蓝牙特性开发包含蓝牙功能的应用？又如何使用蓝牙APL来完善应用的网络功能？如何解决Android网络通信中的乱码问题？在Android中如何使用语音服务和Google Map Apl? Android如何访问摄象头、传感器等硬件的APl？如何时行Widget开发？如何用各种Android组件来打造漂亮的UI界面？Android如何解析XML数据？又如何提高解析速度和减少对内存、CPU资源的消耗？如何使用OpenGL ES在Android平台上开发出绚丽的3D应用？在Android平台上如何更好地设计和实现游戏引擎？如何对Android应用进行优化？如何进行程序性能测试？如何实现UI、zipalign和图片优化？如何通过NDK利用C、C＋＋以及通过ASE利用Python等脚本语言Android开发应用？国内首本基于Android 2.0的经典著作，5大专业社区一致鼎力推荐！</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">第一部分 准备篇</span><br><span class="line">第1章 Android开发简介</span><br><span class="line">1.1 Android基本概念</span><br><span class="line">1.1.1 Android简介</span><br><span class="line">1.1.2 Android的系统构架</span><br><span class="line">1.1.3 Android应用程序框架</span><br><span class="line">1.2 OMS介绍</span><br><span class="line">1.2.1 OPhone介绍</span><br><span class="line">1.2.2 Widget介绍</span><br><span class="line">1.3 小结 </span><br><span class="line"></span><br><span class="line"> 第2章 Android开发环境搭建 2.1 Android开发准备工作 2.2 开发包及其工具的安装和 配置 2.2.1 安装JDK和配置Java开发 环境 2.2.2 Eclipse的安装与汉化 2.2.3 SDK和ADT的安装和 配置 2.3 创建第一个Android项目——HeUoAndroid 2.3.1 创建HelloAndroid项目 2.3.2 运行HelloAndroid及模拟器的使用 2.3.3 调试HelloAndroid 2.4 小结 第二部分 基础篇</span><br><span class="line"></span><br><span class="line"> 第3章 Android程序设计基础 3.1 Android程序框架 3.1.1 Android项目目录结构 3.1.2 Android应用解析 3.2 Android的生命周期 3.3 Android程序U设计 3.4 小结</span><br><span class="line"></span><br><span class="line"> 第4章 用户界面开发 4.1 用户界面开发详解 4.1.1 用户界面简介 4.1.2 事件处理 4.2 常用控件应用 4.2.1 文本框(Textiew) 4.2.2 列表(ListView) 4.2.3 提示(T0ast) 4.2.4 编辑框(EditText) 4.2.5 单项选择(RadioGroup、RadioButton 4.2.6 多项选择(CheckBox) 4.2.7 下拉列表(Spinner) 4.2.8 自动提示(AutoComplete.TextⅥew) 4.2.9 日期和时间(DatePicker、TimePicker) 4.2.10 按钮(Button) 4.2.1l 菜单(Menu) 4.2.12 对话框(Dialog) 4.2.13 图片视图(ImageView) 4.2.14 带图标的按钮(ImageButton) 4.2.15 拖动效果(Gallery) 4.2.16 切换图片(hmgeSwilcher) 4.2.17 网格视图(GridView) 4.2.18 卷轴视图(ScrollView) 4.2.19 进度条(ProgressBar) 4.2.20 拖动条(SeekBar) 4.2.21 状态栏提示(Notification、NotificationManager) 4.2.22 对话框中的进度条(ProgressDialog) 4.3 界面布局 4.3.1 垂直线性布局 4.3.2 水平线性布局 4.3.3.相对布局(RelativeLayout) 4.3.4 表单布局(TableLayout) 4.3.5 切换卡(TabWidget) 4,4 小结</span><br><span class="line"></span><br><span class="line"> 第5章 Android游戏开发 5.1 Android游戏开发框架 5.1.1 View类开发框架 5.1.2 SurfaceView类开发框架 5.2 Graphics类开发 5.5.1 Paint和Color类介绍 5.2.2 Canvas类介绍 5.2.3 几何图形绘制 5.2.4 字符串绘制 5.2.5 图像绘制 5.2.6 图像旋转 5.2.7 图像缩放 5.2.8 图像像素操作 5.2.9 Shader类介绍 5.2.10 双缓冲技术 5.2.11 全屏显示 5.2.12 获得屏幕属性 5.3 动画实现 5.3.1 Tween动画 5.3.2 Frame动画 5.3.3 GIF动画播放 5.4 小结</span><br><span class="line"></span><br><span class="line"> 第6章 Android数据存储 6.1 Android数据存储初探 6.2 数据存储之Shared Preferences 6.3 数据存储之Files 6.4 数据存储之Network 6.5 Android数据库编程 6.5.1 SQLite简介 6.5.2 SQLite编程详解 6.5.3 SQLiteOpenHelper应用 6.6 数据共享(ContentProviders) 6.7 小结</span><br><span class="line"></span><br><span class="line"> 第7 章多媒体开发 7.1 多媒体开发详解 7.1.1 Open Core 7.1.2 MediaPlayer 7.1.3 MediaRecorder 7.2 播放音乐 7.3 播放视频 7.4 录制歌曲 7.5 相机设置 7.6 闹钟设置 7.7 铃声设置 7.8 小结</span><br><span class="line"></span><br><span class="line"> 第8章 网络与通信 8.1 网络通信基础 8.1.1 无线网络技术 8.1.2 Android网络基础 8.2 HTTP通信 8.2.1 HttpURLConnection接口 8.2.2 HttpClient接口 8.2.3 实时更新 8.3 Socket通信 8.3.1 Socket基础 8.3.2 Socket应用(简易聊天室) 8.4 网络通信的中文乱码问题 8.5 WebKit应用 8.5.1 WebKjt概述 8.5.2 WebView浏览网页 8.5.3 WebView与Javascript 8.6 WtFi介绍 8.7 蓝牙 8.8 小结</span><br><span class="line"></span><br><span class="line"> 第9章 Android特色开发 9.1 传感器 9.2 语音识别 9.3 GoogleMap 9.3.1 GoogleMap概述 9.3.2 准备工作 9.3.3 GoogleMapAPI的使用 9.3.4 定位系统 9.4 桌面组件 9.4.1 快捷方式 9.4.2 实时文件夹 9.4.3 Widget开发 9.5 账户管理 9.6 小结 第三部分 实例篇</span><br><span class="line"></span><br><span class="line"> 第10章 Android应用开发 实例 10.1 情境模式 10.2 文件管理器 10.3 通讯录 10.4 音乐播放器 10.5 天气预报 10.6 个人地图 10.7 Widget日历 10.8 小结</span><br><span class="line"></span><br><span class="line"> 第11 章Android游戏开发实例 11.1 手机游戏开发简介 11.2 游戏框架设计 11.3 地图设计 11.4 主角设计 11.5 图层管理器 11.6 游戏音效 11.7 游戏存档 11.8 小结 第四部分 高级篇</span><br><span class="line"></span><br><span class="line"> 第12章 AndroidOpenGL开发 基础 12.1 OpenGL简介 12.2 多边形 12.3 颜色 12.4 旋转 12.5 3D 空间 12.6 纹理映射 12.7 光照和事件 12.8 混合 12.9 小结</span><br><span class="line"></span><br><span class="line"> 第13章 AndroidOpenGL综合 应用 13.1 移动图像 13.2.3D 世界 13.3 飘动的旗帜 13.4 显示列表 13.5 雾 13.6 粒子系统 13.7 蒙版 13.8 变形 13.9 小结</span><br><span class="line"></span><br><span class="line"> 第14章 游戏引擎实现 14.1 游戏引擎介绍 14.1.1 什么是引擎 14.1.2 引擎的进化 14.1.3 常见的游戏引擎 14.1.4 Android游戏引擎 14.2 游戏引擎结构 14.2.1 游戏引擎原理 14.2.2 游戏引擎定位 14.2.3 游戏引擎框架 14.3 游戏引擎设计 14.3.1 游戏引擎结构和功能 设计 14.3.2 游戏引擎设计注意事项 14.4 游戏引擎实现 14.4.1 Activity类实现 14.4.2 流程控制和线程 14.4.3 游戏对象与对象管理 14.4.4 图形引擎 14.4.5 物理引擎 14.4.6 事件模块 14.4.7 工具模块 14.4.8 脚本引擎、音效模块、网络 模块 14.5 小结</span><br><span class="line"></span><br><span class="line"> 第15章 优化技术 15.1 优化的基本知识 15.1.1 如何书写出优秀代码 15.1.2 编程规范 15.2 程序性能测试 15.2.1 计算性能测试 15.2.2 内存消耗测试 15.3 初级优化 15.4 高级优化 15.5 Android高效开发 15.6 AndroidUI优化 15.7 其他优化 15.7.1 zipalign 15.7.2 图片优化 15.8 小结 第五部分 扩展篇</span><br><span class="line"></span><br><span class="line"> 第16章 Android NDK开发 16.1 AndroidNDK简介 16.2 安装和配置NDK开发环境 16.2.1 系统和软件需求 16.2.2 NDK开发环境搭建 16.2.3 编译第一个NDK程序 16.3 AndroidNDK开发 16.3.1 JNI接口设计 16.3.2 使用C\C++实现本地 方法 16.3.3 Android.mk实现 16.3.4 Application.mk实现 16.3.5 编译C\C++代码 16.4 AndroidNDK中使用0penGL 16.5小结</span><br><span class="line"></span><br><span class="line"> 第17章 Android脚本环境 17.1 Android脚本环境简介 17.2 Android脚本环境安装 17.3如何编写Android脚本程序 17.4小结</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0033UX10A/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0033UX10A&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51Mn4UNRZ6L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法分析 C语言描述(原书第2版)</title>
    <url>/2020/04/19/B002WC7NGS/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 数据结构与算法分析 C语言描述(原书第2版)<br>作者信息： 作者: 维斯 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《数据结构与算法分析:C语言描述(原书第2版)》讨论数据结构和算法分析。数据结构主要研究组织大量数据的方法，而算法分析则是对算法运行时间的评估。随着计算机的速度越来越快，对于能够处理大量输入数据的程序的需求变得日益急切。可是，由于在输入量很大的时候，程序的低效率现象变得非常明显，因此这又要求对效率问题给予更仔细的关注。通过在实际编程之前对算法的分析，学生可以决定一个特定的解法是否可行。例如，学生在《数据结构与算法分析:C语言描述(原书第2版)》中将读到一些特定的问题并看到精心的实现方法是如何把对大量数据的时间限制从16年减至不到1秒的。因此，若无运行时间的阐释，就不会有算法和数据结构的提出。《数据结构与算法分析:C语言描述(原书第2版)》是国外数据结构与算法分析方在的标准教材，介绍了数据结构（大量数据的组织方法）以及算法分析（算法运行时间的估算）。《数据结构与算法分析:C语言描述(原书第2版)》的编写目标是同时廛授好的程序设计和算法分析技巧，使读者可以开发出具有最高效率的程序。《数据结构与算法分析:C语言描述(原书第2版)》可作为高级数据结构课程或研究生一年级算法分析课程的教材，使用《数据结构与算法分析:C语言描述(原书第2版)》需具有一些中级程序设计知识，还需要离散数学的一些背景知识。随着速度的不断提高和存储容量的持续增长，计算机的功能日益强大，从而处理数据和解决问题的规模和复杂程度与日俱增。这不仅带来了需要认真研究的新课题，而且突出了原有数据结构和算法效率低下的缺点。程序的效率问题不是由于计算机功能的强大而受到冷落，相反地，倒是被人们提到前所未有的重视程度，因为大型问题的解决所涉及到的大容量存储和高速度运算容不得我们对效率有丝毫的忽视。《数据结构与算法分析:C语言描述(原书第2版)》正是在阐述数据结构基本概念的同时深入地分析了算法的效率。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">出版者的话</span><br><span class="line">专家指导委员会</span><br><span class="line">译者序</span><br><span class="line">前言</span><br><span class="line">第1章 引论</span><br><span class="line">第2章 算法分析</span><br><span class="line">第3章 表、栈和队列</span><br><span class="line">第4章 树</span><br><span class="line">第5章 散列</span><br><span class="line">第6章 优先队列（堆）</span><br><span class="line">第7章 排序</span><br><span class="line">第8章 不相交集AD</span><br><span class="line">第9章 图论算法</span><br><span class="line">第10章 算法设计技巧</span><br><span class="line">第11章 摊还分析</span><br><span class="line">第12章 高级数据结构及其实现</span><br><span class="line">索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B002WC7NGS/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B002WC7NGS&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec8.images-amazon.com/images/I/51ma2qq0dkL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言程序设计 现代方法(第2版)</title>
    <url>/2020/04/19/B003BVBOOQ/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C语言程序设计 现代方法(第2版)<br>作者信息： 作者: 金(K.N.King) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《C语言程序设计:现代方法(第2版)》是C语言的经典之作，被誉为“近10年来最好的一部C语言著作”。书中讨论了标准C和C标准库的全部特性，包括信号、setjmp／longjmp和可变参数列表等其他书中很少涉及的内容。全书由易而难、循序渐进、螺旋式地讲述C语言，很好地处理了指针和位运算等难点。第2版覆盖了C99标准，并提供了对所有C99库函数的参考，还扩展了GCC的内容，增加了对抽象数据类型的讨论，并针对新CPU和操作系统做了更新。《C语言程序设计：现代方法(第2版)》尤为强调软件工程和现代编程理念，在知识的阐述中突出工业界的最佳实践、实际经验和编程风格，使读者能够合理运用所学，编写出可读性好、可靠性高和容易维护的代码。书中精心选择了近500道习题，贴近实战，与叙述文字相得益彰。目前《C语言程序设计：现代方法(第2版)》已被全球200多所学校采用为教材，包括哈佛大学、麻省理工学院、斯坦福大学、加州大学伯克利分校、耶鲁大学、加州理工学院等诸多名校。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 C语言概述1</span><br><span class="line">1.1 C语言的历史1</span><br><span class="line">1.1.1 起源1</span><br><span class="line">1.1.2 标准化1</span><br><span class="line">1.1.3 基于C的语言2</span><br><span class="line">1.2 C语言的优缺点3</span><br><span class="line">1.2.1 C语言的优点3</span><br><span class="line">1.2.2 C语言的缺点3</span><br><span class="line">1.2.3 高效地使用C语言4</span><br><span class="line">问与答5 </span><br><span class="line"></span><br><span class="line"> 第2章 C语言基本概念7 2.1 编写一个简单的C程序7 程序显示双关语7 2.1.1 编译和链接8 2.1.2 集成开发环境8 2.2 简单程序的一般形式9 2.2.1 指令9 2.2.2 函数9 2.2.3 语句10 2.2.4 显示字符串10 2.3 注释11 2.4 变量和赋值12 2.4.1 类型12 2.4.2 声明13 2.4.3 赋值13 2.4.4 显示变量的值14 程序计算箱子的空间重量14 2.4.5 初始化15 2.4.6 显示表达式的值16 2.5 读入输入16 程序计算箱子的空间重量（改进版）16 2.6 定义常量的名字17 程序华氏温度转换为摄氏温度17 2.7 标识符18 2.8 C程序的书写规范19 问与答21 练习题23 编程题24</span><br><span class="line"></span><br><span class="line"> 第3章 格式化输入&#x2F;输出26 3.1 printf函数26 3.1.1 转换说明27 程序用printf函数格式化数28 3.1.2 转义序列28 3.2 scanf函数29 3.2.1 scanf函数的工作方法30 3.2.2 格式串中的普通字符31 3.2.3 易混淆的printf函数和scanf函数32 程序分数相加32 问与答33 练习题34 编程题35</span><br><span class="line"></span><br><span class="line"> 第4章 表达式36 4.1 算术运算符36 程序计算通用产品代码的校验位38 4.2 赋值运算符39 4.2.1 简单赋值40 4.2.2 左值41 4.2.3 复合赋值41 4.3 自增运算符和自减运算符42 4.4 表达式求值43 4.5 表达式语句45 问与答45 练习题47 编程题49</span><br><span class="line"></span><br><span class="line"> 第5章 选择语句50 5.1 逻辑表达式50 5.1.1 关系运算符50 5.1.2 判等运算符51 5.1.3 逻辑运算符51 5.2 if语句52 5.2.1 复合语句53 5.2.2 else子句53 5.2.3 级联式if语句54 程序计算股票经纪人的佣金55 5.2.4 “悬空else”的问题56 5.2.5 条件表达式57 5.2.6 C89中的布尔值58 5.2.7 C99中的布尔值58 5.3 switch语句59 程序显示法定格式的日期61 问与答62 练习题65 编程题67</span><br><span class="line"></span><br><span class="line"> 第6章 循环69 6.1 while语句69 程序显示平方表71 程序数列求和71 6.2 do语句72 程序计算整数的位数73 6.3 for语句73 6.3.1 for语句的惯用法74 6.3.2 在for语句中省略表达式75 6.3.3 C99中的for语句75 6.3.4 逗号运算符76 程序显示平方表（改进版）77 6.4 退出循环78 6.4.1 break语句78 6.4.2 continue语句78 6.4.3 goto语句79 程序账簿结算80 6.5 空语句81 问与答83 练习题84 编程题85</span><br><span class="line"></span><br><span class="line"> 第7章 基本类型88 7.1 整数类型88 7.1.1 C99中的整数类型90 7.1.2 整数常量90 7.1.3 C99中的整数常量91 7.1.4 整数溢出91 7.1.5 读&#x2F;写整数91 程序数列求和（改进版）92 7.2 浮点类型93 7.2.1 浮点常量94 7.2.2 读&#x2F;写浮点数94 7.3 字符类型94 7.3.1 字符操作95 7.3.2 有符号字符和无符号字符95 7.3.3 算术类型96 7.3.4 转义序列96 7.3.5 字符处理函数97 7.3.6 用scanf和printf读&#x2F;写字符98 7.3.7 用getchar和putchar读&#x2F;写字符98 程序确定消息的长度99 7.4 类型转换100 7.4.1 常用算术转换101 7.4.2 赋值过程中的转换102 7.4.3 C99中的隐式转换103 7.4.4 强制类型转换103 7.5 类型定义105 7.5.1 类型定义的优点105 7.5.2 类型定义和可移植性105 7.6 sizeof运算符106 问与答107 练习题109 编程题110</span><br><span class="line"></span><br><span class="line"> 第8章 数组113 8.1 一维数组113 8.1.1 数组下标113 程序数列反向115 8.1.2 数组初始化115 8.1.3 指定初始化式116 程序检查数中重复出现的数字116 8.1.4 对数组使用sizeof运算符117 程序计算利息118 8.2 多维数组119 8.2.1 多维数组初始化120 8.2.2 常量数组121 程序发牌121 8.3 C99中的变长数组122 问与答123 练习题124 编程题125</span><br><span class="line"></span><br><span class="line"> 第9章 函数129 9.1 函数的定义和调用129 程序计算平均值129 程序显示倒计数130 程序显示双关语（改进版）131 9.1.1 函数定义132 9.1.2 函数调用133 程序判定素数134 9.2 函数声明135 9.3 实际参数136 9.3.1 实际参数的转换137 9.3.2 数组型实际参数138 9.3.3 变长数组形式参数140 9.3.4 在数组参数声明中使用static141 9.3.5 复合字面量141 9.4 return语句142 9.5 程序终止143 9.6 递归144 程序快速排序146 问与答147 练习题150 编程题153</span><br><span class="line"></span><br><span class="line"> 第10章 程序结构155 10.1 局部变量155 10.1.1 静态局部变量156 10.1.2 形式参数156 10.2 外部变量156 10.2.1 示例：用外部变量实现栈156 10.2.2 外部变量的利与弊157 程序猜数158 10.3 程序块161 10.4 作用域162 10.5 构建C程序163 程序给一手牌分类163 问与答169 练习题169 编程题170</span><br><span class="line"></span><br><span class="line"> 第11章 指针172 11.1 指针变量172 11.2 取地址运算符和间接寻址运算符173 11.2.1 取地址运算符173 11.2.2 间接寻址运算符174 11.3 指针赋值174 11.4 指针作为参数176 程序找出数组中的最大元素和最小元素177 11.5 指针作为返回值179 问与答180 练习题181 编程题182</span><br><span class="line"></span><br><span class="line"> 第12章 指针和数组184 12.1 指针的算术运算184 12.1.1 指针加上整数185 12.1.2 指针减去整数185 12.1.3 两个指针相减186 12.1.4 指针比较186 12.1.5 指向复合常量的指针186 12.2 指针用于数组处理186 12.3 用数组名作为指针188程序数列反向（改进版）189 12.3.1 数组型实际参数（改进版）189 12.3.2 用指针作为数组名191 12.4 指针和多维数组191 12.4.1 处理多维数组的元素191 12.4.2 处理多维数组的行192 12.4.3 处理多维数组的列192 12.4.4 用多维数组名作为指针192 12.5 C99中的指针和变长数组193 问与答194 练习题195 编程题197</span><br><span class="line"></span><br><span class="line"> 第13章 字符串198 13.1 字符串字面量198 13.1.1 字符串字面量中的转义序列198 13.1.2 延续字符串字面量199 13.1.3 如何存储字符串字面量199 13.1.4 字符串字面量的操作200 13.1.5 字符串字面量与字符常量200 13.2 字符串变量200 13.2.1 初始化字符串变量201 13.2.2 字符数组与字符指针202 13.3 字符串的读和写203 13.3.1 用printf函数和puts函数写字符串203 13.3.2 用scanf函数和gets函数读字符串203 13.3.3 逐个字符读字符串204 13.4 访问字符串中的字符205 13.5 使用C语言的字符串库206 13.5.1 strcpy函数207 13.5.2 strlen函数208 13.5.3 strcat函数208 13.5.4 strcmp函数209程序显示一个月的提醒列表209 13.6 字符串惯用法211 13.6.1 搜索字符串的结尾211 13.6.2 复制字符串213 13.7 字符串数组214 程序核对行星的名字217 问与答218 练习题220 编程题222</span><br><span class="line"></span><br><span class="line"> 第14章 预处理器225 14.1 预处理器的工作原理225 14.2 预处理指令227 14.3 宏定义227 14.3.1 简单的宏227 14.3.2 带参数的宏229 14.3.3 #运算符231 14.3.4 ##运算符231 14.3.5 宏的通用属性232 14.3.6 宏定义中的圆括号233 14.3.7 创建较长的宏233 14.3.8 预定义宏234 14.3.9 C99中新增的预定义宏235 14.3.10 空的宏参数236 14.3.11 参数个数可变的宏236 14.3.12 func标识符237 14.4 条件编译237 14.4.1 #if指令和#endif指令238 14.4.2 defined运算符238 14.4.3 #ifdef指令和#ifndef指令239 14.4.4 #elif指令和#else指令239 14.4.5 使用条件编译240 14.5 其他指令240 14.5.1 #error指令240 14.5.2 #line指令241 14.5.3 #pragma指令242 14.5.4 _Pragma运算符242 问与答243 练习题245</span><br><span class="line"></span><br><span class="line"> 第15章 编写大型程序248 15.1 源文件248 15.2 头文件249 15.2.1 #include指令249 15.2.2 共享宏定义和类型定义250 15.2.3 共享函数原型251 15.2.4 共享变量声明252 15.2.5 嵌套包含253 15.2.6 保护头文件253 15.2.7 头文件中的#error指令254 15.3 把程序划分成多个文件254程序文本格式化255 15.4 构建多文件程序260 15.4.1 makefile260 15.4.2 链接期间的错误262 15.4.3 重新构建程序262 15.4.4 在程序外定义宏264 问与答264 练习题265 编程题266</span><br><span class="line"></span><br><span class="line"> 第16章 结构、联合和枚举267 16.1 结构变量267 16.1.1 结构变量的声明267 16.1.2 结构变量的初始化269 16.1.3 指定初始化269 16.1.4 对结构的操作270 16.2 结构类型270 16.2.1 结构标记的声明271 16.2.2 结构类型的定义272 16.2.3 结构作为参数和返回值272 16.2.4 复合字面量273 16.3 嵌套的数组和结构274 16.3.1 嵌套的结构274 16.3.2 结构数组274 16.3.3 结构数组的初始化275程序维护零件数据库275 16.4 联合281 16.4.1 用联合来节省空间282 16.4.2 用联合来构造混合的数据结构284 16.4.3 为联合添加“标记字段”284 16.5 枚举285 16.5.1 枚举标记和类型名286 16.5.2 枚举作为整数286 16.5.3 用枚举声明“标记字段”286 问与答287 练习题289 编程题293</span><br><span class="line"></span><br><span class="line"> 第17章 指针的高级应用294 17.1 动态存储分配294 17.1.1 内存分配函数294 17.1.2 空指针295 17.2 动态分配字符串296 …… 第18章 声明 327 第19章 程序设计 345 第20章 底层程序设计 363 第21章 标准库 377 第22章 输入&#x2F;输出 384 第23章 库对数值和字符数据的支持 419 第24章 错误处理 446 第25章 国际化特性 456 第26章 其他库函数 482 第27章 C99对数学计算的新增支持 503 附录A C语言运算符 524 附录B C99与C89的比较 525 附录C C89与经典C的比较 529 附录D 标准库函数 532 附录E ASCII字符集 569 参考文献 570 索引 573</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B003BVBOOQ/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B003BVBOOQ&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41E76sOTIPL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统级深入开发 移植与调试</title>
    <url>/2020/04/19/B004J54TPO/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android系统级深入开发 移植与调试<br>作者信息： 作者: 韩超 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Android系统级深入开发:移植与调试》：从Android开源工程到产品的开发宝典、全面介绍Android中与硬件相关的子系统、按照驱动程序和硬件抽象层两方面把握移植要点、高效粘合LinuX系统经验和移动设备应用场景、以三种硬件平台为参考，参考开发环境易于获得。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 Android系统移植开发概述 1</span><br><span class="line">1.1 Android系统架构和生态系统 1</span><br><span class="line">1.1.1 Android软件系统 1</span><br><span class="line">1.1.2 Android的生态系统 3</span><br><span class="line">1.2 Android移植的概念和方法 4</span><br><span class="line">1.3 Android移植的主要工作 5 </span><br><span class="line"></span><br><span class="line"> 第2章 Android源代码和开发环境 8 2.1 开发环境和工具 8 2.2 Android的代码库 9 2.3 Android系统代码和编译 9 2.3.1 获取Android源代码 9 2.3.2 Android源代码结构 12 2.3.3 编译Android系统源代码 13 2.3.4 编译Android结果 13 2.4 Android Kernel代码和编译 14 2.4.1 Goldfish内核源代码 15 2.4.2 MSM内核源代码 15 2.4.3 Omap内核源代码 16 2.5 仿真器的运行环境 16 2.5.1 仿真器的运行 16 2.5.2 使用附加工具 18</span><br><span class="line"></span><br><span class="line"> 第3章 Android系统移植的结构和方法 20 3.1 Android的Linux操作系统 20 3.1.1 标准的Linux操作系统 20 3.1.2 Android对Linux 内核的使用 22 3.1.3 Linux内核空间到用户空间的接口 24 3.1.4 平台数据和平台驱动 34 3.2 Android的硬件抽象层 35 3.2.1 硬件抽象层的地位和功能 35 3.2.2 硬件抽象层接口方式 36 3.3 Android中各个部件的移植方式 41 3.4 辅助性工作和基本调试方法 41 3.4.1 移植的辅助性工作 42 3.4.2 调试的方法 46</span><br><span class="line"></span><br><span class="line"> 第4章 Android的GoldFish内核和驱动 56 4.1 GoldFish内核概述 56 4.2 GoldFish体系结构移植 58 4.3 GoldFish的Android专用驱动和组件 59 4.3.1 wakelock和earlysuspend 59 4.3.2 staging中的驱动程序 61 4.3.3 Ashmem驱动程序 66 4.3.4 Alarm驱动程序 67 4.3.5 pmem驱动程序 67 4.3.6 ADB Garget驱动程序 68 4.3.7 Android Paranoid网络 68 4.4 GoldFish的相关设备驱动 70 4.4.1 Framebuffer的驱动程序 70 4.4.2 键盘的驱动程序 70 4.4.3 实时时钟的驱动程序 71 4.4.4 TTY终端的驱动程序 71 4.4.5 NandFlash的驱动程序 72 4.4.6 MMC的驱动程序 72 4.4.7 电池的驱动程序 73 4.4.8 EAC音频的驱动程序 73</span><br><span class="line"></span><br><span class="line"> 第5章 Android的MSM内核和驱动 74 5.1 MSM处理器概述 74 5.1.1 MSM概述 74 5.1.2 MSM适用于Android的Linux内核的结构 77 5.2 MSM体系结构的移植 79 5.3 MSM的Android专用驱动和组件 80 5.4 MSM的mahimahip平台的主要设备驱动 81 5.4.1 显示的驱动程序 81 5.4.2 触摸屏的驱动程序 82 5.4.3 按键和轨迹球的驱动程序 82 5.4.4 实时时钟的驱动程序 83 5.4.5 摄像头的驱动程序 83 5.4.6 无线局域网的驱动程序 83 5.4.7 蓝牙的驱动程序 84 5.4.8 DSP相关的驱动程序 84 5.4.9 高通特有的组件相关内容 85</span><br><span class="line"></span><br><span class="line"> 第6章 Android的OMAP内核和驱动 87 6.1 OMAP内核概述 87 6.1.1 OMAP概述 87 6.1.2 OMAP适用于Android的Linux内核的结构 91 6.2 OMAP体系结构的移植 92 6.2.1 OMAP平台部分的移植 92 6.2.2 OMAP处理器部分的移植 94 6.3 OMAP的Android专用驱动和组件 96 6.4 OMAP的主要设备驱动 97 6.4.1 显示的驱动程序 97 6.4.2 摄像头和视频输出的驱动程序 98 6.4.3 i2c总线驱动程序 98 6.4.4 键盘的驱动程序 99 6.4.5 触摸屏的驱动程序 99 6.4.6 实时时钟的驱动程序 99 6.4.7 音频的驱动程序 99 6.4.8 蓝牙的驱动程序 100 6.4.9 以太网的驱动程序 100 6.4.10 DSP的驱动程序 100</span><br><span class="line"></span><br><span class="line"> 第7章 显示系统 101 7.1 显示系统结构和移植内容 101 7.1.1 Donut及其之前显示系统的结构 102 7.1.2 Eclair及其之后显示系统的结构 102 7.1.3 移植的内容 103 7.2 移植和调试的要点 104 7.2.1 Framebuffer驱动程序 104 7.2.2 Donut及其之前的硬件抽象层 106 7.2.3 Eclair及其之后的硬件抽象层 107 7.3 显示部分模拟器的实现方式 112 7.3.1 Goldfish的framebuffer驱动程序 112 7.3.2 默认的Gralloc模块的实现 113 7.4 MSM中的实现 119 7.4.1 MSM的framebuffer驱动程序 119 7.4.2 MSM的Gralloc模块的实现 120 7.5 OMAP中的实现 126 7.5.1 OMAP的framebuffer驱动程序 126 7.5.2 OMAP的用户空间的实现 128</span><br><span class="line"></span><br><span class="line"> 第8章 用户输入系统 129 8.1 用户输入系统结构和移植内容 129 8.1.1 用户输入系统的结构 129 8.1.2 移植的内容 131 8.2 移植的要点 131 8.2.1 input驱动程序 131 8.2.2 用户空间的处理 134 8.2.3 移植需要注意的情况 139 8.3 模拟器中的实现 141 8.3.1 驱动程序 141 8.3.2 用户空间的配置文件 141 8.4 MSM中的实现 142 8.4.1 触摸屏，轨迹球和按键驱动程序 142 8.4.2 用户空间的配置文件 144 8.5 OMAP中的实现 144 8.5.1 触摸屏和键盘的驱动程序 144 8.5.2 用户空间的配置文件 146 8.6 虚拟按键的实现 146</span><br><span class="line"></span><br><span class="line"> 第9章 传感器系统 148 9.1 传感器系统结构和移植内容 148 9.1.1 传感器系统的结构 148 9.1.2 移植的内容 150 9.2 移植和调试的要点 150 9.2.1 驱动程序 150 9.2.2 硬件抽象层的内容 151 9.2.3 上层的情况和注意事项 153 9.3 模拟器中的实现 157</span><br><span class="line"></span><br><span class="line"> 第10章 音频系统 162 10.1 音频系统结构和移植内容 162 10.1.1 音频系统的结构 162 10.1.2 移植的内容 164 10.2 移植和调试的要点 164 10.2.1 Audio驱动程序 164 10.2.2 硬件抽象层的内容 164 10.2.3 Audio策略管理的内容 168 10.2.4 上层的情况和注意事项 169 10.3 通用的Audio系统实现 170 10.3.1 用桩实现的Audio硬件抽象层 172 10.3.2 提供Dump功能的Audio硬件抽象层 174 10.3.3 通用的Audio硬件抽象层 177 10.4 MSM系统的实现 178 10.4.1 Audio驱动程序 178 10.4.2 Audio硬件抽象层 180 10.5 基于OSS和ALSA的实现方式 183 10.5.1 OSS驱动程序 183 10.5.2 基于OSS的硬件抽象层 184 10.5.3 ALSA驱动程序 185 10.5.4 基于ALSA的硬件抽象层 186</span><br><span class="line"></span><br><span class="line"> 第11章 视频输出系统 190 11.1 视频输出系统结构和移植内容 190 11.1.1 视频输出系统的结构 191 11.1.2 移植的内容 192 11.2 移植和调试的要点 192 11.2.1 驱动程序 192 11.2.2 硬件抽象层的内容 192 11.2.3 上层的情况和注意实现 195 11.3 Overlay硬件抽象层实现的框架 199 11.4 OMAP系统的实现 200 11.4.1 OMAP的视频输出部分的驱动程序 200 11.4.2 OMAP Overlay 硬件抽象层 202</span><br><span class="line"></span><br><span class="line"> 第12章 照相机系统 205 12.1 照相机系统结构和移植内容 205 12.1.1 照相机系统的结构 206 12.1.2 移植的内容 207 12.2 移植和调试的要点 207 12.2.1 Video for 4Linux驱动程序 207 12.2.2 硬件抽象层的内容 210 12.2.3 上层的情况和注意事项 215 12.2.4 照相机系统的数据流情况 219 12.3 Camera硬件抽象层桩实现 222 12.4 MSM平台的Camera实现 226 12.4.1 MSM平台的Camera驱动程序 226 12.4.2 MSM平台的Camera硬件抽象层 227 12.5 OMAP平台的Camera实现 228 12.5.1 OMAP平台的Camera 驱动程序 228 12.5.2 OMAP平台的Camera硬件抽象层 229</span><br><span class="line"></span><br><span class="line"> 第13章 无线局域网系统 230 13.1 无线局域网系统结构和移植内容 230 13.1.1 无线局域网系统的结构 231 13.1.2 移植的内容 232 13.2 移植和调试的要点 232 13.2.1 协议和驱动程序 232 13.2.2 用户空间的内容 233 13.2.3 上层的情况和调试方法 233 13.3 OMAP系统的无线局域网实现 235 13.3.1 Linux内核中的内容 235 13.3.2 用户空间的实现 236</span><br><span class="line"></span><br><span class="line"> 第14章 蓝牙系统 238 14.1 蓝牙系统结构和移植内容 238 14.1.1 蓝牙系统的结构 239 14.1.2 移植的内容 240 14.2 移植和调试的要点 240 14.2.1 驱动程序 240 14.2.2 本地代码的配置部分 242 14.2.3 上层的情况和调试方法 244 14.3 MSM系统的蓝牙实现 245 14.3.1 驱动部分 245 14.3.2 用户空间的部分 247</span><br><span class="line"></span><br><span class="line"> 第15章 定位系统 248 15.1 定位系统的系统结构和移植内容 248 15.1.1 定位系统的系统结构 248 15.1.2 移植的内容 250 15.2 移植和调试的要点 250 15.2.1 驱动程序 250 15.2.2 硬件抽象层 251 15.2.3 上层的情况和调试方法 253 15.3 仿真器的GPS硬件适配层实现 256 15.4 MSM平台的GPS硬件适配层实现 257</span><br><span class="line"></span><br><span class="line"> 第16章 电话系统 260 16.1 电话系统结构和移植内容 260 16.1.1 电话系统的系统结构 260 16.1.2 移植的内容 262 16.2 移植和调试的要点 262 16.2.1 驱动程序 262 16.2.2 RIL实现库的接口 264 16.2.3 数据连接部分 266 16.2.4 调试方法 267 16.3 电话部分的RIL参考实现 268 16.3.1 端口初始化 268 16.3.2 AT命令处理流程 269 16.3.3 Event模块 270 16.3.4 Modem AT命令初始化 272 16.3.5 请求和响应流程的处理 272 16.3.6 特定命令类型的实现 274</span><br><span class="line"></span><br><span class="line"> 第17章 OpenGL 3D引擎 276 17.1 OpenGL系统结构和移植内容 276 17.1.1 OpenGL系统的结构 277 17.1.2 移植的内容 283 17.2 移植和调试的要点 283 17.2.1 OpenGL移植层的接口 283 17.2.2 上层的情况和OpenGL的调试 285 17.2 Android软件OpenGL的实现 288 17.3 不同系统中的实现 290</span><br><span class="line"></span><br><span class="line"> 第18章 OpenMax多媒体引擎 292 18.1 OpenMax系统结构和移植内容 292 18.1.1 OpenMax系统的结构 293 18.1.2 Android OpenMax实现的内容 297 18.2 OpenMax的接口与实现 297 18.2.1 OpenMax IL层的接口 297 18.2.2 OpenMax IL实现的内容 302 18.2.3 Android中OpenMax的适配层 302 18.3 OMAP平台OpenMax IL的硬件实现 304 18.3.1 TI OpenMax IL实现的结构和机制 304 18.3.2 TI OpenMax IL的核心和公共内容 306 18.3.3 一个TI OpenMax IL组件的实现 307</span><br><span class="line"></span><br><span class="line"> 第19章 多媒体系统的插件 310 19.1 Android多媒体相关结构与移植内容 310 19.1.1 多媒体处理过程 311 19.1.2 移植的内容 312 19.2 OpenCore引擎结构和插件 313 19.2.1 OpenCore的结构 313 19.2.2 OpenCore的Node插件机制 314 19.2.3 OpenMax部分的结构、实现和插件结构 316 19.2.4 关于媒体输入输出类MediaIO 322 19.2.5 OpenCore Player的视频显示部分插件 325 19.3 Stagefright引擎的结构和插件 326 19.3.1 Stagefright系统结构 326 19.3.2 Stagefright对Android中OpenMax接口的实现 328 19.3.3 MediaSource插件机制 328 19.3.4 OpenMax和VideoRenderer插件机制 330 19.4 OMAP平台实现的插件 332 19.4.1 OpenCore的OpenMax插件 333 19.4.2 OpenCore的视频输出插件 334 19.4.3 Stagefright的OpenMax和视频输出插件 336</span><br><span class="line"></span><br><span class="line"> 第20章 位块复制系统 339 20.1 位块复制结构和移植内容 339 20.1.1 位块复制系统的结构 339 20.1.2 移植内容 340 20.2 移植和调试的要点 340 20.2.1 驱动程序 340 20.2.2 硬件抽象层的内容 341 20.2.3 上层的情况和注意事项 342 20.3 MSM中的实现 343</span><br><span class="line"></span><br><span class="line"> 第21章 警报器——实时时钟系统 346 21.1 警报器——实时时钟结构和移植内容 346 21.1.1 警报器——实时时钟系统的结构 346 21.1.2 移植内容 347 21.2 移植与调试的要点 348 21.2.1 RTC驱动程序 348 21.2.2 Alarm驱动程序 349 21.2.3 上层的情况和注意事项 349 21.3 模拟器环境中的实现 351 21.4 MSM平台的实现 351</span><br><span class="line"></span><br><span class="line"> 第22章 光系统 354 22.1 光系统结构和移植内容 354 22.1.1 光系统部分的结构 354 22.1.2 移植内容 355 22.2 移植与调试的要点 356 22.2.1 驱动程序 356 22.2.2 硬件抽象层的内容 356 22.2.3 上层的情况和注意事项 357 22.3 MSM中的实现 359 22.3.1 驱动程序 359 22.3.2 硬件抽象层 359</span><br><span class="line"></span><br><span class="line"> 第23章 振动器系统 361 23.1 振动器系统结构和移植内容 361 23.1.1 振动器部分的结构 361 23.1.2 移植内容 362 23.2 移植与调试的要点 363 23.2.1 驱动程序 363 23.2.2 硬件抽象层的内容 363 23.2.3 上层的情况和注意事项 364 23.3 MSM中的实现 365</span><br><span class="line"></span><br><span class="line"> 第24章 电池系统 367 24.1 电池系统结构和移植内容 367 24.1.1 电池系统部分的结构 367 24.1.2 移植内容 368 24.2 移植和调试的要点 368 24.2.1 驱动程序 368 24.2.2 上层的情况和注意事项 369 24.3 模拟器中的实现 371</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B004J54TPO/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B004J54TPO&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51zDoC8QWwL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android多媒体编程从初学到精通</title>
    <url>/2020/04/19/B004WEFOYM/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android多媒体编程从初学到精通<br>作者信息： 作者: 苗忠良 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Android多媒体编程从初学到精通》内容翔实、分析深刻，是读者学习Anaroid多媒体编程不可多得的资料。从共享内存IPC通信、HAL、原生服务、JNI调用，以及多娱体的图像、音频、视频框架等多个层次和子系统着手深入讲解Android多媒体编程。涉及移动互联网、Android体系应用框架、OpenMAX多媒体框架、渲柔机制等多方面的内容。深入浅出，依靠深厚行业经验讲透技术原理循序渐进，详解典型应用案例提升实战能力</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 Android概述 1</span><br><span class="line">1.1 移动互联网 2</span><br><span class="line">1.1.1 “4C”融合 3</span><br><span class="line">1.1.2 物联网 4</span><br><span class="line">1.2 发展概况 4</span><br><span class="line">1.2.1 OHA联盟 5</span><br><span class="line">1.2.2 Android现状 6</span><br><span class="line">1.2.3 网络资源 7</span><br><span class="line">1.3 开发环境 8</span><br><span class="line">1.3.1 基于SDK的开发环境 8</span><br><span class="line">1.3.2 基于源代码的开发环境 12</span><br><span class="line">1.4 体系架构 12</span><br><span class="line">1.4.1 核心服务 13</span><br><span class="line">1.4.2 原生服务 15</span><br><span class="line">1.4.3 原生库 17</span><br><span class="line">1.4.4 运行时组件 18</span><br><span class="line">1.4.5 硬件抽象层 19</span><br><span class="line">1.4.6 Linux内核 19 </span><br><span class="line"></span><br><span class="line"> 第2章 Android基础 26 2.1 Hello World 27 2.2 应用框架 33 2.2.1 应用组件 33 2.2.2 Activity和Tasks 55 2.2.3 进程和线程 55 2.2.4 组件生命周期 56 2.3 启动过程 58 2.3.1 init.rc初始化脚本 59 2.3.2 服务管理器 65 2.3.3 Dalvik虚拟机 67 2.3.4 实时进程 71 2.4 进程间通信 77 2.4.1 ONC RPC远程调用 78 2.4.2 IBinder通信机制 79 2.5 交互过程 80 2.5.1 Java JNI原生接口 81 2.5.2 直接调用 81 2.5.3 原生服务调用 82 2.5.4 原生守护进程调用 82 2.6 性能优化 83 2.6.1 资源读取 83 2.6.2 DEX文件和APK加载 84 2.6.3 虚拟机和平台实现 86</span><br><span class="line"></span><br><span class="line"> 第3章 多核通信 88 3.1 共享内存 89 3.1.1 同步与互斥 89 3.1.2 SMD数据通信 90 3.1.3 SMSM状态通信 96 3.2 过程调用 98 3.2.1 RPC路由器 99 3.2.2 RPC管道 102</span><br><span class="line"></span><br><span class="line"> 第4章 多媒体框架 106 4.1 框架概述 107 4.2 OpenMAX接口规范 107 4.2.1 OpenMAX AL应用层 108 4.2.2 OpenMAX IL集成层 108 4.2.3 OpenMAX DL开发层 113 4.3 OpenCORE框架 113 4.3.1 内容策略管理 114 4.3.2 多媒体引擎 123 4.3.3 文件解析和组合 130 4.3.4 编解码器 133 4.3.5 OSCL底层移植 139 4.3.6 A&#x2F;V同步 143 4.4 Stagefright框架 145 4.5 元数据 147 4.5.1 色彩模式 147 4.5.2 脉冲调制 148</span><br><span class="line"></span><br><span class="line"> 第5章 图像框架 149 5.1 Camera拍照框架 150 5.1.1 Camera原生服务 150 5.1.2 Camera的HAL接口 156 5.1.3 Camera参数的设置 160 5.2 重要数据结构 162</span><br><span class="line"></span><br><span class="line"> 第6章 音频框架 164 6.1 音频管理框架 165 6.1.1 Audio Flinger 166 6.1.2 Audio Policy Service 177 6.2 音频编解码过程 180 6.2.1 AMR的编码过程 181 6.2.2 AMR的解码过程 188 6.2.3 MP3的解码过程 193</span><br><span class="line"></span><br><span class="line"> 第7章 视频框架 197 7.1 Camera录像框架 198 7.2 媒体播放服务 202 7.3 视频的编解码过程 205 7.3.1 视频的编码过程 206 7.3.2 视频的解码过程 209</span><br><span class="line"></span><br><span class="line"> 第8章 渲染机制 213 8.1 Surface Flinger管理器 214 8.1.1 Layer的四种模式 215 8.1.2 Surface渲染管理 220 8.2 Skia渲染 223 8.2.1 Skia图形渲染 224 8.2.2 Skia图像渲染 226 8.2.3 Skia UI控件 234 8.3 OpenGL ES渲染 235 8.4 硬件加速 238 8.4.1 Overlay 239 8.4.2 帧缓冲 240 8.4.3 MDP 242</span><br><span class="line"></span><br><span class="line"> 第9章 图像应用 243 9.1 基本接口 244 9.2 图像的处理 247 9.3 动画的处理 254</span><br><span class="line"></span><br><span class="line"> 第10章 音频应用 262 10.1 基本接口 263 10.2 Audio Manager 264 10.3 音频记录的处理 266 10.4 音频播放的处理 267 10.5 语音识别 277 10.6 SIP服务 281</span><br><span class="line"></span><br><span class="line"> 第11章 视频应用 286 11.1 视频记录 287 11.2 视频播放 290 跋 295 后记 298 参考文献 304</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B004WEFOYM/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B004WEFOYM&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51Mp934fBZL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android移动开发一本就够</title>
    <url>/2020/04/19/B0055ONY3G/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android移动开发一本就够<br>作者信息： 作者: Lauren Darcey [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Android移动开发一本就够》由Lauren Darcey、Schane Conder所著，在以开放手机联盟(Open HandsetAlliance，OHA)和Google公司为先驱的开拓下，Android作为一个热门、新潮、免费、开源的移动平台在无线通信领域引起了不小的波澜，而你手中的这本书正能够为软件开发团队提供设计、开发、测试、调试和发布Android应用程序的一系列指导。如果你是一位资深的移动开发人员，那么书中一些小提示和小技巧可以帮助你更好地利用Android的某些独特功能，从而更加顺利地完成整个开发过程；相反，如果你刚刚踏入移动开发领域，那么本书将为你提供所有需要掌握的知识和技能，从而帮助你平稳而顺利地从传统软件开发过渡到移动开发，尤其是过渡到其中最富有前景的新平台——Android。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目　录 </span><br><span class="line"></span><br><span class="line"> 第一部分　Android概览</span><br><span class="line"></span><br><span class="line"> 第1章　Android简介　2 1.1　移动软件开发简史　2 1.1.1　遥想当年　2 1.1.2　“砖头”　3 1.1.3　无线应用协议(WAP)　4 1.1.4　专用移动平台　6 1.2　开放手机联盟(OHA)　7 1.2.1　无线Google　8 1.2.2　成立开放手机联盟　8 1.2.3　制造商：设计Android手机　9 1.2.4　移动运营商：传播Android体验　9 1.2.5　内容提供商：开发Android应用程序　9 1.2.6　充分发挥Android的优势　10 1.3　Android平台的不同之处　10 1.3.1　Android：下一代平台　11 1.3.2　免费开放源代码　11 1.3.3　熟悉和廉价的开发工具　12 1.3.4　合理的开发人员学习曲线　12 1.3.5　强大的应用程序开发支持　12 1.3.6　丰富、安全的应用集成　13 1.3.7　无障碍发布　13 1.3.8　为应用程序提供的“自由市场”　13 1.3.9　新生并逐渐成长的平台　14 1.4　Android平台　14 1.4.1　Android的基本体系结构　14 1.4.2　安全与许可权限　16 1.4.3　开发Android应用程序　17 小结　18 参考资料和更多信息　18</span><br><span class="line"></span><br><span class="line"> 第2章　搭建你的Android开发环境　19 2.1　配置你的开发环境　19 2.1.1　配置操作系统以适应设备调试　20 2.1.2　配置Android硬件以供调试　20 2.1.3　升级Android SDK　20 2.1.4　Android软件开发包的问题　21 2.2　探索Android SDK　21 2.2.1　理解Android SDK许可协议　21 2.2.2　阅读Android SDK文档　22 2.2.3　探索Android应用程序框架　23 2.2.4　了解Android工具　24 2.2.5　探索Android示例应用程序　27 小结　28 参考资料和更多信息　28</span><br><span class="line"></span><br><span class="line"> 第3章　编写第一个Android应用程序　29 3.1　测试你的开发环境　29 3.1.1　在Eclipse工程中导入Snake应用程序　29 3.1.2　为Snake工程创建Android虚拟设备(AVD)　31 3.1.3　为Snake工程创建运行配置参数　31 3.1.4　在Android模拟器中运行Snake应用程序　32 3.2　构建你的第一个Android应用程序　33 3.2.1　创建和配置新的Android工程　33 3.2.2　Android应用程序的核心文件和目录　34 3.2.3　为新工程创建Android虚拟设备　35 3.2.4　为工程配置运行参数　35 3.2.5　在模拟器中运行Android应用程序　36 3.2.6　在模拟器中调试Android应用程序　37 3.2.7　为Android应用程序添加日志记录　39 3.2.8　为应用程序添加媒体支持　40 3.2.9　为应用程序添加位置服务(LBS)　42 3.2.10　在硬件上调试应用程序　43 小结　45 参考资料和更多信息　45</span><br><span class="line"></span><br><span class="line"> 第二部分　Android应用程序设计精髓</span><br><span class="line"></span><br><span class="line"> 第4章　剖析Android应用程序　48 4.1　掌握重要的Android术语　48 4.2　使用应用程序Context　48 4.3　使用Activity执行应用程序任务　49 4.3.1　Android Activity的生命周期　50 4.3.2　使用Intent管理Activity跳转　53 4.4　使用服务　56 4.5　接收和广播Intent　57 小结　57 参考资料和更多信息　58</span><br><span class="line"></span><br><span class="line"> 第5章　使用Android Manifest文件定义应用程序　59 5.1　配置Android Manifest文件　59 5.2　管理你的应用程序标识　63 5.2.1　为你的应用程序指定版本　63 5.2.2　给你的应用程序加上名称和图标　63 5.3　强制指定应用程序的系统需求　64 5.3.1　针对特定SDK版本　64 5.3.2　强制指定应用程序平台需求　66 5.3.3　使用外部库　67 5.4　注册Activity和其他应用程序组件　68 5.4.1　使用Intent过滤器为应用程序指派主入口点Activity　68 5.4.2　配置其他Intent过滤器　68 5.5　使用许可权限　69 5.5.1　注册应用程序所需的许可权限　69 5.5.2　注册应用程序授予其他应用程序的许可权限　70 5.6　探索Manifest文件的其他参数　71 小结　71 参考资料和更多信息　71</span><br><span class="line"></span><br><span class="line"> 第6章　管理应用程序资源　72 6.1　什么是资源　72 6.1.1　存储应用程序资源　72 6.1.2　理解资源目录的层级结构　72 6.1.3　资源的类型　73 6.1.4　存储不同的资源类型　74 6.1.5　使用程序访问资源　76 6.2　使用Eclipse设置简单资源　77 6.3　使用资源　79 6.3.1　使用String(字符串)资源　79 6.3.2　使用格式化的字符串资源　80 6.3.3　使用字符串数组　81 6.3.4　使用Boolean(布尔)资源　82 6.3.5　使用Integer(整型)资源　82 6.3.6　使用颜色　83 6.3.7　使用尺寸　83 6.3.8　使用简单Drawable资源　84 6.3.9　使用图像　85 6.3.10　使用动画　87 6.3.11　使用菜单　89 6.3.12　使用XML文件　90 6.3.13　使用原始文件　91 6.3.14　资源引用　91 6.3.15　使用布局(Layout)　92 6.3.16　使用样式(Style)　96 6.3.17　使用主题(Theme)　98 6.4　引用系统资源　98 小结　99 参考资料和更多信息　99</span><br><span class="line"></span><br><span class="line"> 第三部分　Android用户界面设计精髓</span><br><span class="line"></span><br><span class="line"> 第7章　探索用户界面屏幕元素　102 7.1　Android视图和布局简介　102 7.2　使用TextView显示文本　103 7.2.1　配置布局和尺寸　104 7.2.2　在文本中创建上下文链接　104 7.3　获取用户数据　105 7.3.1　使用EditText控件获取用户输入文本　106 7.3.2　使用Spinner控件为用户提供可选输入　109 7.4　使用按钮、多选框和单选组　110 7.4.1　使用基本按钮　110 7.4.2　使用多选框和开关(Toggle)按钮　111 7.4.3　使用RadioGroup和RadioButton　112 7.5　获取用户输入的日期和时间　114 7.6　使用指示器向用户显示数据　115 7.7　使用SeekBar调整进度　116 7.7.1　使用RatingBar显示评分数据　117 7.7.2　使用Chronometer显示时间推移　118 7.7.3　显示时间　119 7.8　为用户提供选项和上下文菜单　119 7.8.1　使用选项菜单　119 7.8.2　使用ContextMenu　121 7.9　处理用户事件　123 7.9.1　监听触摸模式状态改变　123 7.9.2　监听全屏幕上的事件　124 7.9.3　监听长时单击　124 7.9.4　监听焦点改变　125 7.10　使用对话框　126 7.10.1　探索不同类型的对话框　126 7.10.2　跟踪对话框的生命周期　127 7.10.3　使用自定义对话框　128 7.11　使用样式　128 7.12　使用主题　130 小结　131</span><br><span class="line"></span><br><span class="line"> 第8章　使用布局设计用户界面　132 8.1　创建Android用户界面　132 8.1.1　使用XML资源创建布局　132 8.1.2　使用代码创建布局　133 8.2　组织用户界面　135 8.3　使用内建的布局类　138 8.3.1　使用FrameLayout　140 8.3.2　使用LinearLayout　141 8.3.3　使用RelativeLayout　142 8.3.4　使用TableLayout　144 8.3.5　在屏幕上使用多布局　145 8.4　使用内建的View容器类　146 8.4.1　使用数据驱动容器　147 8.4.2　使用标签组织视图　150 8.4.3　添加滚动支持　152 8.4.4　探索其他视图容器　153 小结　154</span><br><span class="line"></span><br><span class="line"> 第9章　绘图与动画　155 9.1　屏幕绘图　155 9.2　使用文字　158 9.2.1　使用默认字体　158 9.2.2　使用自定义字体　159 9.2.3　测量文字所需的屏幕尺寸　160 9.3　使用位图　160 9.4　使用图形　161 9.4.1　用XML资源定义图形　161 9.4.2　使用程序定义图形　162 9.4.3　绘制各种图形　162 9.5　使用动画　167 9.5.1　使用逐帧动画　167 9.5.2　使用补间动画　168 小结　172</span><br><span class="line"></span><br><span class="line"> 第四部分　使用常用Android API</span><br><span class="line"></span><br><span class="line"> 第10章　使用Android数据和存储API　174 10.1　使用应用程序首选项　174 10.1.1　创建私有和共享首选项　174 10.1.2　搜索和读取首选项　175 10.1.3　新增、修改和删除首选项　175 10.1.4　使用Android文件系统查找首选项数据　176 10.2　使用文件和目录　177 10.2.1　探索Android应用程序目录　177 10.2.2　使用Android文件系统操作其他目录和文件　179 10.3　使用SQLite数据库存储结构化数据　180 10.3.1　创建SQLite数据库　181 10.3.2　创建、修改和删除数据库记录　183 10.3.3　在SQLite数据库中执行查询　185 10.3.4　关闭和删除SQLite数据库　189 10.3.5　设计持久数据库　189 10.3.6　向应用程序界面绑定数据　191 小结　195 参考资料和更多信息　195</span><br><span class="line"></span><br><span class="line"> 第11章　使用内容提供器在应用程序间共享数据　196 11.1　探索Android内容提供器　196 11.1.1　使用MediaStore内容提供器　196 11.1.2　使用CallLog内容提供器　198 11.1.3　使用浏览器(Browser)内容提供器　199 11.1.4　使用联系簿(Contacts)内容提供器　200 11.1.5　使用UserDictionary(用户词典)内容提供器　202 11.1.6　使用Settings内容提供器　202 11.2　修改内容提供器的数据　202 11.2.1　添加记录　203 11.2.2　修改记录　203 11.2.3　删除记录　204 11.3　使用内容提供器增强你的应用程序　204 11.4　实现内容提供器　208 11.4.1　实现内容提供器接口　209 11.4.2　定义数据URI　209 11.4.3　定义数据列　210 11.4.4　实现重要的内容提供器方法　210 11.4.5　更新Manifest文件　214 11.5　使用动态文件夹(Live Folder)　215 小结　217 参考资料和更多信息　217</span><br><span class="line"></span><br><span class="line"> 第12章　使用Android网络API　218 12.1　移动网络基础　218 12.2　访问因特网(HTTP)　218 12.2.1　从Web读取数据　219 12.2.2　使用HttpURLConnection　219 12.2.3　解析从网络获取的XML　220 12.2.4　异步操作　222 12.2.5　使用AsyncTask　222 12.2.6　使用线程进行网络访问　223 12.2.7　显示从网络资源获取的图像　224 12.2.8　获取Android网络状态　226 小结　227 参考资料和更多信息　227</span><br><span class="line"></span><br><span class="line"> 第13章　使用Android Web API　228 13.1　使用WebView浏览Web　228 13.1.1　设计带有WebView控件的布局　229 13.1.2　向WebView控件载入内容　229 13.1.3　为WebView控件添加功能　230 13.2　使用WebKit延伸Web应用　232 13.2.1　浏览WebKit API　232 13.2.2　扩展Android Web应用程序的功能　232 13.3　使用Flash　236 13.3.1　使用Flash应用程序　236 13.3.2　构建AIR应用程序　237 小结　237 参考资料和更多信息　237</span><br><span class="line"></span><br><span class="line"> 第14章　使用位置服务API　238 14.1　使用全球定位服务(GPS)　238 14.1.1　在你的应用程序中使用 GPS功能　238 14.1.2　查找你的位置　239 14.1.3　定位你的模拟器　240 14.2　位置地理编码　241 14.3　在地图上标注位置　243 14.3.1　地图标注内容　243 14.3.2　地图标注视图　244 14.3.3　获得调试API Key　245 14.3.4　拖曳地图视图　247 14.3.5　缩放地图视图　247 14.3.6　标记点　248 14.4　位置服务扩展应用　251 小结　252 参考资料和更多信息　252</span><br><span class="line"></span><br><span class="line"> 第15章　使用Android多媒体API　253 15.1　使用多媒体　253 15.2　使用静态图像　254 15.2.1　使用摄像头捕捉静态图像　254 15.2.2　配置摄像头模式　257 15.2.3　分享图像　258 15.2.4　将图像指定为壁纸　259 15.3　使用视频　259 15.3.1　录制视频　260 15.3.2　播放视频　261 15.4　使用音频　262 15.4.1　录制音频　262 15.4.2　播放音频　263 15.4.3　共享音频　264 15.4.4　搜索多媒体　264 15.4.5　使用铃音　265 小结　265 参考资料和更多信息　265</span><br><span class="line"></span><br><span class="line"> 第16章　使用Android电话API　266 16.1　使用电话功能　266 16.1.1　为获取手机状态信息取得许可权限　266 16.1.2　获取通话状态　267 16.1.3　请求获取服务信息　268 16.1.4　监控信号强度和数据连接速度　269 16.1.5　使用电话号码　269 16.2　使用短消息　270 16.2.1　获得发送和接收短消息的许可权限　270 16.2.2　发送短消息　270 16.2.3　接收短消息　272 16.3　拨打和接听电话　273 小结　275 参考资料和更多信息　275</span><br><span class="line"></span><br><span class="line"> 第17章　通过OpenGL ES使用Android 3D图形　276 17.1　使用OpenGL ES　276 17.1.1　在Android中使用OpenGL ES　276 17.1.2　保证设备兼容性　277 17.2　在Android SDK中使用OpenGL ES API　277 17.3　手工处理OpenGL ES任务　278 17.3.1　创建SurfaceView　278 17.3.2　启动OpenGL ES线程　279 17.3.3　初始化EGL　281 17.3.4　初始化GL　282 17.3.5　屏幕绘制　283 17.4　绘制3D物体　283 17.4.1　绘制顶点(Vertices)　283 17.4.2　为顶点着色　284 17.4.3　绘制更多复杂物体　285 17.4.4　照亮你的场景　286 17.4.5　为对象赋予材质　288 17.5　同Android视图和事件进行交互　289 17.5.1　允许OpenGL线程向应用程序线程发送信息　289 17.5.2　允许应用程序线程向OpenGL线程发送信息　290 17.6　清理OpenGL ES　291 17.7　使用GLSurfaceView　292 17.8　使用OpenGL ES 2.0　294 17.8.1　为OpenGL ES 2.0配置应用程序　295 17.8.2　获取OpenGL ES 2.0平面　295 小结　298 参考资料和更多信息　298</span><br><span class="line"></span><br><span class="line"> 第18章　使用Android NDK　299 18.1　何时使用Android NDK　299 18.2　安装Android NDK　300 18.3　探索Android NDK　300 18.4　创建自己的NDK工程　300 18.4.1　使用Java调用原生代码　301 18.4.2　处理参数和返回值　302 18.4.3　在原生代码中使用异常　303 18.5　提升图形处理性能　304 小结　305 参考资料和更多信息　305</span><br><span class="line"></span><br><span class="line"> 第19章　使用Android可选硬件API　306 19.1　与设备硬件进行交互　306 19.2　使用设备传感器　307 19.2.1　使用不同的传感器　307 19.2.2　获取对传感器的访问　307 19.2.3　读取传感器数据　308 19.2.4　校正传感器　309 19.2.5　确定设备的方向　309 19.2.6　指北　309 19.3　使用Wi-Fi　309 19.4　使用蓝牙　311 19.4.1　检查可用的蓝牙硬件　312 19.4.2　开启蓝牙　312 19.4.3　查询配对设备　313 19.4.4　搜索设备　313 19.4.5　建立设备间连接　313 19.5　监视电池　314 小结　316 参考资料和更多信息　316</span><br><span class="line"></span><br><span class="line"> 第五部分　更多Android应用程序设计原则</span><br><span class="line"></span><br><span class="line"> 第20章　使用通知　318 20.1　向用户发出通知　318 20.2　使用状态栏发布通知　319 20.2.1　使用NotificationManager服务　319 20.2.2　创建一个带有图标的简单文本通知　319 20.2.3　使用通知队列　320 20.2.4　更新通知　321 20.2.5　清除通知　321 20.3　让手机震动　322 20.4　灯光闪烁　323 20.5　发出声响　324 20.6　自定义通知　324 20.7　设计有用的通知　326 小结　326 参考资料和更多信息　326</span><br><span class="line"></span><br><span class="line"> 第21章　使用服务　327 21.1　何时使用服务　327 21.2　理解服务的生命周期　328 21.3　创建服务　328 21.4　控制服务　332 21.5　实现远程接口　333 21.6　实现可包装(Parcelable)类　335 小结　337 参考资料和更多信息　337</span><br><span class="line"></span><br><span class="line"> 第22章　扩展Android应用程序　338 22.1　增强你的应用程序　338 22.2　使用应用程序小插件　339 22.2.1　创建应用程序小插件　339 22.2.2　安装应用程序小插件　345 22.2.3　成为小插件“宿主(Host)”　345 22.3　使用动态壁纸(Live Wallpaper)　345 22.3.1　创建动态壁纸　346 22.3.2　安装动态壁纸　348 22.4　成为内容类型处理器(Content Type Handler)　349 22.5　确定Intent动作和MIME类型　350 22.5.1　实现Activity处理Intent　350 22.5.2　注册Intent过滤器　351 22.6　让应用程序的内容可搜索　352 22.6.1　在应用程序内启用搜索　353 22.6.2　启用全局搜索　358 22.7　使用动态文件夹　360 22.7.1　创建动态文件夹　360 22.7.2　安装动态文件夹　364 小结　365 参考资料和更多信息　365</span><br><span class="line"></span><br><span class="line"> 第23章　用户账户管理与数据同步　366 23.1　使用账户管理器管理账户　366 23.2　使用备份服务　367 23.2.1　选择远程备份服务　368 23.2.2　实现备份代理(Agent)　368 23.2.3　备份和恢复应用程序数据　371 小结　372 参考资料和更多信息　373</span><br><span class="line"></span><br><span class="line"> 第24章　处理高级用户输入　374 24.1　使用文本输入法　374 24.1.1　使用软键盘　374 24.1.2　使用文本预测和用户词典　376 24.2　探索辅助功能(Accessibility)框架　376 24.2.1　使用语音识别服务　377 24.2.2　使用语音合成(TTS)服务　378 24.3　使用手势　380 24.4　处理普通单点触控手势　381 24.4.1　处理普通多点触控手势　385 24.4.2　让手势更自然　388 24.5　使用轨迹球　388 24.6　处理屏幕方向改变　388 小结　390 参考资料和更多信息　390</span><br><span class="line"></span><br><span class="line"> 第25章　面向不同设备配置和语言　391 25.1　最大化应用程序兼容性　391 25.2　为兼容性设计用户界面　392 25.2.1　支持特定屏幕类型　393 25.2.2　使用九格拉伸图像　393 25.2.3　使用Working Square原理　395 25.3　提供应用程序替代资源　396 25.3.1　使用替代资源标识符　396 25.3.2　提供用于不同屏幕方向的资源　399 25.3.3　在程序中使用替代资源　400 25.3.4　高效地组织应用程序资源　400 25.4　应用程序国际化　401 25.4.1　使用替代资源实现国际化　401 25.4.2　在程序中实现本地化支持　404 25.5　面向不同设备配置　405 25.5.1　支持硬件配置　405 25.5.2　面向不同Android SDK版本　405 小结　407 参考资料和更多信息　408</span><br><span class="line"></span><br><span class="line"> 第六部分　对外发布你的Android应用程序 第26章　移动软件开发过程　410 26.1　移动开发过程概览　410 26.2　选择一种软件开发方法　410 26.2.1　理解“瀑布模型”的危险　411 26.2.2　认识迭代式开发的价值　411 26.3　整合应用程序需求　411 26.3.1　确定工程需求　411 26.3.2　为移动应用程序开发用例　413 26.3.3　吸纳第三方需求　413 26.3.4　管理设备数据库　413 26.4　项目风险评估　415 26.4.1　确定目标设备　415 26.4.2　获取目标设备　416 26.4.3　确定应用程序需求的可行性　417 26.4.4　理解质量保障的风险　417 26.5　编写基本项目文档　418 26.6　使用配置管理系统　419 26.7　设计移动应用程序　420 26.7.1　认识移动设备的局限　420 26.7.2　移动应用程序体系结构探索　420 26.7.3　可扩展和维护设计　421 26.7.4　应用程序交互设计　422 26.8　开发移动应用程序　422 26.9　测试移动应用程序　422 26.10　发布移动应用程序　423 26.11　支持和维护移动应用程序　423 小结　424 参考资料和更多信息　424</span><br><span class="line"></span><br><span class="line"> 第27章　设计和开发“防弹”Android应用程序　425 27.1 “防弹”移动应用程序设计最佳实践　425 27.1.1　满足移动用户的需求　425 27.1.2　为移动设备设计用户界面　426 27.1.3　设计稳定、灵敏的移动应用程序　426 27.1.4　设计安全的移动应用程序　427 27.1.5　在设计移动应用程序时考虑利益的最大化　428 27.1.6　在Android应用程序设计时使用第三方标准　428 27.1.7　设计便于维护和升级的移动应用程序　429 27.1.8　在应用程序设计中使用Andriod工具　430 27.1.9　避免设计时的愚蠢错误　430 27.2 “防弹”移动应用程序开发最佳实践　431 27.2.1　设计有效的移动开发过程　431 27.2.2　提早和经常地测试应用程序可行性　431 27.2.3　使用代码标准、代码检查和单元测试以提高代码质量　431 27.2.4　处理某单一设备的缺陷　433 27.2.5　在应用程序开发中使用Android工具　434 27.2.6　避免开发时的愚蠢错误　434 小结　434 参考资料和更多信息　434</span><br><span class="line"></span><br><span class="line"> 第28章　测试Android应用程序　435 28.1　设计一个应用程序漏洞跟踪系统　435 28.2　管理测试环境　436 28.3　尽量全面地进行测试　438 28.4　在应用程序测试中使用Android工具　442 28.5　避免测试时的愚蠢错误　443 28.6　外包测试的责任　443 小结　443 参考资料和更多信息　443</span><br><span class="line"></span><br><span class="line"> 第29章　销售你的Android应用程序　444 29.1　选择合适的发布模式　444 29.2　为发布而打包你的应用程序　444 29.2.1　准备封装你的代码　445 29.2.2　为你的应用程序打包并签名　446 29.2.3　测试软件包的发布版本　448 29.2.4　认证你的Android应用程序　448 29.3　发布你的应用程序　448 29.3.1　在Android Market上销售你的应用程序　448 29.3.2　在自己的服务器上销售你的应用程序　453 29.3.3　销售应用程序的其他途径　453 29.3.4　保护你的知识产权　454 29.3.5　让用户付费　454 小结　455 参考资料和更多信息　455</span><br><span class="line"></span><br><span class="line"> 第七部分　附录</span><br><span class="line"></span><br><span class="line"> 附录A　Android模拟器快速入门　458 A.1　模拟器的目的：虚拟现实　458 A.2　使用Android虚拟设备(AVD)　459 A.2.1　使用Android SDK和AVD管理器　460 A.2.2　创建AVD　460 A.3　使用指定AVD启动模拟器　463 A.3.1　配置模拟器启动项　463 A.3.2　启动模拟器运行应用程序　463 A.3.3　从Android SDK和AVD管理器中启动模拟器　464 A.4　配置模拟器的GPS位置信息　465 A.5　在两个模拟器实例之间拨打电话　466 A.6　在两个模拟器实例之间发送消息　466 A.7　通过控制台与模拟器交互　467 A.7.1　使用控制台模拟来电　467 A.7.2　使用控制台模拟短消息　468 A.7.3　使用控制台发送GPS坐标　468 A.7.4　使用控制台监视网络状态　469 A.7.5　使用控制台操作电源设置　469 A.7.6　使用其他控制台命令　470 A.8　享受模拟器　470 A.9　认识模拟器的局限　470</span><br><span class="line"></span><br><span class="line"> 附录B　Android DDMS快速入门　471 B.1　独立或结合Eclipse使用DDMS　471 B.2　熟悉DDMS的关键特性　472 B.3　使用进程　472 B.3.1　向Android应用程序关联调试器　473 B.3.2　监视Android应用程序的线程活动　473 B.3.3　触发垃圾回收(GC)　474 B.3.4　监视堆活动　474 B.3.5　监视内存分配　474 B.3.6　终止Android进程　475 B.4　使用文件浏览器　475 B.4.1　浏览模拟器或设备上的文件系统　475 B.4.2　从模拟器或设备上拷贝文件　476 B.4.3　向模拟器或设备拷贝文件　476 B.4.4　删除模拟器或设备上的文件　476 B.5　使用模拟器控制　476 B.5.1　模拟语音来电　476 B.5.2　模拟短消息接收　477 B.5.3　发送位置坐标　477 B.6　使用应用程序日志　477 B.7　在模拟器或目标设备上截屏　478</span><br><span class="line"></span><br><span class="line"> 附录C　Android调试桥快速入门　479 C.1　列表显示连接的设备和模拟器　479 C.2　针对特定设备使用ADB命令　479 C.3　启动和停止ADB服务进程　480 C.3.1　停止ADB服务进程　480 C.3.2　启动和检测ADB服务进程　480 C.4　发布Shell命令　480 C.4.1　发布单条Shell命令　480 C.4.2　使用Shell会话　481 C.4.3　使用Shell启动和终止模拟器　481 C.5　拷贝文件　481 C.5.1　向设备或模拟器发送文件　481 C.5.2　从设备提取文件　481 C.6　安装和卸载Android应用程序　482 C.6.1　安装应用程序　482 C.6.2　重装应用程序　482 C.6.3　卸载应用程序　482 C.7　使用LogCat记录日志　483 C.7.1　显示所有的日志信息　483 C.7.2　在日志数据中包含日期和时间信息　483 C.7.3　过滤日志信息　483 C.7.4　清除日志　484 C.7.5　将日志输出重定向至一个文件　484 C.7.6　访问次级日志　485 C.8　控制备份服务　485 C.8.1　强制备份操作　485 C.8.2　强制恢复操作　486 C.8.3　将存档数据清空　486 C.9　生成Bug报告　486 C.10　使用Shell查看SQLite数据库　486 C.10.1　在ADB Shell中进行应用程序压力测试　486 C.10.2　通过Shell安装和使用自定义二进制文件　489 C.11　其他ADB命令探索　490</span><br><span class="line"></span><br><span class="line"> 附录D　Eclipse技巧和诀窍　491 D.1　构建你的Eclipse工作空间　491 D.1.1　集成源代码管理服务　491 D.1.2　调整视图中的标签面板　491 D.1.3　最大化窗口　492 D.1.4　最小化窗口　492 D.1.5　显示并排窗口　492 D.1.6　显示同一文件的两个部分　492 D.1.7　关掉不需要的标签面板　492 D.1.8　保持对窗口的控制　492 D.1.9　定制日志过滤器　493 D.2　编写Java代码　493 D.2.1　善用自动补全(Auto-Complete)　493 D.2.2　格式化代码　493 D.2.3　创建类　494 D.2.4　创建方法存根(stub)　494 D.2.5　组织导入　494 D.2.6　重命名　494 D.2.7　重构代码　494 D.2.8　整理代码　496 D.2.9　提供Javadoc风格的文件　496 D.2.10　解决诡异的构建错误　496</span><br><span class="line"></span><br><span class="line"> 附录E　SQLite快速入门　497 E.1　探索SQLite的常见任务　497 E.2　使用sqlite3命令行接口　497 E.2.1　运行ADB Shell　498 E.2.2　连接数据库　498 E.2.3　探索你的数据库　498 E.2.4　导入和导出数据库　499 E.2.5　在命令行中执行SQL命令　501 E.2.6　使用其他的sqlite3命令　502 E.2.7　认识SQLite的局限　502 E.3　通过实例学习：学生成绩数据库　503 E.3.1　设计学生成绩数据库的模式　503 E.3.2　结合AUTOINCREMENT创建简单表　503 E.3.3　向表中插入数据　504 E.3.4　使用SELECT查询表数据　504 E.3.5　创建具有外键和复合主键的表　505 E.3.6　修改和更新表数据　506 E.3.7　使用JOIN进行多表查询　506 E.3.8　使用计算列　507 E.3.9　对计算列使用子查询　508 E.3.10　删除表　508</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0055ONY3G/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0055ONY3G&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41N6ZsVUqeL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言参考手册(原书第5版)</title>
    <url>/2020/04/19/B0056E8U3Y/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C语言参考手册(原书第5版)<br>作者信息： 作者: 徐波 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《C语言参考手册(原书第5版)》是一本C语言的权威参考手册，对C语言的基本概念和运行函数库提供了完整的描述，并强调了以正确性、可移性和可维护性为基本出发点的良好编程风格。《C语言参考手册(原书第5版)》对C语言描述比其他任何书籍都要更加清晰和详细。《C语言参考手册(原书第5版)》涵盖的内容包括：标准C（1999）：新版本的C标准支持复数型和布尔类型、可变长度数组、精确浮点编程以及为可移植性国际化所提供的新函数库。标准C（1989）：当今大部分C程序员所使用的C语言版本。传统C：1990年以前人们所使用的C语言。目前仍有数以百万行计的传统C代码还在使用中。C++和C的兼容：可以同时用于C和C++的代码。适用于所有C语言版本的C运行时函数库。《C语言参考手册(原书第5版)》对C的所有细节都进行了描述，是C语言编程人员和编译器实现者必备的参考手册。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">译者序</span><br><span class="line">前 言</span><br><span class="line">第一部分 c语言</span><br><span class="line">第1章 概述</span><br><span class="line">1.1 c语言的演变</span><br><span class="line">1.1.1 传统c</span><br><span class="line">1.1.2 标准c（1989）</span><br><span class="line">1.1.3 标准c（1995）</span><br><span class="line">1.1.4 标准c（1999）</span><br><span class="line">1.1.5 标准c++</span><br><span class="line">1.1.6 《c语言参考手册（原书第5版）》内容</span><br><span class="line">1.2 应该使用哪种c语言</span><br><span class="line">1.3 c编程概述</span><br><span class="line">1.4 一致性</span><br><span class="line">1.5 语法约定 </span><br><span class="line"></span><br><span class="line"> 第2章 词法元素 2.1 字符集 2.1.1 执行字符集 2.1.2 空白字符和行终止符 2.1.3 字符编码 2.1.4 三字符组 2.1.5 多字节字符和宽字符 2.2 注释 2.3 标记 2.4 操作符和分隔符 2.5 标识符 2.6 关键字 2.7 常量 2.7.1 整数常量 2.7.2 浮点数常量 2.7.3 字符常量 2.7.4 字符串常量 2.7.5 转义字符 2.7.6 字符转义码 2.7.7 数值转义码 2.8 c++兼容性 2.8.1 字符集 2.8.2 注释 2.8.3 操作符 2.8.4 标识符和关键字 2.8.5 字符常量 2.9 关于字符集、指令集和编码 2.10 练习</span><br><span class="line"></span><br><span class="line"> 第3章 c预处理器 3.1 预处理器命令 3.2 预处理器词法约定 3.3 定义和替换 3.3.1 类似对象的宏定义 3.3.2 定义带参数的宏 3.3.3 宏表达式的重新扫描 3.3.4 预定义的宏 3.3.5 取消宏定义和重新定义宏 3.3.6 宏展开的优先级错误 3.3.7 宏参数的副作用 3.3.8 把标记转换为字符串 3.3.9 宏展开中的标记合并 3.3.10 宏的可变参数列表 3.3.11 其他问题 3.4 文件包含 3.5 条件编译 3.5.1 #if、#else和#endif命令 3.5.2 #elif命令 3.5.3 #ifdef和#ifndef命令 3.5.4 条件命令中的常量表达式 3.5.5 defined操作符 3.6 显式的行号 3.7 pragma指令 3.7.1 标准pragma命令 3.7.2 标准pragma指令的位置 3.7.3 pragma操作符 3.8 错误指令 3.9 c++兼容性 3.10 练习</span><br><span class="line"></span><br><span class="line"> 第4章 声明 第5章 类型 第6章 转换和表示形式 第7章 表达式 第8章 语句 第9章 函数</span><br><span class="line"></span><br><span class="line"> 第二部分 c函数库 第10章 函数库简介 第11章 标准语言附加 第12章 字符处理 第13章 字符串处理 第14章 内存函数 第15章 输入&#x2F;输出工具 第16章 基本工具 第17章 数学函数 第18章 时间和日期函数 第19章 控制函数 第20章 区域 第21章 扩展整数类型 第22章 浮点环境 第23章 复数运算 第24章 宽字符和多字节字符工具 附录a ascii字符集 附录b 语法 附录c 练习答案</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0056E8U3Y/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0056E8U3Y&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51b2BUOabhL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发权威指南</title>
    <url>/2020/04/19/B005IUTCQ0/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android开发权威指南<br>作者信息： 作者: 李宁 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Android开发权威指南》内容全面，不仅详细讲解了Android框架、Android控件、用户界面开发、游戏开发、数据存储和网络开发等，还深入阐述了传感器、语音识别、桌面组件开发、多媒体开发、OpenGL ES、HTML5、Android NDK编程、Android平台测试等高级知识。《Android开发权威指南》注重对实际动手能力的指导，在容易产生错误、不易理解的环节都配以了详实的开发情景截图，并将重要的知识点、开发技巧以“多学一招”、“扩展学习”、“技巧点拨”等活泼的形式呈现给读者。体现创新的6大综合案例，如新浪微博客户端、蓝牙聊天、全键盘输入弦、月球登陆游戏、贪吃蛇游戏、笑脸连连看游戏。6大完整综合案例：新浪微博客户端、蓝牙聊天、全键盘输入法、月球登陆游戏、贪吃蛇游戏、笑脸连连看游戏。《Android开发权威指南》基于最新的Android 2．3 SDK。分析常用控件和API的源代码，帮助读者更深入地了解其内部实现原理。超过200个例子、50000行代码。大多数实例稍加改动就可用于实际的项目中。开发视频讲解光盘，帮助读者快速、无障碍地学通Android实战开发。从事一线开发的作者提供微博、博客等在线答疑。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分 准备篇</span><br><span class="line">第1章 初识庐山真面目——Android开发简介 2</span><br><span class="line">1.1 Android的基本概念 2</span><br><span class="line">1.1.1 Android简介 2</span><br><span class="line">1.1.2 Android的版本 4</span><br><span class="line">1.1.3 Android的系统构架 5</span><br><span class="line">1.1.4 Android的应用程序框架 6</span><br><span class="line">1.2 JIL Widget介绍 7</span><br><span class="line">1.3 小结 8 </span><br><span class="line"></span><br><span class="line"> 第2章 工欲善其事，必先利其器——搭建和使用Android开发环境 9 2.1 开发包及工具的安装 9 2.1.1 开发Android程序都需要些什么 9 2.1.2 安装JDK和配置Java开发环境 10 2.1.3 Eclipse的安装与汉化 11 2.1.4 安装AndroidSDK 12 2.1.5 安装Eclipse插件ADT 13 2.2 真实体验——编写第一个Android程序(随机绘制圆饼) 15 2.2.1 创建Android工程 15 2.2.2 在模拟器中运行Android程序 17 2.2.3 界面控件的布局 19 2.2.4 编写代码 20 2.2.5 调试程序 23 2.2.6 在手机上运行和调试程序 28 2.3 迁移Android工程可能发生的错误 29 2.4 不需要写一行代码的开发工具：AppInventor 31 2.4.1 AppInventor简介 31 2.4.2 AppIntentor的下载和安装 31 2.4.3 用拖曳控件的方式设计界面 33 2.4.4 像拼图一样拼装代码 34 2.5 小结 37</span><br><span class="line"></span><br><span class="line"> 第二部分 基础篇 第3章 千里之行始于足下——Android程序设计基础 40 3.1 Android应用程序框架 40 3.1.1 Android项目的目录结构 40 3.1.2 AndroidManifest.xml文件的结构 42 3.2 Android应用程序中的资源 44 3.3 Android的应用程序组件 44 3.3.1 Activity(Android的窗体) 45 3.3.2 Service(服务) 45 3.3.3 Broadcast Receiver(广播接收器) 45 3.3.4 Content Provider(内容提供者) 46 3.4 Android程序的UI设计 46 3.4.1 手工配置XML布局文件 46 3.4.2 ADT自带的可视化UI设计器 47 3.4.3 使用DroidDraw设计UI布局 47 3.5 小结 48</span><br><span class="line"></span><br><span class="line"> 第4章 我的UI我做主——用户界面开发基础 49 4.1 Activity的使用方法 49 4.1.1 创建Activity 49 4.1.2 配置Activity 50 4.1.3 显示其他的Activity(Intent与Activity) 52 4.2 Activity的生命周期 55 4.3 在不同Activity之间传递数据 60 4.3.1 使用Intent传递数据 60 4.3.2 使用静态变量传递数据 62 4.3.3 使用剪切板传递数据 63 4.3.4 使用全局对象传递数据 65 4.3.5 返回数据到前一个Activity 67 4.4 视图(View) 68 4.4.1 视图简介 68 4.4.2 使用XML布局文件定义视图 69 4.4.3 在代码中控制视图 70 4.5 布局(Layout) 72 4.5.1 框架布局(FrameLayout) 72 4.5.2 线性布局(LinearLayout) 75 4.5.3 相对布局(RelativeLayout) 79 4.5.4 表格布局(TableLayout) 81 4.5.5 绝对布局(AbsoluteLayout) 82 4.5.6 重用XML布局文件 82 4.5.7 优化XML布局文件 85 4.5.8 查看apk文件中的布局 86 4.6 小结 87</span><br><span class="line"></span><br><span class="line"> 第5章 良好的学习开端——控件(Widget)详解 88 5.1 常用XML属性解析 88 5.1.1 android:id属性 88 5.1.2 控件的宽度(android:layout_width)和高度(android:layout_height) 88 5.1.3 android:layout_margin属性 89 5.1.4 android:padding属性 89 5.1.5 android:layout_weight属性 90 5.1.6 android:layout_gravity和android:gravity属性 90 5.1.7 android:visibility属性 91 5.1.8 android:background属性 91 5.1.9 指定单击事件方法(android:onClick属性) 92 5.1.10 控件焦点属性(android:focusable和android:focusable-InTouchMode) 92 5.2 TextView(显示文本的控件) 93 5.2.1 显示富文本(URL、不同大小、字体、颜色的文本) 93 5.2.2 在TextView中显示表情图像和文字 97 5.2.3 单击链接弹出Activity 100 5.2.4 为指定文本添加背景 103 5.2.5 带边框的TextView 106 5.2.6 设置行间距 110 5.2.7 在未显示完的文本后面加省略号(…) 111 5.2.8 用TextView实现走马灯效果 113 5.2.9 垂直滚动TextView中的文本 114 5.3 EditText(编辑文本的控件) 115 5.3.1 像QQ一样输入表情图像 115 5.3.2 在EditText中输入特定的字符 117 5.3.3 AutoCompleteText-View(自动完成输入内容的控件) 118 5.4 按钮和复选框控件 120 5.4.1 Button(普通按钮控件) 120 5.4.2 图文混排的按钮 122 5.4.3 ImageButton(图像按钮控件) 124 5.4.4 RadioButton(选项按钮控件) 124 5.4.5 ToggleButton(开关状态按钮控件) 125 5.4.6 CheckBox(复选框控件) 126 5.5 ImageView(显示图像的控件) 128 5.5.1 ImageView控件的基本用法 128 5.5.2 显示指定区域的图像 129 5.5.3 缩放和旋转图像 132 5.6 时间与日期控件 133 5.6.1 DatePicker(输入日期的控件) 133 5.6.2 TimePicker(输入时间的控件) 134 5.6.3 DatePicker、TimePicker与TextView同步显示日期和时间 134 5.6.4 AnalogClock和DigitalClock(显示时钟的控件) 136 5.7 进度条控件 137 5.7.1 ProgressBar(进度条控件) 137 5.7.2 SeekBar(拖动条控件) 139 5.7.3 设置ProgressBar和SeekBar的颜色及背景图 140 5.7.4 RatingBar(评分控件) 143 5.8 列表控件 145 5.8.1 ListView(普通列表控件) 145 5.8.2 为ListView列表项添加复选框和选项按钮 147 5.8.3 对列表项进行增、删、改操作 149 5.8.4 改变列表项的背景色 153 5.8.5 ListActivity(封装ListView的Activity) 154 5.8.6 ExpandableListView(可扩展的列表控件) 155 5.8.7 Spinner(下拉列表控件) 157 5.9 滚动控件 160 5.9.1 ScrollView(垂直滚动控件) 160 5.9.2 HorizontalScrollView(水平滚动控件) 161 5.9.3 可垂直和水平滚动的视图 162 5.9.4 Gallery(画廊控件) 163 5.10 ImageSwitcher(图像切换控件) 164 5.11 GridView(网格控件) 166 5.12 TabHost(标签控件) 168 5.13 ViewStub(惰性装载控件) 169 5.14 小结 171</span><br><span class="line"></span><br><span class="line"> 第6章 友好的菜单——Menu介绍与实例 172 6.1 菜单的基本用法 172 6.1.1 创建选项菜单(Options Menu) 172 6.1.2 带图像的选项菜单 173 6.1.3 关联Activity 173 6.1.4 响应菜单的单击动作 174 6.1.5 动态添加、修改和删除选项菜单 175 6.1.6 带复选框和选项按钮的子菜单 176 6.1.7 上下文菜单 178 6.1.8 菜单事件 179 6.1.9 从菜单资源中装载菜单 180 6.2 菜单特效 181 6.2.1 自定义菜单 181 6.2.2 模拟UCWeb效果菜单 184 6.2.3 QuickContactBadge与联系人菜单 189 6.3 小结 192</span><br><span class="line"></span><br><span class="line"> 第7章 友好地互动交流——信息提醒(对话框、Toast与Notification) 193 7.1 对话框的基本用法 193 7.1.1 带2个按钮(确认&#x2F;取消)的对话框 193 7.1.2 带3个按钮(覆盖&#x2F;忽略&#x2F;取消)的对话框 195 7.1.3 简单列表对话框 196 7.1.4 单选列表对话框 198 7.1.5 多选列表对话框 199 7.1.6 进度对话框 201 7.1.7 登录对话框 205 7.1.8 使用Activity托管对话框 207 7.2 对话框的高级应用 209 7.2.1 阻止单击按钮关闭对话框 209 7.2.2 改变对话框的显示位置 213 7.2.3 在对话框按钮和内容文本中插入图像 215 7.2.4 改变对话框的透明度 216 7.3 Toast 217 7.3.1 Toast的基本用法 217 7.3.2 永不关闭的Toast 218 7.3.3 用PopupWindow模拟Toast提示信息框 221 7.4 通知(Notification) 221 7.4.1 在状态栏上显示通知信息 222 7.4.2 Notification的清除动作 224 7.4.3 永久存在的Notification 225 7.4.4 自定义Notification 226 7.5 小结 227</span><br><span class="line"></span><br><span class="line"> 第8章 移动的信息仓库——数据存储 228 8.1 读写key-value对：SharedPreferences 228 8.1.1 SharedPreferences的基本用法 228 8.1.2 数据的存储位置和格式 229 8.1.3 存取复杂类型的数据 230 8.1.4 设置数据文件的访问权限 233 8.1.5 可以保存设置的Activity：PreferenceActivity 234 8.2 文件存储 238 8.2.1 openFileOutput和openFileInput方法 238 8.2.2 读写SD卡中的文件 239 8.2.3 SAX引擎读取XML文件的原理 241 8.2.4 将XML文件转换成Java对象 242 8.2.5 文件压缩(Jar、Zip) 245 8.3 SQLite数据库 249 8.3.1 SQLite数据库管理工具 249 8.3.2 SQLiteOpenHelper类与自动升级数据库 251 8.3.3 数据绑定与SimpleCursorAdapter类 252 8.3.4 操作SD卡上的数据库 255 8.3.5 将数据库与应用程序一起发布 256 8.3.6 内存数据库 257 8.4 小结 258</span><br><span class="line"></span><br><span class="line"> 第9章 Android中的窗口——Activity 259 9.1 调用其他程序中的Activity 259 9.1.1 直接拨号 259 9.1.2 将电话号传入拨号程序 259 9.1.3 调用拨号程序 260 9.1.4 浏览网页 261 9.1.5 向E-mail客户端传递E-mail地址 261 9.1.6 发送E-mail 261 9.1.7 查看联系人 262 9.1.8 显示系统设置界面(设置主界面、Wifi设置界面) 263 9.1.9 启动处理音频的程序 264 9.2 自定义Activity Action 264 9.3 Activity的高级应用 266 9.3.1 ActivityGroup 266 9.3.2 自定义半透明窗口 268 9.3.3 Activity之间切换的动画效果 269 9.4 小结 270</span><br><span class="line"></span><br><span class="line"> 第10章 全局事件——广播(Broadcast) 271 10.1 什么是广播 271 10.2 接收系统广播 272 10.2.1 短信拦截 272 10.2.2 用代码注册广播接收器 274 10.2.3 广播接收器的优先级 275 10.2.4 来去电拦截 276 10.2.5 截获屏幕休眠与唤醒 280 10.2.6 开机自动运行 281 10.2.7 显示手机电池的当前电量 282 10.3 发送广播 284 10.4 验证广播接收器是否注册 285 10.5 小结 286</span><br><span class="line"></span><br><span class="line"> 第11章 跨应用数据源——Content Provider 287 11.1 Content Provider的作用 287 11.2 获得系统数据 288 11.2.1 读取联系人信息 288 11.2.2 查看收到的短信 290 11.3 自定义Content Provider 291 11.3.1 查询城市信息 291 11.3.2 为Content Provider添加访问权限 297 11.4 小结 298</span><br><span class="line"></span><br><span class="line"> 第12章 一切为用户服务——Service基础与实例 299 12.1 Service基础 299 12.1.1 Service的生命周期 299 12.1.2 绑定Activity和Service 302 12.1.3 开机启动Service 305 12.1.4 判断Service是否已注册 306 12.1.5 判断Service是否已开始 307 12.2 跨进程访问(AIDL服务) 308 12.2.1 什么是AIDL服务 308 12.2.2 建立AIDL服务的步骤 308 12.2.3 建立AIDL服务 308 12.2.4 传递复杂数据的AIDL服务 312 12.2.5 AIDL与来去电自动挂断 317 12.3 小结 319</span><br><span class="line"></span><br><span class="line"> 第13章 做好应用桥梁——网络与通信 320 13.1 WebView控件 320 13.1.1 用WebView控件浏览网页 320 13.1.2 用WebView控件装载HTML代码 322 13.2 访问HTTP资源 324 13.2.1 提交HTTP GET和HTTP POST请求 324 13.2.2 HttpURLConnection类 326 13.2.3 上传文件 327 13.3 客户端Socket 330 13.3.1 连接服务器 331 13.3.2 扫描服务器打开的端口 331 13.3.3 发送和接收数据 333 13.3.4 获得无线路由分配给手机的IP地址 334 13.3.5 设置Socket选项 335 13.4 服务端Socket 339 13.4.1 手机服务器的实现 339 13.4.2 利用Socket在应用程序之间通信 340 13.5 蓝牙通信 342 13.5.1 蓝牙简介 342 13.5.2 打开和关闭蓝牙设备 343 13.5.3 搜索蓝牙设备 344 13.5.4 蓝牙数据传输 346 13.6 小结 351</span><br><span class="line"></span><br><span class="line"> 第14章 炫酷你的应用——多媒体开发 352 14.1 音乐 352 14.1.1 播放音乐 352 14.1.2 录音 353 14.2 视频 354 14.2.1 使用VideoView播放视频 354 14.2.2 使用SurfaceView播放视频 355 14.2.3 录制视频 357 14.3 相机 357 14.3.1 调用系统的拍照功能 358 14.3.2 自定义拍照功能 359 14.4 铃声 364 14.5 小结 366</span><br><span class="line"></span><br><span class="line"> 第15章 2D游戏开发 367 15.1 绘制游戏的画布 367 15.1.1 在View上实现动画效果 367 15.1.2 在SurfaceView上实现动画效果 371 15.2 图形绘制基础 374 15.2.1 绘制像素点 374 15.2.2 绘制直线 374 15.2.3 绘制圆形 375 15.2.4 绘制弧 375 15.2.5 绘制文本 376 15.2.6 综合绘制各种图形 376 15.3 高级图像处理技术 380 15.3.1 绘制位图 380 15.3.2 图像的透明度 382 15.3.3 旋转图像 383 15.3.4 路径 384 15.3.5 Shader的渲染效果 388 15.4 帧(Frame)动画 392 15.4.1 AnimationDrawable与帧动画 392 15.4.2 播放Gif动画 394 15.5 补间(Tween)动画 397 15.5.1 移动补间动画 397 15.5.2 缩放补间动画 399 15.5.3 旋转补间动画 402 15.5.4 透明度补间动画 403 15.6 小结 404</span><br><span class="line"></span><br><span class="line"> 第16章 有趣的Android应用 405 16.1 传感器 405 16.1.1 如何使用传感器 405 16.1.2 加速度传感器(Accelerometer) 409 16.1.3 重力传感器(Gravity) 409 16.1.4 光线传感器(Light) 410 16.1.5 陀螺仪传感器(Gyroscope) 411 16.1.6 方向传感器(Orientation) 411 16.1.7 其他传感器 412 16.2 输入输出技术 413 16.2.1 语音识别 413 16.2.2 手势输入 415 16.2.3 语音朗读(TTS) 417 16.3 Google地图 419 16.4 GPS定位 423 16.5 桌面上的小东西 425 16.5.1 窗口小部件(AppWidget) 425 16.5.2 快捷方式 431 16.5.3 实时文件夹 433 16.6 应用更华丽——动态壁纸 435 16.7 小结 441</span><br><span class="line"></span><br><span class="line"> 第三部分 高级篇 第17章 HTML5与移动Web开发 444 17.1 HTML5简介 444 17.2 HTML5精彩效果演示 445 17.3 HTML5在Android中的应用 447 17.4 HTML5的画布(Canvas) 448 17.4.1 Canvas概述 448 17.4.2 检测浏览器是否支持Canvas 449 17.4.3 在Web页面中使用Canvas 450 17.4.4 使用路径(Path) 452 17.4.5 设置线条风格 453 17.4.6 设置填充类型 453 17.4.7 填充矩形区域 454 17.4.8 使用渐变色(Gradient) 454 17.4.9 拉伸画布对象 455 17.4.10 在Canvas上绘制文本 456 17.4.11 使用阴影 457 17.5 调试JavaScript 458 17.6 小结 459</span><br><span class="line"></span><br><span class="line"> 第18章 输入法开发 460 18.1 Android输入法简介 460 18.2 控制输入法 461 18.3 输入法实战 462 18.3.1 实现输入法的步骤 463 18.3.2 编写输入法程序 463 18.3.3 输入法服务的生命周期 466 18.3.4 预输入文本 467 18.3.5 输入法设置 467 18.4 小结 468</span><br><span class="line"></span><br><span class="line"> 第19章 Android OpenGL ES开发基础 469 19.1 OpenGL简介 469 19.2 什么是OpenGL ES 469 19.3 多边形 470 19.4 颜色 474 19.5 旋转三角形 475 19.6 旋转立方体 477 19.7 小结 478</span><br><span class="line"></span><br><span class="line"> 第20章 OpenGL ES的超酷效果 479 20.1 保持平衡的旋转文本 479 20.2 左右摇摆的Android机器人 482 20.3 纠缠在一起的旋转立方体 485 20.4 透明背景的旋转立方体 486 20.5 触摸旋转的立方体 487 20.6 2D和3D的综合旋转效果 489 20.7 旋转立体天空 491 20.8 小结 493</span><br><span class="line"></span><br><span class="line"> 第21章 Android NDK编程 494 21.1 Android NDK简介 494 21.2 安装、配置和测试NDK开发环境 495 21.2.1 系统和软件要求 495 21.2.2 下载和安装Android NDK 495 21.2.3 下载和安装Cygwin 495 21.2.4 配置Android NDK的开发环境 498 21.3 第一个NDK程序：世界你好 499 21.3.1 编写和调用NDK程序 499 21.3.2 用命令行方式编译NDK程序 501 21.3.3 在Eclipse中集成Android NDK 502 21.4 背景不断变化的三角形(NDK 版OpenGL ES) 504 21.5 使用NDK OpenGL ES API实现千变万化的3D效果 507 21.6 使用NDK调用音频API 510 21.7 本地Activity(Native Activity) 511 21.8 Android NDK配置文件详解 513 21.8.1 Android NDK定义的变量 513 21.8.2 Android NDK定义的函数 514 21.8.3 描述模块的变量 515 21.8.4 配置Application.mk文件 516 21.9 小结 516</span><br><span class="line"></span><br><span class="line"> 第22章 测试驱动开发(TDD) 517 22.1 JUnit测试框架 517 22.2 测试Activity 517 22.3 测试Content Provider 521 22.4 测试Service 523 22.5 测试普通类 523 22.6 小结 525</span><br><span class="line"></span><br><span class="line"> 第四部分 综合实例篇 第23章 Android综合案例一——蓝牙聊天 528 23.1 蓝牙聊天主界面 528 23.2 添加选项菜单 530 23.3 搜索和连接蓝牙设备 530 23.4 使设备可被其他蓝牙设备发现 533 23.5 发送和接收聊天信息 533 23.6 小结 537</span><br><span class="line"></span><br><span class="line"> 第24章 Android综合案例二——月球登陆(游戏) 538 24.1 游戏的玩法 538 24.2 实现游戏界面 539 24.3 设置游戏难度 540 24.4 开始游戏 541 24.5 控制飞船喷火 544 24.6 控制飞船改变飞行方向 544 24.7 判断飞船是否成功着陆 545 24.8 小结 546</span><br><span class="line"></span><br><span class="line"> 第25章 Android综合案例三——全键盘输入法(应用) 547 25.1 安装输入法 547 25.2 输入法的初始化工作 548 25.3 响应键盘操作 549 25.4 根据EditText控件的属性显示不同的软键盘 551 25.5 小结 553</span><br><span class="line"></span><br><span class="line"> 第26章 Android综合案例四——贪吃蛇(游戏) 554 26.1 游戏玩法 554 26.2 游戏主界面设计 555 26.3 控制小蛇的移动 557 26.4 小结 560</span><br><span class="line"></span><br><span class="line"> 第27章 Android综合案例五——新浪微博客户端(应用) 561 27.1 新浪微博简介 561 27.1.1 新浪微博客户端 561 27.1.2 新浪微博开放API 563 27.2 使用新浪微博开发API 563 27.3 创建和配置新浪微博客户端工程 564 27.4 登录新浪微博 564 27.5 功能按钮 567 27.6 显示“我的首页”的微博 569 27.7 评论微博 572 27.8 转发微博 573 27.9 写微博 574 27.10 小结 576</span><br><span class="line"></span><br><span class="line"> 第28章 Android综合案例六——笑脸连连看(游戏) 577 28.1 游戏玩法 577 28.2 准备图像素材 578 28.3 实现主界面 578 28.4 随机生成连连看图像 580 28.5 选中两个相同图像后消失 580 28.6 用定时器限制游戏时间 581 28.7 小结 582</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B005IUTCQ0/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B005IUTCQ0&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/5144KyRq0cL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>学通C语言的24堂课</title>
    <url>/2020/04/19/B0058BIMAQ/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 学通C语言的24堂课<br>作者信息： 作者: 刘彬彬 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《学通C语言的24堂课》：用持续激励培养良好习惯以良好习惯铸就伟大梦想——致亲爱的读者朋友在开始学习《学通C语言的24堂课》的同时，强烈建议读者朋友同时阅读并践行《世界上最伟大的推销员》（奥格曼狄诺著）《学通C语言的24堂课》，该书书名像是写给推销员的书，其实适合所有渴望成功的人们，当然也适合渴望成为优秀程序员的读者朋友。该书是在全世界范围内影响巨大的励志类著作之一，它振奋人心，激励斗志，改变了无数人的命运。成千上万的人们盛赞从该书中得到了神奇的力量，走向了成功之路。该书记载了一则传奇故事。一个名叫海菲的牧童，从他的主人那里幸运地得到十道神秘的羊皮卷，遵循卷中的原则，他执着创业，最终成为了一名伟大的推销员。建立起了一座浩大的商业王国……。怎样使用羊皮卷呢，按照书中所讲，就是每天早上、中午、晚上要分别用心默念或朗诵羊皮卷之一的内容，晚上写下践行记录，该卷内容就会潜移默化影响到自己的行动，通过持续不断的自我激励和实践，30天之后就会形成好良好的习惯，之后再进入下一卷。而成功的秘密就在于养成良好的习惯！良好的习惯可以通过持续不断的激励养成！学习软件开发也是一样，为此，我们借用了该书的方法，在每堂课的最后给出了一个励志故事，希望读者朋友能像上述该书一样，每天早、中、晚上能将该故事默念一遍，并写下践行记录，持续30天使之形成良好习惯，相信这些良好习惯非但助您成功踏上软件开发之路，还能让您受益一生。这也是我们命名为《软件开发羊皮卷》的初衷。375个中小实例训练，550余段源码分析，184个应用模块精解，7大项目案例展示。72集教学视频：72m（308段）多媒体教学视频，听程序员现场讲解、375个中小实例：夯实必备知识。强化基本功训练、550余源码分析：寻找编程感觉。培养编程思想、184个应用模块：激发学习兴趣。突出开发实战、7大项目案例：体验项目开发过程，积累项目开发经验。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1部分 基础篇</span><br><span class="line">第1堂课 初识C语言3</span><br><span class="line">视频讲解：45分钟</span><br><span class="line">1.1 C语言发展史4</span><br><span class="line">1.1.1 程序语言简述4</span><br><span class="line">1.1.2 C语言历史4</span><br><span class="line">1.2 C语言的特点5</span><br><span class="line">1.3 一个简单C程序5</span><br><span class="line">1.4 一个完整的C程序7</span><br><span class="line">1.5 C语言程序的格式10</span><br><span class="line">1.6 开发环境11</span><br><span class="line">1.6.1 Turbo C 2.011</span><br><span class="line">1.6.2 Visual C++ 6.014</span><br><span class="line">1.7 照猫画虎——基本功训练19</span><br><span class="line">1.7.1 基本功训练1——使用TC创建C文件19</span><br><span class="line">1.7.2 基本功训练2——使用Visual C++ 6.0创建.c文件20</span><br><span class="line">1.7.3 基本功训练3——打开一个C文件21</span><br><span class="line">1.7.4 基本功训练4——设置工具栏21</span><br><span class="line">1.8 情景应用——拓展与实践22</span><br><span class="line">1.8.1 情景应用1——求和程序22</span><br><span class="line">1.8.2 情景应用2——求10！23</span><br><span class="line">1.8.3 情景应用3——猴子吃桃24</span><br><span class="line">1.8.4 情景应用4——阳阳买苹果25</span><br><span class="line">1.9 自我测试26</span><br><span class="line">1.10 行动指南27</span><br><span class="line">1.11 成功可以复制——迅雷创始人邹胜龙27 </span><br><span class="line"></span><br><span class="line"> 第2堂课 掌握C语言数据类型29 视频讲解：56分钟 2.1 C语言的编程规范30 2.1.1 注释的合理使用30 2.1.2 程序中的“&#123;&#125;”要对齐30 2.1.3 合理使用空格使代码更规范31 2.1.4 换行使代码更清晰31 2.2 关键字32 2.3 标识符32 2.4 数据类型33 2.5 常量34 2.5.1 整型常量34 2.5.2 实型常量36 2.5.3 字符型常量36 2.5.4 转义字符39 2.5.5 符号常量40 2.6 变量41 2.6.1 整型变量41 2.6.2 实型变量43 2.6.3 字符型变量45 2.7 照猫画虎——基本功训练46 2.7.1 基本功训练1——定义正确的数据类型求圆周长46 2.7.2 基本功训练2——数值型常量的使用47 2.7.3 基本功训练3——字符变量的使用48 2.7.4 基本功训练4——实型变量的使用48 2.8 情景应用——拓展与实践49 2.8.1 情景应用1——十进制转换为二进制49 2.8.2 情景应用2——利用“#”输出图形51 2.8.3 情景应用3——打印杨辉三角51 2.8.4 情景应用4——利用“*”输出矩形52 2.9 自我测试53 2.10 行动指南54 2.11 成功可以复制——盖茨第二 马克·扎克伯格55</span><br><span class="line"></span><br><span class="line"> 第3堂课 表达式与运算符57 视频讲解：59分钟 3.1 表达式58 3.2 赋值运算符与赋值表达式59 3.2.1 变量赋初值60 3.2.2 自动类型转换61 3.2.3 强制类型转换61 3.3 算术运算符与表达式62 3.3.1 算术运算符62 3.3.2 算术表达式63 3.3.3 优先级与结合性64 3.3.4 自增自减运算符66 3.4 关系运算符与表达式68 3.4.1 关系运算符68 3.4.2 关系表达式68 3.4.3 优先级与结合性69 3.5 逻辑运算符与表达式70 3.5.1 逻辑运算符70 3.5.2 逻辑表达式71 3.5.3 优先级与结合性71 3.6 位逻辑运算符与表达式72 3.6.1 位逻辑运算符72 3.6.2 位逻辑表达式72 3.7 逗号运算符与表达式73 3.8 复合赋值运算符74 3.9 照猫画虎——基本功训练75 3.9.1 基本功训练1——使用基本的算术运算符75 3.9.2 基本功训练2——赋值表达式类型的转换76 3.9.3 基本功训练3——复合赋值运算符的应用77 3.9.4 基本功训练4——逗号运算符的应用77 3.9.5 基本功训练5——关系表达式进行算术运算78 3.10 情景应用——拓展与实践78 3.10.1 情景应用1——求1~10的累加和78 3.10.2 情景应用2——计算学生平均身高79 3.10.3 情景应用3——求一元二次方程 ax2+bx+c&#x3D;0的根79 3.10.4 情景应用4——求字符串中字符的个数80 3.10.5 情景应用5——计算a+&#x3D;a*&#x3D;a&#x2F;&#x3D;a-681 3.11 自我测试82 3.12 行动指南83 3.13 成功可以复制——善于抓住时机的人徐少春84</span><br><span class="line"></span><br><span class="line"> 第4堂课 数据输入&#x2F;输出函数87视频讲解：69分钟 4.1 语句88 4.2 字符数据输入&#x2F;输出88 4.2.1 字符数据输出88 4.2.2 字符数据输入89 4.3 字符串输入&#x2F;输出91 4.3.1 字符串输出函数91 4.3.2 字符串输入函数92 4.4 格式输出函数93 4.5 格式输入函数95 4.6 顺序程序设计应用99 4.7 照猫画虎——基本功训练100 4.7.1 基本功训练1——使用字符函数输入&#x2F;输出字符100 4.7.2 基本功训练2——使用字符输出函数输出“mrsoft”101 4.7.3 基本功训练3——输出相对的最小整数102 4.7.4 基本功训练4——输出乘法口诀表102 4.7.5 基本功训练5——输出两个数的最大 公约数103 4.8 情景应用——拓展与实践104 4.8.1 情景应用1——将输入的小写字符 转换为大写字符104 4.8.2 情景应用2——用“*”号输出图案105 4.8.3 情景应用3——输出3×3的矩阵106 4.8.4 情景应用4——输出一个字符的前驱字符106 4.8.5 情景应用5——根据输入判断能否组成三角形107 4.9 自我测试108 4.10 行动指南110 4.11 成功可以复制——暴雪公司的领航者 迈克·莫汉110</span><br><span class="line"></span><br><span class="line"> 第5堂课 设计选择&#x2F;分支结构程序113 视频讲解：81分钟 5.1 if语句114 5.2 if语句的基本形式114 5.2.1 if语句形式114 5.2.2 if…else语句形式117 5.2.3 else if语句形式121 5.3 if的嵌套形式124 5.4 条件运算符126 5.5 switch语句127 5.5.1 switch语句的基本形式127 5.5.2 多路开关模式的switch语句131 5.6 if else语句和switch语句的区别132 5.7 选择结构程序应用134 5.8 照猫画虎——基本功训练136 5.8.1 基本功训练1——单条件单分支选择语句136 5.8.2 基本功训练2——单条件双分支选择语句136 5.8.3 基本功训练3——条件运算符的使用137 5.8.4 基本功训练4——计算工人工资138 5.8.5 基本功训练5——判断闰年139 5.9 情景应用——拓展与实践140 5.9.1 情景应用1——从小到大输出3个数140 5.9.2 情景应用2——求学生的最低分和最高分141 5.9.3 情景应用3——模拟自动售货机142 5.9.4 情景应用4——模拟ATM机界面程序143 5.9.5 情景应用5——计算某日是该年的第几天146 5.10 自我测试147 5.11 行动指南150 5.12 成功可以复制——因特网的点火人 马克·安德森151</span><br><span class="line"></span><br><span class="line"> 第6堂课 循环控制153 视频讲解：82分钟 6.1 循环语句154 6.2 while语句154 6.3 do…while语句157 6.4 for语句158 6.4.1 for语句使用158 6.4.2 for循环的变体161 6.4.3 for语句中的逗号应用163 6.5 3种循环语句的比较164 6.6 循环嵌套164 6.6.1 循环嵌套的结构164 6.6.2 循环嵌套实例166 6.7 转移语句166 6.7.1 goto语句167 6.7.2 break语句168 6.7.3 continue语句169 6.8 照猫画虎——基本功训练170 6.8.1 基本功训练1——求某个数的阶乘170 6.8.2 基本功训练2——一元钱的兑换方案171 6.8.3 基本功训练3——特殊等式172 6.8.4 基本功训练4——计算12+22+…+102173 6.8.5 基本功训练5——输出10~100之间的素数173 6.9 情景应用——拓展与实践175 6.9.1 情景应用1——爱因斯坦阶梯问题175 6.9.2 情景应用2——斐波那契数列176 6.9.3 情景应用3——银行存款问题177 6.9.4 情景应用4——计算学生的最高分177 6.9.5 情景应用5——统计不及格的人数178 6.10 自我测试179 6.11 行动指南182 6.12 成功可以复制——微型博客Twitter创始人埃文·威廉姆斯183</span><br><span class="line"></span><br><span class="line"> 第7堂课 数组的应用185 视频讲解：58分钟 7.1 一维数组186 7.1.1 一维数组的定义和引用186 7.1.2 一维数组初始化187 7.1.3 一维数组应用189 7.2 二维数组190 7.2.1 二维数组的定义和引用190 7.2.2 二维数组初始化191 7.2.3 二维数组应用192 7.3 多维数组193 7.4 数组的排序算法194 7.4.1 选择法排序194 7.4.2 冒泡法排序196 7.4.3 交换法排序197 7.4.4 插入法排序199 7.4.5 折半法排序201 7.4.6 排序算法的比较204 7.5 照猫画虎——基本功训练205 7.5.1 基本功训练1——逆序存放数据205 7.5.2 基本功训练2——查找数组中的最值206 7.5.3 基本功训练3——判断一个数是否存在数组中207 7.5.4 基本功训练4——相邻元素之和208 7.5.5 基本功训练5——求二维数组对角线之和208 7.6 情景应用——拓展与实践209 7.6.1 情景应用1——选票统计209 7.6.2 情景应用2——模拟比赛打分211 7.6.3 情景应用3——统计学生成绩212 7.6.4 情景应用4——矩阵的转置213 7.6.5 情景应用5——设计魔方阵215 7.7 自我测试216 7.8 行动指南218 7.9 成功可以复制——射击游戏之父John Carmack218</span><br><span class="line"></span><br><span class="line"> 第8堂课 字符数组221 视频讲解：60分钟 8.1 字符数组的应用222 8.1.1 字符数组定义和引用222 8.1.2 字符数组初始化222 8.1.3 字符数组的结束标志224 8.1.4 字符数组的输入&#x2F;输出224 8.1.5 字符数组应用226 8.2 字符串处理函数227 8.2.1 字符串复制227 8.2.2 字符串连接228 8.2.3 字符串比较229 8.2.4 字符串大小写转换230 8.2.5 获得字符串长度232 8.3 照猫画虎——基本功训练233 8.3.1 基本功训练1——不使用strcpy函数实现字符串复制功能233 8.3.2 基本功训练2——用字符数组存储学生姓名并输出234 8.3.3 基本功训练3——字符升序排列234 8.3.4 基本功训练4——在指定位置插入字符236 8.3.5 基本功训练5——删除字符串中的连续字符237 8.4 情景应用——拓展与实践238 8.4.1 情景应用1——统计各种字符个数238 8.4.2 情景应用2——字符串倒置239 8.4.3 情景应用3——字符串替换240 8.4.4 情景应用4——回文字符串241 8.4.5 情景应用5——字符串加密和解密242 8.5 自我测试244 8.6 行动指南245 8.7 成功可以复制——图文世界的缔造者约翰·沃洛克246</span><br><span class="line"></span><br><span class="line"> 第2部分 提高篇 第9堂课 函数的应用251 视频讲解：98分钟 9.1 函数概述252 9.2 函数的定义253 9.2.1 函数定义的形式254 9.2.2 定义与声明255 9.3 返回语句257 9.3.1 从函数返回257 9.3.2 返回值258 9.4 函数参数259 9.4.1 形式参数与实际参数260 9.4.2 数组作函数参数261 9.4.3 main的参数266 9.5 函数的调用267 9.5.1 函数调用方式267 9.5.2 嵌套调用269 9.5.3 递归调用271 9.6 内部函数和外部函数273 9.6.1 内部函数274 9.6.2 外部函数275 9.7 局部变量和全局变量276 9.7.1 局部变量276 9.7.2 全局变量278 9.8 函数应用280 9.9 照猫画虎——基本功训练285 9.9.1 基本功训练1——设计函数输出两个数中的最大值285 9.9.2 基本功训练2——设计函数计算学生的平均成绩286 9.9.3 基本功训练3——判断素数287 9.9.4 基本功训练4——求数组元素中的最小值287 9.9.5 基本功训练5——打印1到5的阶乘288 9.10 情景应用——拓展与实践289 9.10.1 情景应用1——递归解决年龄问题289 9.10.2 情景应用2——百钱百鸡问题290 9.10.3 情景应用3——求最大公约数和最小公倍数292 9.10.4 情景应用4——求直角三角形斜边293 9.10.5 情景应用5——小数分离294 9.11 自我测试294 9.12 行动指南296 9.13 成功可以复制——征途巨人史玉柱297</span><br><span class="line"></span><br><span class="line"> 第10堂课 变量的存储类别299 视频讲解：42分钟 10.1 了解变量的存储类型300 10.2 使用auto关键字声明自动变量300 10.3 使用static关键字声明静态变量301 10.4 使用register关键字声明寄存器变量303 10.5 使用extern关键字声明外部变量304 10.5.1 声明在一个文件中使用的外部变量304 10.5.2 声明在多个文件中使用的外部变量305 10.6 使用static关键字声明静态外部变量306 10.7 照猫画虎——基本功训练307 10.7.1 基本功训练1——声明自动变量307 10.7.2 基本功训练2——比较两个数的大小308 10.7.3 基本功训练3——求两个数的和309 10.7.4 基本功训练4——计算用户输入整数的乘积309 10.7.5 基本功训练5——使用register定义局部变量310 10.8 情景应用——拓展与实践311 10.8.1 情景应用1——婚礼上的谎言311 10.8.2 情景应用2——求新同学的年龄312 10.8.3 情景应用3——捕鱼和分鱼313 10.8.4 情景应用4——求邮票总数314 10.8.5 情景应用5——巧分苹果315 10.9 自我测试316 10.10 行动指南318 10.11 成功可以复制——缔造华人的硅谷传奇杨致远319</span><br><span class="line"></span><br><span class="line"> 第11堂课 C语言中的指针321 视频讲解：107分钟 11.1 指针相关概念322 11.1.1 地址与指针322 11.1.2 变量与指针323 11.1.3 指针变量323 11.1.4 指针自加自减运算326 11.2 数组与指针327 11.2.1 一维数组与指针328 11.2.2 二维数组与指针331 11.2.3 字符串与指针333 11.2.4 字符串数组334 11.3 指向指针的指针336 11.4 指针变量作函数参数338 11.5 返回指针值的函数343 11.6 指针数组作main函数的参数345 11.7 照猫画虎——基本功训练346 11.7.1 基本功训练1——利用指针查找数列中最大值和最小值346 11.7.2 基本功训练2——利用指针实现字符串复制347 11.7.3 基本功训练3——实现数组元素值逆序存放348 11.7.4 基本功训练4——使用指针连接两个字符串349 11.7.5 基本功训练5——利用指针输出数组元素350 11.8 情景应用——拓展与实践351 11.8.1 情景应用1——查找成绩不及格的学生351 11.8.2 情景应用2——使用指针实现冒泡排序352 11.8.3 情景应用3——输入月份号输出英文月份名353 11.8.4 情景应用4——使用指针插入元素354 11.8.5 情景应用5——使用指针交换两个数组中的最大值355 11.9 自我测试357 11.10 行动指南359 11.11 成功可以复制——杀毒王王江民360</span><br><span class="line"></span><br><span class="line"> 第12堂课 结构体的使用363 视频讲解：62分钟 12.1 结构体364 12.1.1 结构体类型的概念364 12.1.2 结构体变量的定义365 12.1.3 结构体变量的引用366 12.1.4 结构体类型的初始化368 12.2 结构体数组370 12.2.1 定义结构体数组370 12.2.2 初始化结构体数组371 12.3 结构体指针373 12.3.1 指向结构体变量的指针373 12.3.2 指向结构体数组的指针376 12.3.3 结构体作函数参数377 12.4 包含结构的结构380 12.5 照猫画虎——基本功训练381 12.5.1 基本功训练1——结构体变量的初始化381 12.5.2 基本功训练2——使用结构体存放学生信息382 12.5.3 基本功训练3——整数排序383 12.5.4 基本功训练4——指向数组元素的结构指针运算384 12.5.5 基本功训练5——计算学生的平均成绩385 12.6 情景应用——拓展与实践386 12.6.1 情景应用1——找出最高分386 12.6.2 情景应用2——候选人选票程序387 12.6.3 情景应用3——求平面上两点的距离388 12.6.4 情景应用4——设计通讯录389 12.6.5 情景应用5——输出火车票价390 12.7 自我测试392 12.8 行动指南394 12.9 成功可以复制——中国第一程序员求伯君395</span><br><span class="line"></span><br><span class="line"> 第13堂课 共用体的综合应用397视频讲解：24分钟 13.1 共用体398 13.1.1 共用体的概念398 13.1.2 共用体变量的引用398 13.1.3 共用体变量的初始化399 13.1.4 共用体类型的数据特点400 13.2 枚举类型400 13.3 照猫画虎——基本功训练401 13.3.1 基本功训练1——共用体变量的应用401 13.3.2 基本功训练2——共用体处理任意类型数据402 13.3.3 基本功训练3——取出整型数据的高字节数据403 13.4 情景应用——拓展与实践404 13.4.1 情景应用1——使用共用体存放学生和老师信息404 13.4.2 情景应用2——输出今天星期几405 13.4.3 情景应用3——制作花束406 13.5 自我测试408 13.6 行动指南409 13.7 成功可以复制——80后新贵、泡泡网CEO李想409</span><br><span class="line"></span><br><span class="line"> 第14堂课 使用预处理命令411 视频讲解：62分钟 14.1 宏定义412 14.1.1 不带参数的宏定义412 14.1.2 带参数的宏定义413 14.2 #include指令414 14.3 条件编译416 14.3.1 #if命令416 14.3.2 #ifdef及#ifndef命令418 14.3.3 #undef命令419 14.3.4 #line命令419 14.3.5 #pragma命令420 14.4 照猫画虎——基本功训练420 14.4.1 基本功训练1——不带参数的宏定义求平行四边形面积420 14.4.2 基本功训练2——定义带参数的宏实现求两个整数的乘积421 14.4.3 基本功训练3——编写头文件包含圆面积的计算公式422 14.4.4 基本功训练4——使用条件编译将字符转换为大写423 14.4.5 基本功训练5——使用宏定义实现数组值的互换424 14.5 情景应用——拓展与实践425 14.5.1 情景应用1——使用带参数的宏求圆面积425 14.5.2 情景应用2——利用宏定义求偶数和426 14.5.3 情景应用3——从3个数中找出最小数427 14.5.4 情景应用4——利用文件包含设计输出模式428 14.5.5 情景应用5——使用条件编译隐藏密码428 14.6 自我测试429 14.7 行动指南431 14.8 成功可以复制——使计算机成为 生活的必需品比尔·盖茨432</span><br><span class="line"></span><br><span class="line"> 第3部分 高级篇 第15堂课 存储管理435 视频讲解：33分钟 15.1 内存组织方式436 15.1.1 内存组织方式436 15.1.2 堆管理436 15.2 动态管理437 15.2.1 malloc函数437 15.2.2 calloc函数438 15.2.3 realloc函数439 15.2.4 free函数439 15.3 内存丢失440 15.4 照猫画虎——基本功训练441 15.4.1 基本功训练1——sizeof关键字的应用441 15.4.2 基本功训练2——为具有3个数组元素的数组分配内存442 15.4.3 基本功训练3——为二维数组动态分配内存442 15.5 情景应用——拓展与实践444 15.5.1 情景应用1——使用malloc（）函数分配内存444 15.5.2 情景应用2——调用calloc（）函数动态分配内存444 15.5.3 情景应用3——商品信息的动态存放445 15.6 自我测试446 15.7 行动指南447 15.8 成功可以复制——知识改变命运、科技改变生活李彦宏448</span><br><span class="line"></span><br><span class="line"> 第16堂课 链表在C语言中的应用451视频讲解：76分钟 16.1 链表452 16.1.1 链表概述452 16.1.2 静态链表453 16.1.3 处理动态链表所需的函数454 16.2 链表相关操作454 16.2.1 创建动态链表454 16.2.2 输出链表456 16.2.3 链表的插入操作458 16.2.4 链表的删除操作459 16.3 链表的表现形式463 16.3.1 单向链表463 16.3.2 循环链表464 16.3.3 双向链表464 16.4 照猫画虎——基本功训练465 16.4.1 基本功训练1——创建单向链表465 16.4.2 基本功训练2——向单向链表中插入元素467 16.4.3 基本功训练3——删除结点元素469 16.4.4 基本功训练4——创建双向链表471 16.4.5 基本功训练5——创建循环链表474 16.5 情景应用——拓展与实践475 16.5.1 情景应用1——单向链表逆置475 16.5.2 情景应用2——双向链表逆序输出477 16.5.3 情景应用3——连接两个链表479 16.5.4 情景应用4——使用链表实现约瑟夫环480 16.5.5 情景应用5——查找两个链表中的相同元素482 16.6 自我测试484 16.7 行动指南486 16.8 成功可以复制——中国通信设备行业的领跑者任正非486</span><br><span class="line"></span><br><span class="line"> 第17堂课 栈和队列489 视频讲解：73分钟 17.1 栈的定义和几种基本操作490 17.1.1 栈的定义490 17.1.2 栈常见的几种基本操作491 17.2 栈的存储和实现492 17.2.1 顺序栈492 17.2.2 链栈494 17.3 队列的定义和基本操作497 17.3.1 队列的定义497 17.3.2 队列常见的几种基本操作497 17.4 队列的存储及运算497 17.4.1 顺序队列497 17.4.2 链队列500 17.4.3 循环队列501 17.5 照猫画虎——基本功训练501 17.5.1 基本功训练1——应用栈实现进制转换501 17.5.2 基本功训练2——括号匹配检测504 17.5.3 基本功训练3——利用栈实现递归计算多项式507 17.5.4 基本功训练4——循环队列的基本操作508 17.6 情景应用——拓展与实践511 17.6.1 情景应用1——汉诺塔问题511 17.6.2 情景应用2——机票预售系统513 17.6.3 情景应用3——链队列的使用515 17.7 自我测试519 17.8 行动指南520 17.9 成功可以复制——软件业的华人教父王嘉廉521</span><br><span class="line"></span><br><span class="line"> 第18堂课 C语言中的位运算523 视频讲解：62分钟 18.1 位与字节524 18.2 位运算操作符524 18.2.1 与运算符524 18.2.2 或运算符525 18.2.3 取反运算符527 18.2.4 异或运算符528 18.2.5 左移运算符529 18.2.6 右移运算符530 18.3 循环移位532 18.4 位段533 18.4.1 位段的概念与定义533 18.4.2 位段相关说明534 18.5 照猫画虎——基本功训练535 18.5.1 基本功训练1——输入两个整数实现按位与和按位或535 18.5.2 基本功训练2——使二进制数特定位翻转536 18.5.3 基本功训练3——整数与0异或537 18.5.4 基本功训练4——将输入的数左移两位并输出538 18.5.5 基本功训练5——编程实现循环右移538 18.6 情景应用——拓展与实践539 18.6.1 情景应用1——交换两个值不用临时变量539 18.6.2 情景应用2——取一个整数的后4位540 18.6.3 情景应用3——编写循环移位函数541 18.6.4 情景应用4——取出给定16位二进制数的奇数位541 18.6.5 情景应用5——求一个数的补码542 18.7 自我测试543 18.8 行动指南544 18.9 成功可以复制——创造互联网搜索时代谢尔盖·布林545</span><br><span class="line"></span><br><span class="line"> 第19堂课 文件操作技术547 视频讲解：87分钟 19.1 文件概述548 19.2 文件基本操作548 19.2.1 文件指针548 19.2.2 文件的打开549 19.2.3 文件的关闭549 19.3 文件的读写550 19.3.1 fputc函数550 19.3.2 fgetc函数551 19.3.3 fputs函数551 19.3.4 fgets函数552 19.3.5 fprintf函数553 19.3.6 fscanf函数554 19.3.7 fread函数和fwrite函数555 19.4 文件的定位557 19.4.1 fseek函数557 19.4.2 rewind函数558 19.4.3 ftell函数559 19.5 照猫画虎——基本功训练561 19.5.1 基本功训练1——关闭打开的所有文件561 19.5.2 基本功训练2——读取指定文件的内容563 19.5.3 基本功训练3——同时显示两个文件的内容564 19.5.4 基本功训练4——随机读写文件565 19.5.5 基本功训练5——文件的错误处理567 19.6 情景应用——拓展与实践569 19.6.1 情景应用1——创建文件569 19.6.2 情景应用2——文件的复制570 19.6.3 情景应用3——删除文件572 19.6.4 情景应用4——重命名文件573 19.6.5 情景应用5——文件加密575 19.7 自我测试577 19.8 行动指南579 19.9 成功可以复制——IT风云人物鲍岳桥579</span><br><span class="line"></span><br><span class="line"> 第20堂课 图形图像处理581 视频讲解：129分钟 20.1 字符屏幕582 20.1.1 定义文本窗口582 20.1.2 颜色设置582 20.1.3 文本的输入和输出583 20.1.4 屏幕操作函数584 20.2 图形显示586 20.2.1 图形模式初始化586 20.2.2 屏幕颜色设置588 20.2.3 基本图形函数590 20.2.4 封闭图形的填充597 20.3 图形屏幕599 20.4 图形模式下文本输出600 20.4.1 文本输出函数600 20.4.2 文本属性设置601 20.5 照猫画虎——基本功训练603 20.5.1 基本功训练1——闪烁的文字603 20.5.2 基本功训练2——实现背景颜色切换604 20.5.3 基本功训练3——绘制圆形605 20.5.4 基本功训练4——在屏幕中绘制两个相同的小球605 20.5.5 基本功训练5——绘制五角星607 20.6 情景应用——拓展与实践609 20.6.1 情景应用1——绘制折线图609 20.6.2 情景应用2——输出饼状图611 20.6.3 情景应用3——画条形图612 20.6.4 情景应用4——画玫瑰花615 20.6.5 情景应用5——菜单界面设计619 20.7 自我测试625 20.8 行动指南627 20.9 成功可以复制——IT大王王志东627</span><br><span class="line"></span><br><span class="line"> 第4部分 实战篇 第21堂课 猜数字游戏631 视频讲解：23分钟 21.1 概述632 21.2 需求分析632 21.3 系统设计632 21.3.1 设计目标632 21.3.2 开发及运行环境632 21.4 程序预览632 21.5 设计思路634 21.6 文件引用634 21.7 主要功能实现634 21.7.1 主函数634 21.7.2 猜数字635 21.7.3 光标定位637</span><br><span class="line"></span><br><span class="line"> 第22堂课 五子棋游戏639 视频讲解：27分钟 22.1 概述640 22.2 需求分析640 22.3 系统设计640 22.3.1 设计目标640 22.3.2 开发及运行环境640 22.4 程序预览640 22.5 graphics.h文件641 22.6 设计思路644 22.7 预处理644 22.7.1 文件引用644 22.7.2 宏定义645 22.8 声明变量645 22.9 函数声明645 22.10 主要功能实现645 22.10.1 主函数645 22.10.2 开始游戏647 22.10.3 绘制棋盘647 22.10.4 绘制棋子648 22.10.5 清除棋子648 22.10.6 游戏过程648 22.10.7 判断胜负653</span><br><span class="line"></span><br><span class="line"> 第23堂课 学生成绩管理系统657 视频讲解：40分钟 23.1 需求分析658 23.2 系统设计658 23.3 功能设计658 23.3.1 功能选择界面659 23.3.2 录入学生成绩信息660 23.3.3 查询学生成绩信息662 23.3.4 删除学生成绩信息663 23.3.5 修改学生成绩信息664 23.3.6 插入学生成绩信息666 23.3.7 统计学生人数668</span><br><span class="line"></span><br><span class="line"> 第24堂课 图书管理系统（MySQL）669 视频讲解：32分钟 24.1 概述670 24.1.1 需求分析670 24.1.2 开发工具选择670 24.2 系统设计670 24.2.1 系统目标670 24.2.2 系统功能结构670 24.2.3 系统预览670 24.2.4 开发及运行环境672 24.3 数据库设计673 24.3.1 安装MySQL数据库673 24.3.2 启动MySQL数据库676 24.3.3 创建数据库677 24.3.4 数据表结构678 24.4 C语言开发数据库程序的流程678 24.5 C语言操作MySQL数据库680 24.5.1 MySQL常用数据库操作函数680 24.5.2 连接MySQL数据682 24.5.3 查询图书表记录683 24.5.4 插入图书表记录685 24.5.5 修改图书表记录686 24.5.6 删除图书表记录687 24.6 文件引用687 24.7 变量和函数定义688 24.8 主要功能模块设计688 24.8.1 显示主菜单信息688 24.8.2 显示所有图书信息690 24.8.3 添加图书信息692 24.8.4 修改图书信息698 24.8.5 删除图书信息704 24.8.6 查询图书信息710 24.9 程序调试及错误处理712 24.9.1 解决创建数据表为一个文件的问题712 24.9.2 在创建数据表时，最后一句结尾没有标点713 24.9.3 无法启动MySQL服务714</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0058BIMAQ/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0058BIMAQ&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51dwFoZPcyL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言接口与实现 创建可重用软件的技术</title>
    <url>/2020/04/19/B005LAJ9F6/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C语言接口与实现 创建可重用软件的技术<br>作者信息： 作者: David R. Hanson [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《C语言接口与实现:创建可重用软件的技术》可重用的软件模块是构建大规模可靠应用程序的基石，创建可重用的软件模块是每个程序员和项目经理必须掌握的技能。C语言对创建可重用的API提供的语言和功能支持非常少，虽然C程序员写应用时都会用到API和库，但却很少有人去创建和发布新的能广泛应用的API。《C语言接口与实现:创建可重用软件的技术》介绍用一种基于接口的设计方法创建可重用的API，这一方法将接口与实现分离开来，且与语言无关。书中详细描述了T24个接口及其实现，便于读者深入了解此方法。这些接口涉及很多计算机领域的知识，包括数据结构、算法、字符串处理和并发程序。《C语言接口与实现:创建可重用软件的技术》是C语言领域的经典名著，出版十余年仍畅销不衰，是几代程序员倍加推崇的力作。《C语言接口与实现:创建可重用软件的技术》特色：接口描述简单明了，程序员可将此书用作相关接口的参考手册，深入剖析如何将数据结构及其相关算法打包成可重用的模块，分析了全部24个API和8个示例应用的源代码，揭秘了许多鲜有文档的C语言编程技巧。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 引言 1</span><br><span class="line">1.1 文学程序 2</span><br><span class="line">1.2 程序设计风格 6</span><br><span class="line">1.3 效率 8</span><br><span class="line">1.4 扩展阅读 9</span><br><span class="line">1.5 习题 9 </span><br><span class="line"></span><br><span class="line"> 第2章 接口与实现 11 2.1 接口 11 2.2 实现 13 2.3 抽象数据类型 15 2.4 客户程序的职责 17 2.5 效率 21 2.6 扩展阅读 22 2.7 习题 22</span><br><span class="line"></span><br><span class="line"> 第3章 原子 24 3.1 接口 24 3.2 实现 25 3.3 扩展阅读 30 3.4 习题 31</span><br><span class="line"></span><br><span class="line"> 第4章 异常与断言 33 4.1 接口 35 4.2 实现 38 4.3 断言 44 4.4 扩展阅读 46 4.5 习题 47</span><br><span class="line"></span><br><span class="line"> 第5章 内存管理 49 5.1 接口 50 5.2 产品实现 54 5.3 稽核实现 55 5.4 扩展阅读 62 5.5 习题 63</span><br><span class="line"></span><br><span class="line"> 第6章 再谈内存管理 65 6.1 接口 65 6.2 实现 67 6.3 扩展阅读 72 6.4 习题 73</span><br><span class="line"></span><br><span class="line"> 第7章 链表 75 7.1 接口 75 7.2 实现 79 7.3 扩展阅读 83 7.4 习题 83</span><br><span class="line"></span><br><span class="line"> 第8章 表 84 8.1 接口 84 8.2 例子：词频 87 8.3 实现 91 8.4 扩展阅读 97 8.5 习题 97</span><br><span class="line"></span><br><span class="line"> 第9章 集合 99 9.1 接口 99 9.2 例子：交叉引用列表 101 9.3 实现 107 9.3.1 成员操作 109 9.3.2 集合操作 111 9.4 扩展阅读 114 9.5 习题 115</span><br><span class="line"></span><br><span class="line"> 第10章 动态数组 116 10.1 接口 116 10.2 实现 119 10.3 扩展阅读 122 10.4 习题 122</span><br><span class="line"></span><br><span class="line"> 第11章 序列 123 11.1 接口 123 11.2 实现 125 11.3 扩展阅读 129 11.4 习题 129</span><br><span class="line"></span><br><span class="line"> 第12章 环 131 12.1 接口 131 12.2 实现 134 12.3 扩展阅读 141 12.4 习题 141</span><br><span class="line"></span><br><span class="line"> 第13章 位向量 142 13.1 接口 142 13.2 实现 144 13.2.1 成员操作 146 13.2.2 比较 150 13.2.3 集合操作 151 13.3 扩展阅读 152 13.4 习题 153</span><br><span class="line"></span><br><span class="line"> 第14章 格式化 154 14.1 接口 154 14.1.1 格式化函数 155 14.1.2 转换函数 157 14.2 实现 160 14.2.1 格式化函数 161 14.2.2 转换函数 166 14.3 扩展阅读 170 14.4 习题 171</span><br><span class="line"></span><br><span class="line"> 第15章 低级字符串 172 15.1 接口 173 15.2 例子：输出标识符 178 15.3 实现 179 15.3.1 字符串操作 180 15.3.2 分析字符串 184 15.3.3 转换函数 188 15.4 扩展阅读 189 15.5 习题 189</span><br><span class="line"></span><br><span class="line"> 第16章 高级字符串 192 16.1 接口 192 16.2 实现 197 16.2.1 字符串操作 200 16.2.2 内存管理 204 16.2.3 分析字符串 205 16.2.4 转换函数 209 16.3 扩展阅读 210 16.4 习题 210</span><br><span class="line"></span><br><span class="line"> 第17章 扩展精度算术 212 17.1 接口 212 17.2 实现 217 17.2.1 加减法 218 17.2.2 乘法 220 17.2.3 除法和比较 221 17.2.4 移位 226 17.2.5 字符串转换 228 17.3 扩展阅读 230 17.4 习题 230</span><br><span class="line"></span><br><span class="line"> 第18章 任意精度算术 232 18.1 接口 232 18.2 例子：计算器 235 18.3 实现 240 18.3.1 取反和乘法 242 18.3.2 加减法 243 18.3.3 除法 246 18.3.4 取幂 247 18.3.5 比较 249 18.3.6 便捷函数 250 18.3.7 移位 251 18.3.8 与字符串和整数的转换 252 18.4 扩展阅读 254 18.5 习题 255</span><br><span class="line"></span><br><span class="line"> 第19章 多精度算术 257 19.1 接口 257 19.2 例子：另一个计算器 263 19.3 实现 269 19.3.1 转换 272 19.3.2 无符号算术 275 19.3.3 有符号算术 277 19.3.4 便捷函数 280 19.3.5 比较和逻辑操作 285 19.3.6 字符串转换 288 19.4 扩展阅读 290 19.5 习题 291</span><br><span class="line"></span><br><span class="line"> 第20章 线程 292 20.1 接口 294 20.1.1 线程 294 20.1.2 一般信号量 298 20.1.3 同步通信通道 301 20.2 例子 301 20.2.1 并发排序 302 20.2.2 临界区 305 20.2.3 生成素数 307 20.3 实现 311 20.3.1 同步通信通道 311 20.3.2 线程 313 20.3.3 线程创建和上下文切换 322 20.3.4 抢占 328 20.3.5 一般信号量 330 20.3.6 MIPS和ALPHA上的上下文切换 332 20.4 扩展阅读 335 20.5 习题 336</span><br><span class="line"></span><br><span class="line"> 附录A 接口摘要 339</span><br><span class="line"></span><br><span class="line"> 参考书目 363</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B005LAJ9F6/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B005LAJ9F6&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec8.images-amazon.com/images/I/41OT-F-reoL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 4.0网络编程详解</title>
    <url>/2020/04/19/B006NZMCS4/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android 4.0网络编程详解<br>作者信息： 作者: 王家林 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Android 4.0网络编程详解》：双DVD光盘、配书教学视频、《Android 4.0网络编程详解》配套代码包、以开发中遇到的问题代码的解决方案为主线、解决Android网络编程中实际会遇到的诸多问题。《Android 4.0网络编程详解》专注于移动互联网智能终端操作系统和应用软件的开发，内容涉及iOS、Android和Windows Phone等系统的详细解析。应用软件、游戏的开发以及UI设计等。◆本丛书的作者均具有多年的开发经验，有来自于国内著名的Android、iOS、Windows Phone开发团队和科研机构的开发人员，也有乐于分享的技术达人，实战经验丰富。◆本丛书力求从多个技术角度将移动互联网智能终端软件开发的重点、难点及解决方法呈现给读者，使读者通过系统的学习，可以在移动互联网迅猛发展的浪潮中自由遨游。◆本丛书中基于Android平台的图书包含Android商业软件项目全程实战，移植、测试、管理，网络编程，NDK编程，软件、硬件、云的整合之道等多方面内容。国士工作室，国士工作室是一支专注于Android平台企业级应用开发的技术团队，致力于做最佳的Android应用程序开发机构，提供最佳的Android企业级应用开发培训服务，对娱乐多媒体应用、LBS、手机安全等领域有着深刻的理解和研发能力，致力服务于企业用户。为音／视频等娱乐多媒体网站、手机门户网站、SNS、论坛、电子商务等传统网络应用向移动互联网发展提供解决方案和技术支持，提供手机安全技术和服务，为企业提供Android培训服务等。目前，国士工作室正在务实且卓有成效地与各种传统网络服务商合作，发展迅速，并渴望有志之士的加入，为共同成为最好的Android软件开发、咨询、培训公司而奋斗，为智能手机和移动互联网时代贡献力量！</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章  Android 4.0开发环境搭建和测试</span><br><span class="line">1.1  下载所需要的软件</span><br><span class="line">1.2  安装所需要的软件</span><br><span class="line">1.3  第一个Android 4.0程序</span><br><span class="line">1.4  剖析Android 4.0程序的组织结构</span><br><span class="line">1.5  Android 4.0模拟器无3G信号的解决方案 </span><br><span class="line"></span><br><span class="line"> 第2章 Android 4.0的软件测试和调试 2.1 Android 4.0的软件测试 2.2 Android 4.0的软件调试</span><br><span class="line"></span><br><span class="line"> 第3章 Android 4.0网络下的XML和JSON 3.1 Android 4.0中使用到的XML剖析 3.2 使用SAX解析XML 3.3 使用DOM解析XML 3.4 使用PULL解析XML 3.5 使用PULL生成XML 3.6 SAX、DOM、PULL的比较</span><br><span class="line"></span><br><span class="line"> 第4章 HTTP协议剖析 4.1 HTTP协议概述 4.2 HTTP协议实例剖析</span><br><span class="line"></span><br><span class="line"> 第5章 Android中的网络数据下载 5.1 获取网络上的图片 5.2 获取网络上的网页代码 5.3 获取网络上的XML 5.4 获取网络上的JSON数据 5.5 Java SE单线程下载网络上的音&#x2F;视频等大文件 5.6 Java SE多线程下载网络上的音&#x2F;视频等大文件 5.7 Android多线程断点续传下载网络上的音&#x2F;视频等大文件</span><br><span class="line"></span><br><span class="line"> 第6章 Android中的网络数据上传 6.1 通过GET方式传递数据给服务器以及中文乱码的解决方案 6.2 通过POST方式传递数据给服务器 6.3 通过开源框架HttpClient的方式传递数据给服务器 6.4 Android发送XML数据给服务器 6.5 用手机号码归属地查询的实际商业案例实战Android调用WebService 6.6 通过HTTP协议实现文件上传</span><br><span class="line"></span><br><span class="line"> 第7章 Android中的Socket编程 7.1 TCP&#x2F;IP协议与Socket通信 7.2 Socket通信的一般过程 7.3 Socket编程实战——Android聊天室实例 7.4 Android中通过Socket协议实现断点续传上传音&#x2F;视频等大文件</span><br><span class="line"></span><br><span class="line"> 第8章 Android中的浏览器编程 8.1 WebView简介 8.2 WebView浏览网页简单示例 8.3 WebView浏览网页复杂示例 8.4 Android中软件界面设计新大陆——采用HTML设计软件界面</span><br><span class="line"></span><br><span class="line"> 第9章 彻底剖析Android中软件的启动和退出 9.1 软件启动过程深入剖析 9.2 单个Activity和多个Acitivity退出及源码剖析 9.3 退出软件方式 附录 如何成为Android高手V2.0：结合云计算和智能终端、软硬整合</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B006NZMCS4/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B006NZMCS4&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51DB2P0gcIL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发从入门到精通</title>
    <url>/2020/04/19/B006VQ7IA2/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android开发从入门到精通<br>作者信息： 作者: 扶松柏 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Android开发从入门到精通》定位于Android的中高级用户，还可以作为向此领域发展的程序员的参考书。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章走进Android世界</span><br><span class="line">1.1智能手机飞速发展</span><br><span class="line">1.1.1主流手机系统介绍</span><br><span class="line">1.1.2Android横空出世</span><br><span class="line">1.2Android何以风靡世界</span><br><span class="line">1.2.1丰厚的奖励机制</span><br><span class="line">1.2.2商家的支持</span><br><span class="line">1.2.3光明的前景</span><br><span class="line">1.3搭建Android应用开发环境</span><br><span class="line">1.3.1安装AndroidSDK的系统要求</span><br><span class="line">1.3.2安装JDK、Eclipse、AndroidSDK</span><br><span class="line">1.3.3设定AndroidSDKHome</span><br><span class="line">l.3.4验证开发环境</span><br><span class="line">1.3.5创建Android虚拟设备（AVD）</span><br><span class="line">1.3.6常见的几个问题</span><br><span class="line">1.3.7SDK工具集</span><br><span class="line">1.4Android模拟器</span><br><span class="line">1.4.1Android模拟器简介</span><br><span class="line">1.4.2模拟器和真机究竟有何区别</span><br><span class="line">1.4.3模拟器简单总结</span><br><span class="line">1.5纵览Andr0Id体系</span><br><span class="line">1.5.1简析Android安装文件</span><br><span class="line">1.5.2Android体系结构介绍</span><br><span class="line">1.5.3Android应用工程文件组成</span><br><span class="line">1.5.4应用程序的生命周期</span><br><span class="line">第2塞界面布局实战演练</span><br><span class="line">2.1使用线性布局（LinearLayout）</span><br><span class="line">2.2使用相对布局（RelativeLavout）</span><br><span class="line">2.3使用表格布局（TableLayout）</span><br><span class="line">2.4使用绝对布局（AbsoluteLayout）</span><br><span class="line">2.5使用标签布局（TabLayout）</span><br><span class="line">2.6使用层布局（FrameLayout）</span><br><span class="line">2.7使用桌面组件Widget来布局</span><br><span class="line">2.7.1在屏幕中实现一个按钮效果</span><br><span class="line">2.7.2在屏幕中显示一段文字</span><br><span class="line">2.7.3设置手机屏幕中的字体</span><br><span class="line">2.7.4在屏幕中显示编辑框</span><br><span class="line">2.7.5在屏幕中显示复选框</span><br><span class="line">2.7.6在屏幕中显示单选框</span><br><span class="line">2.7.7在屏幕中显示下拉列表框</span><br><span class="line">2.7.8在屏幕中实现自动输入文本</span><br><span class="line">第3章基本控件实战演练</span><br><span class="line">3.1使用RadioGroup控件实现选择处理</span><br><span class="line">3.2使用屏幕中实现一个购物清单</span><br><span class="line">3.3在手机屏幕中实现相框效果</span><br><span class="line">3.4在屏幕中实现选择处理</span><br><span class="line">3.5在屏幕中实现一个相簿功能</span><br><span class="line">3.6开发一个文件搜索程序</span><br><span class="line">3.7模拟实现一个时钟效果</span><br><span class="line">3.8在手机屏幕中实现进度条效果</span><br><span class="line">3.9开发一个自动选择日期和时间的程序</span><br><span class="line">3.10在收集屏幕中显示磁盘中的图片</span><br><span class="line">3.11触动Menu菜单控件</span><br><span class="line">3.12使用SimpleAdapter实现ListView组件的效果</span><br><span class="line">3.13在屏幕中实现抽屉样式效果</span><br><span class="line">3.14使用Toast和Notification实现提醒效果</span><br><span class="line">3.15添加／删除Spinnerl的菜单</span><br><span class="line">第4章数据存储实战演练</span><br><span class="line">4.1使用SharedPrefererices存储</span><br><span class="line">4.2使用SQLite存储</span><br><span class="line">4.3使用ContentProyider存储</span><br><span class="line">4.4开发一个日记簿项目</span><br><span class="line">4.5升级日记簿功能</span><br><span class="line">第5章通信领域实战演练</span><br><span class="line">5.1拨号、邮件和网址处理</span><br><span class="line">5.2拨打电话</span><br><span class="line">5.3发送短信交互</span><br><span class="line">5.4发送邮件</span><br><span class="line">5.5实现震动效果</span><br><span class="line">5.6搜索通讯录</span><br><span class="line">5.7使用Wi—Fi</span><br><span class="line">5.8触摸拨号</span><br><span class="line">5.9获取设备运营商信息</span><br><span class="line">第6章自动服务实战演练</span><br><span class="line">6.1来短信自动提醒</span><br><span class="line">6.2自动显示剩余电量</span><br><span class="line">6.3来短信E—mail通知</span><br><span class="line">6.4来电后显示提示信息</span><br><span class="line">6.5获取手机存储卡的容量</span><br><span class="line">6.5.1一些基本知识</span><br><span class="line">6.5.2具体实现</span><br><span class="line">6.6闹钟到时响</span><br><span class="line">6.7黑名单来电自动静音</span><br><span class="line">6.8监听发送的短信是否成功</span><br><span class="line">第7章互联网实战演练</span><br><span class="line">7.1浏览指定的网页</span><br><span class="line">7.2加载显示HTML程序</span><br><span class="line">7.3使用浏览器打开网页</span><br><span class="line">7.4显示网络中的照片</span><br><span class="line">7.5播放在线音乐</span><br><span class="line">7.6下载在线手机铃声</span><br><span class="line">7.7开发一个简易RSS系统</span><br><span class="line">第日章多媒傩实战演练</span><br><span class="line">8.1获取图片的宽和高</span><br><span class="line">8.2绘制各种几何图形</span><br><span class="line">8.3开发一个手机屏保程序</span><br><span class="line">8.4在屏幕上触摸移动照片</span><br><span class="line">8.5调节音量</span><br><span class="line">8.6播放MP3音乐</span><br><span class="line">8.7开发一个录音机程序</span><br><span class="line">8.8开发一个拍照程序</span><br><span class="line">8.9开发一个视频播放器</span><br><span class="line">第9章Google地图实战演练</span><br><span class="line">9.1获取当前位置的坐标</span><br><span class="line">9.2在手机中使用谷歌地图</span><br><span class="line">9.3输入坐标后在地图中实现定位</span><br><span class="line">9.4在手机中实现地址查询</span><br><span class="line">9.5实现路径导航</span><br><span class="line">9.6移动手机时自动更新位置</span><br><span class="line">9.7在地图中绘制线路并计算距离</span><br><span class="line">9.8在谷歌地图中显示指定的位置</span><br><span class="line">第10章GoogleApI实战演练</span><br><span class="line">10.1模拟验证官方账号</span><br><span class="line">10.2实现Google搜索</span><br><span class="line">10.3在手机中生成二维条码</span><br><span class="line">1O.4手机翻译</span><br><span class="line">第11章游戏实战演练</span><br><span class="line">11.1益智类游戏——魔塔</span><br><span class="line">11.2竞技类游戏——中国象棋</span><br><span class="line">第12章优化和发布项目</span><br><span class="line">12.1UI界面中优化之标签</span><br><span class="line">12.2测试计算机的性能</span><br><span class="line">12.3测试内存性能</span><br><span class="line">12.4AndroidLayout优化</span><br><span class="line">12.5优化模拟器</span><br><span class="line">12.6发布自己的作品来盈利</span><br><span class="line">12.6.1申请会员</span><br><span class="line">12.6.2生成签名文件</span><br><span class="line">12.6.3使用签名文件</span><br><span class="line">12.6.4发布</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B006VQ7IA2/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B006VQ7IA2&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51zS5OzXFRL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习路线图•C语言必须知道的300个问题</title>
    <url>/2020/04/19/B007BJM5CE/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C语言学习路线图•C语言必须知道的300个问题<br>作者信息： 作者: 明日科技 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《C语言学习路线图•C语言必须知道的300个问题》提供了内容丰富的配套资源，找到《C语言学习路线图•C语言必须知道的300个问题》后，在该页面的“网络资源”超链接处下载也可以访问《C语言学习路线图•C语言必须知道的300个问题》的新浪微博，根据提示链接下载。C语言学习路线图，为读者朋友提供了从入门到实际项目开发所需要的各方面必备知识，提供了较为完善的学习整体解决方案，搭起了从学校走向社会的桥梁各个品种既有前后关联，也可以独立使用从而避免了像以前那样，学完一本书之后，仍然无所适从，既不会做项目也不知道接下来该学什么，以至于半途而废的困惑。快速服务：微博、QQ在线服务，自学视频：72集大型多媒体自学视频，海量资源：模块库、案例库、素材库、题库。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 初识c语言</span><br><span class="line">问题1 c语言是如何发展起来的？</span><br><span class="line">问题2 什么是ansi标准？</span><br><span class="line">问题3 c语言编写程序的优点有哪些？</span><br><span class="line">问题4 如何规避c语言的不足之处？</span><br><span class="line">问题5 c语言的应用领域有哪些？</span><br><span class="line">问题6 什么是c99标准？与c89标准相比，c99标准有哪些新特性？</span><br><span class="line">问题7 c语言是c++的子集吗？</span><br><span class="line">问题8 c语言程序的开发过程是怎样的？</span><br><span class="line">问题9 什么是编译程序和解释程序？</span><br><span class="line">问题10 ansi c的编译限制有哪些？ </span><br><span class="line"></span><br><span class="line"> 第2章 一个简单的c程序 问题11 c语言的入口函数是什么？ 问题12 c语言程序由哪些部分组成？ 问题13 如何在turbo c 2.0中输入一个程序？ 问题14 如何在visual c++ 6.0中运行一个c程序？ 问题15 如何在visual c++ 2008中运行一个c程序？ 问题16 如何提高程序的可读性？ 问题17 什么是关键字？c语言的关键字有哪些？ 问题18 什么是标识符？使用标识符的注意事项是什么？ 问题19 void关键字都有哪些用途？ 问题20 什么是匈牙利命名约定？它是否是好的约定？</span><br><span class="line"></span><br><span class="line"> 第3章 算法入门 问题21 为什么说算法是程序设计的灵魂？ 问题22 算法的特性有哪些？ 问题23 如何评价一个算法的好坏？ 问题24 算法的表示方法都有哪些？ 问题25 算法的基本结构是什么？ 问题26 算法有哪几类？ 问题27 算法的效率度量方法有哪些？ 问题28 什么是算法的时间复杂度？ 问题29 什么是算法的空间复杂度？ 问题30 什么是分治法算法思想？</span><br><span class="line"></span><br><span class="line"> 第4章 常用数据类型 问题31 声明变量和定义变量的区别是什么？ 问题32 在开发时如何决定使用哪种数据类型？ 问题33 什么是常量？如何区分常量和变量？ 问题34 各种数据类型所占的内存是多少？ 问题35 字符与字符串的差别有哪些？ 问题36 变量是否必须初始化？ 问题37 为什么会发生数据溢出？如何避免数据溢出？ 问题38 局部变量和全局变量能否重名？ 问题39 全局变量可不可以定义在可被多个.c文件包含的头文件中？为什么？ 问题40 如何引用一个已经定义过的外部变量？ 问题41 全局变量和局部变量的存储方式有什么区别？ 问题42 整型常量的存储形式是怎样的？ 问题43 整型常量的表示形式有哪几种？ 问题44 使用了没定义的变量会有什么现象？ 问题45 static关键字有什么作用？ 问题46 const关键字有什么作用？ 问题47 const与#define相比有何优点？ 问题48 sizeof不是函数吗？ 问题49 float类型数如何与0值比较？ 问题50 静态变量与自动变量的区别有哪些？</span><br><span class="line"></span><br><span class="line"> 第5章 运算符与表达式 问题51 运算符的优先级和结合性是怎样的？ 问题52 如何区分“，”是运算符还是分隔符？ 问题53 c语言如何解释x&#x3D;a+&#x3D;b+c？ 问题54 x&#x3D;x+1，x+&#x3D;1，x++，哪个效率最高？ 问题55 什么是运算符的目？怎样进行区分？ 问题56 使用“++”和“——”运算符需要注意些什么？ 问题57 如何理解i+++j？ 问题58 赋值表达式中什么是左值和右值？数组名作为左右值时又具有怎样的意义？ 问题59 如何确定条件表达式的结果的数据类型？ 问题60 “%”运算符是否可以对小数进行运算？ 问题61 “&#x2F;”运算符得到的结果一定为整数吗？ 问题62 在进行多种数据类型混合运算的时候，数据类型自动转换有哪些规则？ 问题63 c语言中有哪些简化的运算表达式？ 问题64 使用逻辑表达式需要注意哪几点问题？ 问题65 i++*i++这样的表达式为什么不能得到预期的结果？ 问题66 a[i]&#x3D;i++;这样的代码正确吗？ 问题67 编写表达式时需要注意什么？ 问题68 如何理解c&#x3D;a,b;？ 问题69 为无符号类型变量赋值时，数据类型应怎样转换？ 问题70 c语言表达式的求值顺序总是按照运算符的结合性保证“自左至右”或者“自右至左”吗？</span><br><span class="line"></span><br><span class="line"> 第6章 输入&#x2F;输出函数 问题71 函数printf（）的基本格式是什么？ 问题72 如何认识printf（）函数的格式字符？ 问题73 函数printf（）的标志有几种？如何使用？ 问题74 如何控制输出最小宽度？ 问题75 如何控制输出精度？ 问题76 如何控制输出长度？ 问题77 如何动态设置输出宽度和精度？ 问题78 printf（）函数的返回值是什么？ 问题79 如何理解输出列表？ 问题80 函数scanf（）的基本格式是什么？ 问题81 scanf（）函数的格式字符是什么？ 问题82 使用scanf（）函数应注意的问题是什么？ 问题83 scanf（）函数的返回值是什么？ 问题84 如何使用getchar（）函数？ 问题85 getch（）函数如何使用？ 问题86 如何应用gets（）函数？ 问题87 如何应用putch（）函数？ 问题88 puts（）函数该如何应用？ 问题89 如何控制多数值的输入？ 问题90 如何输入字符数组？</span><br><span class="line"></span><br><span class="line"> 第7章 选择、分支结构程序设计 问题91 5]4]3为什么不成立——谈谈关系表达式的值 问题92 &#x3D;和&#x3D;&#x3D;如何区分？ 问题93 什么叫逻辑短路？ 问题94 if语句的基本形式有哪些？如何应用？ 问题95 浮点数的相等比较是否可以用&#x3D;&#x3D;？ 问题96 关系运算符和数学不等号有什么区别？ 问题97 if语句后面一定不能写分号吗？ 问题98 这个程序为什么多执行了好多语句？ 问题99 不用关系表达式和逻辑表达式做条件 问题100 怎样理解复合语句中的变量？ 问题101 如何进行if语句的嵌套？ 问题102 条件运算符“？ :”怎样应用？ 问题103 switch语句的基本格式是什么？ 问题104 if语句与switch语句的优缺点是什么？ 问题105 switch语句中的default关键字是否必须？ 问题106 break关键字在switch语句中应注意什么？ 问题107 如何正确判断if和else的匹配？ 问题108 switch和case后的表达式值的类型是否可以是浮点型？ 问题109 区段划分型条件有什么技巧？ 问题110 default必须写在所有case之后吗？</span><br><span class="line"></span><br><span class="line"> 第8章 循环结构 问题111 循环结构的基本概念是什么？ 问题112 while语句的基本格式是什么？ 问题113 while循环应注意什么问题？ 问题114 for循环语句的基本格式是什么？ 问题115 for语句的三个表达式都是必须的吗？ 问题116 do…while语句的基本格式是什么？ 问题117 分号在循环体中的作用？ 问题118 while与do…while的区别？ 问题119 什么是循环嵌套？ 问题120 循环嵌套的结构是怎样的？ 问题121 如何正确使用循环嵌套？ 问题122 死循环是怎样产生的？ 问题123 怎样提高循环语句的效率？ 问题124 continue语句的基本作用是什么？ 问题125 break语句的基本作用是什么？ 问题126 goto语句的基本格式是什么？如何使用？ 问题127 goto语句的缺陷是什么？ 问题128 如何选择循环语句？ 问题129 如何判定循环结束和提前结束？ 问题130 如何避免循环中的初值错误问题？</span><br><span class="line"></span><br><span class="line"> 第9章 数组 问题131 什么是数组？其存储有何特点？ 问题132 数组的维数该如何理解？ 问题133 一维数组是怎样定义的？ 问题134 如何引用一维数组元素？ 问题135 如何初始化一维数组？ 问题136 如何设计数组的排序算法？ 问题137 如何定义二维数组？ 问题138 如何引用二维数组元素？ 问题139 如何初始化二维数组？ 问题140 如何定义字符数组？ 问题141 如何初始化字符数组？ 问题142 如何引用字符数组？ 问题143 如何进行字符数组的复制？ 问题144 如何进行字符数组的连接？ 问题145 如何进行字符串的比较？ 问题146 如何测定字符串的长度？ 问题147 如何进行字符串大小写的相互转换？ 问题148 如何计算字符串中有多少个单词？ 问题149 gets（）函数和scanf（）函数在输入字符串时有何区别？ 问题150 puts（）函数和printf（）函数在输出字符串时有何区别？ 问题151 数组与指针的区别是什么？ 问题152 为什么作为函数形参的数组和指针可以互换？ 问题153 为什么数组名作参数传递给子函数时，子函数可以改变主函数中数组的值？ 问题154 c语言中有动态数组吗？ 问题155 如何实现动态二维数组？ 问题156 strcpy（）函数可以复制字符串的一部分吗？ 问题157 字符串和字符数组有什么区别？ 问题158 ‘\0&#39;和“\0”有什么区别？ 问题159 字符数组占用内存怎样算？ 问题160 用字符数组和指针两种方式定义的字符串有什么不同？</span><br><span class="line"></span><br><span class="line"> 第10章 函数编程基础 问题161 什么是函数？如何分类？ 问题162 如何定义无参函数？ 问题163 如何定义有参函数？ 问题164 什么是空函数？作用是什么？ 问题165 什么是形参和实参？如何使用？ 问题166 如何从函数返回？ 问题167 函数返回值你了解多少？ 问题168 如何进行函数的一般调用？ 问题169 函数调用的基本方式有几种？各是什么？ 问题170 函数调用应具备哪些条件？ 问题171 如何进行函数的嵌套调用？ 问题172 什么是递归调用？如何实现？ 问题173 函数如何将数组元素作为实参？ 问题174 如何将数组名作为函数参数？ 问题175 如何将多维数组名作为函数参数？ 问题176 什么是局部变量？ 问题177 什么是全局变量？如何应用？ 问题178 存储方式有哪几种？分别是什么？ 问题179 如何使用auto关键字？ 问题180 什么是静态变量？如何实现？ 问题181 什么是寄存器变量？如何实现？ 问题182 如何声明外部变量？ 问题183 如何调用编译后的函数？ 问题184 如何限定外部变量的使用范围？ 问题185 如何使用函数调用实现对字符串的统计？ 问题186 main（）函数有什么作用？ 问题187 什么是内部函数？ 问题188 什么是外部函数？怎么用？ 问题189 static（）函数与普通函数有什么区别？ 问题190 形参和实参有什么区别？</span><br><span class="line"></span><br><span class="line"> 第11章 指针解析 问题191 什么是指针？什么是指针变量？ 问题192 如何创建指针？ 问题193 如何初始化指针？ 问题194 如何使用指针？ 问题195 函数中如何传递指针？ 问题196 指针、数组和地址之间的关系是什么？ 问题197 如何进行指针运算？ 问题198 如何使用指针操作数组？ 问题199 如何用指针表示多维数组？ 问题200 如何使用指针操作多维数组？ 问题201 如何用指针为函数传递数组？ 问题202 如何用指针表示字符串？ 问题203 如何使用字符串指针作为函数参数？ 问题204 字符数组和字符指针的区别是什么？ 问题205 什么是指针数组？ 问题206 如何使用指针数组处理字符串？ 问题207 如何将指针数组作为函数的参数？ 问题208 什么是指向指针的指针？ 问题209 二级指针如何应用于一维数组？ 问题210 如何实现二级指针对二维数组的操作？ 问题211 二级指针如何操作字符串数组（指针数组）？ 问题212 如何理解返回指针的函数？ 问题213 什么是指向函数的指针？ 问题214 如何用const控制指针？ 问题215 什么是“野指针”？ 问题216 main（）函数的指针数组形参是怎么回事？ 问题217 void指针就是空指针吗？它有什么作用？ 问题218 指针是一种特殊的变量，只能用来保存地址。这句话对吗？ 问题219 字符指针、浮点数指针以及函数指针这三种类型的变量哪个占用的内存最大？为什么？ 问题220 一个32位的机器，该机器的指针是多少位？</span><br><span class="line"></span><br><span class="line"> 第12章 常用数据结构 问题221 空结构体所占的内存是多少？ 问题222 在c语言中，一个结构体可以包含指向自己的指针吗？ 问题223 struct person&#123;…&#125;;person a;为什么编译出错？ 问题224 怎样从&#x2F;向数据文件读&#x2F;写结构？ 问题225 枚举与#define宏的区别有哪些？ 问题226 如何看待枚举类型，枚举类型的优点是什么？ 问题227 关键字typedef的功能是什么？ 问题228 类型定义是否允许嵌套？ 问题229 typedef与#define宏的相似之处与不同之处是什么？ 问题230 什么是散列法？ 问题231 大小端模式对union类型数据有什么影响？ 问题232 如何为联合体变量赋初值？ 问题233 如何证明联合体变量的所有成员是共享一个内存单元的？ 问题234 堆和栈的区别是什么？ 问题235 举例说明，什么是静态链表？什么是动态链表？ 问题236 单向链表、双向链表和循环链表有什么区别？ 问题237 如何在链表中的指定位置插入结点？ 问题238 如何删除链表中指定位置的结点？ 问题239 如何创建一个动态链表？ 问题240 指向结构体数组的指针如何应用？</span><br><span class="line"></span><br><span class="line"> 第13章 位运算操作符 问题241 什么是位运算？位运算符包括哪些？ 问题242 移位运算中如何补位？ 问题243 移位运算符与加减运算符的优先级哪个较高？ 问题244 什么是循环移位？ 问题245 什么是位段？其优点是什么？ 问题246 如何正确使用位段？ 问题247 数据在计算机中的存储单位有哪些？有几种存储形式？</span><br><span class="line"></span><br><span class="line"> 第14章 存储管理 问题248 与内存息息相关的重要概念有哪些？ 问题249 指针指向不合法引起了哪些内存问题？ 问题250 内存分配与释放引起的常见问题有哪些？ 问题251 什么是内存越界？什么是内存泄露？二者是如何产生的？ 问题252 c语言提供了哪些动态内存分配函数？ 问题253 malloc（）函数与calloc（）函数有什么区别？ 问题254 内存耗尽怎么办？ 问题255 动态内存会被自动释放吗？ 问题256 高位优先与低位优先的不同之处是什么？ 问题257 free（）和delete（）怎样处理指针？ 问题258 怎样利用好敏感的内存资源？</span><br><span class="line"></span><br><span class="line"> 第15章 预处理和函数类型 问题259 在头文件中#if、stdc等字符起什么作用？ 问题260 如何书写多条语句宏？ 问题261 预处理中#和##运算符是什么意思？ 问题262 一个头文件可以包含另一个头文件吗？ 问题263 #include[]和#include“”有什么区别？ 问题264 什么是无参宏定义？ 问题265 什么是带参宏定义？ 问题266 怎样写参数个数可变的宏？ 问题267 #pragma预处理的作用是什么？ 问题268 条件编译的表达形式有哪些？ 问题269 如何应用内部函数？ 问题270 如何应用外部函数？</span><br><span class="line"></span><br><span class="line"> 第16章 文件的读写操作 问题271 各个读写操作的区别是什么？ 问题272 c语言文件有哪几类？ 问题273 怎样写数据文件，使之可以在不同字大小、字节顺序或浮点格式的机器上读入？ 问题274 能否使用fflush（）函数清除多余的输入？ 问题275 fopen（）函数打开文件失败的原因是什么？ 问题276 为什么打开文件后要及时关闭？ 问题277 文件的打开方式有哪些？ 问题278 如何正确使用putchar（）函数和getchar（）函数？ 问题279 getchar（）函数、getch（）函数和getche（）函数的区别是什么？ 问题280 使用printf（）函数和scanf（）函数需要注意什么？ 问题281 printf（）函数有哪些参数？ 问题282 scanf（）函数的格式控制包括哪些？ 问题283 printf（）函数和scanf（）函数格式符的修饰符“*”有什么作用？ 问题284 fscanf（）函数、fprintf（）函数与scanf（）函数和printf（）函数有什么不同？ 问题285 如何判断文件的结束？</span><br><span class="line"></span><br><span class="line"> 第17章 图形图像处理 问题286 为什么在使用图形函数时要首先初始化图形模式？ 问题287 怎样初始化图形模式？ 问题288 初始化时提示“bgi error: graphics not initialized（use ‘initgraph&#39;）”怎么办？ 问题289 怎样利用c语言建立独立的图形运行程序？ 问题290 tc中有几个画线函数？怎么使用？ 问题291 tc中有几个画矩形函数？怎么使用？ 问题292 tc中有几个画圆函数？怎么使用？ 问题293 如何使用c语言填充封闭图形？ 问题294 tc中有几个和光标有关的函数？怎样使用？ 问题295 如何在图形模式下输出文本？ 问题296 背景色、线条颜色和填充颜色有什么区别？何时使用？ 问题297 怎样记住那么多的颜色？ 问题298 线条样式和填充样式都有哪些？怎样设置？ 问题299 怎样复制图形？ 问题300 怎样在c语言中制作动画？</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B007BJM5CE/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B007BJM5CE&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51WxBeGvCSL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>Android多媒体开发高级编程 为智能手机和平板电脑开发图形、音乐、视频和富媒体应用</title>
    <url>/2020/04/19/B007H4NZEK/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android多媒体开发高级编程 为智能手机和平板电脑开发图形、音乐、视频和富媒体应用<br>作者信息： 作者: 艾佛瑞(Shawn Van Every) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Android多媒体开发高级编程:为智能手机和平板电脑开发图形、音乐、视频和富媒体应用》是利用Android多媒体API创建动态移动应用程序。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 Android图像概述</span><br><span class="line">1.1 使用内置的Camera应用程序捕获图像</span><br><span class="line">1.1.1 从Camera应用程序返回数据</span><br><span class="line">1.1.2 捕获更大的图像</span><br><span class="line">1.1.3 显示大图像</span><br><span class="line">1.2 图像存储和元数据</span><br><span class="line">1.2.1 获得图像的Uri</span><br><span class="line">1.2.2 更新Camera Activity以使用Media Store存储图像和关联元数据</span><br><span class="line">1.2.3 使用Media Store检索图像</span><br><span class="line">1.2.4 创建图像查看应用程序</span><br><span class="line">1.2.5 内部元数据</span><br><span class="line">1.3 本章小结 </span><br><span class="line"></span><br><span class="line"> 第2章 构建定制的Camera应用程序 2.1 使用Camera类 2.1.1 CAMERA权限 2.1.2 预览Surface 2.1.3 实现Camera对象 2.1.4 汇总 2.2 扩展定制的Camera应用程序 2.2.1 构建基于定时器的Camera应用程序 2.2.2 构建时间推移摄影应用程序 2.3 本章小结</span><br><span class="line"></span><br><span class="line"> 第3章 图像编辑和处理 3.1 使用内置Gallery应用程序选择图像 3.2 在位图上绘制位图 3.3 基本的图像缩放和旋转 3.3.1 输入矩阵 3.3.2 Matrix类的方法 3.4 图像处理 3.4.1 ColorMatrix 3.4.2 改变对比度和亮度 3.4.3 改变饱和度 3.5 图像合成 3.6 本章小结</span><br><span class="line"></span><br><span class="line"> 第4章 图形和触摸事件 4.1 画布绘图 4.1.1 位图创建 4.1.2 位图配置 4.1.3 创建Canvas对象 4.1.4 使用Paint对象 4.1.5 绘制形状 4.1.6 绘制文本 4.2 手指绘图 4.2.1 触摸事件 4.2.2 在现有图像上绘制 4.2.3 保存基于位图的画布绘图 4.3 本章小结</span><br><span class="line"></span><br><span class="line"> 第5章 Android音频概述 5.1 音频播放 5.1.1 支持的音频格式 5.1.2 通过意图使用内置的音频播放器 5.1.3 创建自定义的音频播放应用程序 5.1.4 用于音频的Media Store 5.2 本章小结</span><br><span class="line"></span><br><span class="line"> 第6章 后台和网络音频 6.1 后台音频播放 6.1.1 服务 6.1.2 加上Media Player的本地服务 6.1.3 控制服务中的Media Player 6.2 网络音频 6.2.1 HTTP音频播放 6.2.2 通过HTTP的流式音频 6.2.3 RTSP音频流 6.3 本章小结</span><br><span class="line"></span><br><span class="line"> 第7章 音频捕获 7.1 通过意图捕获音频 7.2 定制音频捕获 7.2.1 Media Recorder音频源 7.2.2 Media Recorder输出格式 7.2.3 Media Recorder音频编码器 7.2.4 Media Recorder输出和录制 7.2.5 Media Recorder状态机 7.2.6 Media Recorder示例 7.2.7 其他的Media Recorder方法 7.3 将音频插入Media Store 7.4 使用Audio Record录制原始音频 7.5 使用Audio Track播放原始音频 7.6 捕获和播放原始音频的示例 7.7 本章小结</span><br><span class="line"></span><br><span class="line"> 第8章 音频合成与分析 8.1 数字音频合成 8.1.1 播放合成声音 8.1.2 生成样本 8.2 音频分析 8.2.1 捕获声音以进行分析 8.2.2 可视化频率 8.3 本章小结</span><br><span class="line"></span><br><span class="line"> 第9章 视频概述 9.1 视频播放 9.1.1 支持的格式 9.1.2 使用意图播放 9.1.3 使用Video View播放 9.1.4 使用Media Controller添加控制 9.1.5 使用Media Player播放 9.2 本章小结</span><br><span class="line"></span><br><span class="line"> 第10章 视频进阶 10.1 使用Media Store检索视频 10.1.1 来自Media Store的视频缩略图 10.1.2 完整的Media Store视频示例 10.2 网络视频 10.2.1 支持的网络视频类型 10.2.2 网络视频播放 10.3 本章小结</span><br><span class="line"></span><br><span class="line"> 第11章视频捕获 11.1 使用意图录制视频 11.2 添加视频元数据 11.3 定制视频捕获 11.3.1 将Media Recorder用于视频 11.3.2 定制视频捕获的完整示例 11.4 本章小结</span><br><span class="line"></span><br><span class="line"> 第12章 使用Web服务的媒体消费和发布 12.1 Web服务 12.2 HTTP请求 12.3 JSON 12.3.1 使用JSON提取Flickr图像 12.3.2 位置 12.3.3 使用JSON和位置提取Flickr图像 12.4 REST 12.4.1 以XML表示数据 12.4.2 SAX分析 12.5 HTTP文件上传 12.5.1 生成HTTP请求 12.5.2 上传视频到Blip TV 12.6 本章小结</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B007H4NZEK/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B007H4NZEK&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51Blc6-c2uL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android框架揭秘</title>
    <url>/2020/04/19/B007PMPHJA/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android框架揭秘<br>作者信息： 作者: 金泰延 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Android框架揭秘》由人民邮电出版社出版。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目　录 </span><br><span class="line"></span><br><span class="line"> 第1章　Android Framework概要　1 1.1　Android源代码组成　2 1.2　通过启动过程分析Android Framework　3</span><br><span class="line"></span><br><span class="line"> 第2章　搭建Android开发环境　7 2.1　主机环境构成　7 2.1.1　安装VirtualBox　7 2.1.2　安装Ubuntu　8 2.2　搭建Android平台编译环境　9 2.2.1　编译工具　10 2.2.2　安装Repo　11 2.2.3　下载Android源代码　11 2.2.4　编译Android源代码　12 2.3　搭建Android SDK开发环境　13 2.3.1　下载、安装Eclipse　13 2.3.2　下载Android SDK starter　13 2.3.3　安装ADT插件　14 2.3.4　设置Android SDK路径　16 2.3.5　安装Android SDK　16 2.4　开发Android应用程序　18 2.5　应用程序Framework源码级别调试　21 2.5.1　加载应用程序Framework源　21 2.5.2　调试HelloWorld Framework(源码级)　24 2.6　小结　27</span><br><span class="line"></span><br><span class="line"> 第3章　init进程　29 3.1　init进程运行过程　29 3.2　init进程源码分析　31 3.3　init.rc脚本文件分析与执行　40 3.3.1　动作列表(Action List)　41 3.3.2　服务列表(Service List)　43 3.3.3　init.rc文件分析函数　44 3.3.4　动作列表与服务列表的运行　48 3.4　创建设备节点文件　52 3.4.1　创建静态设备节点　52 3.4.2　动态设备感知　57 3.5　进程的终止与再启动　58 3.6　属性服务　62 3.6.1　属性初始化　63 3.6.2　属性变更请求处理　65 3.7　小结　67</span><br><span class="line"></span><br><span class="line"> 第4章　JNI与NDK　69 4.1　Android与JNI　69 4.2　JNI的基本原理　72 4.2.1　在Java中调用C库函数　72 4.2.2　小结　83 4.3　调用JNI函数　84 4.3.1　调用JNI函数的示例程序结构　84 4.3.2　Java层代码(JniFuncMain.java)　85 4.3.3　分析JNI本地函数代码　87 4.3.4　编译及运行结果　101 4.3.5　在Android中的应用举例　102 4.4　在C程序中运行Java类　102 4.4.1　Invocation API应用示例　103 4.4.2　编译及运行　108 4.4.3　Invocation API在Android中的应用举例：Zygote进程　110 4.5　直接注册JNI本地函数　110 4.5.1　加载本地库时，注册JNI本地函数　111 4.5.2　Android中的应用举例　115 4.6　使用Android NDK开发　122 4.6.1　安装Android NDK　123 4.6.2　使用Android NDK开发步骤　127 4.6.3　小结　136</span><br><span class="line"></span><br><span class="line"> 第5章　Zygote　137 5.1　Zygote是什么　137 5.2　由app_process运行ZygoteInit class　142 5.2.1　生成AppRuntime对象　143 5.2.2　调用AppRuntime对象　144 5.2.3　创建Dalvik虚拟机　145 5.2.4　运行ZygoteInit类　146 5.3　ZygoteInit类的功能　147 5.3.1　绑定&#x2F;dev&#x2F;socket&#x2F;zygote套接字　149 5.3.2　加载应用程序Framework中的类与平台资源　150 5.3.3　运行SystemServer　155 5.3.4　运行新Android应用程序　158</span><br><span class="line"></span><br><span class="line"> 第6章　Android服务概要　163 6.1　示例程序：理解Android服务的运行　163 6.2　Android服务的种类　166 6.3　Android应用程序服务　168 6.4　Android系统服务　182 6.5　运行系统服务　185 6.5.1　分析媒体服务器(Media Server)的运行代码　186 6.5.2　分析系统服务器(System Server)的运行代码　188 6.6　Android Service Framework、Binder Driver概要及相关术语　192</span><br><span class="line"></span><br><span class="line"> 第7章　Android Binder IPC　197 7.1　Linux内存空间与Binder Driver　197 7.2　Android Binder Model　199 7.2.1　Binder IPC数据传递　201 7.2.2　Binder IPC数据流　202 7.2.3　Binder协议(Binder Protocol)　204 7.2.4　RPC代码与RPC数据　206 7.2.5　Binder寻址(Binder Addressing)　206 7.3　Android Binder Driver分析　209 7.3.1　从进程的角度看服务的使用　210 7.3.2　从Binder Driver角度看服务的使用　214 7.3.3　Binder Driver函数分析　219 7.4　Context Manager　251 7.5　小结　256</span><br><span class="line"></span><br><span class="line"> 第8章　Android Service Framework　257 8.1　服务框架(Service Framework)　257 8.2　服务框架(Service Framework)的构成　259 8.2.1　各层构成元素的配置　260 8.2.2　各层构成元素间的相互作用　261 8.2.3　类的结构　264 8.3　运行机制　266 8.3.1　服务接口　267 8.3.2　服务　273 8.3.3　服务代理(Service Proxy)　276 8.3.4　Binder IPC处理　280 8.4　本地服务管理器(Native Service Manager)　282 8.4.1　Service Manager概要　282 8.4.2　Service Manager类　284 8.4.3　Service Manager的运行　286 8.5　编写本地服务　314 8.5.1　设计HelloWorld系统服务　314 8.5.2　HelloWorld服务接口　315 8.5.3　HelloWorld服务　316 8.5.4　HelloWorld服务代理　319 8.5.5　运行HelloWorld服务　320 8.6　小结　325</span><br><span class="line"></span><br><span class="line"> 第9章　本地系统服务(Native System Service)分析　327 9.1　相机服务(Cameral Service)　327 9.2　相机应用程序　328 9.3　相机服务框架(Camera Service Framework)　331 9.3.1　相机服务框架层次结构　331 9.3.2　相机服务框架类　333 9.4　相机服务框架的运行　334 9.4.1　初始化相机服务　334 9.4.2　连接相机服务　335 9.4.3　相机服务连接过程分析　337 9.4.4　相机设置与控制　340 9.4.5　相机设置与控制分析　341 9.4.6　相机事件处理　342 9.4.7　相机事件处理分析　343 9.5　小结　345</span><br><span class="line"></span><br><span class="line"> 第10章　Java服务框架(Java Service Framework)　347 10.1　Java服务框架(Java Service Framework)　347 10.1.1　Java服务框架的层次结构　348 10.1.2　Java服务框架中各个类间的相互作用　351 10.2　运行机制　354 10.2.1　Java服务框架初始化　355 10.2.2　Binder　355 10.2.3　BinderProxy　361 10.2.4　Parcel　364 10.3　Java系统服务的实现　367 10.3.1　闹钟服务(Alarm Manager Service)分析　368 10.3.2　编写HelloWorldService系统服务　372 10.3.3　使用HelloWorldService系统服务　375 10.3.4　编译HelloWorldService系统服务　378 10.4　Java Service Manager　380 10.4.1　Java Service Manager简介　380 10.4.2　BinderInternal　381 10.4.3　Java Service Manager的运行实例　383 10.5　使用AIDL生成服务代理与服务Stub　389 10.5.1　在AIDL文件中定义服务接口　390 10.5.2　使用AIDL编译器，生成服务接口、服务Stub以及服务代理　391 10.5.3　继承Stub类创建服务　392 10.5.4　服务接口的调用　393 10.6　小结　394</span><br><span class="line"></span><br><span class="line"> 第11章　Java系统服务运行分析　395 11.1　Activity Manager Service　395 11.2　Activity Manager Service创建服务分析　397 11.2.1　Controller Activity-调用startService()方法　398 11.2.2　Activity Manager Service的startService()方法的调用过程(使用Binder RPC)　399 11.2.3　Activity Manager Service——运行startService() Stub方法　405 11.2.4　运行ActivityThread类的main() 方法　409 11.2.5　Activity Manager Service——attachApplication() Stub方法　414 11.3　小结　421</span><br><span class="line"></span><br><span class="line"> 附录　AIDL语法　423</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B007PMPHJA/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B007PMPHJA&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51WUFn33fVL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 3D游戏开发技术宝典 OpenGL ES 2.0</title>
    <url>/2020/04/19/B007UR03AI/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android 3D游戏开发技术宝典 OpenGL ES 2.0<br>作者信息： 作者: 吴亚峰 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Android 3D游戏开发技术宝典:OpenGL ES 2.0》适合Android程序员、游戏开发者及Android爱好者学习，也可以作为相关培训学校和大专院校相关专业的教学用书。《Android 3D游戏开发技术宝典:OpenGL ES 2.0》组织上本着“起点低，终点高”的原则，内容覆盖了从学习OpenGL ES 2.0必知必会的基础知识到基于OpenGL ES 2.0实现高级特效，最后还给出了3个完整的大型3D游戏案例。这3个案例均是笔者带领学员参加谷歌(Google)2011第二届Android应用开发中国大学生挑战赛的获奖作品，第22章的夜鹰行动更是获全国总决赛前5名大奖的作品。《Android 3D游戏开发技术宝典:OpenGL ES 2.0》中配合每个需要讲解的知识点都给出了丰富的插图与完整的案例，使得初学者易于上手，有一定基础的读者便于深入。书中所有的案例均是根据笔者多年的开发心得进行设计的，结构清晰明朗，便于读者进行学习。同时书中还给出了很多笔者多年来积累的编程技巧与心得，具有很高的参考价值。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 新一代的王者——Android概览</span><br><span class="line">1.1 智能手机市场现状</span><br><span class="line">1.1.1 五大智能手机操作系统</span><br><span class="line">1.1.2 智能手机市场的新星</span><br><span class="line">1.2 Android 平台的特点及未来的趋势</span><br><span class="line">1.2.1 全新理念带来的体验风暴</span><br><span class="line">1.2.2 中国手机市场的主导性作用</span><br><span class="line">1.2.3 手机3D游戏和应用增长迅速</span><br><span class="line">1.3 如何搭建Android开发环境</span><br><span class="line">1.3.1 SDK的安装及环境配置</span><br><span class="line">1.3.2 Eclipse集成开发环境的搭建</span><br><span class="line">1.3.3 创建并启动模拟器</span><br><span class="line">1.4 Hello Android应用程序的开发</span><br><span class="line">1.4.1 第一个Android应用程序</span><br><span class="line">1.4.2 Android应用程序的项目结构</span><br><span class="line">1.4.3 Android应用程序的调试</span><br><span class="line">1.4.4 实际设备的联机调试</span><br><span class="line">1.5 Android 应用程序运行的机制</span><br><span class="line">1.5.1应用程序的系统架构</span><br><span class="line">1.5.2 应用程序框架</span><br><span class="line">1.5.3 Android运行时</span><br><span class="line">1.5.4 系统库</span><br><span class="line">1.5.5底层Linux内核</span><br><span class="line">1.6 本章小结</span><br><span class="line">第2章 游戏开发相关Android基础知识</span><br><span class="line">2.1 游戏中的音效</span><br><span class="line">2.1.1 游戏中的即时音效</span><br><span class="line">2.1.2 即时音效的一个案例</span><br><span class="line">2.1.3 背景音乐播放技术</span><br><span class="line">2.1.4 简易音乐播放器的实现</span><br><span class="line">2.2 简单数据的存储——Preferences</span><br><span class="line">2.2.1 Preferences简介33</span><br><span class="line">2.2.2 Preferences实现访问时间的记录</span><br><span class="line">2.3 手机自带数据库——SOLite</span><br><span class="line">2.3.1 初识SOLite</span><br><span class="line">2.3.2 SQLite数据库的基本操作</span><br><span class="line">2.3.3 SQLite数据库的简单案例</span><br><span class="line">2.3.4 使用ContentProvider组件共享数据</span><br><span class="line">2.3.5 使用ContentResolver获取分享数据</span><br><span class="line">2.4.文件I／O</span><br><span class="line">2.4.1 访问SD卡中的文件</span><br><span class="line">2.4.2 访问手机中的文件夹</span><br><span class="line">2.4.3 读取assets文件夹下的内容</span><br><span class="line">2.5 2D动画的开发</span><br><span class="line">2.5.1 SurflaceView用法简介</span><br><span class="line">2.5.2 使用SurfaceView实现2D动画</span><br><span class="line">2.6 Socket网络通信</span><br><span class="line">2.6.1 Socket开发基本知识</span><br><span class="line">2.6.2 服务器端</span><br><span class="line">2.6.3 客户端</span><br><span class="line">2.7蓝牙通信</span><br><span class="line">2.7.1 蓝牙通信的基本知识</span><br><span class="line">2.7.2 聊天案例概览</span><br><span class="line">2.7.3 聊天案例的开发过程</span><br><span class="line">2.8 本章小结</span><br><span class="line">第3章 初识OpenGL ES 2.0</span><br><span class="line">3.1 OpenGL ES 2.0概览</span><br><span class="line">3.1.1 OpenGL ES 2.0简介</span><br><span class="line">3.1.2 初识 OpenGL ES 2.0 应用程序</span><br><span class="line">3.2 着色器与渲染管线</span><br><span class="line">3.2.1 OpenGL ES 1.x的渲染管线</span><br><span class="line">3.2.2 OpenGL ES 2.0的渲染管线</span><br><span class="line">3.2.3 OpenGL ES中立体物体的构建</span><br><span class="line">3.3 主流Android手机GPU大PK</span><br><span class="line">3.3.1 手机GPU大家族对比</span><br><span class="line">3.3.2 主流GPU的性能参数比较</span><br><span class="line">3.4 本章小结</span><br><span class="line">第4章 着色语言Shading Language</span><br><span class="line">4.1 着色语言概述</span><br><span class="line">4.2 着色语言基础</span><br><span class="line">4.2.1 数据类型概述</span><br><span class="line">4.2.2 数据类型的基本使用</span><br><span class="line">4.2.3 运算符</span><br><span class="line">4.2.4 类型转换</span><br><span class="line">4.2.5 限定符</span><br><span class="line">4.2.6 流程控制</span><br><span class="line">4.2.7 函数的声明与使用</span><br><span class="line">4.2.8 片元着色器中浮点变量精度的指定</span><br><span class="line">4.2.9 程序的基本结构</span><br><span class="line">4.3 特殊的内建变量</span><br><span class="line">4.3.1 顶点着色器中的内建变量</span><br><span class="line">4.3.2 片元着色器中的内建变量</span><br><span class="line">4.4 着色语言的内置函数</span><br><span class="line">4.4.1 角度转换与三角函数</span><br><span class="line">4.4.2 指数函数</span><br><span class="line">4.4.3 常见函数</span><br><span class="line">4.4.4 几何函数</span><br><span class="line">4.4.5 矩阵函数</span><br><span class="line">4.4.6 向量关系函数</span><br><span class="line">4.4.7 纹理采样函数</span><br><span class="line">4.4.8 微分函数</span><br><span class="line">4.5 本章小结</span><br><span class="line">第5章 投影及各种变换</span><br><span class="line">5.1 摄像机的设置</span><br><span class="line">5.2 两种投影方式</span><br><span class="line">5.2.1 正交投影</span><br><span class="line">5.2.2 透视投影</span><br><span class="line">5.3 各种变换</span><br><span class="line">5.3.1 基本变换的相关数学知识</span><br><span class="line">5.3.2 平移变换</span><br><span class="line">5.3.3 旋转变换</span><br><span class="line">5.3.4 缩放变换</span><br><span class="line">5.3.5 基本变换的实质</span><br><span class="line">5.4 绘制方式</span><br><span class="line">5.4.1 各种绘制方式概览</span><br><span class="line">5.4.2 点与线段绘制方式</span><br><span class="line">5.4.3 三角形条带与扇面绘制方式</span><br><span class="line">5.4.4.顶点法与索引法</span><br><span class="line">5.5 设置合理的视角</span><br><span class="line">5.6 卷绕和背面剪裁</span><br><span class="line">5.6.1 基本知识</span><br><span class="line">5.6.2 一个简单的案例</span><br><span class="line">5.7 本章小结</span><br><span class="line">……</span><br><span class="line">第6章 光照</span><br><span class="line">第7章 纹理映射</span><br><span class="line">第8章 3D基本形状的构建</span><br><span class="line">第9章 3D模型加载</span><br><span class="line">第10章 混合与雾</span><br><span class="line">第11章 常用3D开发技巧</span><br><span class="line">第12章 几种剪裁与测试</span><br><span class="line">第13章 顶点着色器的妙用</span><br><span class="line">第14章 片元着色器的妙用</span><br><span class="line">第15章 真实光学环境的模拟</span><br><span class="line">第16章 游戏开发中的物理学</span><br><span class="line">第17章 游戏的心脏——物理引擎</span><br><span class="line">第18章 传感器应用的开发</span><br><span class="line">第19章 游戏开发小贴士</span><br><span class="line">第20章 BN赛艇</span><br><span class="line">第21章 火力篮球</span><br><span class="line">第22章 夜鹰行动</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B007UR03AI/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B007UR03AI&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/519yrbvtBLL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android核心原理与系统级应用高效开发</title>
    <url>/2020/04/19/B008GUXLPM/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android核心原理与系统级应用高效开发<br>作者信息： 作者: 韩超 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Android核心原理与系统级应用高效开发》为Android系统级别的开发者系统化而有条理性地展示了庞大的Android系统的软件结构，点明开发思路；Android应用程序的开发者可以通过《Android核心原理与系统级应用高效开发》加深认识，拓展开发手段；从事Android硬件移植的开发者可以通过《Android核心原理与系统级应用高效开发》加深对系统全局的了解。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1篇 Android核心框架层开发</span><br><span class="line">第1章 Android系统框架</span><br><span class="line">1.1 Android系统基础结构</span><br><span class="line">1.2 Android的开发环境</span><br><span class="line">1.2.1 开发环境</span><br><span class="line">1.2.2 源代码获取</span><br><span class="line">1.2.3 编译Android源代码</span><br><span class="line">1.2.4 仿真器运行</span><br><span class="line">1.2.5 使用工具</span><br><span class="line">1.3 系统结构和代码结构</span><br><span class="line">1.3.1 软件系统结构</span><br><span class="line">1.3.2 源代码结构</span><br><span class="line">第2章 编译结构和各种构建</span><br><span class="line">2.1 Android的系统构建</span><br><span class="line">2.1.1 编译环境要求</span><br><span class="line">2.1.2 构建流程</span><br><span class="line">2.1.3 环境设置</span><br><span class="line">2.1.4 系统构建结果</span><br><span class="line">2.2 各种部件的构建</span><br><span class="line">2.2.1 Android.mk的语法</span><br><span class="line">2.2.2 各种部件的构建方式</span><br><span class="line">2.2.3 预编译内容的安装</span><br><span class="line">2.3 Android编译的板级支持</span><br><span class="line">2.3.1 支持一个板的工作</span><br><span class="line">2.3.2 buildspec.mk文件的作用</span><br><span class="line">2.3.3 vendersetup.sh和lunch命令</span><br><span class="line">2.3.4 BoardConfig.mk文件的作用</span><br><span class="line">2.3.5 AndroidProducts.mk文件</span><br><span class="line">2.3.6 AndroidBoard.mk文件</span><br><span class="line">2.3.7 编译中的层叠加</span><br><span class="line">第3章 本地层基础部分</span><br><span class="line">3.1 本地层基础部分结构</span><br><span class="line">3.2 C语言基础：Bionic</span><br><span class="line">3.2.1 Bionic各个部分的结构</span><br><span class="line">3.2.2 Bionic的头文件</span><br><span class="line">3.2.3 内存泄露的检查库</span><br><span class="line">3.2.4 属性系统的支持</span><br><span class="line">3.3 C语言底层库</span><br><span class="line">3.3.1 Log库</span><br><span class="line">3.3.2 C语言工具库libcutils</span><br><span class="line">3.3.3 属性和套接字支持</span><br><span class="line">3.4 init可执行程序和相关脚本</span><br><span class="line">3.4.1 init可执行程序的结构</span><br><span class="line">3.4.2 启动脚本init.rc</span><br><span class="line">3.4.3 init的内建动作和初始化</span><br><span class="line">3.4.4 init的循环</span><br><span class="line">3.4.5 设备管理功能</span><br><span class="line">3.5 shell工具</span><br><span class="line">3.5.1 shell程序sh</span><br><span class="line">3.5.2 命令工具箱toolbox</span><br><span class="line">3.6 Android属性和套接字机制</span><br><span class="line">3.6.1 属性机制</span><br><span class="line">3.6.2 套接字机制</span><br><span class="line">第4章 本地层框架部分</span><br><span class="line">4.1 本地层框架部分结构</span><br><span class="line">4.2 框架层的工具库libutils</span><br><span class="line">4.2.1 libutils的结构</span><br><span class="line">4.2.2 基本的定义和类型</span><br><span class="line">4.2.3 数据结构和容器类</span><br><span class="line">4.2.4 工具类</span><br><span class="line">4.2.5 引用计数和强弱引用指针</span><br><span class="line">4.2.6 线程类及相关辅助功能</span><br><span class="line">4.2.7 文件操作的监听循环</span><br><span class="line">4.3 作为全局守护进程的可执行程序</span><br><span class="line">4.3.1 app_process</span><br><span class="line">4.3.2 keystore</span><br><span class="line">4.3.3 installd</span><br><span class="line">4.3.4 vold</span><br><span class="line">4.3.5 netd</span><br><span class="line">4.4 Binder的IPC机制结构</span><br><span class="line">4.4.1 Android Binder机制的层次结构</span><br><span class="line">4.4.2 具体Binder的实现</span><br><span class="line">4.5 Binder库以及相关内容</span><br><span class="line">4.5.1 具体Binder的实现</span><br><span class="line">4.5.2 Binder库的核心功能</span><br><span class="line">4.5.3 Binder框架和具体IPC结构的实现</span><br><span class="line">4.5.4 IServiceManager相关</span><br><span class="line">4.5.5 Binder库中的其他部分</span><br><span class="line">4.6 servicemanager可执行程序和服务的实现</span><br><span class="line">4.6.1 服务管理器可执行程序和进程</span><br><span class="line">4.6.2 在系统中实现&quot;服务&quot;</span><br><span class="line">4.6.3 servicemanager对服务的管理</span><br><span class="line">4.6.4 Android中本地服务的层次结构</span><br><span class="line">第5章 本地的启动流程、调试和设计结构</span><br><span class="line">5.1 Android启动流程的本地阶段</span><br><span class="line">5.1.1 启动流程概述</span><br><span class="line">5.1.2 BootLoader运行及加载内核</span><br><span class="line">5.1.3 Linux内核运行和加载根文件系统</span><br><span class="line">5.1.4 运行用户空间的第一个进程</span><br><span class="line">5.1.5 挂接各个文件系统</span><br><span class="line">5.1.6 系统各个进程的运行</span><br><span class="line">5.1.7 启动图</span><br><span class="line">5.2 Android本地部分的调试</span><br><span class="line">5.2.1 标准Linux调试方法</span><br><span class="line">5.2.2 使用log的方法</span><br><span class="line">5.2.3 Android的特殊调试工具</span><br><span class="line">5.3 本地程序的结构设计</span><br><span class="line">5.3.1 目标和设计思路</span><br><span class="line">5.3.2 守护进程+保留Socket的设计结构</span><br><span class="line">5.3.3 守护进程+本地层Binder的设计结构</span><br><span class="line">第6章 Java运行环境</span><br><span class="line">6.1 Dalvik虚拟机和相关工具</span><br><span class="line">6.1.1 Dalvik的概述</span><br><span class="line">6.1.2 虚拟机的实现和运行</span><br><span class="line">6.1.3 Dalvik工具</span><br><span class="line">6.1.4 nativehelper库</span><br><span class="line">6.2 Java基础库libcore</span><br><span class="line">6.2.1 libcore的源代码结构</span><br><span class="line">6.2.2 luni目录中的内容</span><br><span class="line">6.2.3 libcore中的其他内容</span><br><span class="line">第7章 Java框架层</span><br><span class="line">7.1 Java框架层结构</span><br><span class="line">7.2 Android的Java层的API</span><br><span class="line">7.2.1 Java框架层API的含义</span><br><span class="line">7.2.2 API的描述文件</span><br><span class="line">7.2.3 被隐藏的内容</span><br><span class="line">7.2.4 不赞成使用的（过时的）API</span><br><span class="line">7.3 Java框架库framework.jar</span><br><span class="line">7.3.1 框架库的组成和作用</span><br><span class="line">7.3.2 框架库的API</span><br><span class="line">7.3.3 框架库的编译结构</span><br><span class="line">7.3.4 框架库的各个部分</span><br><span class="line">7.3.5 属性机制</span><br><span class="line">7.3.6 套接字机制</span><br><span class="line">7.4 Java服务库services.jar</span><br><span class="line">7.4.1 服务库的组成和作用</span><br><span class="line">7.4.2 服务管理器</span><br><span class="line">7.4.3 主要的服务功能</span><br><span class="line">7.4.4 启动结束的处理</span><br><span class="line">7.5 资源包framework—res.apk</span><br><span class="line">7.5.1 资源包的组成和作用</span><br><span class="line">7.5.2 作为API的资源id</span><br><span class="line">7.5.3 资源包AndroidManifest.Xml文件</span><br><span class="line">7.6 策略库</span><br><span class="line">7.6.1 策略库的组成和作用</span><br><span class="line">7.6.2 策略库的功能和使用</span><br><span class="line">7.7 Java层的Binder机制</span><br><span class="line">7.7.1 Java Binder的框架</span><br><span class="line">7.7.2 Java框架层的Binder使用</span><br><span class="line">7.7.3 Binder中参数和返回值的类型</span><br><span class="line">第8章 Java本地调用</span><br><span class="line">8.1 Android的Java本地调用</span><br><span class="line">8.1.1 JNI的基本概念</span><br><span class="line">8.1.2 Android的JNI实现基础</span><br><span class="line">8.1.3 Android中JNI的存在方式</span><br><span class="line">8.2 在框架中使用JNI</span><br><span class="line">8.2.1 框架层使用JNI的结构</span><br><span class="line">8.2.2 框架层JNI的实现</span><br><span class="line">8.3 在应用程序包中使用JNI</span><br><span class="line">8.3.1 应用程序包的JNI部分</span><br><span class="line">8.3.2 应用程序包中JNI的典型实现方式</span><br><span class="line">8.3.3 结构上的几种变化</span><br><span class="line">8.4 JNI的高级使用</span><br><span class="line">8.4.1 JNI的双向调用</span><br><span class="line">8.4.2 线程的处理</span><br><span class="line">8.4.3 JNIHelp中的特殊处理</span><br><span class="line">第9章 Java启动流程、调试和程序结构</span><br><span class="line">9.1 Java部分的启动流程</span><br><span class="line">9.1.1 启动流程概述</span><br><span class="line">9.1.2 Java系统的守护进程</span><br><span class="line">9.1.3 ZygoteInit类的执行</span><br><span class="line">9.1.4 系统服务器部分</span><br><span class="line">9.1.5 Java应用程序部分的启动</span><br><span class="line">9.2 Java部分的调试</span><br><span class="line">9.2.1 在Java中使用Log</span><br><span class="line">9.2.2 Java层的命令行程序</span><br><span class="line">9.2.3 代码内容相关的调试</span><br><span class="line">9.2.4 DDMS工具</span><br><span class="line">9.2.5 HierarchyViewer工具</span><br><span class="line">9.3 Java层程序的结构设计</span><br><span class="line">9.3.1 目标和设计思路</span><br><span class="line">9.3.2 在系统服务器中服务的设计结构</span><br><span class="line">9.3.3 Service组件的设计结构</span><br><span class="line">第10章 GUI系统和应用程序管理</span><br><span class="line">10.1 GUI系统的结构和模块关系</span><br><span class="line">10.2 UI框架库及相关</span><br><span class="line">10.2.1 基本类型方面</span><br><span class="line">10.2.2 显示相关</span><br><span class="line">10.2.3 按键和事件的处理</span><br><span class="line">10.2.4 其他内容</span><br><span class="line">10.3 Surface图层系统</span><br><span class="line">10.3.1 Surface系统的结构</span><br><span class="line">10.3.2 Surface本地的接口部分</span><br><span class="line">10.3.3 Surface本地实现部分</span><br><span class="line">10.3.4 Surface的JNI代码</span><br><span class="line">10.3.5 Surface的Java部分</span><br><span class="line">10.42D图形系统</span><br><span class="line">10.4.12D图形系统的结构</span><br><span class="line">10.4.2 Skia底层库</span><br><span class="line">10.4.3 图形系统的JNI接口</span><br><span class="line">10.4.42D图形包</span><br><span class="line">10.53D图形系统</span><br><span class="line">10.5.1 OpenGL系统的结构</span><br><span class="line">10.5.2 OpenGL的本地代码</span><br><span class="line">10.5.3 OpenGL的JNI代码</span><br><span class="line">10.5.4 OpenGL的Java类</span><br><span class="line">10.6 窗口和视图部分</span><br><span class="line">10.6.1 窗口和视图部分的结构</span><br><span class="line">10.6.2 窗口管理的底层实现</span><br><span class="line">10.6.3 视图实现和上层的窗口管理器的实现</span><br><span class="line">10.7 活动和应用程序管理</span><br><span class="line">10.7.1 活动和应用程序管理的结构</span><br><span class="line">10.7.2 活动界面的实现</span><br><span class="line">10.7.3 应用程序管理的实现</span><br><span class="line">第2篇 Android系统级应用开发要点</span><br><span class="line">第11章 Android应用层接口结构与安全</span><br><span class="line">11.1 Android应用层接口结构</span><br><span class="line">11.1.1 标准应用程序和源代码开发的应用程序</span><br><span class="line">11.1.2 第三方应用程序和预置应用程序</span><br><span class="line">11.2 Android的安全系统</span><br><span class="line">11.2.1 安全机制概述</span><br><span class="line">11.2.2 Linux的用户和组</span><br><span class="line">11.2.3 Android的许可</span><br><span class="line">11.3 程序签名问题</span><br><span class="line">11.3.1 Android应用签名的概念</span><br><span class="line">11.3.2 Android应用签名的流程</span><br><span class="line">11.3.3 不同的程序签名</span><br><span class="line">11.3.4 证书生成工具</span><br><span class="line">11.4 安全策略</span><br><span class="line">11.4.1 安全策略的几个方面</span><br><span class="line">11.4.2 安全策略的实现</span><br><span class="line">11.4.3 安全策略的定制</span><br><span class="line">第12章 应用层的本地内容和NDK开发</span><br><span class="line">12.1 本地应用的标准化</span><br><span class="line">12.2 NDK环境</span><br><span class="line">12.2.1 NDK的基本概念</span><br><span class="line">12.2.2 从几个方面理解NDK的不同含义</span><br><span class="line">12.3 NDK的组成结构</span><br><span class="line">12.3.1 NDK环境的结构</span><br><span class="line">12.3.2 NDK中包含的内容</span><br><span class="line">12.4 NDK开发基础</span><br><span class="line">12.4.1 编译流程</span><br><span class="line">12.4.2 NDK编程要点</span><br><span class="line">12.4.3 开发结构</span><br><span class="line">12.5 使用JNI的方式</span><br><span class="line">12.5.1 NDK中使用JNI工程结构</span><br><span class="line">12.5.2 在本地操作Bitmap位图</span><br><span class="line">12.5.3 在本地使用OpenGL ES绘制</span><br><span class="line">12.5.4 程序实现</span><br><span class="line">12.6 在本地构建应用</span><br><span class="line">12.6.1 本地应用接口基础</span><br><span class="line">12.6.2 实现本地活动的辅助库： android_native_app_glue</span><br><span class="line">12.6.3 程序实现</span><br><span class="line">第13章 预置的应用程序层</span><br><span class="line">13.1 预置应用层程序概述</span><br><span class="line">13.2 预置综合应用程序</span><br><span class="line">13.2.1 主屏幕</span><br><span class="line">13.2.2 设置</span><br><span class="line">13.2.3 联系人和电话</span><br><span class="line">13.2.4 短信息和彩信</span><br><span class="line">13.2.5 浏览器和邮件</span><br><span class="line">13.2.6 音乐</span><br><span class="line">13.2.7 照相机和录音机</span><br><span class="line">13.2.8 画廊</span><br><span class="line">13.2.9 搜索</span><br><span class="line">13.2.10 时钟、计算器和日历</span><br><span class="line">13.3 预置内容提供者</span><br><span class="line">13.3.1 联系人信息提供者</span><br><span class="line">13.3.2 媒体信息提供者</span><br><span class="line">13.3.3 电话信息提供者</span><br><span class="line">13.3.4 下载信息提供者</span><br><span class="line">13.4 预置输入法</span><br><span class="line">13.5 活动墙纸系统</span><br><span class="line">13.5.1 活动墙纸选择器</span><br><span class="line">13.5.2 几个具体的活动墙纸</span><br><span class="line">13.6 实现框架功能的应用程序包</span><br><span class="line">13.6.1 系统界面</span><br><span class="line">13.6.2 设置信息提供者</span><br><span class="line">13.6.3 几个主体为Service组件的应用程序包</span><br><span class="line">第14章 Android系统定制</span><br><span class="line">14.1 Android系统定制概述</span><br><span class="line">14.2 普通应用程序的定制</span><br><span class="line">14.2.1 普通应用定制的方面</span><br><span class="line">14.2.2 预置的应用程序的组件可见性</span><br><span class="line">14.2.3 组件的intent—filter</span><br><span class="line">14.3 桌面的定制</span><br><span class="line">14.3.1 桌面程序的入口和功能</span><br><span class="line">14.3.2 桌面程序细节</span><br><span class="line">14.3.3 在桌面之前执行的程序</span><br><span class="line">14.4 系统资源的定制</span><br><span class="line">14.4.1 定义资源的概念和原则</span><br><span class="line">14.4.2 一些配置的数值</span><br><span class="line">14.4.3 可绘制内容的定制</span><br><span class="line">14.4.4 样式和主题的定制</span><br><span class="line">14.4.5 内部布局的定制</span><br><span class="line">14.5 框架内部组件和界面的定制</span><br><span class="line">14.5.1 内部组件</span><br><span class="line">14.5.2 内部界面</span><br><span class="line">14.6 状态栏界面的定制</span><br><span class="line">14.6.1 状态栏界面的功能和布局</span><br><span class="line">14.6.2 状态栏界面</span><br><span class="line">14.7 锁屏界面的定制</span><br><span class="line">14.7.1 锁屏界面的功能</span><br><span class="line">14.7.2 锁屏界面</span><br><span class="line">14.8 开机动画的定制</span><br><span class="line">第15章 系统级的调试和测试</span><br><span class="line">15.1 调试</span><br><span class="line">15.1.1 命令行调试工具</span><br><span class="line">15.1.2 界面上的辅助工具</span><br><span class="line">15.2 测试系统和工具</span><br><span class="line">15.2.1 测试系统的结构</span><br><span class="line">15.2.2 Monkey.</span><br><span class="line">15.2.3 MonkeyRunner</span><br><span class="line">15.3 代码级别的测试</span><br><span class="line">15.3.1 代码测试框架</span><br><span class="line">15.3.2 代码测试方式</span><br><span class="line">15.4 兼容性及兼容性测试</span><br><span class="line">15.4.1 Android兼容性</span><br><span class="line">15.4.2 CTS兼容性验证</span><br><span class="line">15.4.3 CTS的相关源代码和原理</span><br><span class="line">……</span><br><span class="line">附录A Android版本演进和Android 4.x</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B008GUXLPM/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B008GUXLPM&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41qZoOG1gTL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Learning Android(英文版)</title>
    <url>/2020/04/19/B008KA8EGE/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Learning Android(英文版)<br>作者信息： 作者: 马尔科•加尔根塔(Marko Gargenta) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Learning Android(中文版)》是由电子工业出版社出版。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">第1章 Android概述</span><br><span class="line">概述</span><br><span class="line">完整性</span><br><span class="line">开源平台</span><br><span class="line">为移动设备而设计</span><br><span class="line">历史</span><br><span class="line">Google的动机</span><br><span class="line">开放手持设备联盟</span><br><span class="line">Android的版本</span><br><span class="line">总结</span><br><span class="line">第2章 Android的架构</span><br><span class="line">架构概述</span><br><span class="line">Linux系统</span><br><span class="line">可移植性</span><br><span class="line">安全性</span><br><span class="line">丰富的特性</span><br><span class="line">本地库</span><br><span class="line">Dalvik虚拟机</span><br><span class="line">Android与Java</span><br><span class="line">应用程序框架</span><br><span class="line">应用程序</span><br><span class="line">APK文件</span><br><span class="line">应用程序签名</span><br><span class="line">应用程序发布</span><br><span class="line">总结</span><br><span class="line">第3章快速入门</span><br><span class="line">安装 Android SDK</span><br><span class="line">设置 PATH环境变量</span><br><span class="line">安装 Eclipse</span><br><span class="line">Eclipse的工作区</span><br><span class="line">安装 Android开发工具</span><br><span class="line">Hello, World程序</span><br><span class="line">创建新项目</span><br><span class="line">Manifest文件</span><br><span class="line">Layout（布局） XML代码</span><br><span class="line">Strings（字符串）文件</span><br><span class="line">R（资源）文件</span><br><span class="line">Java源码文件</span><br><span class="line">仿真器</span><br><span class="line">仿真器和真机</span><br><span class="line">总结</span><br><span class="line">第4章基本构件</span><br><span class="line">什么是基本构件</span><br><span class="line">一个实际的例子</span><br><span class="line">活动（ Activity）</span><br><span class="line">活动的生命周期</span><br><span class="line">Intent</span><br><span class="line">服务（ Service）</span><br><span class="line">内容提供器（ Content Provider）</span><br><span class="line">广播接收器（ Broadcast Receiver）</span><br><span class="line">应用程序上下文（ Application Context）</span><br><span class="line">总结</span><br><span class="line">第5章 Yamba项目简介</span><br><span class="line">Yamba应用程序</span><br><span class="line">设计原则</span><br><span class="line">项目设计</span><br><span class="line">第1部分： Android用户界面</span><br><span class="line">构建一个活动</span><br><span class="line">网络和多线程</span><br><span class="line">调试 Android程序</span><br><span class="line">第2部分：首选项、文件系统、选项菜单及 Intent</span><br><span class="line">活动</span><br><span class="line">菜单系统与 Intent</span><br><span class="line">文件系统</span><br><span class="line">第3部分： Android服务</span><br><span class="line">服务</span><br><span class="line">应用程序对象</span><br><span class="line">第4部分：使用数据库</span><br><span class="line">SQLite及Android对它的支持</span><br><span class="line">再次重构代码</span><br><span class="line">第5部分：列表（ List）与适配器（ Adapter）</span><br><span class="line">时间轴（ Timeline）活动</span><br><span class="line">再重构一次</span><br><span class="line">第6部分：广播接收器（ Broadcast Receiver）</span><br><span class="line">启动接收器与网络连接接收器</span><br><span class="line">时间轴（ Timeline）接收器</span><br><span class="line">权限</span><br><span class="line">第7部分：内容提供器（ Content Provider）</span><br><span class="line">状态数据</span><br><span class="line">Android小部件</span><br><span class="line">第8部分：系统服务</span><br><span class="line">指南针与位置</span><br><span class="line">Intent服务、提醒及通知</span><br><span class="line">总结</span><br><span class="line">第6章 Android用户界面</span><br><span class="line">创建用户界面的两种方法</span><br><span class="line">声明式的用户界面</span><br><span class="line">编程式的用户界面</span><br><span class="line">各取所长</span><br><span class="line">控件与布局</span><br><span class="line">LinearLayout</span><br><span class="line">TableLayout</span><br><span class="line">FrameLayout</span><br><span class="line">RelativeLayout</span><br><span class="line">AbsoluteLayout</span><br><span class="line">启动 Yamba项目</span><br><span class="line">StatusActivity布局</span><br><span class="line">控件的重要属性</span><br><span class="line">字符串资源</span><br><span class="line">StatusActivity Java类</span><br><span class="line">编写具体应用的对象，以及初始化相关代码</span><br><span class="line">保存文件：编译代码和构建项目</span><br><span class="line">添加库 jtwitterjar</span><br><span class="line">更新 Manifest文件，获取 Internet权限</span><br><span class="line">Android的日志机制</span><br><span class="line">LogCat</span><br><span class="line">Android的线程机制</span><br><span class="line">单线程执行</span><br><span class="line">多线程执行</span><br><span class="line">AsyncTask</span><br><span class="line">其他 UI事件</span><br><span class="line">添加图片与色彩</span><br><span class="line">添加图片</span><br><span class="line">添加色彩</span><br><span class="line">多版本资源文件</span><br><span class="line">优化用户界面</span><br><span class="line">Hierarchy Viewer工具</span><br><span class="line">总结</span><br><span class="line">……</span><br><span class="line">第7章首选项、文件系统、选项菜单及 Intent</span><br><span class="line">第8章服务</span><br><span class="line">第9章数据库</span><br><span class="line">第10章列表与适配器</span><br><span class="line">第11章广播接收器（ Broadcast Receiver）</span><br><span class="line">第12章内容提供器（ Content Provider）</span><br><span class="line">第13章系统服务</span><br><span class="line">第14章 Android接口描述语言</span><br><span class="line">索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B008KA8EGE/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B008KA8EGE&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51990HLypFL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发精要</title>
    <url>/2020/04/19/B008PLO174/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android开发精要<br>作者信息： 作者: 范怀宇 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Android开发精要》编辑推荐：资深Android专家经验之作，51CTO和开源中国社区联袂推荐！高度抽象Android系统的设计理念和底层实现机制，全面概括Android实现原理的“要点”和实际开发中的“精华”，为开发高质量Android应用提供绝佳指导！</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">致谢</span><br><span class="line">第1章 Android的系统架构 1</span><br><span class="line">1.1 Android系统架构概况 2</span><br><span class="line">1.1.1 应用层 4</span><br><span class="line">1.1.2 框架层 5</span><br><span class="line">1.1.3 运行时 5</span><br><span class="line">1.1.4 核心类库 7</span><br><span class="line">1.1.5 硬件抽象层和Linux内核 7</span><br><span class="line">1.2 Android的核心功能模块 8</span><br><span class="line">1.2.1 界面框架 8</span><br><span class="line">1.2.2 数据存储 9</span><br><span class="line">1.2.3 网络通信 10</span><br><span class="line">1.2.4 地理信息 11</span><br><span class="line">1.2.5 图形和多媒体处理 11</span><br><span class="line">1.2.6 外部设备 12</span><br><span class="line">1.2.7 特色功能模块 13</span><br><span class="line">1.3 Android的架构特征和设计思想 13</span><br><span class="line">1.3.1 平台开放性 14</span><br><span class="line">1.3.2 基于组件的应用设计 14</span><br><span class="line">1.3.3 基于网络服务的平台 15</span><br><span class="line">1.4 小结 15 </span><br><span class="line"></span><br><span class="line"> 第2章 Android源代码的下载和编译 16 2.1 Android源代码的获取和编译 17 2.1.1 环境搭建 18 2.1.2 源代码获取 18 2.1.3 源代码的编译 21 2.2 Android源代码结构 22 2.2.1 框架层源代码目录frameworks 22 2.2.2 应用层源代码目录packages 24 2.2.3 其他源代码目录 24 2.3 Android源代码的阅读和编辑 25 2.3.1 用Eclipse阅读源代码 25 2.3.2 反馈Bug 26 2.3.3 提交修改 27 2.4 小结 27</span><br><span class="line"></span><br><span class="line"> 第3章 Android组件模型解析 28 3.1 基于Mashup的应用设计 29 3.1.1 Android中的Mashup 29 3.1.2 基于Mashup的Android应用模型 30 3.1.3 基于Mashup的应用架构特征 32 3.2 界面组件Activity解析 34 3.2.1 界面组件的功能和特征 34 3.2.2 界面组件的开发 35 3.2.3 界面组件的数据结构 39 3.3 服务组件Service解析 40 3.3.1 服务组件的功能和特征 41 3.3.2 服务组件的开发和使用 43 3.3.3 服务组件的进程间通信模型 45 3.4 触发器组件Broadcast Receiver解析 49 3.4.1 触发器组件的功能和特征 49 3.4.2 触发器组件的使用 50 3.4.3 广播事件的发送 52 3.5 数据源组件Content Provider解析 52 3.5.1 数据源组件的定位和操作 53 3.5.2 数据源组件的开发 55 3.5.3 数据源组件的实现细节 57 3.6 应用配置文件解析 59 3.6.1 权限配置 61 3.6.2 环境配置 63 3.6.3 应用和组件配置 65 3.7 小结 66</span><br><span class="line"></span><br><span class="line"> 第4章 Android的Intent机制 67 4.1 Intent对象的作用和构成 68 4.1.1 Intent对象的作用 69 4.1.2 Intent对象的构成 70 4.1.3 Intent对象解析 75 4.1.4 Intent Filter对象 76 4.2 意图匹配 78 4.2.1 意图匹配的算法流程 79 4.2.2 匹配组件的选择 84 4.2.3 意图匹配的优化 85 4.3 意图机制的应用 86 4.3.1 意图机制在界面组件中的应用 86 4.3.2 意图机制在服务组件中的应用 88 4.3.3 意图机制在触发器组件中的应用 89 4.4 小结 90</span><br><span class="line"></span><br><span class="line"> 第5章 组件生命周期解析 91 5.1 应用进程模型 92 5.1.1 应用、组件和进程 92 5.1.2 组件的应用进程配置 94 5.2 应用进程托管 96 5.2.1 为什么需要进程托管 97 5.2.2 进程优先级 97 5.2.3 进程回收算法 100 5.2.4 进程的强行终止 103 5.2.5 掌控进程的优先级 105 5.3 组件的生命周期模型 106 5.3.1 界面组件的生命周期 107 5.3.2 服务组件的生命周期 115 5.3.3 触发器组件的生命周期 119 5.3.4 数据源组件的生命周期 120 5.3.5 应用环境的生命周期 120 5.4 任务和界面组件栈 120 5.4.1 界面组件的运行模式 122 5.4.2 组件的任务黏度 126 5.4.3 实际应用中的任务控制 127 5.5 小结 128</span><br><span class="line"></span><br><span class="line"> 第6章 组件间的数据传输 129 6.1 利用Intent对象进行数据传输 130 6.1.1 利用Intent对象回传数据 131 6.1.2 利用Intent对象传递数据的优缺点 133 6.2 利用文件进行数据共享 134 6.2.1 利用文件进行数据共享的实现 134 6.2.2 利用文件进行数据共享的优缺点 135 6.3 利用应用环境的全局数据共享 136 6.3.1 利用应用环境对象共享数据的实现 137 6.3.2 利用应用环境对象共享数据的优缺点 138 6.4 利用组件共享数据 139 6.4.1 利用数据源组件共享数据 139 6.4.2 利用服务组件共享数据 140 6.5 小结 140</span><br><span class="line"></span><br><span class="line"> 第7章 Android控件解析 141 7.1 Android的控件框架 142 7.1.1 Android控件构成 142 7.1.2 Android交互事件传输 143 7.1.3 Android控件属性 145 7.1.4 控件的丈量和绘制 150 7.2 Android的窗口机制 150 7.2.1 窗口机制的基本原理 151 7.2.2 界面组件和窗口 152 7.2.3 对话框 154 7.2.4 弹出窗口 156 7.3 Android的基本控件介绍 158 7.3.1 文本控件 159 7.3.2 图像控件 163 7.3.3 Surface控件 164 7.3.4 Layout控件 164 7.3.5 适配器控件 167 7.3.6 选项卡控件 172 7.3.7 浏览器控件 173 7.4 自定义控件 175 7.4.1 控件的定制 175 7.4.2 复合控件 180 7.4.3 自绘控件 183 7.5 Android界面新发展 188 7.5.1 动作栏 188 7.5.2 界面片段 191 7.5.3 重新定制选项卡 197 7.5.4 交互界面的适配 200 7.6 小结 204</span><br><span class="line"></span><br><span class="line"> 第8章 应用资源 205 8.1 Android应用资源体系 206 8.1.1 Android的应用资源构成 206 8.1.2 应用资源的适配 208 8.1.3 应用资源的动态匹配 209 8.2 应用资源的调用 213 8.2.1 应用资源的编译和R类 213 8.2.2 应用资源的管理 215 8.2.3 使用应用资源 216 8.3 应用资源的类型 217 8.3.1 界面和样式 217 8.3.2 字符串和常量 221 8.3.3 图像、图形和动画 223 8.3.4 其他资源文件 225 8.4 小结 225</span><br><span class="line"></span><br><span class="line"> 第9章 数据存储 226 9.1 Android的文件系统 227 9.1.1 Android的目录结构 229 9.1.2 Android的应用数据存储 229 9.1.3 Android的文件操作 231 9.2 使用设置文件 233 9.2.1 设置文件的存储和使用 234 9.2.2 设置界面组件 235 9.3 使用数据库 238 9.3.1 Android数据库实现 238 9.3.2 Android数据库的使用 240 9.4 存储在云端 243 9.4.1 云端存储的架构 244 9.4.2 云端存储的使用 245 9.5 小结 247</span><br><span class="line"></span><br><span class="line"> 第10章 网络通信 248 10.1 Web通信 249 10.1.1 基于HTTP的网络连接 249 10.1.2 联网方式的选择 252 10.1.3 WiFi的管理 254 10.2 蓝牙 256 10.2.1 Android的蓝牙实现 256 10.2.2 基于蓝牙的通信 257 10.3 近场通信 259 10.3.1 基于NFC的识别和通信 259 10.3.2 基于NFC的点对点通信 263 10.4 基于WiFi连接的P2P通信 263 10.4.1 Android 4.0的P2P连接实现 264 10.4.2 使用Socket进行数据传输 266 10.5 小结 268</span><br><span class="line"></span><br><span class="line"> 第11章 地理信息服务 269 11.1 Android的定位服务 270 11.1.1 定位服务框架 270 11.1.2 位置信息源 272 11.1.3 定位选择 273 11.1.4 定位实例 274 11.2 Android的地址服务 277 11.2.1 地址服务的框架 277 11.2.2 使用地址服务 278 11.3 Android的地图服务 279 11.3.1 使用地图 279 11.3.2 其他使用地图服务的方式 282 11.4 小结 283</span><br><span class="line"></span><br><span class="line"> 第12章 多媒体处理 284 12.1 Android的图像处理 285 12.1.1 图像的表示 285 12.1.2 图像的读取和输出 286 12.1.3 图像的呈现 288 12.1.4 图像的管理 290 12.2 Android的音视频处理 291 12.2.1 Android音视频的支持框架 291 12.2.2 Android音视频的播放 292 12.2.3 Android音视频的录制 294 12.3 Android中相机的使用 296 12.4 小结 300</span><br><span class="line"></span><br><span class="line"> 第13章 其他重要模块 301 13.1 通话和短信 302 13.1.1 Android的通话和短信框架 302 13.1.2 通话的处理 303 13.1.3 短信的发送和接收 305 13.2 App Widget的使用和实现 308 13.2.1 Android的App Widget框架 309 13.2.2 App Widget的界面构造和Remote Views 311 13.2.3 App Widget的事件处理和Pending Intent 313 13.3 Android的应用内搜索 317 13.3.1 Android应用内搜索实现框架 317 13.3.2 为应用定制搜索功能 318 13.3.3 全局搜索功能 322 13.4 Android的全局通知机制 323 13.4.1 全局通知的类型和实现 324 13.4.2 Toast的使用 325 13.4.3 状态栏通知 327 13.5 Android联系人处理 331 13.5.1 Android联系人数据存储框架 331 13.5.2 Android联系人操作 332 13.6 小结 334</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B008PLO174/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B008PLO174&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41eyOWQKwGL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android移动应用开发(第3版)卷1：基础篇</title>
    <url>/2020/04/19/B009C2XM2K/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android移动应用开发(第3版)卷1：基础篇<br>作者信息： 作者: 达西 (Lauren Darcey) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>依托Android最新的主流平台为Android 4.0，面向最新的SDK和相关工具，同时还涵盖了老版平台中的一些常用功能，以帮助开发人员适应目前市面上所有的主流设备。《Android移动应用开发(第3版)卷Ⅰ：基础篇》涵盖了作者数年来在移动开发领域所积累的经验，以及成功进行移动项目开发所需的全部概念和实用技术，包括移动开发过程与传统软件开发的区别，还包括帮助你节约宝贵时间和规避隐患的技巧。不管你的项目有多大规模，《Android移动应用开发(第3版)卷Ⅰ：基础篇》都能为你提供帮助。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分 Android平台概览</span><br><span class="line">第1章 Android简介</span><br><span class="line">1.1 移动软件开发简史</span><br><span class="line">1.1.1 遥想当年</span><br><span class="line">1.1.2 “砖头”</span><br><span class="line">1.1.3 无线应用协议（WAP）</span><br><span class="line">1.1.4 专用移动平台</span><br><span class="line">1.2 开放手机联盟（OHA）</span><br><span class="line">1.2.1 无线Google</span><br><span class="line">1.2.2 成立开放手机联盟</span><br><span class="line">1.2.3 制造商：设计Android手机</span><br><span class="line">1.2.4 移动运营商：传播Android体验</span><br><span class="line">1.2.5 应用程序推动的设备销售：开发Android应用程序</span><br><span class="line">1.2.6 充分发挥Android的优势</span><br><span class="line">1.2.7 Android市场：我们的定位</span><br><span class="line">1.3 Android平台的不同之处</span><br><span class="line">1.3.1 Android：下一代平台</span><br><span class="line">1.3.2 免费开放源代码</span><br><span class="line">1.3.3 熟悉和廉价的开发工具</span><br><span class="line">1.3.4 合理的开发人员学习曲线</span><br><span class="line">1.3.5 强大的应用程序开发支持</span><br><span class="line">1.3.6 丰富、安全的应用集成</span><br><span class="line">1.3.7 无障碍发布</span><br><span class="line">1.3.8 为应用程序提供的“自由市场”</span><br><span class="line">1.3.9 新生并逐渐成长的平台</span><br><span class="line">1.4 Android平台</span><br><span class="line">1.4.1 Android的基本体系结构</span><br><span class="line">1.4.2 安全与许可权限</span><br><span class="line">1.4.3 开发Android应用程序</span><br><span class="line">小结</span><br><span class="line">参考资料和更多信息</span><br><span class="line">第2章 搭建你的Android开发环境</span><br><span class="line">2.1 配置你的开发环境</span><br><span class="line">2.1.1 配置操作系统以适应设备调试</span><br><span class="line">2.1.2 配置Android硬件以供调试</span><br><span class="line">2.1.3 升级Android SDK</span><br><span class="line">2.1.4 Android软件开发包的问题</span><br><span class="line">2.2 探索Android SDK</span><br><span class="line">2.2.1 理解Android SDK许可协议</span><br><span class="line">2.2.2 阅读Android SDK文档</span><br><span class="line">2.2.3 探索Android应用程序核心框架</span><br><span class="line">2.2.4 了解Android核心工具</span><br><span class="line">2.2.5 探索Android示例应用程序</span><br><span class="line">小结</span><br><span class="line">参考资料和更多信息</span><br><span class="line">第3章 编写第一个Android应用程序</span><br><span class="line">3.1 测试你的开发环境</span><br><span class="line">3.1.1 在Eclipse工程中导入Snake应用程序</span><br><span class="line">3.1.2 为Snake工程创建Android虚拟设备（AVD）</span><br><span class="line">3.1.3 为Snake工程创建运行配置参数</span><br><span class="line">3.1.4 在Android模拟器中运行Snake应用程序</span><br><span class="line">3.2 构建你的第一个Android应用程序</span><br><span class="line">3.2.1 创建和配置新的Android工程</span><br><span class="line">3.2.2 Android应用程序的核心文件和目录</span><br><span class="line">3.2.3 为新工程创建Android虚拟设备</span><br><span class="line">3.2.4 为工程配置运行参数</span><br><span class="line">3.2.5 在模拟器中运行Android应用程序</span><br><span class="line">3.2.6 在模拟器中调试Android应用程序</span><br><span class="line">3.2.7 为Android应用程序添加日志记录</span><br><span class="line">3.2.8 为应用程序添加媒体支持</span><br><span class="line">3.2.9 为应用程序添加位置服务（LBS）</span><br><span class="line">3.2.10 在硬件上调试应用程序</span><br><span class="line">小结</span><br><span class="line">参考资料和更多信息</span><br><span class="line">第4章 掌握Android开发工具</span><br><span class="line">4.1 使用Android文档</span><br><span class="line">4.2 使用Android模拟器</span><br><span class="line">4.3 使用LogCat查看应用程序日志数据</span><br><span class="line">4.4 使用DDMS调试应用程序</span><br><span class="line">4.5 使用Android调试桥（ADB）</span><br><span class="line">4.6 使用资源编辑器和UI设计器</span><br><span class="line">4.7 使用Android层级浏览器</span><br><span class="line">4.7.1 运行层级浏览器</span><br><span class="line">4.7.2 使用布局浏览模式</span><br><span class="line">4.7.3 优化用户界面</span><br><span class="line">4.7.4 使用精细像素模式</span><br><span class="line">4.8 使用九格拉伸图像</span><br><span class="line">4.9 使用其他Android工具</span><br><span class="line">小结</span><br><span class="line">参考资料和更多信息</span><br><span class="line">第二部分 Android应用程序设计基础</span><br><span class="line">第5章 剖析Android应用程序</span><br><span class="line">5.1 掌握重要的Android术语</span><br><span class="line">5.2 使用应用程序Context</span><br><span class="line">5.2.1 获取应用程序Context</span><br><span class="line">5.2.2 使用应用程序Context</span><br><span class="line">5.2.3 获取应用程序资源</span><br><span class="line">5.2.4 访问应用程序首选项</span><br><span class="line">5.2.5 访问应用程序文件和目录</span><br><span class="line">5.2.6 获取应用程序组件</span><br><span class="line">5.3 使用Activity执行应用程序任务</span><br><span class="line">5.3.1 Android Activity的生命周期</span><br><span class="line">5.3.2 使用Activity回调管理应用程序状态和资源</span><br><span class="line">5.4 使用Fragment组织Activity组件</span><br><span class="line">5.5 使用Intent管理Activity跳转</span><br><span class="line">5.5.1 使用Intent实现Activity之间的跳转</span><br><span class="line">5.5.2 使用Activity和Intent组织应用程序导航</span><br><span class="line">5.6 使用服务</span><br><span class="line">5.7 接收和广播Intent</span><br><span class="line">小结</span><br><span class="line">参考资料和更多信息</span><br><span class="line">第6章 使用Android Manifest文件定义应用程序</span><br><span class="line">6.1 使用Android Manifest文件配置Android应用程序</span><br><span class="line">6.2 管理你的应用程序标识</span><br><span class="line">6.2.1 为你的应用程序指定版本</span><br><span class="line">6.2.2 给你的应用程序加上名称和图标</span><br><span class="line">6.3 强制指定应用程序的系统需求</span><br><span class="line">6.3.1 针对特定SDK版本</span><br><span class="line">6.3.2 强制指定应用程序平台需求</span><br><span class="line">6.3.3 使用外部库</span><br><span class="line">6.3.4 其他应用程序配置及筛选器</span><br><span class="line">6.4 在Android Manifest文件中注册Activity</span><br><span class="line">6.4.1 使用Intent过滤器为应用程序指派主入口点Activity</span><br><span class="line">6.4.2 配置其他Intent过滤器</span><br><span class="line">6.4.3 注册其他应用程序组件</span><br><span class="line">6.5 使用许可权限</span><br><span class="line">6.5.1 注册应用程序所需的许可权限</span><br><span class="line">6.5.2 注册应用程序强制要求的许可权限</span><br><span class="line">6.6 探索Manifest文件的其他设置</span><br><span class="line">小结</span><br><span class="line">参考资料和更多信息</span><br><span class="line">第7章 管理应用程序资源</span><br><span class="line">7.1 什么是资源</span><br><span class="line">7.1.1 存储应用程序资源</span><br><span class="line">7.1.2 资源的类型</span><br><span class="line">7.1.3 使用程序访问资源</span><br><span class="line">7.2 使用Eclipse设置简单资源</span><br><span class="line">7.3 使用不同种类的资源</span><br><span class="line">7.3.1 使用String（字符串）资源</span><br><span class="line">7.3.2 使用格式化的字符串资源</span><br><span class="line">7.3.3 使用字符串数组</span><br><span class="line">7.3.4 使用Boolean（布尔）资源</span><br><span class="line">7.3.5 使用Integer（整型）资源</span><br><span class="line">7.3.6 使用颜色</span><br><span class="line">7.3.7 使用尺寸</span><br><span class="line">7.3.8 使用简单Drawable资源</span><br><span class="line">7.3.9 使用图像</span><br><span class="line">7.3.10 使用动画</span><br><span class="line">7.3.11 使用菜单</span><br><span class="line">7.3.12 使用XML文件</span><br><span class="line">7.3.13 使用原始文件</span><br><span class="line">7.3.14 资源引用</span><br><span class="line">7.3.15 使用布局（Layout）</span><br><span class="line">7.4 引用系统资源</span><br><span class="line">小结</span><br><span class="line">参考资料和更多信息</span><br><span class="line">第三部分 Android用户界面设计精髓</span><br><span class="line">第8章 探索用户界面屏幕元素</span><br><span class="line">8.1 Android视图和布局简介</span><br><span class="line">8.1.1 Android视图简介</span><br><span class="line">8.1.2 Android控件简介</span><br><span class="line">8.1.3 Android布局简介</span><br><span class="line">8.2 使用TextView显示文本</span><br><span class="line">8.2.1 配置布局和尺寸</span><br><span class="line">8.2.2 在文本中创建上下文链接</span><br><span class="line">8.3 使用EditText获取用户数据</span><br><span class="line">8.3.1 使用EditText控件获取用户输入文本</span><br><span class="line">8.3.2 使用输入过滤器约束用户输入</span><br><span class="line">8.4 使用自动补全辅助用户</span><br><span class="line">8.5 使用Spinner控件为用户提供可选输入</span><br><span class="line">8.6 使用按钮、多选框和单选组完成简单的用户选择</span><br><span class="line">8.6.1 使用基本按钮</span><br><span class="line">8.6.2 使用BheckBox和ToggleButton控件</span><br><span class="line">8.6.3 使用RadioGroup和Radio Button</span><br><span class="line">8.7 获取用户输入的日期和时间</span><br><span class="line">8.8 使用指示器向用户显示数据</span><br><span class="line">8.8.1 使用ProgressBar指示进度</span><br><span class="line">8.8.2 使用SeekBar调整进度</span><br><span class="line">8.8.3 使用RatingBar显示评分数据</span><br><span class="line">8.8.4 使用Chronometer显示时间推移</span><br><span class="line">8.8.5 显示时间</span><br><span class="line">小结</span><br><span class="line">参考资料和更多信息</span><br><span class="line">第9章 使用布局设计用户界面</span><br><span class="line">9.1 创建Android用户界面</span><br><span class="line">9.1.1 使用XML资源创建布局</span><br><span class="line">9.1.2 使用代码创建布局</span><br><span class="line">9.2 组织用户界面</span><br><span class="line">9.2.1 为布局设计使用ViewGroup子类</span><br><span class="line">9.2.2 将ViewGroup子类作为视图容器</span><br><span class="line">9.3 使用内建的布局类</span><br><span class="line">9.3.1 使用FrameLayout</span><br><span class="line">9.3.2 使用LinearLayout</span><br><span class="line">9.3.3 使用RelativeLayout</span><br><span class="line">9.3.4 使用TableLayout</span><br><span class="line">9.3.5 使用GridLayout</span><br><span class="line">9.3.6 在屏幕上使用多布局</span><br><span class="line">9.4 使用容器控件类</span><br><span class="line">9.4.1 使用数据驱动容器</span><br><span class="line">9.4.2 使用标签组织视图</span><br><span class="line">9.4.3 添加滚动支持</span><br><span class="line">9.4.4 探索其他视图容器</span><br><span class="line">小结</span><br><span class="line">参考资料和更多信息</span><br><span class="line">第10章 使用Fragment</span><br><span class="line">10.1 理解Fragment</span><br><span class="line">10.1.1 理解Fragment生命周期</span><br><span class="line">10.1.2 使用特化的Fragment</span><br><span class="line">10.1.3 设计基于Fragment的应用程序</span><br><span class="line">10.2 使用Android支持包</span><br><span class="line">10.2.1 为旧版应用程序添加Android Fragment支持</span><br><span class="line">10.2.2 在新应用程序中针对旧版平台使用Fragment</span><br><span class="line">10.2.3 在项目中链接Android支持包</span><br><span class="line">小结</span><br><span class="line">参考资料和更多信息</span><br><span class="line">第11章 使用对话框</span><br><span class="line">11.1 选择一种方式实现对话框</span><br><span class="line">11.2 探索不同类型的对话框</span><br><span class="line">11.3 使用对话框：以前的方法</span><br><span class="line">11.4 使用对话框：Fragment方法</span><br><span class="line">小结</span><br><span class="line">参考资料和更多信息</span><br><span class="line">第四部分 Android应用程序设计精髓</span><br><span class="line">第12章 使用Android首选项</span><br><span class="line">12.1 使用应用程序首选项</span><br><span class="line">12.1.1 正确地使用首选项</span><br><span class="line">12.1.2 存储不同类型的首选项值</span><br><span class="line">12.1.3 创建私有和共享首选项</span><br><span class="line">12.1.4 创建可供多个Activity使用的共享首选项</span><br><span class="line">12.1.5 搜索和读取首选项</span><br><span class="line">12.1.6 新增、修改和删除首选项</span><br><span class="line">12.1.7 处理首选项变更</span><br><span class="line">12.1.8 使用Android文件系统查找首选项数据</span><br><span class="line">12.2 创建可管理的用户首选项</span><br><span class="line">12.2.1 创建首选项资源文件</span><br><span class="line">12.2.2 使用PreferenceActivity类</span><br><span class="line">小结</span><br><span class="line">参考资料和更多信息</span><br><span class="line">第13章 使用文件和目录</span><br><span class="line">13.1 使用设备应用程序数据</span><br><span class="line">13.2 练习良好的文件管理</span><br><span class="line">13.3 理解Android文件许可权限</span><br><span class="line">13.4 使用文件和目录</span><br><span class="line">13.4.1 探索Android应用程序目录</span><br><span class="line">13.4.2 使用Android文件系统操作其他目录和文件</span><br><span class="line">小结</span><br><span class="line">参考资料和更多信息</span><br><span class="line">第14章 使用内容提供器</span><br><span class="line">14.1 探索Android内容提供器</span><br><span class="line">14.1.1 使用MediaStore内容提供器</span><br><span class="line">14.1.2 使用CallLog内容提供器</span><br><span class="line">14.1.3 使用浏览器（Browser）内容提供器</span><br><span class="line">14.1.4 使用CalenderContract内容提供器</span><br><span class="line">14.1.5 使用UserDictionary（用户词典）内容提供器</span><br><span class="line">14.1.6 使用VoicemailContract内容提供器</span><br><span class="line">14.1.7 使用Settings内容提供器</span><br><span class="line">14.1.8 使用联系簿（Contacts）内容提供器</span><br><span class="line">14.2 修改内容提供器的数据</span><br><span class="line">14.2.1 添加记录</span><br><span class="line">14.2.2 修改记录</span><br><span class="line">14.2.3 删除记录</span><br><span class="line">14.3 使用第三方内容提供器</span><br><span class="line">小结</span><br><span class="line">参考资料和更多信息</span><br><span class="line">第15章 设计高兼容性应用程序</span><br><span class="line">15.1 最大化应用程序兼容性</span><br><span class="line">15.2 为兼容性设计用户界面</span><br><span class="line">15.2.1 使用Fragment</span><br><span class="line">15.2.2 使用Android支持包</span><br><span class="line">15.2.3 支持特定屏幕类型</span><br><span class="line">15.2.4 使用九格拉伸图像</span><br><span class="line">15.2.5 使用Working Square原理</span><br><span class="line">15.3 提供应用程序替代资源</span><br><span class="line">15.3.1 理解资源的解析（Resolve）方式</span><br><span class="line">15.3.2 使用替代资源标识符</span><br><span class="line">15.3.3 提供用于不同屏幕方向的资源</span><br><span class="line">15.3.4 在程序中使用替代资源</span><br><span class="line">15.3.5 高效地组织应用程序资源</span><br><span class="line">15.4 面向平板电脑、电视和其他新设备</span><br><span class="line">15.4.1 面向平板设备</span><br><span class="line">15.4.2 面向Google电视设备</span><br><span class="line">小结</span><br><span class="line">参考资料和更多信息</span><br><span class="line">第五部分 对外发布你的Android应用程序</span><br><span class="line">第16章 移动软件开发过程</span><br><span class="line">16.1 移动开发过程概览</span><br><span class="line">16.2 选择一种软件开发方法</span><br><span class="line">16.2.1 理解“瀑布模型”的危险</span><br><span class="line">16.2.2 认识迭代式开发的价值</span><br><span class="line">16.3 整合应用程序需求</span><br><span class="line">16.3.1 确定工程需求</span><br><span class="line">16.3.2 为移动应用程序开发用例</span><br><span class="line">16.3.3 吸纳第三方需求</span><br><span class="line">16.3.4 管理设备数据库</span><br><span class="line">16.4 项目风险评估</span><br><span class="line">16.4.1 确定目标设备</span><br><span class="line">16.4.2 获取目标设备</span><br><span class="line">16.4.3 确定应用程序需求的可行性</span><br><span class="line">16.4.4 理解质量保障的风险</span><br><span class="line">16.5 编写基本项目文档</span><br><span class="line">16.5.1 为质量保障制定测试计划</span><br><span class="line">16.5.2 提供第三方所需的文档</span><br><span class="line">16.5.3 提供维护和移植所需的文档</span><br><span class="line">16.6 使用配置管理系统</span><br><span class="line">16.6.1 选择一个源代码控制系统</span><br><span class="line">16.6.2 实现一个可用的版本管理系统</span><br><span class="line">16.7 设计移动应用程序</span><br><span class="line">16.7.1 认识移动设备的局限</span><br><span class="line">16.7.2 移动应用程序体系结构探索</span><br><span class="line">16.7.3 可扩展和维护设计</span><br><span class="line">16.7.4 应用程序交互设计</span><br><span class="line">16.8 开发移动应用程序</span><br><span class="line">16.9 测试移动应用程序</span><br><span class="line">16.1 发布移动应用程序</span><br><span class="line">16.11 支持和维护移动应用程序</span><br><span class="line">16.11.1 跟踪和定位用户产生的“崩溃”报告</span><br><span class="line">16.11.2 测试固件升级</span><br><span class="line">16.11.3 维护适当的应用程序文档</span><br><span class="line">16.11.4 管理服务器的动态更改</span><br><span class="line">16.11.5 确定低风险移植机会</span><br><span class="line">小结</span><br><span class="line">参考资料和更多信息</span><br><span class="line">第17章 设计和开发“防弹”Android应用程序</span><br><span class="line">17.1 “防弹”移动应用程序设计最佳实践</span><br><span class="line">17.1.1 满足移动用户的需求</span><br><span class="line">17.1.2 为移动设备设计用户界面</span><br><span class="line">17.1.3 设计稳定、灵敏的移动应用程序</span><br><span class="line">17.1.4 设计安全的移动应用程序</span><br><span class="line">17.1.5 在设计移动应用程序时考虑利益的最大化</span><br><span class="line">17.1.6 在Android应用程序设计时使用第三方标准</span><br><span class="line">17.1.7 设计便于维护和升级的移动应用程序</span><br><span class="line">17.1.8 在应用程序设计中使用Andriod工具</span><br><span class="line">17.1.9 避免设计时的愚蠢错误</span><br><span class="line">17.2 “防弹”移动应用程序开发最佳实践</span><br><span class="line">17.2.1 设计有效的移动开发过程</span><br><span class="line">17.2.2 提早和经常地测试应用程序可行性</span><br><span class="line">17.2.3 使用代码标准、代码检查和单元测试以提高代码质量</span><br><span class="line">17.2.4 处理某单一设备的缺陷</span><br><span class="line">17.2.5 在应用程序开发中使用Android工具</span><br><span class="line">17.2.6 避免开发时的愚蠢错误</span><br><span class="line">小结</span><br><span class="line">参考资料和更多信息</span><br><span class="line">第18章 测试Android应用程序</span><br><span class="line">18.1 设计一个应用程序漏洞跟踪系统</span><br><span class="line">18.2 管理测试环境</span><br><span class="line">18.3 尽量全面地进行测试</span><br><span class="line">18.4 在应用程序测试中使用Android工具</span><br><span class="line">18.5 避免测试时的愚蠢错误</span><br><span class="line">小结</span><br><span class="line">参考资料和更多信息</span><br><span class="line">第19章 发布你的Android应用程序</span><br><span class="line">19.1 选择合适的发布模式</span><br><span class="line">19.1.1 保护你的知识产权</span><br><span class="line">19.1.2 向用户收费</span><br><span class="line">19.2 为发布而打包你的应用程序</span><br><span class="line">19.2.1 准备封装你的代码</span><br><span class="line">19.2.2 为你的应用程序打包并签名</span><br><span class="line">19.2.3 测试软件包的发布版本</span><br><span class="line">19.2.4 发布你的应用程序</span><br><span class="line">19.3 在Android Market上发布你的应用程序</span><br><span class="line">19.3.1 在Android Market上注册一个开发人员账号</span><br><span class="line">19.3.2 将你的应用程序上传至Android Market</span><br><span class="line">19.3.3 上传应用程序市场资源</span><br><span class="line">19.3.4 配置应用程序详情页面</span><br><span class="line">19.3.5 配置应用程序发布选项</span><br><span class="line">19.3.6 配置应用程序联系信息和知情通知</span><br><span class="line">19.3.7 将你的应用程序发布至Android Market</span><br><span class="line">19.3.8 在Android Market上管理你的应用程序</span><br><span class="line">19.4 通过其他途径发布应用程序</span><br><span class="line">19.5 通过自主渠道发布应用程序</span><br><span class="line">小结</span><br><span class="line">参考资料和更多信息</span><br><span class="line">第六部分 附录</span><br><span class="line">附录A Android模拟器快速入门</span><br><span class="line">A.1 模拟器的目的：虚拟现实</span><br><span class="line">A.2 使用Android虚拟设备（AVD）</span><br><span class="line">A.2.1 使用Android SDK和AVD管理器</span><br><span class="line">A.2.2 创建AVD</span><br><span class="line">A.3 使用指定AVD启动模拟器</span><br><span class="line">A.3.1 维持模拟器高效运行</span><br><span class="line">A.3.2 配置模拟器启动项</span><br><span class="line">A.3.3 启动模拟器运行应用程序</span><br><span class="line">A.3.4 从Android SDK和AVD管理器中启动模拟器</span><br><span class="line">A.4 配置模拟器的GPS位置信息</span><br><span class="line">A.5 在两个模拟器实例之间拨打电话</span><br><span class="line">A.6 在两个模拟器实例之间发送消息</span><br><span class="line">A.7 通过控制台与模拟器交互</span><br><span class="line">A.7.1 使用控制台模拟来电</span><br><span class="line">A.7.2 使用控制台模拟短消息</span><br><span class="line">A.7.3 使用控制台发送GPS坐标</span><br><span class="line">A.7.4 使用控制台监视网络状态</span><br><span class="line">A.7.5 使用控制台操作电源设置</span><br><span class="line">A.7.6 使用其他控制台命令</span><br><span class="line">A.8 享受模拟器</span><br><span class="line">A.9 认识模拟器的局限</span><br><span class="line">参考资料和更多信息</span><br><span class="line">附录B Android DDMS快速入门</span><br><span class="line">B.1 独立或结合Eclipse使用DDMS</span><br><span class="line">B.2 熟悉DDMS的关键特性</span><br><span class="line">B.3 使用进程、线程和堆</span><br><span class="line">B.3.1 向Android应用程序关联调试器</span><br><span class="line">B.3.2 终止Android进程</span><br><span class="line">B.3.3 监视Android应用程序的线程活动</span><br><span class="line">B.3.4 监视堆活动</span><br><span class="line">B.3.5 触发垃圾回收（GC）</span><br><span class="line">B.3.6 创建和使用HPROF文件</span><br><span class="line">B.4 使用内存分配（allocation）跟踪器</span><br><span class="line">B.5 使用文件浏览器</span><br><span class="line">B.5.1 浏览模拟器或设备上的文件系统</span><br><span class="line">B.5.2 从模拟器或设备上复制文件</span><br><span class="line">B.5.3 向模拟器或设备复制文件</span><br><span class="line">B.5.4 删除模拟器或设备上的文件</span><br><span class="line">B.6 使用模拟器控制</span><br><span class="line">B.6.1 模拟语音来电</span><br><span class="line">B.6.2 模拟短消息接收</span><br><span class="line">B.6.3 发送位置坐标</span><br><span class="line">B.7 在模拟器或目标设备上截屏</span><br><span class="line">B.8 使用应用程序日志</span><br><span class="line">附录C Eclipse技巧和诀窍</span><br><span class="line">C.1 构建你的Eclipse工作空间</span><br><span class="line">C.1.1 集成源代码管理服务</span><br><span class="line">C.1.2 调整视图中的标签面板</span><br><span class="line">C.1.3 最大化窗口</span><br><span class="line">C.1.4 最小化窗口</span><br><span class="line">C.1.5 显示并排窗口</span><br><span class="line">C.1.6 显示同一文件的两个部分</span><br><span class="line">C.1.7 关掉不需要的标签面板</span><br><span class="line">C.1.8 保持对窗口的控制</span><br><span class="line">C.1.9 定制日志过滤器</span><br><span class="line">C.1.10 在项目中搜索</span><br><span class="line">C.1.11 组织Eclipse任务</span><br><span class="line">C.2 编写Java代码</span><br><span class="line">C.2.1 善用自动补全（Autocomplete）</span><br><span class="line">C.2.2 创建类和方法</span><br><span class="line">C.2.3 组织导入</span><br><span class="line">C.2.4 格式化代码</span><br><span class="line">C.2.5 重命名</span><br><span class="line">C.2.6 重构代码</span><br><span class="line">C.2.7 整理代码</span><br><span class="line">C.2.8 使用QuickFix</span><br><span class="line">C.2.9 提供Javadoc风格的文件</span><br><span class="line">C.2.10 解决诡异的构建错误</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B009C2XM2K/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B009C2XM2K&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51h6edqPMZL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android UI基础教程</title>
    <url>/2020/04/19/B009NKMGTG/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android UI基础教程<br>作者信息： 作者: Jason Ostrander [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>详尽的知识点介绍，丰富的图示说明，以及清晰实用的示例。作者集多年实际工作经验，给予读者贴近现实的指导和建议。作者以Android编程专家的身份，对诸多现实问题给出了最佳的解决方案。强调建立扎实的技术基础，从而将精彩的创意完美地表现出来。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1部分 Android UI基础</span><br><span class="line">第1章 入门</span><br><span class="line">1.1 Hello World</span><br><span class="line">1.2 Android应用程序的基本结构</span><br><span class="line">1.2.1 文件夹结构</span><br><span class="line">1.2.2 Android Manifest</span><br><span class="line">1.2.3 资源</span><br><span class="line">1.3 Android UI基础</span><br><span class="line">1.3.1 主屏幕和通知栏</span><br><span class="line">1.3.2 XML布局</span><br><span class="line">1.3.3 ACTIVIY类</span><br><span class="line">1.3.4 硬件按钮</span><br><span class="line">1.4 工具</span><br><span class="line">1.4.1 Android开发者工具</span><br><span class="line">1.4.2 Android虚拟设备</span><br><span class="line">1.4.3 层次浏览器（Hierarehy Viewer）</span><br><span class="line">1.4.4 用DDMS截屏</span><br><span class="line">1.4.5 其他工具</span><br><span class="line">1.5 结束语</span><br><span class="line">第2章 创建第一个应用</span><br><span class="line">2.1 创建一个应用</span><br><span class="line">2.2 开始使用Android视图</span><br><span class="line">2.3 排布视图</span><br><span class="line">2.3.1 FrameLayout</span><br><span class="line">2.3.2 TableLayout</span><br><span class="line">2.3.3 LinearLayout</span><br><span class="line">2.3.4 RelativeLayout</span><br><span class="line">2.3.5 GridLayout</span><br><span class="line">2.4 显示列表</span><br><span class="line">2.4.1 ListActivity</span><br><span class="line">2.4.2 XML布局</span><br><span class="line">2.4.3 把数据绑定到列表</span><br><span class="line">2.4.4 Loader</span><br><span class="line">2.5 理解活动</span><br><span class="line">2.5.1 声明活动</span><br><span class="line">2.5.2 了解活动的生命周期</span><br><span class="line">2.5.3 了解任务和返回堆栈</span><br><span class="line">2.5.4 处理配置更改</span><br><span class="line">2.6 防止应用程序无响应（ANR）</span><br><span class="line">2.6.1 StrictMode</span><br><span class="line">2.6.2 后台任务</span><br><span class="line">2.7 完成TIMETRACKER</span><br><span class="line">2.8 结束语</span><br><span class="line">第3章 更进一步</span><br><span class="line">3.1 支持多种屏幕尺寸</span><br><span class="line">3.1.1 资源限定符</span><br><span class="line">3.1.2 资源限定符优先级</span><br><span class="line">3.1.3 密度无关的像素</span><br><span class="line">3.1.49-补丁图形</span><br><span class="line">3.2 处理通知</span><br><span class="line">3.2.1 TOAST</span><br><span class="line">3.2.2 状态栏通知</span><br><span class="line">3.2.3 对话框</span><br><span class="line">3.3 处理事件</span><br><span class="line">3.3.1 屏幕点击</span><br><span class="line">3.3.2 长按（long press）</span><br><span class="line">3.3.3 聚焦事件（Focus Event）和关键事件（Key Events）</span><br><span class="line">3.4 创建菜单</span><br><span class="line">3.4.1 菜单布局</span><br><span class="line">3.4.2 菜单回调函数</span><br><span class="line">3.4.3 上下文菜单</span><br><span class="line">3.5 实现Time Tracker</span><br><span class="line">3.6 结束语</span><br><span class="line">第2部分 视图框架</span><br><span class="line">第4章 基本视图</span><br><span class="line">4.1 创建一个基本表格</span><br><span class="line">4.1.1 TextView和EditText</span><br><span class="line">4.1.2 按钮</span><br><span class="line">4.1.3 布尔值按钮</span><br><span class="line">4.1.4 Spinner（下拉列表）</span><br><span class="line">4.1.5 ScrollView</span><br><span class="line">4.2 显示图片</span><br><span class="line">4.2.1 ImageView和资源</span><br><span class="line">4.2.2 位图</span><br><span class="line">4.2.3 Drawable</span><br><span class="line">4.3 创建地图和展示网站</span><br><span class="line">4.3.1 MapView</span><br><span class="line">4.3.2 WebView</span><br><span class="line">4.4 结束语</span><br><span class="line">第5章 可复用UI</span><br><span class="line">5.1 抽象布局</span><br><span class="line">5.1.1 标签 5.1.2 标签 5.1.3 ViewStub 5.2 抽象样式和主题 5.2.1 样式 5.2.2 主题 5.3 使用Fragment 5.3.1 布局 5.3.2 Fragment生命周期 5.3.3 Fragment事务 5.3.4 Fragment回退栈 5.4 结束语 第6章 导航和数据加载 6.1 介绍操作栏 6.1.1 操作项 6.1.2 操作视图 6.1.3 ActionProvider类 6.2 应用导航 6.2.1 操作栏导航 6.2.2 TabWidget 6.2.3 ViewPager 6.3 往视图中加载数据 6.3.1 基础数据绑定 6.3.2 Adapter类 6.3.3 loader 6.4 结束语 第7章 Android部件 7.1 创建一个基础的部件 7.1.1 声明部件 7.1.2 AppWidgetProviderInfo XML 7.1.3 AppWidgetProvider类 7.1.4 Remote视图 7.1.5 应用部件配置活动 7.2 创建集合部件 7.2.1 创建布局 7.2.2 创建服务 7.3 结束语 第3部分 高级UI开发 第8章 处理手势操作 8.1 监听触摸事件 8.2 响应手势操作 8.2.1 GestureDetector 8.2.2 ScaleGestureDetector 8.3 结束语 第9章 动画 9.1 创建Drawable动画 9.2 创建视图动画 9.2.1 定义动画 9.2.2 使用Interpolator 9.2.3 使用动画 9.2.4 为TimeTracker添加一个时钟走动的动画 9.3 创建属性动画 9.3.1 ValueAnimator 9.3.2 Animator集 9.3.3 XML中的属性动画 9.3.4 ViewPropertyAnimator 9.3.5 LayoutTransition 9.4 结束语 第10章 创建自定义视图 10.1 理解Android如何绘制视图 10.2 创建自定义视图 10.2.1 OnMeasure 10.2.2 OnDraw 10.3 向自定义视图中添加自定义属性 10.3.1 声明属性 10.3.2 在XML中使用属性 10.3.3 在代码中使用属性 10.4 创建复合组件 10.4.1 创建一个复合组件 10.4.2 优化布局 10.5 结束语 第11章 创建高级图形 11.1 使用Canvas 11.1.1 实现SurfaceView 11.1.2 在SurfaceView上绘图 11.2 使用RenderScript 11.2.1 RenderScript文件 11.2.2 Java API ll.3 使用OpenGL 11.3.1 OpenGL基础 11.3.2 绘制图形 11.4 结束语 第12章 本地化和辅助功能 12.1 让应用可以使用多国语言 12.1.1 Android的本地化概述 12.1.2 格式和复数 12.2 让应用易于访问 12.2.1 导航和聚焦 12.2.2 内容描述 12.2.3 AccessibilityEvents 12.3 结束语   &lt;&#x2F;merge&gt;&lt;&#x2F;include&gt;</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B009NKMGTG/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B009NKMGTG&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41vrbp2ew3L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Arduino+Android互动智作</title>
    <url>/2020/04/19/B009QY1ESI/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Arduino+Android互动智作<br>作者信息： 作者: Simon Monk [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Arduino+Android互动智作》适合广大“创客”和电子爱好者自学、培训，也可作为高等院校相关专业及电子设计（制作）大赛的教学用书。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Chapter 1 蓝牙自走车</span><br><span class="line">制作</span><br><span class="line">原理讲解</span><br><span class="line">小结 </span><br><span class="line"></span><br><span class="line"> Chapter 2 Android盖革计数器 Google开源附件 制作 原理讲解 小结</span><br><span class="line"></span><br><span class="line"> Chapter 3 Android彩灯板 制作Arduino USB Host加料扩展板 制作彩灯板 使用效果 原理讲解 小结</span><br><span class="line"></span><br><span class="line"> Chapter 4 电视遥控器 制作 使用效果 小结</span><br><span class="line"></span><br><span class="line"> Chapter 5 温度记录器 制作 使用效果 原理讲解 小结</span><br><span class="line"></span><br><span class="line"> Chapter 6 超声波距离探测器 制作 使用效果 原理讲解 小结</span><br><span class="line"></span><br><span class="line"> Chapter 7 家居自动化控制器 制作音频连接模块 Android APP 通过互联网访问 原理讲解 小结</span><br><span class="line"></span><br><span class="line"> Chapter 8 电源控制 电源控制模块的概貌 制作电源控制模块 整合到家居自动化控制器 使用效果 原理讲解 小结</span><br><span class="line"></span><br><span class="line"> Chapter 9 智能恒温器 制作 使用效果 原理讲解 小结</span><br><span class="line"></span><br><span class="line"> Chapter 10 RFID门锁 制作 使用效果 原理讲解 小结</span><br><span class="line"></span><br><span class="line"> Chapter 11 信号旗 制作 原理讲解 小结</span><br><span class="line"></span><br><span class="line"> Chapter 12 延时器 制作 原理讲解 小结</span><br><span class="line"></span><br><span class="line"> 附录 Android开源附件开发入门 学习Android编程 学习Arduino编程 选择学习示例 Arduino端开发 Android端开发 总结</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B009QY1ESI/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B009QY1ESI&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51wZcDgdz7L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android应用性能优化</title>
    <url>/2020/04/19/B009VV6EG8/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android应用性能优化<br>作者信息： 作者: Hervé Guihot [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Android应用开发者经常要想尽办法来提升程序性能。Herve Guihot专著的《Android应用性能优化》主要介绍如何快速高效地优化应用，让应用变得稳定高效。你将学会利用Android SDK和NDK来混合或单独使用Java、C/C++来开发应用。    把Herve Guihot专著的《Android应用性能优化》的内容学以致用，你的编程技术就会得到关键性的提升，写出的应用就会更为健壮高效，从而广受用户好评，并最终获得成功。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章Java代码优化</span><br><span class="line">1.1Android如何执行代码</span><br><span class="line">1.2优化斐波纳契数列</span><br><span class="line">1.2.1从递归到迭代</span><br><span class="line">1.2.2BigInteger</span><br><span class="line">1.3缓存结果</span><br><span class="line">1.4API等级</span><br><span class="line">1.5数据结构</span><br><span class="line">1.6响应能力</span><br><span class="line">1.6.1推迟初始化</span><br><span class="line">1.6.2StrictMode</span><br><span class="line">1.7SQLite</span><br><span class="line">1.7.1SQLite语句</span><br><span class="line">1.7.2事务</span><br><span class="line">1.7.3查询</span><br><span class="line">1.8总结</span><br><span class="line">第2章NDK入门</span><br><span class="line">2.1NDK里有什么</span><br><span class="line">2.2混合使用Java和C&#x2F;C++代码</span><br><span class="line">2.2.1声明本地方法</span><br><span class="line">2.2.2实现JNI粘合层</span><br><span class="line">2.2.3创建Makefile</span><br><span class="line">2.2.4实现本地函数</span><br><span class="line">2.2.5编译本地库</span><br><span class="line">2.2.6加载本地库</span><br><span class="line">2.3Application.mk</span><br><span class="line">2.3.1为（几乎）所有设备优化</span><br><span class="line">2.3.2支持所有设备</span><br><span class="line">2.4Android.mk</span><br><span class="line">2.5使用C&#x2F;C++改进性能</span><br><span class="line">2.6本地Acitivity</span><br><span class="line">2.6.1构建缺失的库</span><br><span class="line">2.6.2替代方案</span><br><span class="line">2.7总结</span><br><span class="line">第3章NDK进阶</span><br><span class="line">3.1汇编</span><br><span class="line">3.1.1最大公约数</span><br><span class="line">3.1.2色彩转换</span><br><span class="line">3.1.3并行计算平均值</span><br><span class="line">3.1.4ARM指令</span><br><span class="line">3.1.5ARMNEON</span><br><span class="line">3.1.6CPU特性</span><br><span class="line">3.2C扩展</span><br><span class="line">3.2.1内置函数</span><br><span class="line">3.2.2向量指令</span><br><span class="line">3.3技巧</span><br><span class="line">3.3.1内联函数</span><br><span class="line">3.3.2循环展开</span><br><span class="line">3.3.3内存预读取</span><br><span class="line">3.3.4用LDM&#x2F;STM替换LDR&#x2F;STD</span><br><span class="line">3.4总结</span><br><span class="line">第4章高效使用内存</span><br><span class="line">4.1说说内存</span><br><span class="line">4.2数据类型</span><br><span class="line">4.2.1值的比较</span><br><span class="line">4.2.2其他算法</span><br><span class="line">4.2.3数组排序</span><br><span class="line">4.2.4定义自己的类</span><br><span class="line">4.3访问内存</span><br><span class="line">4.4排布数据</span><br><span class="line">4.5垃圾收集</span><br><span class="line">4.5.1内存泄漏</span><br><span class="line">4.5.2引用</span><br><span class="line">4.6API</span><br><span class="line">4.7内存少的时候</span><br><span class="line">4.8总结</span><br><span class="line">第5章多线程和同步</span><br><span class="line">5.1线程</span><br><span class="line">5.2AsyncTask</span><br><span class="line">5.3Handler和Looper</span><br><span class="line">5.3.1Handler</span><br><span class="line">5.3.2Looper</span><br><span class="line">5.4数据类型</span><br><span class="line">5.5并发</span><br><span class="line">5.6多核</span><br><span class="line">5.6.1为多核修改算法</span><br><span class="line">5.6.2使用并发缓存</span><br><span class="line">5.7Activity生命周期</span><br><span class="line">5.7.1传递信息</span><br><span class="line">5.7.2记住状态</span><br><span class="line">5.8总结</span><br><span class="line">第6章性能评测和剖析</span><br><span class="line">6.1时间测量</span><br><span class="line">6.1.1System.nanoTime（）</span><br><span class="line">6.1.2Debug.threadCpuTimeNanos（）</span><br><span class="line">6.2方法调用跟踪</span><br><span class="line">6.2.1Debug.startMethodTracing（）</span><br><span class="line">6.2.2使用Traceview工具</span><br><span class="line">6.2.3DDMS中的Traceview</span><br><span class="line">6.2.4本地方法跟踪</span><br><span class="line">6.3日志</span><br><span class="line">6.4总结</span><br><span class="line">第7章延长电池续航时间</span><br><span class="line">7.1电池</span><br><span class="line">7.2禁用广播接收器</span><br><span class="line">7.3网络</span><br><span class="line">7.3.1后台数据</span><br><span class="line">7.3.2数据传输</span><br><span class="line">7.4位置</span><br><span class="line">7.4.1注销监听器</span><br><span class="line">7.4.2更新频率</span><br><span class="line">7.4.3多种位置服务</span><br><span class="line">7.4.4筛选定位服务</span><br><span class="line">7.4.5最后已知位置</span><br><span class="line">7.5传感器</span><br><span class="line">7.6图形</span><br><span class="line">7.7提醒</span><br><span class="line">7.8WakeLock</span><br><span class="line">7.9总结</span><br><span class="line">第8章图形</span><br><span class="line">8.1布局优化</span><br><span class="line">8.1.1相对布局</span><br><span class="line">8.1.2合并布局</span><br><span class="line">8.1.3重用布局</span><br><span class="line">8.1.4ViewStub</span><br><span class="line">8.2布局工具</span><br><span class="line">8.2.1层级视图</span><br><span class="line">8.2.2layoutopt</span><br><span class="line">8.3Open GLES</span><br><span class="line">8.3.1扩展</span><br><span class="line">8.3.2纹理压缩</span><br><span class="line">8.3.3Mipmap</span><br><span class="line">8.3.4多APK</span><br><span class="line">8.3.5着色</span><br><span class="line">8.3.6场景复杂性</span><br><span class="line">8.3.7消隐</span><br><span class="line">8.3.8渲染模式</span><br><span class="line">8.3.9功耗管理</span><br><span class="line">8.4总结</span><br><span class="line">第9章RenderScript</span><br><span class="line">9.1概览</span><br><span class="line">9.2HelloWorld</span><br><span class="line">9.3HelloRendering</span><br><span class="line">9.3.1创建渲染脚本</span><br><span class="line">9.3.2创建RenderScriptGL Context</span><br><span class="line">9.3.3展开RSSurfaceView</span><br><span class="line">9.3.4设置内容视图</span><br><span class="line">9.4在脚本中添加变量</span><br><span class="line">9.5HelloCompute</span><br><span class="line">9.5.1Allocation</span><br><span class="line">9.5.2rsForEach</span><br><span class="line">9.5.3性能</span><br><span class="line">9.6自带的RenderScript API</span><br><span class="line">9.6.1rs_types.rsh</span><br><span class="line">9.6.2rs_core.rsh</span><br><span class="line">9.6.3rs_cl.rsh</span><br><span class="line">9.6.4rs_math.rsh</span><br><span class="line">9.6.5rs_graphics.rsh</span><br><span class="line">9.6.6rs_time.rsh</span><br><span class="line">9.6.7rs_atomic.rsh</span><br><span class="line">9.7RenderScript与NDK对比</span><br><span class="line">9.8总结</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B009VV6EG8/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B009VV6EG8&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec8.images-amazon.com/images/I/4170K0zYMTL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 4游戏编程入门经典</title>
    <url>/2020/04/19/B00A74LES6/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android 4游戏编程入门经典<br>作者信息： 作者: 策希纳 (Mario Zechner) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Android 4游戏编程入门经典》囊括了成为一名成功的Android游戏开发者所需的全部知识。《Android 4游戏编程入门经典》是一本可以信赖的指南，能够帮助你在移动游戏开发中迅速“升级”。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 Android，后起之秀</span><br><span class="line">1.1 Android简介</span><br><span class="line">1.2 版本分裂</span><br><span class="line">1.3 谷歌的角色</span><br><span class="line">1.3.1 Android开源项目</span><br><span class="line">1.3.2 Android Market</span><br><span class="line">1.3.3 挑战赛、设备播种计划和谷歌I&#x2F;O</span><br><span class="line">1.4 Android的功能和体系结构</span><br><span class="line">1.4.1 内核</span><br><span class="line">1.4.2 运行库和Dalvik虚拟机</span><br><span class="line">1.4.3 系统库</span><br><span class="line">1.4.4 应用程序框架</span><br><span class="line">1.5 软件开发工具包</span><br><span class="line">1.6 开发人员社区</span><br><span class="line">1.7 设备，设备，设备</span><br><span class="line">1.7.1 硬件</span><br><span class="line">1.7.2 没备的范围</span><br><span class="line">1.8 所有设备之间的兼容性</span><br><span class="line">1.9 不同的手机游戏</span><br><span class="line">1.9.1 人手一台游戏机</span><br><span class="line">1.9.2 随时上网</span><br><span class="line">1.9.3 普通用户与游戏迷</span><br><span class="line">1.9.4 市场很大，开发人员很少</span><br><span class="line">1.10 小结</span><br><span class="line">第2章 从Android SDK开始</span><br><span class="line">2.1 搭建开发环境</span><br><span class="line">2.1.1 安装JDK</span><br><span class="line">2.1.2 安装Android SDK</span><br><span class="line">2.1.3 安装Eclipse</span><br><span class="line">2.1.4 安装ADT Eclipse插件</span><br><span class="line">2.1.5 Eclipse快速浏览</span><br><span class="line">2.1.6 一些实用的Eclipse快捷键</span><br><span class="line">2.2 Android环境下的Hello World</span><br><span class="line">2.2.1 创建项目</span><br><span class="line">2.2.2 进一步分析项目</span><br><span class="line">2.2.3 编写应用程序代码</span><br><span class="line">2.3 运行和调试Android应用程序</span><br><span class="line">2.3.1 连接设备</span><br><span class="line">2.3.2 创建一个Android虚拟设备</span><br><span class="line">2.3.3 运行应用程序</span><br><span class="line">2.3.4 调试应用程序</span><br><span class="line">2.3.5 LogCat和DDMS</span><br><span class="line">2.3.6 使用ADB</span><br><span class="line">2.4 小结</span><br><span class="line">第3章 游戏开发基础</span><br><span class="line">3.1 游戏类型</span><br><span class="line">3.1.1 休闲游戏</span><br><span class="line">3.1.2 益智游戏</span><br><span class="line">3.1.3 动作和街机游戏</span><br><span class="line">3.1.4 塔防游戏</span><br><span class="line">3.1.5 创新</span><br><span class="line">3.2 游戏设计：笔比代码更强大</span><br><span class="line">3.2.1 游戏的核心机制</span><br><span class="line">3.2.2 一个故事和一种艺术风格</span><br><span class="line">3.2.3 画面和切换</span><br><span class="line">3.3 代码：具体细节</span><br><span class="line">3.3.1 应用程序和窗口管理</span><br><span class="line">3.3.2 输入</span><br><span class="line">3.3.3 文件I&#x2F;O</span><br><span class="line">3.3.4 音频</span><br><span class="line">3.3.5 图形</span><br><span class="line">3.3.6 游戏框架</span><br><span class="line">3.4 小结</span><br><span class="line">第4章 面向游戏开发人员的Android</span><br><span class="line">4.1 定义一个Android应用程序：清单文件</span><br><span class="line">4.1.1 元素 4.1.2 元素 4.1.3 元素 4.1.4 元素 4.1.5 元素 4.1.6 元素 4.1.7 10个简单步骤建立Android游戏项目 4.1.8 市场过滤器 4.1.9 定义游戏图标 4.2 Android Apl基础 4.2.1 创建测试项目 4.2.2 活动的牛命周期 4.2.3 处理输入设备 4.2.4 文件处理 4.2.5 音频编程 4.2.6 播放音效 4.2.7 音乐流 4.2.8 基本图形编程 4.3 最佳实践 4.4 小结 第5章 Android游戏开发框架 5.1 制定计划 5.2 AndroidFileIO类 5.3 AndroidAudio、AndroidSound和AndroidMusic 5.4 Androidlnput和Accelerometer—Handler 5.4.1 AccelerometerHandler：手机哪一面朝上 5.4.2 CompassHandler 5.4.3 Pool类：重用相当有用 5.4.4 KevboardHandler 5.4.5 触摸处理程序 5.4.6 Androidlnput：优秀的协调者 5.5 AndroidGraphics和AndroidPixmap 5.5.1 处理不同屏幕人小和分辨率的问题 5.5.2 AndroidPixmap：人物的像素 5.5.3 AndroidGraphics：满足绘图需求 5.5.4 AndroidFastRenderView 5.6 AndroidGame：合并所有内容 5.7 小结 第6章 Mr.Nom入侵Android 6.1 创建资源 6.2 建立项目 6.3 MrNomGame：主要活动 6.3.1 资源：便捷的资源存储 6.3.2 设置：跟踪用户的选项设置和高分榜 6.3.3 LoadingScreen：从磁盘获取资源 6.4 主菜单画面 6.5 HelpScreen类 6.6 高分榜画面显示 6.6.1 渲染数字 6.6.2 画面的实现 6.7 抽象 6.7.1 抽象Mr.Nom的世界：模型、视图、控制器 6.7.2 GameScreen类 6.8 小结 第7章 OpenGL ES介绍 7.1 OpenGL ES概述以及关注它的原因 7.1.1 编程模型：一个比喻 …… 第8章 2D游戏编程技巧 第9章 Super Jumper：一个2D 第10章 OpenGL ES：进入3D世界 第11章 3D编程技巧 第12章 Droid Invaders游戏 第13章 发布游戏 第14章 进阶内容   &lt;&#x2F;uses&gt;&lt;&#x2F;uses&gt;&lt;&#x2F;uses&gt;&lt;&#x2F;activity&gt;&lt;&#x2F;application&gt;&lt;&#x2F;manifest&gt;</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00A74LES6/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00A74LES6&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec8.images-amazon.com/images/I/51vFJMbDzxL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android应用开发入门</title>
    <url>/2020/04/19/B00APLPK18/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android应用开发入门<br>作者信息： 作者: 杰克逊 (Wallace Jackson) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>零基础 轻松学会Android应用开发巧入门 从容探索移动开发新世界大视野 助力Android新起跑线</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 绪论 1</span><br><span class="line">1.1 Android是什么 1</span><br><span class="line">1.2 Android的优势 2</span><br><span class="line">1.3 本书范围 3</span><br><span class="line">1.3.1 本书所涉及的内容 3</span><br><span class="line">1.3.2 本书未涉及的内容 4</span><br><span class="line">1.4 下载SDK工具 4</span><br><span class="line">1.4.1 Java 5</span><br><span class="line">1.4.2 Eclipse 6</span><br><span class="line">1.4.3 AndroidSDK 7</span><br><span class="line">1.5 小结 7</span><br><span class="line">第2章 本书内容梗概 9</span><br><span class="line">2.1 Android集成开发环境 9</span><br><span class="line">2.2 Java、XML以及Android的工作原理 11</span><br><span class="line">2.3 Android应用程序框架 11</span><br><span class="line">2.4 屏幕布局设计 12</span><br><span class="line">2.5 用户界面设计 12</span><br><span class="line">2.6 图像与动画设计 13</span><br><span class="line">2.7 交互性 13</span><br><span class="line">2.8 内容提供器 13</span><br><span class="line">2.9 Intent和Intent过滤器 14</span><br><span class="line">2.10 Android的未来 14</span><br><span class="line">2.11 小结 15</span><br><span class="line">第3章 配置Android开发环境 16</span><br><span class="line">3.1 安装Java、Eclipse和Android 16</span><br><span class="line">3.1.1 JavaSE和JRE：应用程序开发的基础 16</span><br><span class="line">3.1.2 EclipseIDE：开发环境 18</span><br><span class="line">3.1.3 AndroidSDK：用于Eclipse的Android工具包 21</span><br><span class="line">3.1.4 Android开发工具：用于Eclipse的Android工具 22</span><br><span class="line">3.1.5 Eclipse中的Android环境 25</span><br><span class="line">3.2 升级AndroidSDK 26</span><br><span class="line">3.3 配置AVD与智能手机连接 29</span><br><span class="line">3.3.1 AVD：智能手机模拟器 29</span><br><span class="line">3.3.2 USB智能手机驱动程序：外部设备 31</span><br><span class="line">3.4 在64位平台上进行开发 31</span><br><span class="line">3.5 小结 33</span><br><span class="line">第4章 Android软件开发平台介绍 34</span><br><span class="line">4.1 了解JavaSE与Dalvik虚拟机 34</span><br><span class="line">4.2 Android工程的目录结构 35</span><br><span class="line">4.2.1 典型的默认资源目录 36</span><br><span class="line">4.2.2 Values目录 37</span><br><span class="line">4.3 用好AndroidXML（你的秘密武器） 38</span><br><span class="line">4.3.1 屏幕尺寸 39</span><br><span class="line">4.3.2 桌面时钟 39</span><br><span class="line">4.4 使用Android应用程序资源 40</span><br><span class="line">4.4.1 位图图片 40</span><br><span class="line">4.4.2 可选资源目录 40</span><br><span class="line">4.5 启动应用程序：AndroidManifest.xml文件 41</span><br><span class="line">4.6 创建第一个Android应用 42</span><br><span class="line">4.6.1 启动Eclipse 42</span><br><span class="line">4.6.2 创建一个Android工程 43</span><br><span class="line">4.6.3 查看并编辑应用程序文件 45</span><br><span class="line">4.6.4 在strings.xml中设置一个变量的值 49</span><br><span class="line">4.6.5 运行应用 51</span><br><span class="line">4.6.6 添加应用程序图标 52</span><br><span class="line">4.7 小结 55</span><br><span class="line">第5章 Android框架概览 56</span><br><span class="line">5.1 OOP的基础：对象 56</span><br><span class="line">5.1.1 一些OOP术语 58</span><br><span class="line">5.1.2 对象的设计图：类 58</span><br><span class="line">5.1.3 为类赋予结构：继承 62</span><br><span class="line">5.1.4 定义接口 64</span><br><span class="line">5.1.5 将类组织起来：包 65</span><br><span class="line">5.2 XML概览 66</span><br><span class="line">5.3 剖析Android应用程序：APK文件 66</span><br><span class="line">5.4 Android应用程序组件 68</span><br><span class="line">5.4.1 Android活动：定义UI 68</span><br><span class="line">5.4.2 Android服务：后台处理 69</span><br><span class="line">5.4.3 广播接收器：消息和通知 69</span><br><span class="line">5.4.4 内容提供器：数据管理 70</span><br><span class="line">5.5 AndroidIntent对象：组件的通信 71</span><br><span class="line">5.6 AndroidManifestXML：组件的声明 71</span><br><span class="line">5.7 小结 73</span><br><span class="line">第6章 屏幕布局设计：视图与布局 75</span><br><span class="line">6.1 Android视图结构 75</span><br><span class="line">6.1.1 使用View类 75</span><br><span class="line">6.1.2 嵌套视图：使用ViewGroup类 76</span><br><span class="line">6.2 定义屏幕布局：使用XML 77</span><br><span class="line">6.2.1 配置屏幕布局 77</span><br><span class="line">6.2.2 使用线性布局 78</span><br><span class="line">6.2.3 使用相对布局 88</span><br><span class="line">6.2.4 滑动抽屉：扩展你的UI 91</span><br><span class="line">6.2.5 在视图和布局中使用内外边距和外外边距 94</span><br><span class="line">6.2.6 在View中设置内边距 95</span><br><span class="line">6.2.7 在ViewGroup中设置外边距 95</span><br><span class="line">6.3 小结 95</span><br><span class="line">第7章 按钮、菜单与对话框 97</span><br><span class="line">7.1 使用常见的UI元素 97</span><br><span class="line">7.1.1 为布局添加图像按钮 97</span><br><span class="line">7.1.2 为布局添加文本 107</span><br><span class="line">7.1.3 添加图片 108</span><br><span class="line">7.2 使用菜单 110</span><br><span class="line">7.2.1 用XML创建菜单结构 111</span><br><span class="line">7.2.2 定义菜单项文本 112</span><br><span class="line">7.2.3 通过Java载入菜单结构 115</span><br><span class="line">7.2.4 在Android模拟器中运行应用 116</span><br><span class="line">7.2.5 让菜单发挥作用 117</span><br><span class="line">7.3 添加对话框 119</span><br><span class="line">7.3.1 使用自定义对话框子类 120</span><br><span class="line">7.3.2 显示警告对话框 120</span><br><span class="line">7.4 小结 124</span><br><span class="line">第8章 Android图像资源介绍 125</span><br><span class="line">8.1 图像资源简介 125</span><br><span class="line">8.1.1 调用图片 126</span><br><span class="line">8.1.2 核心图像资源子类 126</span><br><span class="line">8.2 使用位图 127</span><br><span class="line">8.2.1 PNG图片 127</span><br><span class="line">8.2.2 JPEG和GIF图片 128</span><br><span class="line">8.3 创建动画 128</span><br><span class="line">8.3.1 基于帧的2D动画 128</span><br><span class="line">8.3.2 补间动画 136</span><br><span class="line">8.4 使用过渡 141</span><br><span class="line">8.5 创建9—Patch自定义伸缩图片 145</span><br><span class="line">8.6 播放视频 150</span><br><span class="line">8.6.1 添加VideoView对象 150</span><br><span class="line">8.6.2 为视频添加Java代码 152</span><br><span class="line">8.7 小结 154</span><br><span class="line">第9章 增加交互性：处理UI事件 155</span><br><span class="line">9.1 UI事件概述 155</span><br><span class="line">9.1.1 监听及处理事件 155</span><br><span class="line">9.1.2 通过View类处理UI事件 155</span><br><span class="line">9.1.3 事件回调方法 156</span><br><span class="line">9.2 处理onClick事件 157</span><br><span class="line">9.2.1 为UI元素实现onClick监听器 157</span><br><span class="line">9.2.2 向活动添加onClick监听器 158</span><br><span class="line">9.3 Android触摸屏事件：onTouch 165</span><br><span class="line">9.4 触屏版右键点击：onLongClick 166</span><br><span class="line">9.5 键盘事件监听器：onKeyUp和onKeyDown 169</span><br><span class="line">9.5.1 添加用于键盘事件的XML代码 169</span><br><span class="line">9.5.2 添加用于键盘事件的Java代码 170</span><br><span class="line">9.6 上下文菜单：onCreateContextMenu 171</span><br><span class="line">9.6.1 添加用于上下文菜单的XML代码 172</span><br><span class="line">9.6.2 添加用于上下文菜单的Java代码 173</span><br><span class="line">9.7 焦点控制 178</span><br><span class="line">9.7.1 添加用于焦点控制的XML代码 179</span><br><span class="line">9.7.2 添加用于焦点控制的Java代码 182</span><br><span class="line">9.7.3 设置焦点可用性 184</span><br><span class="line">9.8 小结 185</span><br><span class="line">第10章 了解内容提供器 186</span><br><span class="line">10.1 Android内容提供器概述 186</span><br><span class="line">10.1.1 数据库和数据库管理系统 186</span><br><span class="line">10.1.2 Android内置内容提供器 188</span><br><span class="line">10.2 定义内容提供器 190</span><br><span class="line">10.2.1 在Eclipse中创建内容提供器示例 191</span><br><span class="line">10.2.2 定义安全权限 192</span><br><span class="line">10.2.3 向联系人数据库添加数据 195</span><br><span class="line">10.3 操作数据库 197</span><br><span class="line">10.3.1 查询内容提供器 197</span><br><span class="line">10.3.2 向内容提供器添加数据 203</span><br><span class="line">10.3.3 修改内容提供器数据 208</span><br><span class="line">10.3.4 删除内容提供器数据 212</span><br><span class="line">10.4 小结 217</span><br><span class="line">第11章 了解Intent和Intent过滤器 218</span><br><span class="line">11.1 什么是Intent 218</span><br><span class="line">11.2 通过Intent对象传递消息 219</span><br><span class="line">11.3 Intent解析：显式Intent和隐式Intent 221</span><br><span class="line">11.3.1 显式Intent 221</span><br><span class="line">11.3.2 隐式Intent 222</span><br><span class="line">11.4 在活动中使用Intent 223</span><br><span class="line">11.4.1 编写数字时钟活动 227</span><br><span class="line">11.4.2 连接到应用程序 230</span><br><span class="line">11.4.3 发送Intent 231</span><br><span class="line">11.5 Android服务：在自己的类中处理数据 234</span><br><span class="line">11.5.1 在服务中使用Intent 234</span><br><span class="line">11.5.2 创建服务 237</span><br><span class="line">11.5.3 实现媒体播放功能 241</span><br><span class="line">11.5.4 将按钮连接到服务 241</span><br><span class="line">11.5.5 运行应用程序 243</span><br><span class="line">11.6 在广播接收器中使用Intent 244</span><br><span class="line">11.6.1 用XML创建定时器用户界面 244</span><br><span class="line">11.6.2 创建一个定时广播接收器 246</span><br><span class="line">11.6.3 配置AndroidManifest.xml文件的标签 247</span><br><span class="line">11.6.4 实现Intent 248</span><br><span class="line">11.6.5 在Android1.5模拟器中运行定时器应用程序 252</span><br><span class="line">11.7 小结 253</span><br><span class="line">第12章 探索未来 254</span><br><span class="line">12.1 创建自定义部件 254</span><br><span class="line">12.2 位置服务 256</span><br><span class="line">12.3 Google地图 256</span><br><span class="line">12.4 Google搜索 259</span><br><span class="line">12.5 数据存储 260</span><br><span class="line">12.5.1 共享配置选项 260</span><br><span class="line">12.5.2 内部存储 261</span><br><span class="line">12.5.3 外部存储 261</span><br><span class="line">12.5.4 使用SQLite 261</span><br><span class="line">12.6 设备管理：IT安全部署 262</span><br><span class="line">12.7 用Camera类控制摄像头 262</span><br><span class="line">12.8 3D图形：使用OpenGLES1.x 262</span><br><span class="line">12.9 面部识别 263</span><br><span class="line">12.10 音频池 263</span><br><span class="line">12.11 媒体录制 264</span><br><span class="line">12.12 小结 265</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00APLPK18/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00APLPK18&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/61uAhpa2gOL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android软件安全与逆向分析</title>
    <url>/2020/04/19/B00BMTVUGG/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android软件安全与逆向分析<br>作者信息： 作者: 丰生强 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>国内第一本Android软件安全书别让你的代码成为别人的炮灰eoe全球最大中文Android开发者社区、看雪论坛、安卓巴士          推荐每一位Android开发者的必备之书！在Android这个平台，我们已面临诸多威胁！2013年超过1800万台Android设备会遭遇某种形式的恶意软件的攻击。  恶意代码和病毒数量呈指数增长；  应用软件和数字内容的版权不断遭到侵害；  软件破解、篡改、广告库修改和植入、应用内付费破解等普遍存在；  软件本身的安全漏洞也频繁出现在国内外互联网企业的产品中；  数据泄露和账户被盗等潜在风险让人担忧；  官方系统、第三方定制系统和预装软件的漏洞不断被发现。要掌握主动，免除威胁，你应了解真相！安全技术几乎都是双刃剑，它们既能协助我们开发更有效的保护技术，也几乎必定会被攻击者学习和参考。这里的问题是，大量安全技术的首次大范围公开，是否会带来广泛的模仿和学习，从而引发更多的攻击？在这个问题上，安全界一直存在争议。这是任何一本里程碑式的安全书籍都无法绕开的话题。在《信息安全工程》中，Ross Anderson说：”尽管一些恶意分子会从这样的书中获益，但他们大都已经知道了这些技巧，而好人们获得的收益会多得多。”正是基于对这种观念的认同，才使得这本书呈现于此。强实践性。这本书的几乎每一个部分，都结合实际例子，一步步讲解如何操作。缺乏可操作性，是Android安全方面现有论文、白皮书、技术文章最大的问题之一，很多人读到最后可能对内容有了一些概念，却不知道从何下手。强时效性。作者在写作的同时，持续跟随业界最新进展，刚刚发布不久的Santoku虚拟机、APIMonitor等工具，以及Androguard的新特性等，已然出现在了这本书中。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章Android程序分析环境搭建</span><br><span class="line">1.1Windows分析环境搭建</span><br><span class="line">1.1.1安装JDK</span><br><span class="line">1.1.2安装Android SDK</span><br><span class="line">1.1.3安装Android NDK</span><br><span class="line">1.1.4Eclipse集成开发环境</span><br><span class="line">1.1.5安装CDT、ADT插件</span><br><span class="line">1.1.6创建Android Virtual Device</span><br><span class="line">1.1.7使用到的工具</span><br><span class="line">1.2Linux分析环境搭建</span><br><span class="line">1.2.1本书的Linux环境</span><br><span class="line">1.2.2安装JDK</span><br><span class="line">1.2.3在Ubuntu上安装Android SDK</span><br><span class="line">1.2.4在Ubuntu上安装Android NDK</span><br><span class="line">1.2.5在Ubuntu上安装Eclipse集成开发环境</span><br><span class="line">1.2.6在Ubuntu上安装CDT、ADT插件</span><br><span class="line">1.2.7创建Android Virtual Device</span><br><span class="line">1.2.8使用到的工具</span><br><span class="line">1.3本章小结</span><br><span class="line">第2章如何分析Android程序</span><br><span class="line">2.1编写第一个Android程序</span><br><span class="line">2.1.1使用Eclipse创建Android工程</span><br><span class="line">2.1.2编译生成APK文件</span><br><span class="line">2.2破解第一个程序</span><br><span class="line">2.2.1如何动手？</span><br><span class="line">2.2.2反编译APK文件</span><br><span class="line">2.2.3分析APK文件</span><br><span class="line">2.2.4修改Smali文件代码</span><br><span class="line">2.2.5重新编译APK文件并签名</span><br><span class="line">2.2.6安装测试</span><br><span class="line">2.3本章小结</span><br><span class="line">第3章进入Android Dalvik虚拟机</span><br><span class="line">3.1Dalvik虚拟机的特点——掌握Android程序的运行原理</span><br><span class="line">3.1.1Dalvik虚拟机概述</span><br><span class="line">3.1.2Dalvik虚拟机与Java虚拟机的区别</span><br><span class="line">3.1.3Dalvik虚拟机是如何执行程序的</span><br><span class="line">3.1.4关于Dalvik虚拟机JIT（即时编译）</span><br><span class="line">3.2Dalvik汇编语言基础为分析Android程序做准备</span><br><span class="line">3.2.1Dalvik指令格式</span><br><span class="line">3.2.2DEX文件反汇编工具</span><br><span class="line">3.2.3了解Dalvik寄存器</span><br><span class="line">3.2.4两种不同的寄存器表示方法——v命名法与p命名法</span><br><span class="line">3.2.5Dalvik字节码的类型、方法与字段表示方法</span><br><span class="line">3.3Dalvik指令集</span><br><span class="line">3.3.1指令特点</span><br><span class="line">3.3.2空操作指令</span><br><span class="line">3.3.3数据操作指令</span><br><span class="line">3.3.4返回指令</span><br><span class="line">3.3.5数据定义指令</span><br><span class="line">3.3.6锁指令</span><br><span class="line">3.3.7实例操作指令</span><br><span class="line">3.3.8数组操作指令</span><br><span class="line">3.3.9异常指令</span><br><span class="line">3.3.10跳转指令</span><br><span class="line">3.3.11比较指令</span><br><span class="line">3.3.12字段操作指令</span><br><span class="line">3.3.13方法调用指令</span><br><span class="line">3.3.14数据转换指令</span><br><span class="line">3.3.15数据运算指令</span><br><span class="line">3.4Dalvik指令集练习——写一个Dalvik版的Hello World</span><br><span class="line">3.4.1编写smali文件</span><br><span class="line">3.4.2编译smali文件</span><br><span class="line">3.4.3测试运行</span><br><span class="line">3.5本章小结</span><br><span class="line">第4章Android可执行文件</span><br><span class="line">4.1Android程序的生成步骤</span><br><span class="line">4.2Android程序的安装流程</span><br><span class="line">4.3dex文件格式</span><br><span class="line">4.3.1dex文件中的数据结构</span><br><span class="line">4.3.2dex文件整体结构</span><br><span class="line">4.3.3dex文件结构分析</span><br><span class="line">4.4odex文件格式</span><br><span class="line">4.4.1如何生成odex文件</span><br><span class="line">4.4.2odex文件整体结构</span><br><span class="line">4.4.3odex文件结构分析</span><br><span class="line">4.5dex文件的验证与优化工具dexopt的工作过程</span><br><span class="line">4.6Android应用程序另类破解方法</span><br><span class="line">4.7本章小结</span><br><span class="line">第5章静态分析Android程序</span><br><span class="line">5.1什么是静态分析</span><br><span class="line">5.2快速定位Android程序的关键代码</span><br><span class="line">5.2.1反编译apk程序</span><br><span class="line">5.2.2程序的主Activity</span><br><span class="line">5.2.3需重点关注的Application类</span><br><span class="line">5.2.4如何定位关键代码——六种方法</span><br><span class="line">5.3smali文件格式</span><br><span class="line">5.4Android程序中的类</span><br><span class="line">5.4.1内部类</span><br><span class="line">5.4.2监听器</span><br><span class="line">5.4.3注解类</span><br><span class="line">5.4.4自动生成的类</span><br><span class="line">5.5阅读反编译的smali代码</span><br><span class="line">5.5.1循环语句</span><br><span class="line">5.5.2switch分支语句</span><br><span class="line">5.5.3try&#x2F;catch语句</span><br><span class="line">5.6使用IDA Pro静态分析Android程序</span><br><span class="line">5.6.1IDA Pro对Android的支持</span><br><span class="line">5.6.2如何操作</span><br><span class="line">5.6.3定位关键代码——使用IDA Pro进行破解的实例</span><br><span class="line">5.7恶意软件分析工具包——Androguard</span><br><span class="line">5.7.1Androguard的安装与配置</span><br><span class="line">5.7.2Androguard的使用方法</span><br><span class="line">5.7.3使用Androguard配合Gephi进行静态分析</span><br><span class="line">5.7.4使用androlyze.py进行静态分析</span><br><span class="line">5.8其他静态分析工具</span><br><span class="line">5.9阅读反编译的Java代码</span><br><span class="line">5.9.1使用dex2jar生成jar文件</span><br><span class="line">5.9.2使用jd—gui查看jar文件的源码</span><br><span class="line">5.10集成分析环境——santoku</span><br><span class="line">5.11本章小结</span><br><span class="line">第6章基于Android的ARM汇编语言基础——逆向原生！</span><br><span class="line">6.1Android与ARM处理器</span><br><span class="line">6.1.1ARM处理器架构概述</span><br><span class="line">6.1.2ARM处理器家族</span><br><span class="line">6.1.3Android支持的处理器架构</span><br><span class="line">6.2原生程序与ARM汇编语言——逆向你的原生Hello ARM</span><br><span class="line">6.2.1原生程序逆向初步</span><br><span class="line">6.2.2原生程序的生成过程</span><br><span class="line">6.2.3必须了解的ARM知识</span><br><span class="line">6.3ARM汇编语言程序结构</span><br><span class="line">6.3.1完整的ARM汇编程序</span><br><span class="line">6.3.2处理器架构定义</span><br><span class="line">6.3.3段定义</span><br><span class="line">6.3.4注释与标号</span><br><span class="line">6.3.5汇编器指令</span><br><span class="line">6.3.6子程序与参数传递</span><br><span class="line">6.4ARM处理器寻址方式</span><br><span class="line">6.4.1立即寻址</span><br><span class="line">6.4.2寄存器寻址</span><br><span class="line">6.4.3寄存器移位寻址</span><br><span class="line">6.4.4寄存器间接寻址</span><br><span class="line">6.4.5基址寻址</span><br><span class="line">6.4.6多寄存器寻址</span><br><span class="line">6.4.7堆栈寻址</span><br><span class="line">6.4.8块拷贝寻址</span><br><span class="line">6.4.9相对寻址</span><br><span class="line">6.5ARM与Thumb指令集</span><br><span class="line">6.5.1指令格式</span><br><span class="line">6.5.2跳转指令</span><br><span class="line">6.5.3存储器访问指令</span><br><span class="line">6.5.4数据处理指令</span><br><span class="line">6.5.5其他指令</span><br><span class="line">6.6用于多媒体编程与浮点计算的NEON与VFP指令集</span><br><span class="line">6.7本章小结</span><br><span class="line">……</span><br><span class="line">第7章Android NDK程序逆向分析</span><br><span class="line">第8章动态调试Android程序</span><br><span class="line">第9章Android软件的破解技术</span><br><span class="line">第10章Android程序的反破解技术</span><br><span class="line">第11章Android系统攻击与防范</span><br><span class="line">第12章DroidKongFu变种病毒实例分析</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00BMTVUGG/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00BMTVUGG&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/510HeV7pweL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Arduino从基础到实践</title>
    <url>/2020/04/19/B00C9IVSNO/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Arduino从基础到实践<br>作者信息： 作者: 米歇尔•麦克罗伯茨 (Michael McRoberts) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Arduino从基础到实践》对读者的基础知识要求非常低，非常适合学生进行课外电子制作项目使用，同时《Arduino从基础到实践》也介绍了一些相当有难度和实用性很强的项目，对于有一定基础的电子爱好者也有很好的参考价值。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">作者简介</span><br><span class="line">校订者简介</span><br><span class="line">致谢</span><br><span class="line">简介</span><br><span class="line">第1章 引言</span><br><span class="line">如何使用本书</span><br><span class="line">你需要的东西</span><br><span class="line">Arduino到底是什么？</span><br><span class="line">可以开始了</span><br><span class="line">在Windows XP上安装</span><br><span class="line">在Windows 7或Vista上安装</span><br><span class="line">在Mac OSX上安装</span><br><span class="line">板子和接口的选择</span><br><span class="line">加载第一个程序</span><br><span class="line">Arduino的IDE</span><br><span class="line">第2章 让我们开始吧</span><br><span class="line">项目1——LED闪灯器</span><br><span class="line">需要的元件</span><br><span class="line">连接所有的东西</span><br><span class="line">输入代码</span><br><span class="line">代码回顾</span><br><span class="line">硬件回顾</span><br><span class="line">项目2——S.O.S莫尔斯码信号源</span><br><span class="line">代码回顾</span><br><span class="line">项目3——交通信号灯</span><br><span class="line">需要的元件</span><br><span class="line">把元件连起来</span><br><span class="line">输入代码</span><br><span class="line">项目4——互动交通灯</span><br><span class="line">需要的元件</span><br><span class="line">把元件连接起来</span><br><span class="line">输入代码</span><br><span class="line">代码回顾</span><br><span class="line">硬件回顾</span><br><span class="line">逻辑状态</span><br><span class="line">下拉电阻</span><br><span class="line">上拉电阻</span><br><span class="line">Arduino的内部上拉电阻</span><br><span class="line">小结</span><br><span class="line">本章的主题和概念</span><br><span class="line">第3章 LED效果</span><br><span class="line">项目5——LED跑马灯效果</span><br><span class="line">需要的元件</span><br><span class="line">把元件连接起来</span><br><span class="line">代码回顾</span><br><span class="line">项目6——互动LED跑马灯效果</span><br><span class="line">需要的元件</span><br><span class="line">把元件连接起来</span><br><span class="line">输入代码</span><br><span class="line">代码回顾</span><br><span class="line">硬件回顾</span><br><span class="line">项目7——闪烁灯</span><br><span class="line">需要的元件</span><br><span class="line">把元件连起来</span><br><span class="line">输入代码</span><br><span class="line">代码回顾</span><br><span class="line">项目8——RGB彩灯</span><br><span class="line">需要的元件</span><br><span class="line">把元件连接起来</span><br><span class="line">输入代码</span><br><span class="line">代码回顾</span><br><span class="line">项目9——LED火焰效果</span><br><span class="line">需要的元件</span><br><span class="line">把元件连接起来</span><br><span class="line">输入代码</span><br><span class="line">代码回顾</span><br><span class="line">项目10——串口控制彩灯</span><br><span class="line">输入代码</span><br><span class="line">代码回顾</span><br><span class="line">小结</span><br><span class="line">本章的主题和概念</span><br><span class="line">第4章 简单的发声器和传感器</span><br><span class="line">项目11——压电声音报警器</span><br><span class="line">需要的元件</span><br><span class="line">把元件连接起来</span><br><span class="line">输入代码</span><br><span class="line">代码回顾</span><br><span class="line">硬件回顾</span><br><span class="line">项目12——压电扬声器音乐演奏</span><br><span class="line">输入代码</span><br><span class="line">代码回顾</span><br><span class="line">项目13——压电震动传感器</span><br><span class="line">需要的元件</span><br><span class="line">把元件连接起来</span><br><span class="line">输入代码</span><br><span class="line">代码回顾</span><br><span class="line">项目14——光敏元件</span><br><span class="line">需要的元件</span><br><span class="line">把元件连接起来</span><br><span class="line">输入代码</span><br><span class="line">硬件回顾</span><br><span class="line">小结</span><br><span class="line">本章的主题和概念</span><br><span class="line">第5章 驱动直流电机</span><br><span class="line">项目15——简单的电机控制系统</span><br><span class="line">需要的元件</span><br><span class="line">把元件连接起来</span><br><span class="line">输入代码</span><br><span class="line">代码回顾</span><br><span class="line">硬件回顾</span><br><span class="line">项目16——使用L293D电机驱动芯片</span><br><span class="line">需要的元件</span><br><span class="line">把元件连接起来</span><br><span class="line">输入代码</span><br><span class="line">代码回顾</span><br><span class="line">硬件回顾</span><br><span class="line">小结</span><br><span class="line">本章的主题和概念</span><br><span class="line">第6章 二进制计数器</span><br><span class="line">项目17——移位寄存器8位二进制计数器</span><br><span class="line">需要的元件</span><br><span class="line">把元件连接起来</span><br><span class="line">输入代码</span><br><span class="line">二进制数制</span><br><span class="line">硬件回顾</span><br><span class="line">代码回顾</span><br><span class="line">按位操作</span><br><span class="line">代码回顾（继续）</span><br><span class="line">项目18——16位二进制计数器</span><br><span class="line">需要的元件</span><br><span class="line">把元件连接起来</span><br><span class="line">输入代码</span><br><span class="line">代码和硬件回顾</span><br><span class="line">小结</span><br><span class="line">本章的主题和概念</span><br><span class="line">……</span><br><span class="line">第7章 LED显示器</span><br><span class="line">第8章 液晶显示器</span><br><span class="line">第9章 舵机</span><br><span class="line">第10章 步进电机和机器人</span><br><span class="line">第11章 压力传感器</span><br><span class="line">第12章 触摸屏</span><br><span class="line">第13章 温度传感器</span><br><span class="line">第14章 超声测距</span><br><span class="line">第15章 读写SD卡</span><br><span class="line">第16章 RFID读卡器</span><br><span class="line">第17章 连接到Internet</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00C9IVSNO/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00C9IVSNO&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/5176XzTrwPL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>明解C语言</title>
    <url>/2020/04/19/B00CMD4IIS/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 明解C语言<br>作者信息： 作者: 柴田望洋 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>原版畅销20万册！ 日本C语言入门第一书 荣获日本工学教育协会著作奖《明解C语言》是日本的C语言经典教材，自出版以来不断重印、修订，被誉为“C语言圣经”。作者在日本IT界家喻户晓，出版过一系列极富影响力的计算机教材和参考书。其简洁、通俗的文风深受读者的喜爱。 《明解C语言》图文并茂，示例丰富，设有190段代码和164幅图表，对C语言的基础知识进行了彻底剖析，内容涉及数组、函数、指针、文件操作等。对于C语言语法以及一些难以理解的概念，均以精心绘制的示意图，清晰、通俗地进行讲解。原著在日本广受欢迎，始终位于网上书店C语言著作排行榜首位。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 初识C语言</span><br><span class="line">1—1 显示计算结果</span><br><span class="line">计算整数的和并显示结果 2</span><br><span class="line">程序和编译 2</span><br><span class="line">注释 3</span><br><span class="line">固定代码 4</span><br><span class="line">格式化输出函数printf 4</span><br><span class="line">语句 5</span><br><span class="line">计算并显示整数的差 5</span><br><span class="line">格式化字符串和转换说明 6</span><br><span class="line">符号的称呼 7</span><br><span class="line">无格式化输出 8</span><br><span class="line">字符串常量 9</span><br><span class="line">转义字符 9</span><br><span class="line">1—2 变量 </span><br><span class="line">常量和变量 10</span><br><span class="line">声明多个变量 11</span><br><span class="line">赋值 11</span><br><span class="line">1—3 输入和显示 </span><br><span class="line">通过键盘进行输入 12</span><br><span class="line">格式化输入函数scanf 12</span><br><span class="line">乘法运算 13</span><br><span class="line">输出函数puts 14</span><br><span class="line">第2章 运算和数据类型</span><br><span class="line">2—1 运算 </span><br><span class="line">四则运算 18</span><br><span class="line">运算符和操作数 18</span><br><span class="line">商和余数 19</span><br><span class="line">乘除运算符和加减运算符 19</span><br><span class="line">使用printf函数打印 % 19</span><br><span class="line">获取整数的最后一位数字 20</span><br><span class="line">多个转换说明 21</span><br><span class="line">单目运算符 22</span><br><span class="line">赋值运算符 23</span><br><span class="line">表达式和赋值表达式 23</span><br><span class="line">表达式语句 23</span><br><span class="line">2—2 数据类型 </span><br><span class="line">求平均值 24</span><br><span class="line">数据类型 24</span><br><span class="line">int类型和double类型 25</span><br><span class="line">数据类型和对象 26</span><br><span class="line">整数常量和浮点数常量 27</span><br><span class="line">double类型的运算 27</span><br><span class="line">数据类型和运算 28</span><br><span class="line">类型转换 30</span><br><span class="line">转换说明 32</span><br><span class="line">第3章 分支结构程序</span><br><span class="line">3—1 if语句 </span><br><span class="line">程序的流程 36</span><br><span class="line">if语句（1） 36</span><br><span class="line">奇数的判定 37</span><br><span class="line">if语句（2） 38</span><br><span class="line">奇数和偶数 39</span><br><span class="line">判断 39</span><br><span class="line">非0的判断 40</span><br><span class="line">语法结构 40</span><br><span class="line">相等运算符 42</span><br><span class="line">比较余数 43</span><br><span class="line">关系运算符 44</span><br><span class="line">嵌套的if语句 45</span><br><span class="line">计算较大值 46</span><br><span class="line">计算三个数的最大值 47</span><br><span class="line">条件运算符 48</span><br><span class="line">差值计算 49</span><br><span class="line">复合语句（程序块） 50</span><br><span class="line">判断季节 52</span><br><span class="line">逻辑运算符 52</span><br><span class="line">3—2 switch语句 </span><br><span class="line">程序的流程 54</span><br><span class="line">switch语句和if语句 57</span><br><span class="line">选择语句 57</span><br><span class="line">第4章 程序的循环控制</span><br><span class="line">4—1 do语句 </span><br><span class="line">do语句 60</span><br><span class="line">复合语句（程序块）中的声明 61</span><br><span class="line">逻辑非运算符 61</span><br><span class="line">逆向显示整数值 62</span><br><span class="line">计算整数的位数 63</span><br><span class="line">初始化 64</span><br><span class="line">复合赋值运算符 66</span><br><span class="line">后置递增运算符和</span><br><span class="line">后置递减运算符 67</span><br><span class="line">4—2 while语句 </span><br><span class="line">while语句 68</span><br><span class="line">字符常量 69</span><br><span class="line">putchar 69</span><br><span class="line">用递减运算符简化程序代码 70</span><br><span class="line">数据递增 71</span><br><span class="line">限定次数的循环操作 72</span><br><span class="line">前置递增运算符和</span><br><span class="line">前置递减运算符 73</span><br><span class="line">4—3 for语句 </span><br><span class="line">for语句 74</span><br><span class="line">循环语句 75</span><br><span class="line">固定次数的循环 76</span><br><span class="line">4—4 多重循环 </span><br><span class="line">九九乘法表 78</span><br><span class="line">多重循环 79</span><br><span class="line">长方形 80</span><br><span class="line">直角三角形 80</span><br><span class="line">4—5 程序的组成元素和格式 </span><br><span class="line">关键字 82</span><br><span class="line">标识符 82</span><br><span class="line">分隔符 83</span><br><span class="line">运算符 83</span><br><span class="line">常量和字符串常量 83</span><br><span class="line">自由的书写格式 84</span><br><span class="line">连接相邻的字符串常量 85</span><br><span class="line">缩进 85</span><br><span class="line">第5章 数组</span><br><span class="line">5—1 数组 </span><br><span class="line">数组 88</span><br><span class="line">数组和for语句 90</span><br><span class="line">数组初始化 92</span><br><span class="line">数组的复制 93</span><br><span class="line">输入数组元素的值 94</span><br><span class="line">对数组进行倒序排列 94</span><br><span class="line">使用数组进行成绩处理 96</span><br><span class="line">对象式宏 96</span><br><span class="line">赋值表达式 98</span><br><span class="line">及格学生一览表 100</span><br><span class="line">数组的元素个数 100</span><br><span class="line">成绩分布图 101</span><br><span class="line">5—2 多维数组 </span><br><span class="line">矩阵 102</span><br><span class="line">5—3 质数计算 </span><br><span class="line">质数 104</span><br><span class="line">质数计算程序（第1版） 104</span><br><span class="line">大整数 104</span><br><span class="line">break语句 104</span><br><span class="line">质数计算程序（第2版） 106</span><br><span class="line">质数计算程序（第3版） 107</span><br><span class="line">质数计算程序（第4版） 108</span><br><span class="line">质数计算程序（第5版） 110</span><br><span class="line">逗号运算符 110</span><br><span class="line">第6章 函数</span><br><span class="line">6—1 什么是函数 </span><br><span class="line">main函数 114</span><br><span class="line">库函数 114</span><br><span class="line">函数定义和函数调用 114</span><br><span class="line">三个数中的最大值 118</span><br><span class="line">平方差 119</span><br><span class="line">幂 120</span><br><span class="line">值传递 120</span><br><span class="line">调用其他函数 121</span><br><span class="line">6—2 函数设计 </span><br><span class="line">没有返回值的函数 122</span><br><span class="line">通用性 122</span><br><span class="line">不含形参的函数 124</span><br><span class="line">函数返回值的初始化 125</span><br><span class="line">作用域 125</span><br><span class="line">计算最高分的程序 126</span><br><span class="line">文件作用域 126</span><br><span class="line">声明和定义 127</span><br><span class="line">函数原型声明 127</span><br><span class="line">头文件和文件包含指令 128</span><br><span class="line">函数的通用性 129</span><br><span class="line">数组的传递 130</span><br><span class="line">对接收到的数组进行写入处理 132</span><br><span class="line">const类型的修饰符 133</span><br><span class="line">顺序查找 134</span><br><span class="line">哨兵查找法 135</span><br><span class="line">表达式语句和空语句 137</span><br><span class="line">多维数组的传递 138</span><br><span class="line">6—3 作用域和存储期 </span><br><span class="line">作用域和标识符的可见性 140</span><br><span class="line">存储期 142</span><br><span class="line">第7章 基本数据类型</span><br><span class="line">7—1 基本数据类型和数 </span><br><span class="line">基本数据类型 148</span><br><span class="line">基数 149</span><br><span class="line">基数转换 150</span><br><span class="line">7—2 整型和字符型 </span><br><span class="line">字符型和整型 152</span><br><span class="line">&lt;limits.h&gt;头文件 154</span><br><span class="line">字符型 155</span><br><span class="line">sizeof运算符 156</span><br><span class="line">size_t型和typedef声明 157</span><br><span class="line">整型的灵活运用 157</span><br><span class="line">整型常量 158</span><br><span class="line">整型常量的数据类型 158</span><br><span class="line">内部表示和位 160</span><br><span class="line">无符号整数的内部表示 160</span><br><span class="line">有符号整数的内部表示 161</span><br><span class="line">反码表示法和补码表示法 162</span><br><span class="line">窥探整数内部 163</span><br><span class="line">按位操作的逻辑运算 164</span><br><span class="line">位移运算符 166</span><br><span class="line">位数的计算 168</span><br><span class="line">求出unsigned型的位数 168</span><br><span class="line">显示位的内容 169</span><br><span class="line">整数的显示 170</span><br><span class="line">数据溢出和异常 171</span><br><span class="line">7—3 浮点型 </span><br><span class="line">浮点型 172</span><br><span class="line">浮点型常量 173</span><br><span class="line">循环的控制 174</span><br><span class="line">&lt;math.h&gt;头文件 175</span><br><span class="line">7—4 运算 </span><br><span class="line">运算符一览 176</span><br><span class="line">优先级 176</span><br><span class="line">结合性 176</span><br><span class="line">数据类型转换 178</span><br><span class="line">sizeof运算符 180</span><br><span class="line">sizeof运算符和数组 181</span><br><span class="line">第8章 动手编写各种程序吧</span><br><span class="line">8—1 函数式宏 </span><br><span class="line">函数和数据类型 184</span><br><span class="line">函数式宏 185</span><br><span class="line">函数和函数式宏 186</span><br><span class="line">不带参数的函数式宏 187</span><br><span class="line">函数式宏和逗号运算符 188</span><br><span class="line">8—2 枚举类型 </span><br><span class="line">枚举类型 190</span><br><span class="line">枚举常量 192</span><br><span class="line">命名空间 193</span><br><span class="line">8—3 递归 </span><br><span class="line">阶乘 194</span><br><span class="line">最大公约数 196</span><br><span class="line">问题和递归 197</span><br><span class="line">8—4 输入输出和字符 </span><br><span class="line">数字字符计数 198</span><br><span class="line">getchar函数 198</span><br><span class="line">EOF 198</span><br><span class="line">字符和数值 199</span><br><span class="line">字符 200</span><br><span class="line">转义字符 203</span><br><span class="line">复制 204</span><br><span class="line">第9章 字符串的基本知识</span><br><span class="line">9—1 什么是字符串</span><br><span class="line">字符串字面量 208</span><br><span class="line">字符串字面量的长度 208</span><br><span class="line">字符串 210</span><br><span class="line">字符数组的初始化赋值 211</span><br><span class="line">空字符串 212</span><br><span class="line">字符串的读取 212</span><br><span class="line">格式化显示字符串 213</span><br><span class="line">9—2 字符串数组</span><br><span class="line">字符串数组 214</span><br><span class="line">读取字符串数组中的字符串 215</span><br><span class="line">9—3 字符串处理</span><br><span class="line">字符串长度 216</span><br><span class="line">遍历字符串 218</span><br><span class="line">数字字符的出现次数 219</span><br><span class="line">字符串数组的参数传递 220</span><br><span class="line">大小写字符转换 222</span><br><span class="line">第10章 指针</span><br><span class="line">10—1 指针 </span><br><span class="line">函数的参数 226</span><br><span class="line">变量和对象 227</span><br><span class="line">地址 227</span><br><span class="line">取址运算符 228</span><br><span class="line">指针 229</span><br><span class="line">指针运算符 231</span><br><span class="line">10—2 指针和函数 </span><br><span class="line">作为函数参数的指针 232</span><br><span class="line">二值互换 234</span><br><span class="line">引用传递（C++语言） 235</span><br><span class="line">计算和与差 236</span><br><span class="line">scanf函数和指针 236</span><br><span class="line">将两个值升序排列 237</span><br><span class="line">指针的类型 238</span><br><span class="line">标量型 239</span><br><span class="line">10—3 指针和数组 </span><br><span class="line">指针和数组 240</span><br><span class="line">数组的传递 244</span><br><span class="line">第11章 字符串和指针</span><br><span class="line">11—1 字符串和指针 </span><br><span class="line">字符串和指针 248</span><br><span class="line">数组和指针的相同点 249</span><br><span class="line">数组和指针的不同点 250</span><br><span class="line">字符串数组 252</span><br><span class="line">11—2 通过指针操作字符串 </span><br><span class="line">字符串和指针 254</span><br><span class="line">判断字符串长度 254</span><br><span class="line">const 254</span><br><span class="line">使用指针进行遍历 255</span><br><span class="line">字符串的复制 256</span><br><span class="line">不正确的字符串复制 258</span><br><span class="line">返回指针的函数 259</span><br><span class="line">11—3 字符串处理库函数 </span><br><span class="line">字符串处理函数 260</span><br><span class="line">字符串转换函数 264 </span><br><span class="line">第12章 结构体</span><br><span class="line">12—1 结构体 </span><br><span class="line">排序 268</span><br><span class="line">冒泡排序法 269</span><br><span class="line">数据关联性 270</span><br><span class="line">结构体 272</span><br><span class="line">结构体成员（运算符） 274</span><br><span class="line">成员的初始化 275</span><br><span class="line">结构体成员（—&gt;运算符） 276</span><br><span class="line">结构体和typedef 278</span><br><span class="line">结构体和程序 279</span><br><span class="line">聚合类型 280</span><br><span class="line">命名空间 280</span><br><span class="line">返回结构体的函数 281</span><br><span class="line">结构体数组 282</span><br><span class="line">派生类型 282</span><br><span class="line">表示日期和时间的结构体 284</span><br><span class="line">12—2 作为成员的结构体 </span><br><span class="line">表示坐标的结构体 286</span><br><span class="line">表示具有定位功能的汽车的</span><br><span class="line">结构体 286</span><br><span class="line">第13章 文件处理</span><br><span class="line">13—1 文件与流 </span><br><span class="line">文件 290</span><br><span class="line">流 290</span><br><span class="line">标准流 291</span><br><span class="line">FILE型 291</span><br><span class="line">打开文件 292</span><br><span class="line">关闭文件 294</span><br><span class="line">打开与关闭文件示例 295</span><br><span class="line">文件数据汇总 296</span><br><span class="line">写入日期和时间 298</span><br><span class="line">获取上一次运行时的信息 300</span><br><span class="line">标准输入输出 302</span><br><span class="line">显示文件内容 302</span><br><span class="line">文件的复制 304</span><br><span class="line">13—2 文本和二进制 </span><br><span class="line">在文本文件中保存实数 306</span><br><span class="line">文本文件和二进制文件 307</span><br><span class="line">在二进制文件中保存实数 308</span><br><span class="line">显示文件自身 310</span><br><span class="line">附录1 C语言简介</span><br><span class="line">C语言的历史 314</span><br><span class="line">K&amp;R——C语言的圣经 314</span><br><span class="line">C语言标准规范 314</span><br><span class="line">附录2 printf函数与scanf函数</span><br><span class="line">printf函数 318</span><br><span class="line">scanf函数 322</span><br><span class="line">致谢 326</span><br><span class="line">参考文献 326</span><br><span class="line">索引 327 </span><br><span class="line">版权声明 338 </span><br><span class="line"></span><br><span class="line">   &lt;&#x2F;math.h&gt;&lt;&#x2F;limits.h&gt;</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00CMD4IIS/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00CMD4IIS&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/417%2BzSH0dbL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 4高级编程(第3版)</title>
    <url>/2020/04/19/B00CE1JQO4/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android 4高级编程(第3版)<br>作者信息： 作者: Reto Meier [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Android 4高级编程(第3版)》由Android权威专家编写，涵盖了所有最新的内容，是学习使用Android 4 SDK开发移动应用程序的理想指南,经典图书升级版本！</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 Android简介 1</span><br><span class="line">1.1 一些背景信息 2</span><br><span class="line">1.1.1 不远的过去 2</span><br><span class="line">1.1.2 未来的前景 2</span><br><span class="line">1.2 对Android的误解 3</span><br><span class="line">1.3 Android：开放的移动开发平台 3</span><br><span class="line">1.4 原生Android应用程序 4</span><br><span class="line">1.5 Android SDK的特征 5</span><br><span class="line">1.5.1 访问硬件（包括摄像头、GPS和传感器） 5</span><br><span class="line">1.5.2 使用Wi-Fi、蓝牙技术和NFC进行数据传输 6</span><br><span class="line">1.5.3 地图、地理编码和基于位置的服务 6</span><br><span class="line">1.5.4 后台服务 6</span><br><span class="line">1.5.5 使用SQLite数据库进行数据存储和检索 7</span><br><span class="line">1.5.6 共享数据和应用程序间通信 7</span><br><span class="line">1.5.7 使用Widget和Live Wallpaper增强主屏幕 7</span><br><span class="line">1.5.8 广泛的媒体支持和2D&#x2F;3D图形 7</span><br><span class="line">1.5.9 Cloud to Device Messaging 8</span><br><span class="line">1.5.10 优化的内存和进程管理 8</span><br><span class="line">1.6 开放手机联盟简介 8</span><br><span class="line">1.7 运行Android的环境 9</span><br><span class="line">1.8 从事移动开发的原因 9</span><br><span class="line">1.9 从事Android开发的原因 9</span><br><span class="line">1.9.1 推动Android普及的因素 10</span><br><span class="line">1.9.2 Android的独到之处 10</span><br><span class="line">1.9.3 改变移动开发格局 11</span><br><span class="line">1.10 开发框架简介 11</span><br><span class="line">1.10.1 开发包中的资源 12</span><br><span class="line">1.10.2 理解Android软件栈 12</span><br><span class="line">1.10.3 Dalvik虚拟机 14</span><br><span class="line">1.10.4 Android应用程序架构 14</span><br><span class="line">1.10.5 Android库 15 </span><br><span class="line"></span><br><span class="line"> 第2章 开始入手 17 2.1 Android开发 18 2.1.1 开始前的准备工作 18 2.1.2 创建第一个Android应用程序 24 2.1.3 Android应用程序的类型 31 2.2 面向移动设备和嵌入式设备的开发 32 2.2.1 硬件限制带来的设计考虑事项 32 2.2.2 考虑用户环境 35 2.2.3 Android开发 36 2.3 Android开发工具 40 2.3.1 Android虚拟设备管理器 41 2.3.2 Android SDK管理器 42 2.3.3 Android模拟器 42 2.3.4 Dalvik调试监控服务（DDMS） 42 2.3.5 Android调试桥（ADB） 43 2.3.6 Hierarchy Viewer和Lint工具 43 2.3.7 Monkey和Monkey Runner 43</span><br><span class="line"></span><br><span class="line"> 第3章 创建应用程序和Activity 45 3.1 Android应用程序的组成部分 46 3.2 应用程序Manifest文件简介 47 3.3 使用Manifest编辑器 54 3.4 分离资源 55 3.4.1 创建资源 55 3.4.2 使用资源 63 3.4.3 为不同的语言和硬件创建资源 66 3.4.4 运行时配置更改 68 3.5 Android应用程序生命周期 70 3.6 理解应用程序的优先级和进程状态 70 3.7 Android Application类简介 72 3.7.1 扩展和使用Application类 72 3.7.2 重写应用程序的生命周期事件 73 3.8 深入探讨Android Activity 74 3.8.1 创建Activity 74 3.8.2 Activity的生存期 76 3.8.3 Android Activity类 81</span><br><span class="line"></span><br><span class="line"> 第4章 创建用户界面 83 4.1 Android UI基本设计 84 4.2 Android UI的基础知识 84 4.3 布局简介 85 4.3.1 定义布局 86 4.3.2 使用布局创建设备无关的UI 87 4.3.3 优化布局 90 4.4 To-Do List示例 93 4.5 Fragment介绍 100 4.5.1 创建新的Fragment 101 4.5.2 Fragment的生命周期 101 4.5.3 Fragment Manager介绍 105 4.5.4 向Activity中添加Fragment 105 4.5.5 Fragment和Activity之间的接口 110 4.5.6 没有用户界面的Fragment 111 4.5.7 Android Fragment 类 112 4.5.8 对To-Do List示例使用Fragment 112 4.6 Android widget 工具箱 116 4.7 创建新视图 117 4.7.1 修改现有的视图 118 4.7.2 创建复合控件 122 4.7.3 使用布局创建简单的复合控件 124 4.7.4 创建定制的视图 124 4.7.5 使用定制的控件 137 4.8 Adapter简介 137 4.8.1 部分原生Adapter简介 138 4.8.2 定制ArrayAdapter 138 4.8.3 使用Adapter绑定数据到视图 139</span><br><span class="line"></span><br><span class="line"> 第5章 Intent和Broadcast Receiver 145 5.1 Intent简介 145 5.1.1 使用Intent来启动Activity 146 5.1.2 Linkify简介 153 5.1.3 使用Intent广播事件 155 5.1.4 Local Broadcast Manager 159 5.1.5 Pending Intent简介 160 5.2 创建Intent Filter和Broadcast Receiver 161 5.2.1 使用Intent Filter为隐式Intent提供服务 161 5.2.2 使用Intent Filter作为插件和扩展 170 5.2.3 监听本地Broadcast Intent 173 5.2.4 使用Broadcast Intent监控设备的状态变化 174 5.2.5 在运行时管理Manifest Receiver 176</span><br><span class="line"></span><br><span class="line"> 第6章 使用Internet资源 177 6.1 下载和分析Internet资源 177 6.1.1 连接Internet资源 178 6.1.2 使用XML Pull Parser分析XML 179 6.1.3 创建一个地震查看器 180 6.2 使用Download Manager 186 6.2.1 下载文件 186 6.2.2 自定义Download Manager Notification 187 6.2.3 指定下载位置 188 6.2.4 取消和删除下载 189 6.2.5 查询Download Manager 189 6.3 使用Internet服务 192 6.4 连接到Google App Engine 192 6.5 下载数据而不会耗尽电量的最佳实践 194</span><br><span class="line"></span><br><span class="line"> 第7章 文件、保存状态和首选项 195 7.1 保存简单的应用程序数据 195 7.2 创建并保存Shared Preference 196 7.3 检索Shared Preference 197 7.4 为地震查看器创建一个设置Activity 197 7.5 首选项框架和Preference Activity概述 205 7.5.1 在XML中定义一个Preference Screen布局 206 7.5.2 Preference Fragment简介 208 7.5.3 使用Preference Header定义Preference Fragment的层次结构 208 7.5.4 Preference Activity简介 209 7.5.5 向后兼容性与Preference Screen 210 7.5.6 找到并使用Preference Screen设置的Shared Preference 210 7.5.7 Shared Preference Change Listener简介 211 7.6 为地震查看器创建一个标准的Preference Activity 211 7.7 持久化应用程序实例的状态 215 7.7.1 使用Shared Preference保存Activity状态 215 7.7.2 使用生命周期处理程序保存和还原Activity实例 215 7.7.3 使用生命周期处理程序保存和还原Fragment实例状态 216 7.8 将静态文件作为资源添加 218 7.9 在文件系统下工作 218 7.9.1 文件管理工具 218 7.9.2 使用特定于应用程序的文件夹存储文件 219 7.9.3 创建私有的应用程序文件 219 7.9.4 使用应用程序文件缓存 220 7.9.5 存储公共可读的文件 220</span><br><span class="line"></span><br><span class="line"> 第8章 数据库和Content Provider 223 8.1 Android数据库简介 223 8.1.1 SQLite数据库简介 224 8.1.2 Content Provider简介 224 8.2 SQLite简介 224 8.3 Content Value和Cursor 225 8.4 使用SQLite数据库 225 8.4.1 SQLiteOpenHelper简介 226 8.4.2 在不使用SQLiteOpenHelper的情况下打开和创建数据库 228 8.4.3 Android数据库设计注意事项 228 8.4.4 查询数据库 228 8.4.5 从Cursor中提取值 229 8.4.6 添加、更新和删除行 230 8.5 创建Content Provider 232 8.5.1 注册Content Provider 233 8.5.2 发布Content Provider的URI地址 233 8.5.3 创建Content Provide的数据库 234 8.5.4 实现Content Provider查询 235 8.5.5 Content Provider事务 236 8.5.6 在Content Provider中存储文件 239 8.5.7 一个Content Provider的实现框架 240 8.6 使用Content Provider 244 8.6.1 Content Resolver简介 244 8.6.2 查询Content Provider 244 8.6.3 使用Cursor Loader异步查询内容 247 8.6.4 添加、删除和更新内容 249 8.6.5 访问Content Provider中存储的文件 251 8.6.6 创建一个To-Do List数据库和Content Provider 253 8.7 将搜索功能添加到应用程序中 260 8.7.1 使Content Provider可搜索 261 8.7.2 为应用程序创建一个搜索Activity 261 8.7.3 将搜索Activity设置为应用程序的默认搜索Provider 263 8.7.4 使用搜索视图微件 266 8.7.5 由Content Provider支持搜索建议 267 8.7.6 在快速搜索框中显示搜索结果 270 8.8 创建可搜索的地震Content Provider 270 8.8.1 创建Content Provider 270 8.8.2 使用地震Content Provider 276 8.8.3 搜索EarthquakeContent Provider 279 8.9 本地Android Content Provider 285 8.9.1 使用Media StoreContent Provider 285 8.9.2 使用Contacts Contract Content Provider 286 8.9.3 使用Calendar Content Provider 293</span><br><span class="line"></span><br><span class="line"> 第9章 在后台操作 297 9.1 Service简介 298 9.1.1 创建和控制Service 298 9.1.2 将Service绑定到Activity 302 9.1.3 地震监控Service示例 304 9.1.4 创建前台Service 308 9.2 使用后台线程 309 9.2.1 使用AsyncTask运行异步任务 310 9.2.2 Intent Service简介 312 9.2.3 Loader简介 313 9.2.4 手动创建线程和GUI线程同步 313 9.3 使用Alarm 315 9.3.1 创建、设置和取消Alarm 316 9.3.2 设置重复Alarm 317 9.3.3 使用重复Alarm调度网络刷新 318 9.4 使用Intent Service简化Earthquake更新Service 320</span><br><span class="line"></span><br><span class="line"> 第10章 扩展用户体验 323 10.1 操作栏简介 324 10.1.1 自定义操作栏 325 10.1.2 自定义操作栏来控制应用程序的导航行为 328 10.1.3 操作栏操作简介 333 10.2 向地震监控程序添加一个操作栏 333 10.3 创建并使用菜单和操作栏操作项 339 10.3.1 Android菜单系统简介 340 10.3.2 创建菜单 341 10.3.3 指定操作栏的操作 342 10.3.4 菜单项选项 343 10.3.5 添加操作View和操作提供程序 344 10.3.6 在Fragment中添加菜单项 345 10.3.7 使用XML定义菜单层次结构 345 10.3.8 动态更新菜单项 347 10.3.9 处理菜单选择 347 10.3.10 子菜单和上下文菜单简介 348 10.4 更新地震监控程序 351 10.5 全屏显示 353 10.6 对话框简介 355 10.6.1 创建一个对话框 356 10.6.2 使用AlertDialog类 356 10.6.3 使用专门的输入对话框 357 10.6.4 通过Dialog Fragment管理和显示对话框 358 10.6.5 通过Activity事件处理程序管理和显示对话框 360 10.6.6 将Activity用作对话框 361 10.7 创建Toast 361 10.7.1 自定义Toast 362 10.7.2 在工作线程中使用Toast 364 10.8 Notification简介 365 10.8.1 Notification Manager简介 366 10.8.2 创建Notification 366 10.8.3 设置和自定义通知托盘UI 369 10.8.4 配置持续和连续的Notification 373 10.8.5 触发、更新和取消Notification 374 10.9 向地震监控程序中添加Notification和对话框 376</span><br><span class="line"></span><br><span class="line"> 第11章 高级用户体验 381 11.1 为每个屏幕尺寸和分辨率做设计 382 11.1.1 分辨率无关 382 11.1.2 为不同的屏幕大小提供支持和优化 383 11.1.3 创建可缩放的图形资源 386 11.1.4 创建优化的、自适应的、动态的设计 390 11.1.5 反复测试 390 11.2 确保可访问性 391 11.2.1 为非触屏设备提供导航 391 11.2.2 为每个View提供文本描述 391 11.3 Android Text-to-Speech简介 392 11.4 使用语音识别 394 11.4.1 使用语音识别进行语音输入 395 11.4.2 使用语音识别进行搜索 396 11.5 控制设备振动 396 11.6 使用动画 397 11.6.1 补间View动画 397 11.6.2 创建和使用逐帧动画 400 11.6.3 插值属性动画 400 11.7 强化View 404 11.7.1 高级Canvas绘图 404 11.7.2 硬件加速 419 11.7.3 Surface View简介 420 11.7.4 创建交互式控件 423 11.8 高级Drawable资源 428 11.9 复制、粘贴和剪贴板 431 11.9.1 向剪贴板中复制数据 431 11.9.2 粘贴剪贴板数据 431</span><br><span class="line"></span><br><span class="line"> 第12章 硬件传感器 433 12.1 使用传感器和传感器管理器 433 12.1.1 受支持的Android传感器 434 12.1.2 虚拟传感器简介 435 12.1.3 查找传感器 435 12.1.4 监视传感器 436 12.1.5 解释传感器值 438 12.2 监视设备的移动和方向 439 12.2.1 确定设备的自然方向 440 12.2.2 加速计简介 441 12.2.3 检测加速度变化 442 12.2.4 创建一个重力计 443 12.2.5 确定设备方向 446 12.2.6 创建一个指南针和人工地平仪 450 12.2.7 陀螺仪传感器简介 453 12.3 环境传感器简介 454 12.3.1 使用气压计传感器 454 12.3.2 创建气象站 455</span><br><span class="line"></span><br><span class="line"> 第13章 地图、地理编码和基于位置的服务 461 13.1 使用基于位置的服务 461 13.2 在模拟器中使用基于位置的服务 462 13.2.1 更新模拟器位置提供器中的位置 463 13.2.2 配置模拟器来测试基于位置的服务 463 13.3 选择一个位置提供器 464 13.3.1 查找位置提供器 464 13.3.2 通过指定条件查找位置提供器 464 13.3.3 确定位置提供器的能力 465 13.4 确定当前位置 466 13.4.1 位置的隐私性 466 13.4.2 找出上一次确定的位置 466 13.4.3 Where Am I示例 466 13.4.4 刷新当前位置 469 13.4.5 在Where Am I中跟踪位置 472 13.4.6 请求单独一次位置更新 473 13.5 位置更新的最佳实践 474 13.6 使用近距离提醒 477 13.7 使用地理编码器 478 13.7.1 反向地理编码 479 13.7.2 前向地理编码 480 13.7.3 对“Where Am I”示例进行地理编码 481 13.8 创建基于地图的Activity 482 13.8.1 MapView和MapActivity简介 482 13.8.2 获得地图的API key 483 13.8.3 创建一个基于地图的Activity 483 13.8.4 地图和Fragment 485 13.8.5 配置和使用MapView 486 13.8.6 使用MapController 486 13.8.7 对“Where Am I”示例使用地图 487 13.8.8 创建和使用覆盖（Overlay） 490 13.8.9 MyLocationOverlay简介 497 13.8.10 ItemizedOverlay和OverlayItem简介 498 13.8.11 将视图固定到地图和地图的某个位置上 500 13.9 对Earthquake示例添加地图功能 501</span><br><span class="line"></span><br><span class="line"> 第14章 个性化主屏幕 507 14.1 主屏幕Widget简介 507 14.2 创建App Widgets 509 14.2.1 创建Widget的XML布局资源 509 14.2.2 定义Widget设置 511 14.2.3 创建Widget Broadcast Receiver并将其添加到应用程序的manifest文件中 512 14.2.4 AppWidgetManager和RemoteView简介 513 14.2.5 刷新Widget 518 14.2.6 创建并使用Widget配置Activity 521 14.3 创建地震Widget 522 14.4 Collection View Widget简介 528 14.4.1 创建Collection View Widget的布局 529 14.4.2 创建RemoteViewsService 530 14.4.3 创建一个RemoteViews-Factory 531 14.4.4 使用RemoteViewsService填充CollectionViewWidget 533 14.4.5 向Collection View Widget中的项添加交互性 534 14.4.6 将Collection View Widget绑定到Content Provider 535 14.4.7 刷新Collection View Widget 537 14.4.8 创建Earthquake Collection View Widget 537 14.5 Live Folder简介 543 14.5.1 创建Live Folder 544 14.5.2 创建Earthquake Live Folder 548 14.6 使用快速搜索框显示应用程序搜索结果 551 14.6.1 在快速搜索框中显示搜索结果 551 14.6.2 将Earthquake示例的搜索结果添加到快速搜索框中 552 14.7 创建Live Wallpaper 553 14.7.1 创建Live Wallpaper定义资源 553 14.7.2 创建Wallpaper Service 554 14.7.3 创建Wallpaper Service引擎 555</span><br><span class="line"></span><br><span class="line"> 第15章 音频、视频以及摄像头的使用 557 15.1 播放音频和视频 558 15.1.1 Media Player简介 559 15.1.2 准备音频播放 559 15.1.3 准备视频播放 560 15.1.4 控制Media Player的播放 564 15.1.5 管理媒体播放输出 566 15.1.6 响应音量控制 566 15.1.7 响应Media播放控件 567 15.1.8 请求和管理音频焦点 569 15.1.9 当音频输出改变时暂停播放 571 15.1.10 Remote Control Client简介 572 15.2 操作原始音频 574 15.2.1 使用AudioRecord录制声音 574 15.2.2 使用AudioTrack播放音频 575 15.3 创建一个Sound Pool 577 15.4 使用音效 578 15.5 使用摄像头拍摄照片 579 15.5.1 使用Intent拍摄照片 579 15.5.2 直接控制摄像头 581 15.5.3 读取并写入 JPEG EXIF图像详细信息 588 15.6 录制视频 589 15.6.1 使用Intent录制视频 589 15.6.2 使用MediaRecorder录制视频 590 15.7 使用媒体效果 593 15.8 向媒体库中添加新媒体 594 15.8.1 使用媒体扫描仪插入媒体 594 15.8.2 手动插入媒体 595</span><br><span class="line"></span><br><span class="line"> 第16章 蓝牙、NFC、网络和Wi-Fi 597 16.1 使用蓝牙 597 16.1.1 管理本地蓝牙设备适配器 598 16.1.2 可发现性和远程设备发现 600 16.1.3 蓝牙通信 604 16.2 管理网络和Internet连接 609 16.2.1 Connectivity Manager简介 609 16.2.2 支持用户首选项以进行后台数据传输 609 16.2.3 查找和监视网络连接 611 16.3 管理Wi-Fi 612 16.3.1 监视Wi-Fi连接 613 16.3.2 监视活动的Wi-Fi连接的详细信息 613 16.3.3 扫描热点 613 16.3.4 管理Wi-Fi配置 614 16.3.5 创建Wi-Fi网络配置 615 16.4 使用Wi-Fi Direct传输数据 615 16.4.1 初始化Wi-Fi Direct框架 615 16.4.2 启用Wi-Fi Direct并监视其状态 617 16.4.3 发现对等设备 618 16.4.4 连接对等设备 618 16.4.5 在对等设备之间传输数据 620 16.5 近场通信 621 16.5.1 读取NFC标签 622 16.5.2 使用前台分派系统 623 16.5.3 Android Beam简介 625</span><br><span class="line"></span><br><span class="line"> 第17章 电话服务和SMS 629 17.1 电话服务的硬件支持 629 17.1.1 将电话功能指定为必需的硬件功能 629 17.1.2 检查电话硬件 630 17.2 使用电话服务 630 17.2.1 启动电话呼叫 630 17.2.2 替换本机拨号程序 631 17.2.3 访问电话服务的属性及状态 632 17.2.4 使用PhoneStateListener监视电话状态的变化 635 17.2.5 使用Intent Receiver监视传入的电话呼叫 639 17.3 SMS和MMS简介 640 17.3.1 在应用程序中使用SMS和MMS 640 17.3.2 使用Intent从应用程序中发送SMS和MMS 640 17.3.3 使用SMS Manager发送SMS消息 641 17.3.4 监听传入的SMS消息 644 17.3.5 紧急响应程序SMS示例 646 17.3.6 自动紧急响应程序 654 17.4 SIP和VOIP简介 662</span><br><span class="line"></span><br><span class="line"> 第18章 Android高级开发 663 18.1 Android的安全性 664 18.1.1 Linux内核安全 664 18.1.2 权限简介 664 18.2 Cloud to Device Messaging简介 666 18.2.1 C2DM的局限性 667 18.2.2 注册使用C2DM 667 18.2.3 在C2DM服务器上注册设备 667 18.2.4 向设备发送C2DM消息 670 18.2.5 接收C2DM消息 672 18.3 使用License Verification Library实现版权保护 673 18.3.1 安装License Verification Library 673 18.3.2 获得License Verification公钥 673 18.3.3 配置License Validation Policy 674 18.3.4 执行许可验证检查 674 18.4 应用程序内收费 675 18.4.1 应用程序内收费的局限性 676 18.4.2 安装IAB库 676 18.4.3 获得公钥和定义可购买的物品 676 18.4.4 开始IAB交易 677 18.4.5 处理IAB购买请求的响应 678 18.5 使用Wake Lock 679 18.6 使用AIDL支持Service的IPC 680 18.7 处理不同硬件和软件的可用性 686 18.7.1 指定硬件的要求 686 18.7.2 确认硬件可用性 687 18.7.3 构建向后兼容的应用程序 687 18.8 利用STRICT模式优化UI性能 689</span><br><span class="line"></span><br><span class="line"> 第19章 推广和发布应用程序并从中获利 691 19.1 签名和发布应用程序 691 19.2 发布应用程序 693 19.2.1 Google Play简介 693 19.2.2 开始使用Google Play 694 19.2.3 发布应用程序 695 19.2.4 开发者控制台上的应用程序报告 697 19.2.5 查看应用程序错误报告 697 19.3 如何通过应用程序赚钱 698 19.4 应用程序销售、推广和分发的策略 699 19.4.1 应用程序的起步策略 699 19.4.2 在Google Play上推广 700 19.4.3 国际化 700 19.5 分析数据和跟踪推荐人 701 19.5.1 使用移动应用程序的Google Analytics 702 19.5.2 使用Google Analytics追踪推荐 703</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00CE1JQO4/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00CE1JQO4&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51NM2TT9eyL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Android网络编程 技术详解与最佳实践</title>
    <url>/2020/04/19/B00EDE9802/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 深入理解Android网络编程 技术详解与最佳实践<br>作者信息： 作者: 陈文 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>系统讲解Android网络编程的各项核心技术和功能模块，多个案例解读Android网络编程的方法和技巧     从源码角度深入解析Android核心网络处理方法和关键应用的实现原理，包含大量最佳实践</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">第一篇概述篇</span><br><span class="line">第1章Android网络编程概要2</span><br><span class="line">1.1 Android简介2</span><br><span class="line">1.1.1 Android的发展2</span><br><span class="line">1.1.2 Android功能特性3</span><br><span class="line">1.1.3 Android系统构架4</span><br><span class="line">1.2 Android网络程序的功能6</span><br><span class="line">1.2.1通信功能6</span><br><span class="line">1.2.2及时分享6</span><br><span class="line">1.2.3个人管理6</span><br><span class="line">1.2.4娱乐游戏7</span><br><span class="line">1.2.5企业应用7</span><br><span class="line">1.3设置Android开发环境7</span><br><span class="line">1.3.1相关下载7</span><br><span class="line">1.3.2安装ADT9</span><br><span class="line">1.3.3Hello World！11</span><br><span class="line">1.4网络应用实战案例17</span><br><span class="line">1.4.1加载一个页面17</span><br><span class="line">1.4.2下载一个页面21</span><br><span class="line">1.5小结21</span><br><span class="line">第二篇实战篇</span><br><span class="line">第2章Android基本网络技术和编程实践24</span><br><span class="line">2.1计算机网络及其协议24</span><br><span class="line">2.1.1计算机网络概述24</span><br><span class="line">2.1.2网络协议概述25</span><br><span class="line">2.1.3IP、TCP和UDP协议26</span><br><span class="line">2.2在 Android中使用TCP、UDP协议31</span><br><span class="line">2.2.1Socket基础31</span><br><span class="line">2.2.2使用TCP通信34</span><br><span class="line">2.2.3使用UDP通信36</span><br><span class="line">2.3 Socket实战案例39</span><br><span class="line">2.3.1 Socket聊天举例39</span><br><span class="line">2.3.2 FTP客户端41</span><br><span class="line">2.3.3 Telnet客户端44</span><br><span class="line">2.4小结46</span><br><span class="line">第3章Android基本Web技术和编程实践47</span><br><span class="line">3.1 HTTP协议47</span><br><span class="line">3.1.1 HTTP简介47</span><br><span class="line">3.1.2实战案例：基于HTTP协议的文件上传51</span><br><span class="line">3.2 Android中的HTTP编程57</span><br><span class="line">3.2.1 HttpClient和URLConnection57</span><br><span class="line">3.2.2Post和Get在HttpClient的使用58</span><br><span class="line">3.2.3实战案例：使用HttpClient和URLConnection访问维基百科60</span><br><span class="line">3.3Android处理JSON64</span><br><span class="line">3.3.1JSON简介64</span><br><span class="line">3.3.2JSON数据解析65</span><br><span class="line">3.3.3JSON打包67</span><br><span class="line">3.3.4实战案例：JSON解析wikipedia内容68</span><br><span class="line">3.4Android处理SOAP71</span><br><span class="line">3.4.1SOAP简介71</span><br><span class="line">3.4.2SOAP消息72</span><br><span class="line">3.4.3实战案例：SOAP解析天气服务74</span><br><span class="line">3.5Android对HTML的处理79</span><br><span class="line">3.5.1解析HTML79</span><br><span class="line">3.5.2HTML适配屏幕80</span><br><span class="line">3.5.3JavaScript混合编程81</span><br><span class="line">3.5.4实战案例：Android自定义打开HTML页面87</span><br><span class="line">3.6小结91</span><br><span class="line">第4章Android常见网络接口编程92</span><br><span class="line">4.1Android解析和创建XML92</span><br><span class="line">4.1.1XML简介92</span><br><span class="line">4.1.2DOM解析XML97</span><br><span class="line">4.1.3SAX解析XML102</span><br><span class="line">4.1.4PULL解析XML108</span><br><span class="line">4.1.5实战案例：Android中创建XML110</span><br><span class="line">4.2Android订阅RSS113</span><br><span class="line">4.2.1RSS简介113</span><br><span class="line">4.2.2实战案例：简单RSS阅读器115</span><br><span class="line">4.3AndroidEmail编程122</span><br><span class="line">4.3.1Android发送Email122</span><br><span class="line">4.3.2实战案例：Android下Email的Base64加密123</span><br><span class="line">4.4Android网络安全125</span><br><span class="line">4.4.1Android网络安全简介125</span><br><span class="line">4.4.2Android加密和解密127</span><br><span class="line">4.4.3实战案例：Android应用添加签名133</span><br><span class="line">4.5OAuth认证135</span><br><span class="line">4.5.1OAuth简介135</span><br><span class="line">4.5.2实战案例：使用OAuth接口137</span><br><span class="line">4.6小结139</span><br><span class="line">第5章Android网络模块编程141</span><br><span class="line">5.1Android地图和定位141</span><br><span class="line">5.1.1获取map—api密钥141</span><br><span class="line">5.1.2获取位置144</span><br><span class="line">5.1.3实战案例：利用MapView显示地图146</span><br><span class="line">5.2USB编程150</span><br><span class="line">5.2.1USB主从设备150</span><br><span class="line">5.2.2USBAccessoryMode151</span><br><span class="line">5.2.3USBHostMode157</span><br><span class="line">5.2.4实战案例：Android和Arduino交互159</span><br><span class="line">5.3Wi—Fi编程168</span><br><span class="line">5.3.1AndroidWi—Fi相关类168</span><br><span class="line">5.3.2AndroidWi—Fi基本操作171</span><br><span class="line">5.3.3实战案例：使用Wi—Fi直连方式传输文件177</span><br><span class="line">5.4蓝牙编程185</span><br><span class="line">5.4.1蓝牙简介185</span><br><span class="line">5.4.2Android蓝牙API分析185</span><br><span class="line">5.4.3Android蓝牙基本操作187</span><br><span class="line">5.4.4实战案例：蓝牙连接192</span><br><span class="line">5.5NFC编程简介197</span><br><span class="line">5.5.1NFC技术简介197</span><br><span class="line">5.5.2NFCAPI简介198</span><br><span class="line">5.5.3NFC处理流程分析199</span><br><span class="line">5.6小结205</span><br><span class="line">第6章Android线程、数据存取、缓存和UI同步206</span><br><span class="line">6.1Android线程206</span><br><span class="line">6.1.1Android线程模型206</span><br><span class="line">6.1.2异步任务类211</span><br><span class="line">6.1.3实战案例：利用AsyncTask实现多线程下载213</span><br><span class="line">6.2数据存取214</span><br><span class="line">6.2.1 Shared Preferences数据存储215</span><br><span class="line">6.2.2 Internal Storage数据存储216</span><br><span class="line">6.2.3 External Storage数据存储217</span><br><span class="line">6.2.4SQLiteDatabases数据存储219</span><br><span class="line">6.2.5实战案例：SQLite数据库操作220</span><br><span class="line">6.3网络判定227</span><br><span class="line">6.3.1判断用户是否连接228</span><br><span class="line">6.3.2判断网络连接的类型228</span><br><span class="line">6.3.3监控网络连接改变228</span><br><span class="line">6.3.4实战案例：根据广播消息判断网络连接情况228</span><br><span class="line">6.4消息缓存230</span><br><span class="line">6.4.1Android中的缓存机制230</span><br><span class="line">6.4.2实战案例：下载、缓存和显示图片231</span><br><span class="line">6.5界面更新236</span><br><span class="line">6.5.1刷新数据时的界面更新236</span><br><span class="line">6.5.2完成任务时的界面更新237</span><br><span class="line">6.5.3实战案例：自定义列表显示更新238</span><br><span class="line">6.6小结248</span><br><span class="line">第7章基于SIP协议的VoIP应用249</span><br><span class="line">7.1SIP协议简介249</span><br><span class="line">7.2SIP服务器搭建250</span><br><span class="line">7.2.1下载安装BrekekeSIPServer250</span><br><span class="line">7.2.2访问服务器251</span><br><span class="line">7.2.3启动服务器252</span><br><span class="line">7.3SIP程序设置253</span><br><span class="line">7.3.1Android SIPAPI中的类和接口253</span><br><span class="line">7.3.2Android极限列表253</span><br><span class="line">7.3.3完整的Manifest文件254</span><br><span class="line">7.4SIP初始化通话255</span><br><span class="line">7.4.1SipManager对象255</span><br><span class="line">7.4.2SipProfile对象256</span><br><span class="line">7.5监听SIP通话257</span><br><span class="line">7.5.1创建监听器258</span><br><span class="line">7.5.2拨打电话258</span><br><span class="line">7.5.3接收呼叫259</span><br><span class="line">7.6实战案例：SIP通话261</span><br><span class="line">7.7小结270</span><br><span class="line">第8章基于XMPP协议的即时通信应用271</span><br><span class="line">8.1XMPP协议简介271</span><br><span class="line">8.2使用Openfire搭建XMPP服务器272</span><br><span class="line">8.3登录XMPP服务器276</span><br><span class="line">8.3.1Asmack相关类276</span><br><span class="line">8.3.2登录XMPP服务器277</span><br><span class="line">8.4联系人相关操作279</span><br><span class="line">8.4.1获取联系人列表279</span><br><span class="line">8.4.2获取联系人状态280</span><br><span class="line">8.4.3添加和删除联系人280</span><br><span class="line">8.4.4监听联系人添加信息281</span><br><span class="line">8.5消息处理282</span><br><span class="line">8.5.1接收消息282</span><br><span class="line">8.5.2发送消息283</span><br><span class="line">8.6实战案例：XMPP多人聊天283</span><br><span class="line">8.6.1创建新多人聊天室284</span><br><span class="line">8.6.2加入聊天室286</span><br><span class="line">8.6.3发送和接收消息287</span><br><span class="line">8.7小结288</span><br><span class="line">第三篇源码分析篇</span><br><span class="line">第9章Android对HTML的处理290</span><br><span class="line">9.1AndroidHTML处理关键类290</span><br><span class="line">9.2HTMLViewer分析292</span><br><span class="line">9.3浏览器源代码解析296</span><br><span class="line">9.3.1WebView加载入口分析296</span><br><span class="line">9.3.2调用JavaScript接口299</span><br><span class="line">9.4WebKit简单分析300</span><br><span class="line">9.4.1HTTPCache管理300</span><br><span class="line">9.4.2Cookie管理301</span><br><span class="line">9.4.3处理HTTP认证以及证书302</span><br><span class="line">9.4.4处理JavaScript的请求302</span><br><span class="line">9.4.5处理MIME类型305</span><br><span class="line">9.4.6访问WebView的历史306</span><br><span class="line">9.4.7保存网站图标306</span><br><span class="line">9.4.8WebStorage306</span><br><span class="line">9.4.9处理UI307</span><br><span class="line">9.4.10Web设置分析309</span><br><span class="line">9.4.11HTML5音视频处理309</span><br><span class="line">9.4.12缩放和下载311</span><br><span class="line">9.4.13插件管理311</span><br><span class="line">9.5小结313</span><br><span class="line">第10章Android网络处理分析314</span><br><span class="line">10.1Android网络处理关键类及其说明314</span><br><span class="line">10.2Android网络处理流程315</span><br><span class="line">10.2.1监控网络连接状态315</span><br><span class="line">10.2.2认证类316</span><br><span class="line">10.2.3DHCP状态机317</span><br><span class="line">10.2.4LocalServerSocket318</span><br><span class="line">10.2.5响应邮件请求320</span><br><span class="line">10.2.6提供网络信息323</span><br><span class="line">10.2.7Proxy类324</span><br><span class="line">10.2.8VPN服务325</span><br><span class="line">10.3Android封装的HTTP处理类326</span><br><span class="line">10.3.1AndroidHttpClient类和DefaultHttpClient类326</span><br><span class="line">10.3.2SSL认证信息处理类327</span><br><span class="line">10.3.3SSL错误信息处理328</span><br><span class="line">10.3.4AndroidHttpClient328</span><br><span class="line">10.4AndroidRTP协议329</span><br><span class="line">10.4.1传输音频码330</span><br><span class="line">10.4.2AudioGroup331</span><br><span class="line">10.4.3语音流RtpStream和AudioStream332</span><br><span class="line">10.5AndroidSIP协议333</span><br><span class="line">10.5.1SIP通话简介334</span><br><span class="line">10.5.2SIP初始化335</span><br><span class="line">10.5.3SipProfile336</span><br><span class="line">10.5.4SipSession337</span><br><span class="line">10.5.5SIP包错误处理338</span><br><span class="line">10.6小结339</span><br><span class="line">第11章Android网络应用分析340</span><br><span class="line">11.1Android中使用SAX解析XML340</span><br><span class="line">11.1.1几种XML解析方式讨论340</span><br><span class="line">11.1.2SAX解析XML的原理341</span><br><span class="line">11.1.3SAX发现XML的根元素342</span><br><span class="line">11.1.4SAX发现XML的子元素345</span><br><span class="line">11.2基于位置的服务348</span><br><span class="line">11.2.1位置服务的基本概念348</span><br><span class="line">11.2.2位置服务的基本类348</span><br><span class="line">11.2.3调用Google地图350</span><br><span class="line">11.2.4根据位置刷新地图显示351</span><br><span class="line">11.3媒体传输协议353</span><br><span class="line">11.3.1MTP和PTP简介353</span><br><span class="line">11.3.2定义MTP和PTP的类型354</span><br><span class="line">11.3.3封装MTP设备信息357</span><br><span class="line">11.3.4封装MTP对象的信息358</span><br><span class="line">11.3.5封装MTP设备上存储单元的信息360</span><br><span class="line">11.4小结362</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00EDE9802/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00EDE9802&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51c8LTAFYfL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发权威指南(第2版)</title>
    <url>/2020/04/19/B00EOIDFX8/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android开发权威指南(第2版)<br>作者信息： 作者: 李宁 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>第一本Android 4.X新版本的图书 所有案例来自于作者的真实项目，技术实用性强，案例含金量高</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 初识Android平台 1</span><br><span class="line">1.1 Android简介 1</span><br><span class="line">1.2 Android的制胜法宝 2</span><br><span class="line">1.3 Android的版本发展历程 3</span><br><span class="line">1.3.1 Android1.5（纸杯蛋糕） 3</span><br><span class="line">1.3.2 Android1.6（甜甜圈） 4</span><br><span class="line">1.3.3 Android2.1（松饼） 4</span><br><span class="line">1.3.4 Android2.2（冻酸奶） 5</span><br><span class="line">1.3.5 Android2.3（姜饼） 5</span><br><span class="line">1.3.6 Android3.0（蜂巢） 6</span><br><span class="line">1.3.7 Android4.0（冰激凌三明治） 6</span><br><span class="line">1.3.8 Android4.¼.2（果冻豆） 7</span><br><span class="line">1.4 Android的系统架构 8</span><br><span class="line">1.5 小结 9</span><br><span class="line">第2章 搭建Android开发和测试环境 10</span><br><span class="line">2.1 搭建Android开发环境需要些什么 10</span><br><span class="line">2.2 安装Java开发环境 10</span><br><span class="line">2.2.1 安装JDK 11</span><br><span class="line">2.2.2 安装和配置Eclipse 11</span><br><span class="line">2.3 安装Android开发环境 12</span><br><span class="line">2.3.1 下载和安装AndroidSDK 13</span><br><span class="line">2.3.2 下载和安装AndroidNDK 13</span><br><span class="line">2.3.3 安装和配置Eclipse插件：ADT 14</span><br><span class="line">2.4 配置Android测试环境 15</span><br><span class="line">2.4.1 建立Android虚拟设备（AVD） 15</span><br><span class="line">2.4.2 启动Android模拟器 16</span><br><span class="line">2.4.3 安装真机测试环境 17</span><br><span class="line">2.5 小结 18</span><br><span class="line">第3章 第一个Android应用程序 19</span><br><span class="line">3.1 从第一个Android程序中可以学到什么 19</span><br><span class="line">3.2 建立Android工程 19</span><br><span class="line">3.3 Android工程的结构 21</span><br><span class="line">3.4 在窗口上放两个按钮 22</span><br><span class="line">3.5 编写窗口类 23</span><br><span class="line">3.6 修改字符串资源 24</span><br><span class="line">3.7 运行Android应用程序 25</span><br><span class="line">3.8 调试Android应用程序 27</span><br><span class="line">3.9 签名Android应用程序 27</span><br><span class="line">3.10 小结 29</span><br><span class="line">第4章 Android应用程序架构 30</span><br><span class="line">4.1 Android应用程序中的资源 30</span><br><span class="line">4.1.1 资源存放在哪里 30</span><br><span class="line">4.1.2 资源的基本使用方法 30</span><br><span class="line">4.2 Android的应用程序组件 32</span><br><span class="line">4.2.1 窗口（Activity）组件 32</span><br><span class="line">4.2.2 服务（Service）组件 32</span><br><span class="line">4.2.3 广播接收者（Broadcastreceivers）组件 33</span><br><span class="line">4.2.4 内容提供者（ContentProvider）组件 33</span><br><span class="line">4.3 AndroidManifest.xml文件的结构 33</span><br><span class="line">4.4 小结 34</span><br><span class="line">第5章 窗口（Activity）与视图（View） 35</span><br><span class="line">5.1 声明和使用Activity 35</span><br><span class="line">5.1.1 Activity的基本用法 35</span><br><span class="line">5.1.2 同时适合手机和平板电脑的窗口风格 38</span><br><span class="line">5.2 Activity的生命周期 40</span><br><span class="line">5.3 窗口的常用事件 43</span><br><span class="line">5.3.1 设置窗口标题事件（onTitleChanged） 44</span><br><span class="line">5.3.2 键盘按下和抬起事件（onKeyDown和onKeyUp） 45</span><br><span class="line">5.3.3 任意情况下捕捉键盘事件（dispatchKeyEvent） 48</span><br><span class="line">5.3.4 回退事件（onBackPressed） 49</span><br><span class="line">5.3.5 按键长按事件（onKeyLongPress） 50</span><br><span class="line">5.3.6 屏幕触摸事件（onTouchEvent） 50</span><br><span class="line">5.3.7 窗口获得焦点事件（onWindowFocusChanged） 51</span><br><span class="line">5.4 在不同Activity之间传递数据 52</span><br><span class="line">5.4.1 使用Intent传递数据 53</span><br><span class="line">5.4.2 使用静态变量传递数据 54</span><br><span class="line">5.4.3 使用剪贴板传递数据 55</span><br><span class="line">5.4.4 使用全局对象传递数据 57</span><br><span class="line">5.5 从Activity返回数据 59</span><br><span class="line">5.6 视图（View） 61</span><br><span class="line">5.6.1 视图简介 61</span><br><span class="line">5.6.2 使用XML布局文件定义视图 61</span><br><span class="line">5.6.3 在代码中控制视图 62</span><br><span class="line">5.7 显示系统窗口 64</span><br><span class="line">5.7.1 直接拨号 65</span><br><span class="line">5.7.2 将电话号传入拨号程序 65</span><br><span class="line">5.7.3 调用拨号程序 65</span><br><span class="line">5.7.4 浏览网页 65</span><br><span class="line">5.7.5 查看联系人 66</span><br><span class="line">5.7.6 显示系统设置界面（设置主界面、Wi—Fi设置界面） 66</span><br><span class="line">5.7.7 启动处理音频的程序 66</span><br><span class="line">5.7.8 回到Home窗口（相当于按Home键） 66</span><br><span class="line">5.8 与Activity相关的技巧与特效 67</span><br><span class="line">5.8.1 全屏显示（隐藏标题栏和状态栏） 67</span><br><span class="line">5.8.2 定制窗口标题栏 71</span><br><span class="line">5.8.3 为程序添加Splash 75</span><br><span class="line">5.8.4 改变窗口大小、位置和透明度 76</span><br><span class="line">5.8.5 按两次关闭窗口 79</span><br><span class="line">5.8.6 关闭所有的窗口 79</span><br><span class="line">5.8.7 窗口截屏 80</span><br><span class="line">5.9 小结 82</span><br><span class="line">第6章 Intent与IntentFilter 83</span><br><span class="line">6.1 Android系统的信使：Intent 83</span><br><span class="line">6.2 Intent对象 84</span><br><span class="line">6.2.1 Intent对象可以封装和传递哪些信息 84</span><br><span class="line">6.2.2 组件名（Componentname） 84</span><br><span class="line">6.2.3 动作（Action） 85</span><br><span class="line">6.2.4 种类（Category） 86</span><br><span class="line">6.2.5 数据（Data） 87</span><br><span class="line">6.2.6 附加数据（Extra） 88</span><br><span class="line">6.2.7 标志（Flags） 89</span><br><span class="line">6.3 显式和隐式访问窗口 89</span><br><span class="line">6.4 跨应用程序访问窗口 90</span><br><span class="line">6.5 Android系统的过滤机制大揭秘 96</span><br><span class="line">6.5.1 过滤条件的设置 96</span><br><span class="line">6.5.2 过滤器的筛选规则 97</span><br><span class="line">6.5.3 示例：过滤机制应用演示 101</span><br><span class="line">6.6 Android源代码与过滤器 104</span><br><span class="line">6.6.1 系统内置程序有哪些窗口可以利用 104</span><br><span class="line">6.6.2 显示计算器（Calculator） 105</span><br><span class="line">6.6.3 用浏览器（Browser）显示网页 106</span><br><span class="line">6.6.4 拨打电话（Phone）与授权 108</span><br><span class="line">6.7 获取第三方程序中可调用的窗口 109</span><br><span class="line">6.8 传递附加数据（Extra） 111</span><br><span class="line">6.9 解析数据 113</span><br><span class="line">6.10 小结 114</span><br><span class="line">第7章 窗口（Activity）高级技术 115</span><br><span class="line">7.1 ActivityXML属性详解 115</span><br><span class="line">7.1.1 设置Activity的基本信息 115</span><br><span class="line">7.1.2 屏幕方向切换（android：screenOrientation） 117</span><br><span class="line">7.1.3 阻止Activity销毁和重建（android：configChanges） 119</span><br><span class="line">7.1.4 允许Activity被实例化（android：enabled） 123</span><br><span class="line">7.1.5 在最近应用列表中显示（android：excludeFromRecents） 124</span><br><span class="line">7.1.6 允许其他程序访问当前窗口（android：exported） 124</span><br><span class="line">7.1.7 硬件加速（android：hardwareAccelerated） 125</span><br><span class="line">7.1.8 在多进程中创建窗口实例（android：multiprocess） 125</span><br><span class="line">7.1.9 无法返回的Activity（android：noHistory） 125</span><br><span class="line">7.1.10 指定要返回的窗口（android：parentActivityName） 126</span><br><span class="line">7.1.11 使窗口受到权限的保护（android：permission） 126</span><br><span class="line">7.1.12 改变窗口所在的进程（android：process） 127</span><br><span class="line">7.1.13 不保存窗口的状态（android：stateNotNeeded） 129</span><br><span class="line">7.1.14 窗口的主题（android：theme） 129</span><br><span class="line">7.1.15 扩展窗口UI（android：uiOptions） 129</span><br><span class="line">7.1.16 设置输入法显示模式（android：windowSoftInputMode） 130</span><br><span class="line">7.2 深入探索Activity从创建到销毁的过程 130</span><br><span class="line">7.2.1 任务（Task）与回退栈（BackStack） 131</span><br><span class="line">7.2.2 保存窗口（Activity）状态 133</span><br><span class="line">7.2.3 管理任务和回退栈 134</span><br><span class="line">7.2.4 Activity的4种创建模式 135</span><br><span class="line">7.2.5 用Java代码设置窗口创建模式 141</span><br><span class="line">7.2.6 窗口的乾坤大挪移（affinity） 144</span><br><span class="line">7.2.7 销毁不再使用的窗口 147</span><br><span class="line">7.3 Activity的别名 149</span><br><span class="line">7.4 小结 151</span><br><span class="line">第8章 布局 152</span><br><span class="line">8.1 Android的五大布局 152</span><br><span class="line">8.1.1 框架布局（FrameLayout） 152</span><br><span class="line">8.1.2 线性布局（LinearLayout） 154</span><br><span class="line">8.1.3 相对布局（RelativeLayout） 158</span><br><span class="line">8.1.4 表格布局（TableLayout） 159</span><br><span class="line">8.1.5 绝对布局（AbsoluteLayout） 160</span><br><span class="line">8.2 属性资源与Android命名空间 160</span><br><span class="line">8.3 布局属性 162</span><br><span class="line">8.4 布局高级技术 163</span><br><span class="line">8.4.1 布局别名 163</span><br><span class="line">8.4.2 重用布局 164</span><br><span class="line">8.4.3 优化布局 166</span><br><span class="line">8.4.4 动态装载布局 167</span><br><span class="line">8.4.5 动态设置布局属性 169</span><br><span class="line">8.4.6 从右到左布局（RTLLayout） 169</span><br><span class="line">8.5 小结 170</span><br><span class="line">第9章 菜单 171</span><br><span class="line">9.1 菜单的基本用法 171</span><br><span class="line">9.1.1 创建选项菜单（OptionsMenu） 171</span><br><span class="line">9.1.2 关联Activity 173</span><br><span class="line">9.1.3 响应菜单的单击动作 173</span><br><span class="line">9.1.4 动态添加、修改和删除选项菜单 174</span><br><span class="line">9.1.5 带复选框和选项按钮的子菜单 175</span><br><span class="line">9.1.6 上下文菜单 176</span><br><span class="line">9.1.7 菜单事件 177</span><br><span class="line">9.1.8 从菜单资源中装载菜单 177</span><br><span class="line">9.2 菜单特效 177</span><br><span class="line">9.2.1 自定义菜单 178</span><br><span class="line">9.2.2 模拟UCWeb菜单效果 180</span><br><span class="line">9.3 小结 184</span><br><span class="line">第10章 Android的资源详解（一） 185</span><br><span class="line">10.1 创建资源 185</span><br><span class="line">10.1.1 手工创建资源文件 185</span><br><span class="line">10.1.2 用ADT模板创建本地化图标资源 186</span><br><span class="line">10.1.3 用ADT模板创建XML文件资源 188</span><br><span class="line">10.2 使用资源 188</span><br><span class="line">10.2.1 生成资源类文件（R.java） 188</span><br><span class="line">10.2.2 从XML文件中访问资源 190</span><br><span class="line">10.2.3 使用Java代码访问资源 191</span><br><span class="line">10.2.4 Java反射技术与枚举资源 192</span><br><span class="line">10.3 字符串（String）资源 193</span><br><span class="line">10.3.1 普通字符串 193</span><br><span class="line">10.3.2 字符串数组 194</span><br><span class="line">10.3.3 复数字符串 194</span><br><span class="line">10.3.4 在字符串中使用引号 195</span><br><span class="line">10.3.5 用占位符格式化字符串 195</span><br><span class="line">10.3.6 用HTML标签格式化字符串资源 195</span><br><span class="line">10.4 值（values）资源 196</span><br><span class="line">10.4.1 整数（Integer）资源 196</span><br><span class="line">10.4.2 尺寸（Dimension）资源 197</span><br><span class="line">10.4.3 布尔（Boolean）资源 198</span><br><span class="line">10.4.4 颜色（Color）资源 198</span><br><span class="line">10.4.5 ID资源 199</span><br><span class="line">10.4.6 整数数组（Integer—Array）资源 200</span><br><span class="line">10.4.7 类型数组（Typed—Array）资源 200</span><br><span class="line">10.5 菜单（menu）资源 200</span><br><span class="line">10.6 图像（drawable）资源 203</span><br><span class="line">10.6.1 普通图像资源 203</span><br><span class="line">10.6.2 XML图像资源 204</span><br><span class="line">10.6.3 Nine—Patch图像资源 204</span><br><span class="line">10.6.4 XMLNine—Patch图像资源 205</span><br><span class="line">10.6.5 图层（Layer）资源 205</span><br><span class="line">10.6.6 图像状态（State）资源 206</span><br><span class="line">10.6.7 图像级别（Level）资源 207</span><br><span class="line">10.6.8 淡入淡出（Cross—fade）资源 208</span><br><span class="line">10.6.9 嵌入（Inset）图像资源 210</span><br><span class="line">10.6.10 剪切（Clip）图像资源 210</span><br><span class="line">10.6.11 外形（Shape）资源 211</span><br><span class="line">10.7 小结 212</span><br><span class="line">第11章 Android的资源详解（二） 213</span><br><span class="line">11.1 动画资源 213</span><br><span class="line">11.1.1 属性（Property）动画 213</span><br><span class="line">11.1.2 帧（Frame）动画 215</span><br><span class="line">11.1.3 移动补间（TranslateTween）动画 217</span><br><span class="line">11.1.4 循环向右移动的EditText与上下弹跳的球 218</span><br><span class="line">11.1.5 缩放补间（ScaleTween）动画 220</span><br><span class="line">11.1.6 跳动的心 221</span><br><span class="line">11.1.7 旋转补间（RotateTween）动画 222</span><br><span class="line">11.1.8 旋转的星系 222</span><br><span class="line">11.1.9 透明度补间（AlphaTween）动画 223</span><br><span class="line">11.1.10 投掷炸弹 224</span><br><span class="line">11.1.11 震动渲染器（ShakeInterpolator） 226</span><br><span class="line">11.1.12 自定义渲染器（Interpolator） 227</span><br><span class="line">11.2 风格（Style）资源与主题（Theme） 229</span><br><span class="line">11.3 小结 232</span><br><span class="line">第12章 资源的本地化 233</span><br><span class="line">12.1 建立本地化的资源目录 233</span><br><span class="line">12.2 资源目录的命名规则 237</span><br><span class="line">12.3 建立别名资源 237</span><br><span class="line">12.3.1 图像别名资源 237</span><br><span class="line">12.3.2 布局别名资源 238</span><br><span class="line">12.3.3 字符串别名资源 238</span><br><span class="line">12.3.4 其他简单值别名资源 238</span><br><span class="line">12.4 资源目录的优先级 238</span><br><span class="line">12.5屏幕适配 239</span><br><span class="line">12.5.1 屏幕适配要考虑的因素 239</span><br><span class="line">12.5.2 适配不同屏幕可以采用的规则 241</span><br><span class="line">12.5.3 屏幕尺寸和屏幕密度 241</span><br><span class="line">12.5.4 位置、尺寸和字体应使用屏幕密度单位 244</span><br><span class="line">12.5.5 与屏幕适配有关的标识符 244</span><br><span class="line">12.5.6 影响屏幕适配的重要因素：布局和图像 245</span><br><span class="line">12.5.7 典型的屏幕适配案例 246</span><br><span class="line">12.5.8 在GooglePlay上限制屏幕尺寸和屏幕密度 247</span><br><span class="line">12.5.9 在Android模拟器上测试各种屏幕尺寸和密度 248</span><br><span class="line">12.6 小结 248</span><br><span class="line">第13章 Android的控件详解（一） 249</span><br><span class="line">13.1 显示文本的控件（TextView） 249</span><br><span class="line">13.1.1 显示富文本（URL、不同大小、字体、颜色的文本） 250</span><br><span class="line">13.1.2 用标签在TextView控件上显示图像 252</span><br><span class="line">13.1.3 单击链接弹出Activity 254</span><br><span class="line">13.1.4 为指定文本添加背景 256</span><br><span class="line">13.2 编辑文本的控件（EditText） 258</span><br><span class="line">13.2.1 像QQ一样输入表情图像 259</span><br><span class="line">13.2.2 在EditText中输入特定的字符 260</span><br><span class="line">13.2.3 AutoCompleteTextView（自动完成输入内容的控件） 261</span><br><span class="line">13.3 按钮（Button）和复选框（Checkbox）控件 263</span><br><span class="line">13.3.1 Button（普通按钮控件） 263</span><br><span class="line">13.3.2 图文混排的按钮 265</span><br><span class="line">13.3.3 ImageButton（图像按钮控件） 266</span><br><span class="line">13.3.4 RadioButton（选项按钮控件） 267</span><br><span class="line">13.3.5 ToggleButton（开关状态按钮控件） 267</span><br><span class="line">13.3.6 CheckBox（复选框控件） 268</span><br><span class="line">13.4 图像控件（ImageView） 270</span><br><span class="line">13.4.1 ImageView控件的基本用法 270</span><br><span class="line">13.4.2 显示指定区域的图像 270</span><br><span class="line">13.4.3 缩放和旋转图像 272</span><br><span class="line">13.5 时间与日期控件 273</span><br><span class="line">13.5.1 DatePicker（输入日期的控件） 273</span><br><span class="line">13.5.2 TimePicker（输入时间的控件） 274</span><br><span class="line">13.5.3 DatePicker、TimePicker与TextView同步显示日期和时间 274</span><br><span class="line">13.5.4 AnalogClock和DigitalClock（显示时钟的控件） 275</span><br><span class="line">13.6 小结 275</span><br><span class="line">第14章 Android的控件详解（二） 276</span><br><span class="line">14.1 进度条控件 276</span><br><span class="line">14.1.1 ProgressBar（进度条控件） 276</span><br><span class="line">14.1.2 SeekBar（拖动条控件） 278</span><br><span class="line">14.1.3 设置ProgressBar和SeekBar的颜色及背景图 278</span><br><span class="line">14.1.4 RatingBar（评分控件） 281</span><br><span class="line">14.2 列表控件 282</span><br><span class="line">14.2.1 ListView（普通列表控件） 282</span><br><span class="line">14.2.2 为ListView列表项添加复选框和选项按钮 285</span><br><span class="line">14.2.3 对列表项进行增、删、改操作 286</span><br><span class="line">14.2.4 改变列表项的背景色 290</span><br><span class="line">14.2.5 ListActivity（封装ListView的Activity） 290</span><br><span class="line">14.2.6 ExpandableListView（可扩展的列表控件） 291</span><br><span class="line">14.2.7 Spinner（下拉列表控件） 293</span><br><span class="line">14.3 GridView（网格控件） 296</span><br><span class="line">14.4 TabHost（标签控件） 298</span><br><span class="line">14.5 ViewStub（惰性装载控件） 299</span><br><span class="line">14.6 小结 300</span><br><span class="line">第15章 可视化UI设计 301</span><br><span class="line">15.1 拖放控件 301</span><br><span class="line">15.2 设置视图属性 303</span><br><span class="line">15.3 预览各种屏幕尺寸 303</span><br><span class="line">15.4 语言和地区的本地化测试 304</span><br><span class="line">15.5 其他可视化功能 304</span><br><span class="line">15.6 小结 305</span><br><span class="line">第16章 对话框、Toast与通知栏（Notification） 306</span><br><span class="line">16.1 对话框 306</span><br><span class="line">16.1.1 带2个按钮（确认／取消）的对话框 306</span><br><span class="line">16.1.2 带3个按钮（覆盖／忽略／取消）的对话框 307</span><br><span class="line">16.1.3 简单列表对话框 308</span><br><span class="line">16.1.4 单选列表对话框 309</span><br><span class="line">16.1.5 多选列表对话框 311</span><br><span class="line">16.1.6 进度对话框 312</span><br><span class="line">16.1.7 登录对话框 315</span><br><span class="line">16.1.8 使用Activity托管对话框 316</span><br><span class="line">16.2 Toast 318</span><br><span class="line">16.3 通知（Notification） 319</span><br><span class="line">16.3.1 在状态栏上显示通知信息 319</span><br><span class="line">16.3.2 永久存在的Notification 322</span><br><span class="line">16.3.3 自定义Notification 323</span><br><span class="line">16.4 小结 324</span><br><span class="line">第17章 封装UI和代码利器——Fragment 325</span><br><span class="line">17.1 Fragment简介 325</span><br><span class="line">17.2 什么时候使用Fragment 326</span><br><span class="line">17.3 按照Fragment设计原则编写程序 328</span><br><span class="line">17.4 Fragment的生命周期 332</span><br><span class="line">17.5 创建Fragment 341</span><br><span class="line">17.5.1 通过XML布局文件创建Fragment 341</span><br><span class="line">17.5.2 通过Java代码创建Fragment 342</span><br><span class="line">17.5.3 创建无UI的Fragment 344</span><br><span class="line">17.5.4 在低版本Android中使用Fragment（SupportLibrary） 345</span><br><span class="line">17.6 Activity与Fragment之间的交互 346</span><br><span class="line">17.6.1 Fragment与Activity之间的交互 346</span><br><span class="line">17.6.2 Fragment的回调机制 348</span><br><span class="line">17.7 Fragment状态的持久化 351</span><br><span class="line">17.8 Fragment与回退栈（导航） 355</span><br><span class="line">17.9 FragmentManager与FragmentTransaction 357</span><br><span class="line">17.9.1 管理Fragment事务 357</span><br><span class="line">17.9.2 查找Fragment 357</span><br><span class="line">17.9.3 跟踪回退栈状态 358</span><br><span class="line">17.9.4 恢复历史状态 358</span><br><span class="line">17.9.5 管理Fragment的状态 359</span><br><span class="line">17.9.6 添加、删除和替换Fragment 359</span><br><span class="line">17.9.7 分离（Detach）与附加（Attach）Fragment 360</span><br><span class="line">17.9.8 显示和隐藏Fragment 361</span><br><span class="line">17.10 Fragment扩展 361</span><br><span class="line">17.10.1 ListFragment 361</span><br><span class="line">17.10.2 DialogFragment 363</span><br><span class="line">17.10.3 其他Fragment扩展类 366</span><br><span class="line">17.11 Fragment模板源代码分析 366</span><br><span class="line">17.12 小结 368</span><br><span class="line">第18章 动作栏——ActionBar 369</span><br><span class="line">18.1 ActionBar简介 369</span><br><span class="line">18.2 ActionBar基础 370</span><br><span class="line">18.2.1 隐藏／显示ActionBar 370</span><br><span class="line">18.2.2 添加和响应Action按钮 372</span><br><span class="line">18.3可上下两分的ActionBar 374</span><br><span class="line">18.4 应用程序图标导航 376</span><br><span class="line">18.5 收缩和展开ActionView 377</span><br><span class="line">18.6 ActionProvider 380</span><br><span class="line">18.6.1 分享信息（ShareActionProvider） 380</span><br><span class="line">18.6.2 定制ActionProvider 382</span><br><span class="line">18.7 导航标签 384</span><br><span class="line">18.8 下拉导航列表 388</span><br><span class="line">18.9 小结 390</span><br><span class="line">第19章 Android的拖放技术 391</span><br><span class="line">19.1 Android中的拖放操作 391</span><br><span class="line">19.2 拖放状态与拖放处理 391</span><br><span class="line">19.3 拖动阴影 392</span><br><span class="line">19.4 示例：拖动复制图像 393</span><br><span class="line">19.5 小结 395</span><br><span class="line">第20章 数据存储解决方案 396</span><br><span class="line">20.1 读写key—value对：SharedPreferences 396</span><br><span class="line">20.2 文件流操作 397</span><br><span class="line">20.2.1 openFileOutput和openFileInput方法 398</span><br><span class="line">20.2.2 读写SD卡中的文件 399</span><br><span class="line">20.3 读写JSON格式的数据 400</span><br><span class="line">20.4 SQLite数据库 404</span><br><span class="line">20.4.1 SQLite数据库管理工具 404</span><br><span class="line">20.4.2 SQLiteOpenHelper类与自动升级数据库 405</span><br><span class="line">20.4.3 数据绑定与SimpleCursorAdapter类 406</span><br><span class="line">20.4.4 操作SD卡上的数据库 409</span><br><span class="line">20.4.5 将数据库与应用程序一起发布 410</span><br><span class="line">20.4.6 内存数据库 411</span><br><span class="line">20.5 小结 412</span><br><span class="line">第21章 内容提供者（ContentProvider） 413</span><br><span class="line">21.1 ContentProvider的作用 413</span><br><span class="line">21.2 获得系统数据 413</span><br><span class="line">21.2.1 读取联系人信息 414</span><br><span class="line">21.2.2 查看收件箱的短信 415</span><br><span class="line">21.3 自定义ContentProvider 417</span><br><span class="line">21.3.1 查询城市信息 417</span><br><span class="line">21.3.2 为ContentProvider添加访问权限 422</span><br><span class="line">21.4 如何查找系统提供的ContentProvider 423</span><br><span class="line">21.5 小结 425</span><br><span class="line">第22章 广播接收器（BroadcastReceiver） 426</span><br><span class="line">22.1 什么是广播 426</span><br><span class="line">22.2 接收系统广播 427</span><br><span class="line">22.2.1 短信拦截 427</span><br><span class="line">22.2.2 用代码注册广播接收器 429</span><br><span class="line">22.2.3 广播接收器的优先级 429</span><br><span class="line">22.2.4 来去电拦截 430</span><br><span class="line">22.2.5 截获屏幕休眠与唤醒 432</span><br><span class="line">22.2.6 开机自动运行 433</span><br><span class="line">22.2.7 显示手机电池的当前电量 434</span><br><span class="line">22.3 发送广播 434</span><br><span class="line">22.4 小结 435</span><br><span class="line">第23章 服务（Service） 436</span><br><span class="line">23.1 Service基础 436</span><br><span class="line">23.1.1 Service的生命周期 436</span><br><span class="line">23.1.2 开机启动Service 438</span><br><span class="line">23.2 跨进程访问（AIDL服务） 439</span><br><span class="line">23.2.1 什么是AIDL服务 439</span><br><span class="line">23.2.2 建立AIDL服务的步骤 439</span><br><span class="line">23.2.3 创建和调用AIDL服务 440</span><br><span class="line">23.2.4 传递复杂数据的AIDL服务 442</span><br><span class="line">23.2.5 AIDL与来去电自动挂断 445</span><br><span class="line">23.3 小结 447</span><br><span class="line">第24章 Android的组件开发 448</span><br><span class="line">24.1 Android支持哪些组件开发方式 448</span><br><span class="line">24.2 引用jar文件 449</span><br><span class="line">24.3 跨工程引用 450</span><br><span class="line">24.4 引用NDKLibrary 451</span><br><span class="line">24.5 动态引用APK文件 451</span><br><span class="line">24.6 动静结合的组件 453</span><br><span class="line">24.7 脚本类型组件（JavaScript）与WebView控件 453</span><br><span class="line">24.8 如何确定动态组件是否安装 457</span><br><span class="line">24.9 升级动态组件 459</span><br><span class="line">24.10 小结 461</span><br><span class="line">第25章 Android的蓝牙开发技术 462</span><br><span class="line">25.1 蓝牙简介 462</span><br><span class="line">25.2 打开和关闭蓝牙设备 462</span><br><span class="line">25.3 搜索蓝牙设备 463</span><br><span class="line">25.4 蓝牙数据传输 465</span><br><span class="line">25.5 蓝牙通信一定需要UUID吗 467</span><br><span class="line">25.6 小结 467</span><br><span class="line">第26章 近距离天线通信——NFC技术 468</span><br><span class="line">26.1 NFC简介 468</span><br><span class="line">26.2 NFC、蓝牙和红外之间的差异 469</span><br><span class="line">26.3 NFC技术的未来前景 470</span><br><span class="line">26.4 Android中的NFC技术 471</span><br><span class="line">26.4.1 NDEF与非NDEF数据 471</span><br><span class="line">26.4.2 NFC的三重过滤机制 471</span><br><span class="line">26.4.3 开启Android的NFC功能 472</span><br><span class="line">26.4.4 编写NFC程序的基本步骤 473</span><br><span class="line">26.5 测试NFC程序需要的设备 474</span><br><span class="line">26.6 让Android手机自动运行程序 475</span><br><span class="line">26.6.1 向NFC标签写入数据的基本步骤 475</span><br><span class="line">26.6.2 向NFC标签写入启动Android应用程序的消息 476</span><br><span class="line">26.7 让Android手机自动打开网页 483</span><br><span class="line">26.8 读写NFC标签中的文本 485</span><br><span class="line">26.8.1 实现读写文本数据应用的基本思路 485</span><br><span class="line">26.8.2 如何将NFC标签变成NDEF文本格式 485</span><br><span class="line">26.8.3 NDEF文本格式解析 486</span><br><span class="line">26.8.4 实现读写文本数据的Android应用程序 490</span><br><span class="line">26.9 读写NFC标签中的Uri 496</span><br><span class="line">26.9.1 NDEFUri格式解析 496</span><br><span class="line">26.9.2 实现读写Uri的Android应用程序 499</span><br><span class="line">26.10 利用NFC标签支持的数据格式进行过滤 502</span><br><span class="line">26.11 处理任意NFC标签 504</span><br><span class="line">26.12 读写非NDEF格式的数据 505</span><br><span class="line">26.13 AndroidBeam技术与数据交互 507</span><br><span class="line">26.13.1 传递NDEF消息 507</span><br><span class="line">26.13.2 传输文件 511</span><br><span class="line">26.14 小结 513</span><br><span class="line">第27章 Android的网络开发技术 514</span><br><span class="line">27.1 提交HTTPGET和HTTPPOST请求 514</span><br><span class="line">27.2 HttpURLConnection类 516</span><br><span class="line">27.3 上传文件 517</span><br><span class="line">27.4 下载管理（DownloadManager） 519</span><br><span class="line">27.5 Wi—FiDirect 524</span><br><span class="line">27.5.1 Wi—FiDirectAPI的核心部分 524</span><br><span class="line">27.5.2 创建监听Wi—FiDirect动作的广播接收器 524</span><br><span class="line">27.5.3 注册广播接收器 525</span><br><span class="line">27.5.4 发现Wi—FiDirect设备 526</span><br><span class="line">27.5.5 连接Wi—FiDirect设备 526</span><br><span class="line">27.5.6 数据传输 527</span><br><span class="line">27.6 Internet电话（SIP） 528</span><br><span class="line">27.6.1 使用SIP的要求和限制 528</span><br><span class="line">27.6.2 配置Android版SIP电话 528</span><br><span class="line">27.6.3 创建SipManager 529</span><br><span class="line">27.6.4 注册SIP服务器 529</span><br><span class="line">27.6.5 开始打电话 530</span><br><span class="line">27.6.6 接听电话 530</span><br><span class="line">27.7 小结 531</span><br><span class="line">第28章 并发与定时器 532</span><br><span class="line">28.1 Handler 532</span><br><span class="line">28.1.1 更新UI 532</span><br><span class="line">28.1.2 延迟执行 535</span><br><span class="line">28.2 定时器 537</span><br><span class="line">28.2.1 单秒循环的定时器：Chronometer 537</span><br><span class="line">28.2.2 任意时间间隔的定时器：Timer 538</span><br><span class="line">28.2.3 全局定时器：AlarmManager 539</span><br><span class="line">28.3 AsyncTask 541</span><br><span class="line">28.4 小结 543</span><br><span class="line">第29章 异步装载（Loader） 544</span><br><span class="line">29.1 Loader简介 544</span><br><span class="line">29.2 Loader的核心类／接口 544</span><br><span class="line">29.3 如何使用Loader 545</span><br><span class="line">29.3.1 创建／重用Loader 545</span><br><span class="line">29.3.2 遗弃旧的数据 546</span><br><span class="line">29.3.3 LoaderManager与方法回调 546</span><br><span class="line">29.3.4 创建Loader对象（onCreateLoader） 547</span><br><span class="line">29.3.5 完成数据装载（onLoadFinished） 547</span><br><span class="line">29.3.6 Loader被重置（onLoaderReset） 548</span><br><span class="line">29.4 异步装载联系人（CursorLoader的应用） 548</span><br><span class="line">29.5 小结 552</span><br><span class="line">第30章 Android推送技术 553</span><br><span class="line">30.1 IOS的推送方案 553</span><br><span class="line">30.2 WindowsPhone的推送方案 554</span><br><span class="line">30.3 Android的推送方案 554</span><br><span class="line">30.4 第三方推送服务：极光推送 556</span><br><span class="line">30.5 自己搭建推送服务器：AndroidPN 557</span><br><span class="line">30.6 小结 558</span><br><span class="line">第31章 Android的多媒体开发技术 559</span><br><span class="line">31.1 音频 559</span><br><span class="line">31.1.1 音频播放 559</span><br><span class="line">31.1.2 录制音频 561</span><br><span class="line">31.2 视频 563</span><br><span class="line">31.2.1 播放视频 563</span><br><span class="line">31.2.2 录制视频 564</span><br><span class="line">31.3 相机 565</span><br><span class="line">31.3.1 调用系统的拍照功能 565</span><br><span class="line">31.3.2 自定义拍照功能 566</span><br><span class="line">31.4 铃声 570</span><br><span class="line">31.5 小结 572</span><br><span class="line">第32章 Android的2D绘图 573</span><br><span class="line">32.1 绘制基本的图形 573</span><br><span class="line">32.1.1 绘制像素点 573</span><br><span class="line">32.1.2 绘制直线 574</span><br><span class="line">32.1.3 绘制圆形 574</span><br><span class="line">32.1.4 绘制圆弧 574</span><br><span class="line">32.1.5 绘制文本 575</span><br><span class="line">32.1.6 示例：绘制基本的图形和文本 575</span><br><span class="line">32.2 绘制位图 578</span><br><span class="line">32.2.1 绘制Bitmap对象 578</span><br><span class="line">32.2.2 使用Drawable.draw方法绘制位图 579</span><br><span class="line">32.2.3 示例：用两种方式绘制位图 579</span><br><span class="line">32.3 设置图像的透明度 580</span><br><span class="line">32.4 旋转图像 581</span><br><span class="line">32.5 小结 583</span><br><span class="line">第33章 3D绘图之OpenGLES 584</span><br><span class="line">33.1 OpenGLES简介 584</span><br><span class="line">33.2 在3D空间中绘图 585</span><br><span class="line">33.2.1 要绘制3D图形了，第一步要做什么 585</span><br><span class="line">33.2.2 定义顶点 587</span><br><span class="line">33.2.3 绘制三角形 588</span><br><span class="line">33.2.4 三角形合并法绘制矩形 590</span><br><span class="line">33.2.5 顶点法绘制矩形 592</span><br><span class="line">33.2.6 顶点的选取顺序 592</span><br><span class="line">33.2.7 索引法绘制矩形 593</span><br><span class="line">33.2.8 基于OpenGLES的动画原理 594</span><br><span class="line">33.2.9 旋转的矩形 594</span><br><span class="line">33.3 视图 595</span><br><span class="line">33.3.1 有趣的比喻：照相机拍照 596</span><br><span class="line">33.3.2 模型变换：立方体旋转 597</span><br><span class="line">33.3.3 用gluLookAt方法变换视图 599</span><br><span class="line">33.4 颜色 600</span><br><span class="line">33.5 小结 602</span><br><span class="line">第34章 Android的桌面上的“尤物” 603</span><br><span class="line">34.1 窗口小部件（AppWidget） 603</span><br><span class="line">34.1.1 在Android桌面上添加AppWidget 603</span><br><span class="line">34.1.2 开发AppWidget的步骤 603</span><br><span class="line">34.1.3 数字时钟 605</span><br><span class="line">34.1.4 AppWidgetProvider类 607</span><br><span class="line">34.1.5 向AppWidget添加配置窗口 608</span><br><span class="line">34.1.6 可以选择风格的数字时钟 608</span><br><span class="line">34.2 动态壁纸（随机变换的圆圈） 612</span><br><span class="line">34.3 小结 618</span><br><span class="line">第35章 Android中的短信（SMS）与彩信（MMS）开发技术 619</span><br><span class="line">35.1 通过系统程序发短信 619</span><br><span class="line">35.2 直接发送短信 619</span><br><span class="line">35.3 保存短信发送记录 620</span><br><span class="line">35.4 监听短信和彩信 621</span><br><span class="line">35.5 显示视频缩略图 622</span><br><span class="line">35.6 彩信内容与SMIL协议 624</span><br><span class="line">35.7 小结 631</span><br><span class="line">第36章 Android的传感器开发技术 632</span><br><span class="line">36.1 如何使用传感器 632</span><br><span class="line">36.2 加速度传感器（Accelerometer） 635</span><br><span class="line">36.3 重力传感器（Gravity） 635</span><br><span class="line">36.4 光线传感器（Light） 636</span><br><span class="line">36.5 陀螺仪传感器（Gyroscope） 636</span><br><span class="line">36.5 方向传感器（Orientation） 637</span><br><span class="line">36.6 其他传感器 638</span><br><span class="line">36.7 小结 638</span><br><span class="line">第37章 Android的全球定位系统（GPS） 639</span><br><span class="line">37.1 GPS的核心API 639</span><br><span class="line">37.2 获取位置提供者（LocationProvider） 641</span><br><span class="line">37.2.1 获取所有可用的LocationProvider 641</span><br><span class="line">37.2.2 根据名称获取LocationProvider 642</span><br><span class="line">37.2.3 根据条件（Criteria）获取LocationProvider 642</span><br><span class="line">37.3 实时获取GPS定位数据 643</span><br><span class="line">37.4 测量地球上任意两点之间的距离 645</span><br><span class="line">37.5 邻近警告 646</span><br><span class="line">37.6 小结 647</span><br><span class="line">第38章 谷歌地图（GoogleMap）开发应用 648</span><br><span class="line">38.1 GoogleMap的跨平台解决方案：MapsJavaScriptAPIv3 648</span><br><span class="line">38.2 GoogleMap的显示与定位 648</span><br><span class="line">38.3 在GoogleMap上插入图像标志 651</span><br><span class="line">38.4 插入多个图像标志 653</span><br><span class="line">38.5 带阴影的位置坐标信息 653</span><br><span class="line">38.6 地图与Java交互 655</span><br><span class="line">38.7 小结 657</span><br><span class="line">第39章 Android中的人机交互设计 658</span><br><span class="line">39.1 手势（Gesture） 658</span><br><span class="line">39.1.1 创建手势文件 658</span><br><span class="line">39.1.2 通过手势输入字符串 658</span><br><span class="line">39.1.3 通过手势调用程序 660</span><br><span class="line">39.1.4 编写自己的手势创建器 661</span><br><span class="line">39.2 多点触摸与放大／缩小操作 662</span><br><span class="line">39.3 语音识别 664</span><br><span class="line">39.4 让手机说话（TTS） 665</span><br><span class="line">39.5 小结 666</span><br><span class="line">第40章 Android中的输入法开发 667</span><br><span class="line">40.1 Android输入法简介 667</span><br><span class="line">40.2 控制输入法 668</span><br><span class="line">40.3 输入法实战 669</span><br><span class="line">40.3.1 实现输入法的步骤 669</span><br><span class="line">40.3.2 编写输入法程序 669</span><br><span class="line">40.3.3 输入法服务的生命周期 672</span><br><span class="line">40.3.4 预输入文本 672</span><br><span class="line">40.3.5 输入法设置 673</span><br><span class="line">40.4 小结 673</span><br><span class="line">第41章 AndroidNDK开发 674</span><br><span class="line">41.1 AndroidNDK简介 674</span><br><span class="line">41.2 安装、配置和测试NDK开发环境 674</span><br><span class="line">41.2.1 系统和软件要求 675</span><br><span class="line">41.2.2 下载和安装AndroidNDK 675</span><br><span class="line">41.2.3 下载和安装Cygwin 675</span><br><span class="line">41.2.4 配置AndroidNDK的开发环境 677</span><br><span class="line">41.3 利用NDKSamples学习NDK开发 678</span><br><span class="line">41.3.1 编译NDKSamples 678</span><br><span class="line">41.3.2 NDK程序的结构与命名规则 678</span><br><span class="line">41.4 AndroidNDK配置文件详解 679</span><br><span class="line">41.4.1 AndroidNDK定义的变量 680</span><br><span class="line">41.4.2 AndroidNDK定义的函数 680</span><br><span class="line">41.4.3 描述模块的变量 681</span><br><span class="line">41.4.4 配置Application.mk文件 682</span><br><span class="line">41.5 第一个NDK示例：字母的大小写转换 682</span><br><span class="line">41.5.1 编写NDK程序 682</span><br><span class="line">41.5.2 编写调用NDK函数的Java程序 684</span><br><span class="line">41.5.3 在Eclipse中开发和编译NDK程序 684</span><br><span class="line">41.6 NDK程序读取Java字段值 686</span><br><span class="line">41.7 小结 687</span><br><span class="line">第42章 Android的测试驱动开发（TDD） 688</span><br><span class="line">42.1 JUnit测试框架 688</span><br><span class="line">42.2 测试Activity 688</span><br><span class="line">42.3 测试ContentProvider 691</span><br><span class="line">42.4 测试Service 692</span><br><span class="line">42.5 测试普通类 692</span><br><span class="line">42.6 小结 693</span><br><span class="line">第43章 Android应用的性能优化 694</span><br><span class="line">43.1 性能优化的基础知识 694</span><br><span class="line">43.2 编写Java程序的最优化原则 695</span><br><span class="line">43.2.1 用静态工厂方法代替构造方法 695</span><br><span class="line">43.2.2 避免创建重复的对象 695</span><br><span class="line">43.2.3 防止内存泄漏 697</span><br><span class="line">43.2.4 返回零长度的集合而不是null 697</span><br><span class="line">43.2.5 通过接口引用对象 698</span><br><span class="line">43.3 避免ANR 698</span><br><span class="line">43.4 执行时间测试 699</span><br><span class="line">43.5 内存消耗测试 700</span><br><span class="line">43.6 测试性能的工具：traceview 701</span><br><span class="line">43.7 小结 702</span><br><span class="line">第44章 游戏项目实战：笑脸连连看 703</span><br><span class="line">44.1 游戏玩法 703</span><br><span class="line">44.2 准备图像素材 703</span><br><span class="line">44.3 实现主界面 704</span><br><span class="line">44.4 随机生成连连看图像 705</span><br><span class="line">44.5 选中两个相同图像后消失 705</span><br><span class="line">44.6 用定时器限制游戏时间 706</span><br><span class="line">44.7 小结 707</span><br><span class="line">第45章 开源项目实战：NFC侠（NFCMan） 708</span><br><span class="line">45.1 什么是NFCMan 708</span><br><span class="line">45.2 用Android模拟器和非NFC设备测试NFC应用 709</span><br><span class="line">45.3 NFCMan的实现原理 711</span><br><span class="line">45.4 实现服务端程序（NFCMan） 711</span><br><span class="line">45.4.1 可视化SWT开发环境 712</span><br><span class="line">45.4.2 创建NFC标签 712</span><br><span class="line">45.4.3 描述虚拟NFC标签的NFCTag类 714</span><br><span class="line">45.4.4 保证虚拟NFC标签的全局唯一 715</span><br><span class="line">45.4.5 显示与保存虚拟NFC标签 716</span><br><span class="line">45.4.6 装载已经存在的虚拟NFC标签 719</span><br><span class="line">45.4.7 开启服务 720</span><br><span class="line">45.4.8 处理客户端请求 721</span><br><span class="line">45.4.9 保证虚拟Android设备全局唯一 723</span><br><span class="line">45.4.10 描述虚拟Android设备 724</span><br><span class="line">45.4.11 添加虚拟Android设备 725</span><br><span class="line">45.4.12 异常处理机制 727</span><br><span class="line">45.5 客户端与服务端之间的数据管道（NFCManService） 728</span><br><span class="line">45.5.1 与NFCMan交互（Socket方式） 728</span><br><span class="line">45.5.2 与ANFCMan交互（广播方式） 732</span><br><span class="line">45.6 客户端Library（ANFCMan） 733</span><br><span class="line">45.6.1 ANFCMan的数据结构和异常类 733</span><br><span class="line">45.6.2 ANFCMan的入口类 734</span><br><span class="line">45.6.3 模拟检测到NFC标签的广播接收器 734</span><br><span class="line">45.6.4 同时处理物理NFC标签和虚拟NFC标签的窗口 735</span><br><span class="line">45.7 测试ANFCMan（TestANFCMan） 738</span><br><span class="line">45.8 小结 739</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00EOIDFX8/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00EOIDFX8&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41Fr4uV8OEL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android应用UI设计模式</title>
    <url>/2020/04/19/B00GU73RHA/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android应用UI设计模式<br>作者信息： 作者: 纳德尔曼 (Greg Nudelman) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>58个重要交互设计模式将扁平化设计理念发挥到极致，Android应用设计难题各个击破集各家操作系统（iOS、Windows Phone）之所长，将其绝妙理念融入Android交互设计多个试验模式和反模式帮助探索Android设计的前沿部分，避开设计误区，打破设计僵局</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分 用户体验原则和Android特色</span><br><span class="line">第1章 向Android迁移（案例）</span><br><span class="line">1.1 启动图标</span><br><span class="line">1.2 操作栏与信息架构</span><br><span class="line">1.2.1 重新设计前</span><br><span class="line">1.2.2 重新设计后</span><br><span class="line">1.3 选项卡</span><br><span class="line">1.4 专用选择页</span><br><span class="line">1.5 选择控件</span><br><span class="line">1.5.1 重新设计前</span><br><span class="line">1.5.2 重新设计后</span><br><span class="line">1.6 按钮</span><br><span class="line">1.7 搜索结果屏幕</span><br><span class="line">1.7.1 重新设计前</span><br><span class="line">1.7.2 重新设计后</span><br><span class="line">1.8 结果详情屏幕</span><br><span class="line">1.8.1 重新设计前</span><br><span class="line">1.8.2 重新设计后</span><br><span class="line">1.9 最终结果</span><br><span class="line">第2章 Android的特色</span><br><span class="line">2.1 这里是平面国</span><br><span class="line">2.2 轻按任何地方</span><br><span class="line">2.3 适合各种设备</span><br><span class="line">2.4 摆脱空间限制</span><br><span class="line">2.5 大局着眼，小处着手</span><br><span class="line">第3章 Android分散化</span><br><span class="line">3.1 何谓分散化</span><br><span class="line">3.2 花无百日红</span><br><span class="line">3.3 Android设备类型</span><br><span class="line">3.3.1 紧凑型手机</span><br><span class="line">3.3.2 全尺寸移动手机</span><br><span class="line">3.3.3 平板手机</span><br><span class="line">3.3.4 小型平板</span><br><span class="line">3.3.5 大型平板</span><br><span class="line">3.4 为分散化而歌</span><br><span class="line">第4章 移动设计流程</span><br><span class="line">4.1 现场观察用户如何与移动设备交互</span><br><span class="line">4.2 原型设计方法必须考虑尺寸因素</span><br><span class="line">4.3 用户测试必须涵盖运动、声音和多点触控等方面</span><br><span class="line">4.4 触控界面必须既简约又精巧</span><br><span class="line">4.5 愉悦不可或缺</span><br><span class="line">4.6 讲述完整的故事——为跨界而设计</span><br><span class="line">4.7 移动设计案例研究</span><br><span class="line">4.7.1 第1步：范围、概念和规划</span><br><span class="line">4.7.2 第2步：设计研讨会</span><br><span class="line">4.7.3 第3步：使用便利贴做RITE调查</span><br><span class="line">4.7.4 第4步：视觉设计</span><br><span class="line">第二部分 Android 设计模式与反模式</span><br><span class="line">第5章 欢迎体验</span><br><span class="line">5.1 最终用户许可协议（反模式）</span><br><span class="line">5.1.1 出现的时间和场合</span><br><span class="line">5.1.2 示例</span><br><span class="line">5.1.3 为何要避免</span><br><span class="line">5.1.4 其他考虑因素</span><br><span class="line">5.2 联系障碍（反模式）</span><br><span class="line">5.2.1 出现的时间和场合</span><br><span class="line">5.2.2 示例</span><br><span class="line">5.2.3 为何要避免</span><br><span class="line">5.2.4 其他考虑因素</span><br><span class="line">5.3 注册（反模式）</span><br><span class="line">5.3.1 出现的时间和场合</span><br><span class="line">5.3.2 示例</span><br><span class="line">5.3.3 为何要避免</span><br><span class="line">5.3.4 其他考虑因素</span><br><span class="line">5.4 欢迎动画</span><br><span class="line">5.4.1 工作原理</span><br><span class="line">5.4.2 示例</span><br><span class="line">5.4.3 使用的时机和场合</span><br><span class="line">5.4.4 使用的原因</span><br><span class="line">5.4.5 其他用途</span><br><span class="line">5.4.6 Pet Shop应用</span><br><span class="line">5.4.7 平板应用</span><br><span class="line">5.5 使用说明</span><br><span class="line">5.5.1 工作原理</span><br><span class="line">5.5.2 示例</span><br><span class="line">5.5.3 使用的时机和场合</span><br><span class="line">5.5.4 使用的原因</span><br><span class="line">5.5.5 其他用途</span><br><span class="line">5.5.6 Pet Shop应用</span><br><span class="line">5.5.7 平板应用</span><br><span class="line">第6章 主屏幕</span><br><span class="line">6.1 链接列表</span><br><span class="line">6.1.1 工作原理</span><br><span class="line">6.1.2 示例</span><br><span class="line">6.1.3 使用的时机和场合</span><br><span class="line">6.1.4 使用的原因</span><br><span class="line">6.1.5 其他用途</span><br><span class="line">6.1.6 Pet Shop应用</span><br><span class="line">6.1.7 平板应用</span><br><span class="line">6.2 仪表板</span><br><span class="line">6.2.1 工作原理</span><br><span class="line">6.2.2 示例</span><br><span class="line">6.2.3 使用的时机和场合</span><br><span class="line">6.2.4 使用的原因</span><br><span class="line">6.2.5 Pet Shop应用</span><br><span class="line">6.2.6 平板应用</span><br><span class="line">6.3 更新</span><br><span class="line">6.3.1 工作原理</span><br><span class="line">6.3.2 示例</span><br><span class="line">6.3.3 使用的时机和场合</span><br><span class="line">6.3.4 使用的原因</span><br><span class="line">6.3.5 其他用途</span><br><span class="line">6.3.6 Pet Shop应用</span><br><span class="line">6.3.7 平板应用</span><br><span class="line">6.4 浏览</span><br><span class="line">6.4.1 工作原理</span><br><span class="line">6.4.2 示例</span><br><span class="line">6.4.3 使用的时机和场合</span><br><span class="line">6.4.4 使用的原因</span><br><span class="line">6.4.5 其他用途</span><br><span class="line">6.4.6 Pet Shop应用</span><br><span class="line">6.4.7 平板应用</span><br><span class="line">6.5 地图</span><br><span class="line">6.5.1 工作原理</span><br><span class="line">6.5.2 示例</span><br><span class="line">6.5.3 使用的时机和场合</span><br><span class="line">6.5.4 使用的原因</span><br><span class="line">6.5.5 其他用途</span><br><span class="line">6.5.6 Pet Shop应用</span><br><span class="line">6.5.7 平板应用</span><br><span class="line">6.6 历史记录</span><br><span class="line">6.6.1 工作原理</span><br><span class="line">6.6.2 示例</span><br><span class="line">6.6.3 使用的时机和场合</span><br><span class="line">6.6.4 使用的原因</span><br><span class="line">6.6.5 其他用途</span><br><span class="line">6.6.6 Pet Shop应用</span><br><span class="line">6.6.7 平板应用</span><br><span class="line">第7章 搜索</span><br><span class="line">7.1 语音搜索</span><br><span class="line">7.1.1 工作原理</span><br><span class="line">7.1.2 示例</span><br><span class="line">7.1.3 使用的时机和场合</span><br><span class="line">7.1.4 使用的原因</span><br><span class="line">7.1.5 其他用途</span><br><span class="line">7.1.6 Pet Shop应用</span><br><span class="line">7.1.7 平板应用</span><br><span class="line">7.2 自动完成与自动建议</span><br><span class="line">7.2.1 工作原理</span><br><span class="line">7.2.2 示例</span><br><span class="line">7.2.3 使用的时机和场合</span><br><span class="line">7.2.4 使用的原因</span><br><span class="line">7.2.5 其他用途</span><br><span class="line">7.2.6 Pet Shop应用</span><br><span class="line">7.2.7 平板应用</span><br><span class="line">7.3 轻按优先</span><br><span class="line">7.3.1 工作原理</span><br><span class="line">7.3.2 示例</span><br><span class="line">7.3.3 使用的时机和场合</span><br><span class="line">7.3.4 使用的原因</span><br><span class="line">7.3.5 其他用途</span><br><span class="line">7.3.6 Pet Shop应用</span><br><span class="line">7.3.7 平板应用</span><br><span class="line">7.4 拖动刷新</span><br><span class="line">7.4.1 工作原理</span><br><span class="line">7.4.2 示例</span><br><span class="line">7.4.3 使用的时机和场合</span><br><span class="line">7.4.4 使用的原因</span><br><span class="line">7.4.5 其他用途</span><br><span class="line">7.4.6 Pet Shop应用</span><br><span class="line">7.4.7 平板应用</span><br><span class="line">7.5 从菜单搜索</span><br><span class="line">7.5.1 工作原理</span><br><span class="line">7.5.2 示例</span><br><span class="line">7.5.3 使用的时机和场合</span><br><span class="line">7.5.4 使用的原因</span><br><span class="line">7.5.5 其他用途</span><br><span class="line">7.5.6 Pet Shop应用</span><br><span class="line">7.5.7 平板应用</span><br><span class="line">7.6 从操作栏搜索</span><br><span class="line">7.6.1 工作原理</span><br><span class="line">7.6.2 示例</span><br><span class="line">7.6.3 使用的时机和场合</span><br><span class="line">7.6.4 使用的原因</span><br><span class="line">7.6.5 其他用途</span><br><span class="line">7.6.6 Pet Shop应用</span><br><span class="line">7.6.7 平板应用</span><br><span class="line">7.7 专用搜索</span><br><span class="line">7.7.1 工作原理</span><br><span class="line">7.7.2 示例</span><br><span class="line">7.7.3 使用的时机和场合</span><br><span class="line">7.7.4 使用的原因</span><br><span class="line">7.7.5 其他用途</span><br><span class="line">7.7.6 Pet Shop应用</span><br><span class="line">7.7.7 平板应用</span><br><span class="line">7.8 在内容页面中搜索</span><br><span class="line">7.8.1 工作原理</span><br><span class="line">7.8.2 示例</span><br><span class="line">7.8.3 使用的时机和场合</span><br><span class="line">7.8.4 使用的原因</span><br><span class="line">7.8.5 其他用途</span><br><span class="line">7.8.6 Pet Shop应用</span><br><span class="line">7.8.7 平板应用</span><br><span class="line">7.9 搜索与细化分离（反模式）</span><br><span class="line">7.9.1 出现的时间和场合</span><br><span class="line">7.9.2 示例</span><br><span class="line">7.9.3 为何要避免</span><br><span class="line">7.9.4 其他考虑因素</span><br><span class="line">第8章 排序和筛选</span><br><span class="line">8.1 残缺的细化（反模式）</span><br><span class="line">8.1.1 出现的时机和场合</span><br><span class="line">8.1.2 示例</span><br><span class="line">8.1.3 为何要避免</span><br><span class="line">8.2 细化页面</span><br><span class="line">8.2.1 工作原理</span><br><span class="line">8.2.2 示例</span><br><span class="line">8.2.3 使用的时机和场合</span><br><span class="line">8.2.4 使用的原因</span><br><span class="line">8.2.5 其他用途</span><br><span class="line">8.2.6 Pet Shop应用</span><br><span class="line">8.2.7 平板应用</span><br><span class="line">8.3 筛选带</span><br><span class="line">8.3.1 工作原理</span><br><span class="line">8.3.2 示例</span><br><span class="line">8.3.3 使用的时机和场合</span><br><span class="line">8.3.4 使用的原因</span><br><span class="line">8.3.5 其他用途</span><br><span class="line">8.3.6 Pet Shop应用</span><br><span class="line">8.3.7 平板应用</span><br><span class="line">8.4 并行架构</span><br><span class="line">8.4.1 工作原理</span><br><span class="line">8.4.2 示例</span><br><span class="line">8.4.3 使用的时机和场合</span><br><span class="line">8.4.4 使用的原因</span><br><span class="line">8.4.5 其他用途</span><br><span class="line">8.4.6 Pet Shop应用</span><br><span class="line">8.4.7 平板应用</span><br><span class="line">8.5 选项卡</span><br><span class="line">8.5.1 工作原理</span><br><span class="line">8.5.2 示例</span><br><span class="line">8.5.3 使用的时机和场合</span><br><span class="line">8.5.4 使用的原因</span><br><span class="line">8.5.5 其他用途</span><br><span class="line">8.5.6 Pet Shop应用</span><br><span class="line">8.5.7 平板应用</span><br><span class="line">第9章 避免无结果或无关结果</span><br><span class="line">9.1 不指出系统状态（反模式）</span><br><span class="line">9.1.1 出现的时机和场合</span><br><span class="line">9.1.2 示例</span><br><span class="line">9.1.3 为何要避免</span><br><span class="line">9.1.4 其他考虑因素</span><br><span class="line">9.2 低效界面（反模式）</span><br><span class="line">9.2.1 出现的时机和场合</span><br><span class="line">9.2.2 示例</span><br><span class="line">9.2.3 其他考虑因素</span><br><span class="line">9.3 无用控件（反模式）</span><br><span class="line">9.3.1 出现的时机和场合</span><br><span class="line">9.3.2 示例</span><br><span class="line">9.3.3 为何要避免</span><br><span class="line">9.4 你要找的是不是</span><br><span class="line">9.4.1 工作原理</span><br><span class="line">9.4.2 示例</span><br><span class="line">9.4.3 使用的时机和场合</span><br><span class="line">9.4.4 使用的原因</span><br><span class="line">9.4.5 其他用途</span><br><span class="line">9.4.6 Pet Shop应用</span><br><span class="line">9.4.7 平板应用</span><br><span class="line">9.5 部分匹配</span><br><span class="line">9.5.1 工作原理</span><br><span class="line">9.5.2 示例</span><br><span class="line">9.5.3 使用的时机和场合</span><br><span class="line">9.5.4 使用的原因</span><br><span class="line">9.5.5 其他用途</span><br><span class="line">9.5.6 Pet Shop应用</span><br><span class="line">9.5.7 平板应用</span><br><span class="line">9.6 本地结果</span><br><span class="line">9.6.1 工作原理</span><br><span class="line">9.6.2 示例</span><br><span class="line">9.6.3 使用的时机和场合</span><br><span class="line">9.6.4 使用的原因</span><br><span class="line">9.6.5 其他用途</span><br><span class="line">9.6.6 Pet Shop应用</span><br><span class="line">9.6.7 平板应用</span><br><span class="line">第10章 数据输入</span><br><span class="line">10.1 滑块</span><br><span class="line">10.1.1 工作原理</span><br><span class="line">10.1.2 示例</span><br><span class="line">10.1.3 使用的时机和场合</span><br><span class="line">10.1.4 使用的原因</span><br><span class="line">10.1.5 其他用途</span><br><span class="line">10.1.6 Pet Shop应用</span><br><span class="line">10.1.7 平板应用</span><br><span class="line">10.2 步进器</span><br><span class="line">10.2.1 工作原理</span><br><span class="line">10.2.2 示例</span><br><span class="line">10.2.3 使用的时机和场合</span><br><span class="line">10.2.4 使用的原因</span><br><span class="line">10.2.5 其他用途</span><br><span class="line">10.2.6 Pet Shop应用</span><br><span class="line">10.2.7 平板应用</span><br><span class="line">10.3 可滚动的日历</span><br><span class="line">10.3.1 工作原理</span><br><span class="line">10.3.2 示例</span><br><span class="line">10.3.3 使用的时机和场合</span><br><span class="line">10.3.4 使用的原因</span><br><span class="line">10.3.5 其他用途</span><br><span class="line">10.3.6 Pet Shop应用</span><br><span class="line">10.3.7 平板应用</span><br><span class="line">10.4 日期与时间选择器</span><br><span class="line">10.4.1 工作原理</span><br><span class="line">10.4.2 示例</span><br><span class="line">10.4.3 使用的时机和场合</span><br><span class="line">10.4.4 使用的原因</span><br><span class="line">10.4.5 其他用途</span><br><span class="line">10.4.6 Pet Shop应用</span><br><span class="line">10.4.7 平板应用</span><br><span class="line">10.5 下拉列表</span><br><span class="line">10.5.1 工作原理</span><br><span class="line">10.5.2 示例</span><br><span class="line">10.5.3 使用的时机和场合</span><br><span class="line">10.5.4 使用的原因</span><br><span class="line">10.5.5 其他用途</span><br><span class="line">10.5.6 Pet Shop应用</span><br><span class="line">10.5.7 平板应用</span><br><span class="line">10.6 多选</span><br><span class="line">10.6.1 工作原理</span><br><span class="line">10.6.2 示例</span><br><span class="line">10.6.3 使用的时机和场合</span><br><span class="line">10.6.4 使用的原因</span><br><span class="line">10.6.5 其他用途</span><br><span class="line">10.6.6 Pet Shop应用</span><br><span class="line">10.6.7 平板应用</span><br><span class="line">10.7 自由文本输入与提取</span><br><span class="line">10.7.1 工作原理</span><br><span class="line">10.7.2 示例</span><br><span class="line">10.7.3 使用的时机和场合</span><br><span class="line">10.7.4 使用的原因</span><br><span class="line">10.7.5 其他用途</span><br><span class="line">10.7.6 Pet Shop应用</span><br><span class="line">10.7.7 平板应用</span><br><span class="line">10.8 带输入掩码的文本框</span><br><span class="line">10.8.1 工作原理</span><br><span class="line">10.8.2 示例</span><br><span class="line">10.8.3 使用的时机和场合</span><br><span class="line">10.8.4 使用的原因</span><br><span class="line">10.8.5 其他用途</span><br><span class="line">10.8.6 Pet Shop应用</span><br><span class="line">10.8.7 平板应用</span><br><span class="line">10.9 带原子实体的文本框</span><br><span class="line">10.9.1 工作原理</span><br><span class="line">10.9.2 示例</span><br><span class="line">10.9.3 使用的时机和场合</span><br><span class="line">10.9.4 使用的原因</span><br><span class="line">10.9.5 其他用途</span><br><span class="line">10.9.6 Pet Shop应用</span><br><span class="line">10.9.7 平板应用</span><br><span class="line">第11章 表单</span><br><span class="line">11.1 内嵌式错误消息</span><br><span class="line">11.1.1 工作原理</span><br><span class="line">11.1.2 示例</span><br><span class="line">11.1.3 使用的时机和场合</span><br><span class="line">11.1.4 使用的原因</span><br><span class="line">11.1.5 其他用途</span><br><span class="line">11.1.6 Pet Shop应用</span><br><span class="line">11.1.7 平板应用</span><br><span class="line">11.2 提示框</span><br><span class="line">11.2.1 工作原理</span><br><span class="line">11.2.2 示例</span><br><span class="line">11.2.3 使用的时机和场合</span><br><span class="line">11.2.4 使用的原因</span><br><span class="line">11.2.5 其他用途</span><br><span class="line">11.2.6 Pet Shop应用</span><br><span class="line">11.2.7 平板应用</span><br><span class="line">11.3 弹出框</span><br><span class="line">11.3.1 工作原理</span><br><span class="line">11.3.2 示例</span><br><span class="line">11.3.3 使用的时机和场合</span><br><span class="line">11.3.4 使用的原因</span><br><span class="line">11.3.5 其他用途</span><br><span class="line">11.3.6 Pet Shop应用</span><br><span class="line">11.3.7 平板应用</span><br><span class="line">11.4 回调验证</span><br><span class="line">11.4.1 工作原理</span><br><span class="line">11.4.2 示例</span><br><span class="line">11.4.3 使用的时机和场合</span><br><span class="line">11.4.4 使用的原因</span><br><span class="line">11.4.5 其他用途</span><br><span class="line">11.4.6 Pet Shop应用</span><br><span class="line">11.4.7 平板应用</span><br><span class="line">11.5 取消∕确定</span><br><span class="line">11.5.1 工作原理</span><br><span class="line">11.5.2 示例</span><br><span class="line">11.5.3 使用的时机和场合</span><br><span class="line">11.5.4 使用的原因</span><br><span class="line">11.5.5 其他用途</span><br><span class="line">11.5.6 Pet Shop应用</span><br><span class="line">11.5.7 平板应用</span><br><span class="line">11.6 上方标签</span><br><span class="line">11.6.1 工作原理</span><br><span class="line">11.6.2 示例</span><br><span class="line">11.6.3 使用的时机和场合</span><br><span class="line">11.6.4 使用的原因</span><br><span class="line">11.6.5 其他用途</span><br><span class="line">11.6.6 Pet Shop应用</span><br><span class="line">11.6.7 平板应用</span><br><span class="line">11.7 从环境获取输入</span><br><span class="line">11.7.1 工作原理</span><br><span class="line">11.7.2 示例</span><br><span class="line">11.7.3 使用的时机和场合</span><br><span class="line">11.7.4 使用的原因</span><br><span class="line">11.7.5 其他用途</span><br><span class="line">11.7.6 Pet Shop应用</span><br><span class="line">11.7.7 平板应用</span><br><span class="line">11.8 输入加速</span><br><span class="line">11.8.1 工作原理</span><br><span class="line">11.8.2 示例</span><br><span class="line">11.8.3 使用的时机和场合</span><br><span class="line">11.8.4 使用的原因</span><br><span class="line">11.8.5 其他用途</span><br><span class="line">11.8.6 Pet Shop应用</span><br><span class="line">11.8.7 平板应用</span><br><span class="line">第12章 移动银行</span><br><span class="line">12.1 登录加速器</span><br><span class="line">12.1.1 工作原理</span><br><span class="line">12.1.2 示例</span><br><span class="line">12.1.3 使用的时机和场合</span><br><span class="line">12.1.4 使用的原因</span><br><span class="line">12.1.5 其他用途</span><br><span class="line">12.1.6 Pet Shop应用</span><br><span class="line">12.1.7 平板应用</span><br><span class="line">12.2 专用选择页面</span><br><span class="line">12.2.1 工作原理</span><br><span class="line">12.2.2 示例</span><br><span class="line">12.2.3 使用的时机和场合</span><br><span class="line">12.2.4 使用的原因</span><br><span class="line">12.2.5 其他用途</span><br><span class="line">12.2.6 Pet Shop应用</span><br><span class="line">12.2.7 平板应用</span><br><span class="line">12.3 表单至上</span><br><span class="line">12.3.1 工作原理</span><br><span class="line">12.3.2 示例</span><br><span class="line">12.3.3 使用的时机和场合</span><br><span class="line">12.3.4 使用的原因</span><br><span class="line">12.3.5 其他用途</span><br><span class="line">12.3.6 Pet Shop应用</span><br><span class="line">12.3.7 平板应用</span><br><span class="line">12.4 专用页面向导</span><br><span class="line">12.4.1 工作原理</span><br><span class="line">12.4.2 示例</span><br><span class="line">12.4.3 使用的时机和场合</span><br><span class="line">12.4.4 使用的原因</span><br><span class="line">12.4.5 其他用途</span><br><span class="line">12.4.6 Pet Shop应用</span><br><span class="line">12.4.7 平板应用</span><br><span class="line">12.5 以表单结尾的向导</span><br><span class="line">12.5.1 工作原理</span><br><span class="line">12.5.2 示例</span><br><span class="line">12.5.3 使用的时机和场合</span><br><span class="line">12.5.4 使用的原因</span><br><span class="line">12.5.5 其他用途</span><br><span class="line">12.5.6 Pet Shop应用</span><br><span class="line">12.5.7 平板应用</span><br><span class="line">12.6 核对？确认</span><br><span class="line">12.6.1 工作原理</span><br><span class="line">12.6.2 示例</span><br><span class="line">12.6.3 使用的时机和场合</span><br><span class="line">12.6.4 使用的原因</span><br><span class="line">12.6.5 其他用途</span><br><span class="line">12.6.6 Pet Shop应用</span><br><span class="line">12.6.7 平板应用</span><br><span class="line">12.7 近场通信</span><br><span class="line">12.7.1 工作原理</span><br><span class="line">12.7.2 示例</span><br><span class="line">12.7.3 使用的时机和场合</span><br><span class="line">12.7.4 使用的原因</span><br><span class="line">12.7.5 其他用途</span><br><span class="line">12.7.6 Pet Shop应用</span><br><span class="line">12.7.7 平板应用</span><br><span class="line">第13章 导航</span><br><span class="line">13.1 上窜下跳（反模式）</span><br><span class="line">13.1.1 出现的时间和场合</span><br><span class="line">13.1.2 示例</span><br><span class="line">13.1.3 为何要避免</span><br><span class="line">13.1.4 其他考虑因素</span><br><span class="line">13.1.5 出现的时间和场合</span><br><span class="line">13.2 多个推荐区域（反模式）</span><br><span class="line">13.2.1 出现的时间和场合</span><br><span class="line">13.2.2 示例</span><br><span class="line">13.2.3 为何要避免</span><br><span class="line">13.2.4 其他考虑因素</span><br><span class="line">13.3 轮播</span><br><span class="line">13.3.1 工作原理</span><br><span class="line">13.3.2 示例</span><br><span class="line">13.3.3 使用的时机和场合</span><br><span class="line">13.3.4 使用的原因</span><br><span class="line">13.3.5 其他用途</span><br><span class="line">13.3.6 Pet Shop应用</span><br><span class="line">13.3.7 平板应用</span><br><span class="line">13.4 弹出式菜单</span><br><span class="line">13.4.1 工作原理</span><br><span class="line">13.4.2 示例</span><br><span class="line">13.4.3 使用的时机和场合</span><br><span class="line">13.4.4 使用的原因</span><br><span class="line">13.4.5 其他用途</span><br><span class="line">13.4.6 Pet Shop应用</span><br><span class="line">13.4.7 平板应用</span><br><span class="line">13.5 水印</span><br><span class="line">13.5.1 工作原理</span><br><span class="line">13.5.2 示例</span><br><span class="line">13.5.3 使用的时机和场合</span><br><span class="line">13.5.4 使用的原因</span><br><span class="line">13.5.5 其他用途</span><br><span class="line">13.5.6 Pet Shop应用</span><br><span class="line">13.5.7 平板应用</span><br><span class="line">13.6 瑞士军刀导航</span><br><span class="line">13.6.1 工作原理</span><br><span class="line">13.6.2 示例</span><br><span class="line">13.6.3 使用的时机和场合</span><br><span class="line">13.6.4 使用的原因</span><br><span class="line">13.6.5 其他用途</span><br><span class="line">13.6.6 Pet Shop应用</span><br><span class="line">13.6.7 平板应用</span><br><span class="line">13.7 集成</span><br><span class="line">13.7.1 工作原理</span><br><span class="line">13.7.2 示例</span><br><span class="line">13.7.3 使用的时机和场合</span><br><span class="line">13.7.4 使用的原因</span><br><span class="line">13.7.5 其他用途</span><br><span class="line">13.7.6 Pet Shop应用</span><br><span class="line">13.7.7 平板应用</span><br><span class="line">第14章 平板模式</span><br><span class="line">14.1 片段</span><br><span class="line">14.1.1 工作原理</span><br><span class="line">14.1.2 示例</span><br><span class="line">14.1.3 使用的时机和场合</span><br><span class="line">14.1.4 使用的原因</span><br><span class="line">14.1.5 其他用途</span><br><span class="line">14.2 复合视图</span><br><span class="line">14.2.1 工作原理</span><br><span class="line">14.2.2 示例</span><br><span class="line">14.2.3 使用的时机和场合</span><br><span class="line">14.2.4 使用的原因</span><br><span class="line">14.2.5 其他用途</span><br><span class="line">14.3 侧面导航（试验模式）</span><br><span class="line">14.3.1 工作原理</span><br><span class="line">14.3.2 示例</span><br><span class="line">14.3.3 使用的时机和场合</span><br><span class="line">14.3.4 使用的原因</span><br><span class="line">14.3.5 其他用途</span><br><span class="line">14.4 将内容用作导航元素</span><br><span class="line">14.4.1 工作原理</span><br><span class="line">14.4.2 示例</span><br><span class="line">14.4.3 使用的时机和场合</span><br><span class="line">14.4.4 使用的原因</span><br><span class="line">14.4.5 其他用途</span><br><span class="line">14.5 二维更多类似</span><br><span class="line">14.5.1 工作原理</span><br><span class="line">14.5.2 示例</span><br><span class="line">14.5.3 使用的时机和场合</span><br><span class="line">14.5.4 使用的原因</span><br><span class="line">14.5.5 其他用途</span><br><span class="line">14.6 C形轻扫（试验模式）</span><br><span class="line">14.6.1 工作原理</span><br><span class="line">14.6.2 示例</span><br><span class="line">14.6.3 使用的时机和场合</span><br><span class="line">14.6.4 使用的原因</span><br><span class="line">14.6.5 其他用途</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00GU73RHA/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00GU73RHA&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41fMYcrGNML._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言入门经典(第5版)</title>
    <url>/2020/04/19/B00GYLA7O8/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C语言入门经典(第5版)<br>作者信息： 作者: I.) 霍尔顿 (Horton [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>编程导师Ivor Horton经典巨作，长期位居C语言开发类零售榜首，第五版全新包装隆重上市，超高的性价比助你快速掌握C语言，提升您的编程技能；完善您的职业生涯</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目    录</span><br><span class="line">第1章  C语言编程 1</span><br><span class="line">1.1  C语言 1</span><br><span class="line">1.2  标准库 2</span><br><span class="line">1.3  学习C 2</span><br><span class="line">1.4  创建C程序 2</span><br><span class="line">1.4.1  编辑 2</span><br><span class="line">1.4.2  编译 3</span><br><span class="line">1.4.3  链接 4</span><br><span class="line">1.4.4  执行 4</span><br><span class="line">1.5  创建第一个程序 5</span><br><span class="line">1.6  编辑第一个程序 5</span><br><span class="line">1.7  处理错误 6</span><br><span class="line">1.8  剖析一个简单的程序 7</span><br><span class="line">1.8.1  注释 7</span><br><span class="line">1.8.2  预处理指令 8</span><br><span class="line">1.8.3  定义main()函数 9</span><br><span class="line">1.8.4  关键字 10</span><br><span class="line">1.8.5  函数体 10</span><br><span class="line">1.8.6  输出信息 11</span><br><span class="line">1.8.7  参数 11</span><br><span class="line">1.8.8  控制符 11</span><br><span class="line">1.8.9  三字母序列 13</span><br><span class="line">1.9  预处理器 14</span><br><span class="line">1.10  用C语言开发程序 14</span><br><span class="line">1.10.1  了解问题 14</span><br><span class="line">1.10.2  详细设计 15</span><br><span class="line">1.10.3  实施 15</span><br><span class="line">1.10.4  测试 15</span><br><span class="line">1.11  函数及模块化编程 16</span><br><span class="line">1.12  常见错误 19</span><br><span class="line">1.13  要点 19</span><br><span class="line">1.14  小结 20</span><br><span class="line">1.15  习题 20</span><br><span class="line">第2章  编程初步 21</span><br><span class="line">2.1  计算机的内存 21</span><br><span class="line">2.2  什么是变量 23</span><br><span class="line">2.3  存储整数的变量 24</span><br><span class="line">2.3.1  变量的使用 28</span><br><span class="line">2.3.2  变量的初始化 29</span><br><span class="line">2.4  变量与内存 36</span><br><span class="line">2.4.1  带符号的整数类型 36</span><br><span class="line">2.4.2  无符号的整数类型 37</span><br><span class="line">2.4.3  指定整数常量 37</span><br><span class="line">2.5  使用浮点数 39</span><br><span class="line">2.6  浮点数变量 41</span><br><span class="line">2.6.1  使用浮点数完成除法运算 42</span><br><span class="line">2.6.2  控制输出中的小数位数 43</span><br><span class="line">2.6.3  控制输出的字段宽度 43</span><br><span class="line">2.7  较复杂的表达式 44</span><br><span class="line">2.8  定义命名常量 46</span><br><span class="line">2.8.1  极限值 49</span><br><span class="line">2.8.2  sizeof运算符 51</span><br><span class="line">2.9  选择正确的类型 52</span><br><span class="line">2.10  强制类型转换 55</span><br><span class="line">2.10.1  自动转换类型 56</span><br><span class="line">2.10.2  隐式类型转换的规则 56</span><br><span class="line">2.10.3  赋值语句中的隐式类型转换 57</span><br><span class="line">2.11  再谈数值数据类型 58</span><br><span class="line">2.11.1  字符类型 58</span><br><span class="line">2.11.2  字符的输入输出 59</span><br><span class="line">2.11.3  枚举 62</span><br><span class="line">2.11.4  存储布尔值的变量 64</span><br><span class="line">2.12  赋值操作的op&#x3D;形式 65</span><br><span class="line">2.13  数学函数 66</span><br><span class="line">2.14  设计一个程序 67</span><br><span class="line">2.14.1  问题 68</span><br><span class="line">2.14.2  分析 68</span><br><span class="line">2.14.3  解决方案 70</span><br><span class="line">2.15  小结 73</span><br><span class="line">2.16  练习 74</span><br><span class="line">第3章  条件判断 75</span><br><span class="line">3.1  判断过程 75</span><br><span class="line">3.1.1  算术比较 75</span><br><span class="line">3.1.2  基本的if语句 76</span><br><span class="line">3.1.3  扩展if语句：if-else 79</span><br><span class="line">3.1.4  在if语句中使用代码块 82</span><br><span class="line">3.1.5  嵌套的if语句 83</span><br><span class="line">3.1.6  测试字符 85</span><br><span class="line">3.1.7  逻辑运算符 88</span><br><span class="line">3.1.8  条件运算符 91</span><br><span class="line">3.1.9  运算符的优先级 94</span><br><span class="line">3.2  多项选择问题 98</span><br><span class="line">3.2.1  给多项选择使用else-if语句 98</span><br><span class="line">3.2.2  switch语句 99</span><br><span class="line">3.2.3  goto语句 107</span><br><span class="line">3.3  按位运算符 108</span><br><span class="line">3.3.1  按位运算符的op&#x3D;用法 110</span><br><span class="line">3.3.2  使用按位运算符 111</span><br><span class="line">3.4  设计程序 114</span><br><span class="line">3.4.1  问题 114</span><br><span class="line">3.4.2  分析 114</span><br><span class="line">3.4.3  解决方案 114</span><br><span class="line">3.5  小结 118</span><br><span class="line">3.6  练习 118</span><br><span class="line">第4章  循环 119</span><br><span class="line">4.1  循环 119</span><br><span class="line">4.2  递增和递减运算符 120</span><br><span class="line">4.3  for循环 120</span><br><span class="line">4.4  for循环的一般语法 124</span><br><span class="line">4.5  再谈递增和递减运算符 125</span><br><span class="line">4.5.1  递增运算符 125</span><br><span class="line">4.5.2  递增运算符的前置和后置形式 125</span><br><span class="line">4.5.3  递减运算符 126</span><br><span class="line">4.6  再论for循环 127</span><br><span class="line">4.6.1  修改for循环变量 129</span><br><span class="line">4.6.2  没有参数的for循环 129</span><br><span class="line">4.6.3  循环内的break语句 130</span><br><span class="line">4.6.4  使用for循环限制输入 132</span><br><span class="line">4.6.5  生成伪随机整数 135</span><br><span class="line">4.6.6  再谈循环控制选项 137</span><br><span class="line">4.6.7  浮点类型的循环控制变量 137</span><br><span class="line">4.7  while循环 138</span><br><span class="line">4.8  嵌套循环 140</span><br><span class="line">4.9  嵌套循环和goto语句 146</span><br><span class="line">4.10  do-while循环 147</span><br><span class="line">4.11  continue语句 149</span><br><span class="line">4.12  设计程序 150</span><br><span class="line">4.12.1  问题 150</span><br><span class="line">4.12.2  分析 150</span><br><span class="line">4.12.3  解决方案 151</span><br><span class="line">4.13  小结 162</span><br><span class="line">4.14  习题 163</span><br><span class="line">第5章  数组 165</span><br><span class="line">5.1  数组简介 165</span><br><span class="line">5.1.1  不用数组的程序 165</span><br><span class="line">5.1.2  什么是数组 167</span><br><span class="line">5.1.3  使用数组 168</span><br><span class="line">5.2  寻址运算符 171</span><br><span class="line">5.3  数组和地址 173</span><br><span class="line">5.4  数组的初始化 174</span><br><span class="line">5.5  确定数组的大小 175</span><br><span class="line">5.6  多维数组 176</span><br><span class="line">5.7  多维数组的初始化 178</span><br><span class="line">5.8  变长数组 184</span><br><span class="line">5.9  设计一个程序 186</span><br><span class="line">5.9.1  问题 186</span><br><span class="line">5.9.2  分析 186</span><br><span class="line">5.9.3  解决方案 187</span><br><span class="line">5.10  小结 193</span><br><span class="line">5.11  习题 193</span><br><span class="line">第6章  字符串和文本的应用 195</span><br><span class="line">6.1  什么是字符串 195</span><br><span class="line">6.2  存储字符串的变量 197</span><br><span class="line">6.3  字符串操作 202</span><br><span class="line">6.3.1  检查对C11的支持 202</span><br><span class="line">6.3.2  确定字符串的长度 203</span><br><span class="line">6.3.3  复制字符串 204</span><br><span class="line">6.3.4  连接字符串 204</span><br><span class="line">6.3.5  比较字符串 208</span><br><span class="line">6.3.6  搜索字符串 211</span><br><span class="line">6.3.7  单元化字符串 215</span><br><span class="line">6.3.8  将换行符读入字符串 219</span><br><span class="line">6.4  分析和转换字符串 221</span><br><span class="line">6.4.1  转换字符的大小写形式 223</span><br><span class="line">6.4.2  将字符串转换成数值 225</span><br><span class="line">6.5  设计一个程序 227</span><br><span class="line">6.5.1  问题 227</span><br><span class="line">6.5.2  分析 227</span><br><span class="line">6.5.3  解决方案 228</span><br><span class="line">6.6  小结 233</span><br><span class="line">6.7  习题 233</span><br><span class="line">第7章  指针 235</span><br><span class="line">7.1  指针初探 235</span><br><span class="line">7.1.1  声明指针 236</span><br><span class="line">7.1.2  通过指针访问值 237</span><br><span class="line">7.1.3  使用指针 240</span><br><span class="line">7.1.4  指向常量的指针 244</span><br><span class="line">7.1.5  常量指针 244</span><br><span class="line">7.1.6  指针的命名 245</span><br><span class="line">7.2  数组和指针 245</span><br><span class="line">7.3  多维数组 248</span><br><span class="line">7.3.1  多维数组和指针 252</span><br><span class="line">7.3.2  访问数组元素 253</span><br><span class="line">7.4  内存的使用 256</span><br><span class="line">7.4.1  动态内存分配：malloc()函数 256</span><br><span class="line">7.4.2  释放动态分配的内存 257</span><br><span class="line">7.4.3  用calloc()函数分配内存 261</span><br><span class="line">7.4.4  扩展动态分配的内存 262</span><br><span class="line">7.5  使用指针处理字符串 265</span><br><span class="line">7.5.1  使用指针数组 266</span><br><span class="line">7.5.2  指针和数组记号 272</span><br><span class="line">7.6  设计程序 276</span><br><span class="line">7.6.1  问题 276</span><br><span class="line">7.6.2  分析 277</span><br><span class="line">7.6.3  解决方案 277</span><br><span class="line">7.7  小结 284</span><br><span class="line">7.8  习题 285</span><br><span class="line">第8章  编程的结构 287</span><br><span class="line">8.1  程序的结构 287</span><br><span class="line">8.1.1  变量的作用域和生存期 288</span><br><span class="line">8.1.2  变量的作用域和函数 291</span><br><span class="line">8.2  函数 291</span><br><span class="line">8.2.1  定义函数 291</span><br><span class="line">8.2.2  return语句 294</span><br><span class="line">8.3  按值传递机制 299</span><br><span class="line">8.4  函数原型 300</span><br><span class="line">8.5  指针用作参数和返回值 301</span><br><span class="line">8.5.1  常量参数 302</span><br><span class="line">8.5.2  返回指针的风险 307</span><br><span class="line">8.6  小结 310</span><br><span class="line">8.7  习题 310</span><br><span class="line">第9章  函数再探 313</span><br><span class="line">9.1  函数指针 313</span><br><span class="line">9.1.1  声明函数指针 313</span><br><span class="line">9.1.2  通过函数指针调用函数 314</span><br><span class="line">9.1.3  函数指针的数组 316</span><br><span class="line">9.1.4  作为变元的函数指针 319</span><br><span class="line">9.2  函数中的变量 321</span><br><span class="line">9.2.1  静态变量：函数内部的追踪 321</span><br><span class="line">9.2.2  在函数之间共享变量 323</span><br><span class="line">9.3  调用自己的函数：递归 325</span><br><span class="line">9.4  变元个数可变的函数 328</span><br><span class="line">9.4.1  复制va_list 331</span><br><span class="line">9.4.2  长度可变的变元列表的基本规则 331</span><br><span class="line">9.5  main()函数 332</span><br><span class="line">9.6  结束程序 333</span><br><span class="line">9.6.1  abort()函数 333</span><br><span class="line">9.6.2  exit()和atexit()函数 333</span><br><span class="line">9.6.3  Exit()函数 334 9.6.4 quick_exit()和at_quick_exit()函数 334 9.7 提高性能 335 9.7.1 内联声明函数 335 9.7.2 使用restrict关键字 335 9.7.3 Noreturn函数限定符 336</span><br><span class="line">9.8  设计程序 336</span><br><span class="line">9.8.1  问题 336</span><br><span class="line">9.8.2  分析 337</span><br><span class="line">9.8.3  解决方案 338</span><br><span class="line">9.9  小结 351</span><br><span class="line">9.10  习题 352</span><br><span class="line">第10章  基本输入和输出操作 353</span><br><span class="line">10.1  输入和输出流 353</span><br><span class="line">10.2  标准流 354</span><br><span class="line">10.3  键盘输入 354</span><br><span class="line">10.3.1  格式化键盘输入 355</span><br><span class="line">10.3.2  输入格式控制字符串 355</span><br><span class="line">10.3.3  输入格式字符串中的字符 360</span><br><span class="line">10.3.4  输入浮点数的各种变化 362</span><br><span class="line">10.3.5  读取十六进制和八进制值 363</span><br><span class="line">10.3.6  用scanf_s()读取字符 364</span><br><span class="line">10.3.7  从键盘上输入字符串 366</span><br><span class="line">10.3.8  单个字符的键盘输入 367</span><br><span class="line">10.4  屏幕输出 372</span><br><span class="line">10.4.1  使用printf_s()的格式化输出 372</span><br><span class="line">10.4.2  转义序列 375</span><br><span class="line">10.4.3  整数输出 375</span><br><span class="line">10.4.4  输出浮点数 378</span><br><span class="line">10.4.5  字符输出 379</span><br><span class="line">10.5  其他输出函数 380</span><br><span class="line">10.5.1  屏幕的非格式化输出 381</span><br><span class="line">10.5.2  数组的格式化输出 381</span><br><span class="line">10.5.3  数组的格式化输入 382</span><br><span class="line">10.6  小结 382</span><br><span class="line">10.7  习题 383</span><br><span class="line">第11章  结构化数据 385</span><br><span class="line">11.1  数据结构：使用struct 385</span><br><span class="line">11.1.1  定义结构类型和结构变量 387</span><br><span class="line">11.1.2  访问结构成员 388</span><br><span class="line">11.1.3  未命名的结构 390</span><br><span class="line">11.1.4  结构数组 391</span><br><span class="line">11.1.5  表达式中的结构成员 393</span><br><span class="line">11.1.6  结构指针 393</span><br><span class="line">11.1.7  为结构动态分配内存 394</span><br><span class="line">11.2  再探结构成员 397</span><br><span class="line">11.2.1  将一个结构作为另一个结构的成员 397</span><br><span class="line">11.2.2  声明结构中的结构 398</span><br><span class="line">11.2.3  将结构指针用作结构成员 399</span><br><span class="line">11.2.4  双向链表 403</span><br><span class="line">11.2.5  结构中的位字段 406</span><br><span class="line">11.3  结构与函数 407</span><br><span class="line">11.3.1  结构作为函数的变元 407</span><br><span class="line">11.3.2  结构指针作为函数变元 408</span><br><span class="line">11.3.3  作为函数返回值的结构 409</span><br><span class="line">11.3.4  二叉树 414</span><br><span class="line">11.4  共享内存 421</span><br><span class="line">11.5  设计程序 425</span><br><span class="line">11.5.1  问题 425</span><br><span class="line">11.5.2  分析 426</span><br><span class="line">11.5.3  解决方案 426</span><br><span class="line">11.6  小结 438</span><br><span class="line">11.7  习题 438</span><br><span class="line">第12章  处理文件 441</span><br><span class="line">12.1  文件的概念 441</span><br><span class="line">12.1.1  文件中的位置 442</span><br><span class="line">12.1.2  文件流 442</span><br><span class="line">12.2  文件访问 442</span><br><span class="line">12.2.1  打开文件 443</span><br><span class="line">12.2.2  缓存文件操作 445</span><br><span class="line">12.2.3  文件重命名 446</span><br><span class="line">12.2.4  关闭文件 447</span><br><span class="line">12.2.5  删除文件 447</span><br><span class="line">12.3  写入文本文件 448</span><br><span class="line">12.4  读取文本文件 449</span><br><span class="line">12.5  在文本文件中读写字符串 452</span><br><span class="line">12.6  格式化文件的输入输出 456</span><br><span class="line">12.6.1  格式化文件输出 456</span><br><span class="line">12.6.2  格式化文件输入 457</span><br><span class="line">12.7  错误处理 459</span><br><span class="line">12.8  再探文本文件操作模式 460</span><br><span class="line">12.9  freopen_s()函数 461</span><br><span class="line">12.10  二进制文件的输入输出 462</span><br><span class="line">12.10.1  以二进制模式打开文件 462</span><br><span class="line">12.10.2  写入二进制文件 463</span><br><span class="line">12.10.3  读取二进制文件 464</span><br><span class="line">12.11  在文件中移动 469</span><br><span class="line">12.11.1  文件定位操作 469</span><br><span class="line">12.11.2  找出我们在文件中的位置 470</span><br><span class="line">12.11.3  在文件中设定位置 471</span><br><span class="line">12.12  使用临时文件 477</span><br><span class="line">12.12.1  创建临时文件 477</span><br><span class="line">12.12.2  创建唯一的文件名 478</span><br><span class="line">12.13  更新二进制文件 479</span><br><span class="line">12.13.1  修改文件的内容 484</span><br><span class="line">12.13.2  从键盘输入创建记录 485</span><br><span class="line">12.13.3  将记录写入文件 486</span><br><span class="line">12.13.4  从文件中读取记录 486</span><br><span class="line">12.13.5  写入文件 487</span><br><span class="line">12.13.6  列出文件内容 488</span><br><span class="line">12.13.7  更新已有的文件内容 489</span><br><span class="line">12.14  文件打开模式小结 495</span><br><span class="line">12.15  设计程序 496</span><br><span class="line">12.15.1  问题 496</span><br><span class="line">12.15.2  分析 496</span><br><span class="line">12.15.3  解决方案 496</span><br><span class="line">12.16  小结 501</span><br><span class="line">12.17  习题 501</span><br><span class="line">第13章  支持功能 503</span><br><span class="line">13.1  预处理 503</span><br><span class="line">13.1.1  在程序中包含头文件 503</span><br><span class="line">13.1.2  定义自己的头文件 504</span><br><span class="line">13.1.3  管理多个源文件 504</span><br><span class="line">13.1.4  外部变量 505</span><br><span class="line">13.1.5  静态函数 505</span><br><span class="line">13.1.6  替换程序源代码 506</span><br><span class="line">13.2  宏 507</span><br><span class="line">13.2.1  看起来像函数的宏 507</span><br><span class="line">13.2.2  字符串作为宏参数 509</span><br><span class="line">13.2.3  在宏展开式中结合两个变元 510</span><br><span class="line">13.3  多行上的预处理器指令 510</span><br><span class="line">13.3.1  预处理器逻辑指令 511</span><br><span class="line">13.3.2  条件编译 511</span><br><span class="line">13.3.3  测试多个条件 512</span><br><span class="line">13.3.4  取消定义的标识符 512</span><br><span class="line">13.3.5  测试标识符的指定值的指令 512</span><br><span class="line">13.3.6  多项选择 513</span><br><span class="line">13.3.7  标准预处理宏 514</span><br><span class="line">13.4  调试方法 515</span><br><span class="line">13.4.1  集成的调试器 515</span><br><span class="line">13.4.2  调试阶段的预处理器 515</span><br><span class="line">13.4.3  断言 519</span><br><span class="line">13.5  日期和时间函数 521</span><br><span class="line">13.5.1  获取时间值 522</span><br><span class="line">13.5.2  获取日期 525</span><br><span class="line">13.5.3  确定某一天是星期几 529</span><br><span class="line">13.6  小结 531</span><br><span class="line">13.7  习题 531</span><br><span class="line">第14章  高级专用主题 533</span><br><span class="line">14.1  使用国际字符集 533</span><br><span class="line">14.1.1  理解Unicode 533</span><br><span class="line">14.1.2  设置区域 534</span><br><span class="line">14.1.3  宽字符类型wchar_t 535</span><br><span class="line">14.1.4  宽字符串的操作 537</span><br><span class="line">14.1.5  宽字符的文件流操作 540</span><br><span class="line">14.1.6  存储Unicode字符的固定大小类型 541</span><br><span class="line">14.2  用于可移植性的专用整数类型 545</span><br><span class="line">14.2.1  固定宽度的整型 545</span><br><span class="line">14.2.2  最小宽度的整型 545</span><br><span class="line">14.2.3  最大宽度的整型 546</span><br><span class="line">14.3  复数类型 546</span><br><span class="line">14.3.1  复数基础 546</span><br><span class="line">14.3.2  复数类型和操作 547</span><br><span class="line">14.4  用线程编程 550</span><br><span class="line">14.4.1  创建线程 550</span><br><span class="line">14.4.2  退出线程 551</span><br><span class="line">14.4.3  把一个线程连接到另一个线程上 552</span><br><span class="line">14.4.4  挂起线程 555</span><br><span class="line">14.4.5  管理线程对数据的访问 555</span><br><span class="line">14.5  小结 561</span><br><span class="line">附录A  计算机中的数学知识 563</span><br><span class="line">附录B  ASCII字符代码定义 571</span><br><span class="line">附录C  C语言中的保留字 575</span><br><span class="line">附录D  输入输出格式说明符 577</span><br><span class="line">附录E  标准库头文件 583</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00GYLA7O8/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00GYLA7O8&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51fD0hTgOAL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>学习使用C指针(英文本)</title>
    <url>/2020/04/19/B00H93ETKS/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 学习使用C指针(英文本)<br>作者信息： 作者: 雷斯 (Richard Reese) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>通过对C指针和内存管理的扎实理解来提高你的编程技能。在《学习使用C指针》这本贴合实际的书籍里，你将了解到指针是如何提供了相应的机制来动态操纵内存，增强对数据结构的支持，允许直接访问硬件。作者Richard Reese(雷斯)通过本书中的内存模型为你展示了如何在数组、字符串、结构和函数中使用指针。    虽然难以掌握，但是指针为C语言提供了灵活性和强大能力，不过很少有资料来讲述这种数据类型。无论你是初学者还是有经验的C或者C++编程人员和开发者，这本详尽的书籍都有着你所需要的知识。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Preface</span><br><span class="line">1.Introduction</span><br><span class="line">Pointers and Memory</span><br><span class="line">Why You Should Become Proficient with Pointers</span><br><span class="line">Declaring Pointers</span><br><span class="line">How to Read a Declaration</span><br><span class="line">Address of Operator</span><br><span class="line">Displaying Pointer Values</span><br><span class="line">Dereferencing a Pointer Using the Indirection Operator</span><br><span class="line">Pointers to Functions</span><br><span class="line">The Concept of Null</span><br><span class="line">Pointer Size and Types</span><br><span class="line">Memory Models</span><br><span class="line">Predefined Pointer—Related Types</span><br><span class="line">Pointer Operators</span><br><span class="line">Pointer Arithmetic</span><br><span class="line">Comparing Pointers</span><br><span class="line">Common Uses of Pointers</span><br><span class="line">Multiple Levels of Indirection</span><br><span class="line">Constants and Pointers</span><br><span class="line">Summary</span><br><span class="line">2.Dynamic Memory Management in C</span><br><span class="line">Dynamic Memory Allocation</span><br><span class="line">Memory Leaks</span><br><span class="line">Dynamic Memory Allocation Functions</span><br><span class="line">Using the malloc Function</span><br><span class="line">Using the calloc Function</span><br><span class="line">Using the realloc Function</span><br><span class="line">The alloca Function and Variable Length Arrays</span><br><span class="line">Deallocating Memory Using the free Function</span><br><span class="line">Assigning NULL to a Freed Pointer</span><br><span class="line">Double Free</span><br><span class="line">The Heap and System Memory</span><br><span class="line">Freeing Memory upon Program Termination</span><br><span class="line">Dangling Pointers</span><br><span class="line">Dangling Pointer Examples</span><br><span class="line">Dealing with Dangling Pointers</span><br><span class="line">Debug Version Support for Detecting Memory Leaks</span><br><span class="line">Dynamic Memory Allocation Technologies</span><br><span class="line">Garbage Collection in C</span><br><span class="line">Resource Acquisition Is Initialization</span><br><span class="line">Using Exception Handlers</span><br><span class="line">Summary</span><br><span class="line">3.Pointers and Functions</span><br><span class="line">Program Stack and Heap</span><br><span class="line">Program Stack</span><br><span class="line">Organization of a Stack Frame</span><br><span class="line">Passing and Returning by Pointer</span><br><span class="line">Passing Data Using a Pointer</span><br><span class="line">Passing Data by Value</span><br><span class="line">Passing a Pointer to a Constant</span><br><span class="line">Returning a Pointer</span><br><span class="line">Pointers to Local Data</span><br><span class="line">Passing Null Pointers</span><br><span class="line">Passing a Pointer to a Pointer</span><br><span class="line">Function Pointers</span><br><span class="line">Declaring Function Pointers</span><br><span class="line">Using a Function Pointer</span><br><span class="line">Passing Function Pointers</span><br><span class="line">Returning Function Pointers</span><br><span class="line">Using an Array of Function Pointers</span><br><span class="line">Comparing Function Pointers</span><br><span class="line">Casting Function Pointers</span><br><span class="line">Summary</span><br><span class="line">4.Pointers and Arrays</span><br><span class="line">Quick Review of Arrays</span><br><span class="line">One—Dimensional Arrays</span><br><span class="line">Two—Dimensional Arrays</span><br><span class="line">Multidimensional Arrays</span><br><span class="line">Pointer Notation and Arrays</span><br><span class="line">Differences Between Arrays and Pointers</span><br><span class="line">Using malloc to Create a One—Dimensional Array</span><br><span class="line">Using the realloc Function to Resize an Array</span><br><span class="line">Passing a One—Dimensional Array</span><br><span class="line">Using Array Notation</span><br><span class="line">Using Pointer Notation</span><br><span class="line">Using a One—Dimensional Array of Pointers</span><br><span class="line">Pointers and Multidimensional Arrays</span><br><span class="line">Passing a Multidimensional Array</span><br><span class="line">Dynamically Allocating a Two—Dimensional Array</span><br><span class="line">Allocating Potentially Noncontiguous Memory</span><br><span class="line">Allocating Contiguous Memory</span><br><span class="line">Jagged Arrays and Pointers</span><br><span class="line">Summary</span><br><span class="line">5.Pointers and Strings</span><br><span class="line">String Fundamentals</span><br><span class="line">String Declaration</span><br><span class="line">The String Literal Pool</span><br><span class="line">String Initialization</span><br><span class="line">Standard String Operations</span><br><span class="line">Comparing Strings</span><br><span class="line">Copying Strings</span><br><span class="line">Concatenating Strings</span><br><span class="line">Passing Strings</span><br><span class="line">Passing a Simple String</span><br><span class="line">Passing a Pointer to a Constant char</span><br><span class="line">Passing a String to Be Initialized</span><br><span class="line">Passing Arguments to an Application</span><br><span class="line">Returning Strings</span><br><span class="line">Returning the Address of a Literal</span><br><span class="line">Returning the Address of Dynamically Allocated Memory</span><br><span class="line">Function Pointers and Strings</span><br><span class="line">Summary</span><br><span class="line">6.Pointers and Structures</span><br><span class="line">Introduction</span><br><span class="line">How Memory Is Allocated for a Structure</span><br><span class="line">Structure Deallocation Issues</span><br><span class="line">Avoiding malloc／free Overhead</span><br><span class="line">Using Pointers to Support Data Structures</span><br><span class="line">Single—Linked List</span><br><span class="line">Using Pointers to Support a Queue</span><br><span class="line">Using Pointers to Support a Stack</span><br><span class="line">Using Pointers to Support a Tree</span><br><span class="line">Summary</span><br><span class="line">7.Security Issues and the Improper Use of Pointers</span><br><span class="line">Pointer Declaration and Initialization</span><br><span class="line">Improper Pointer Declaration</span><br><span class="line">Failure to Initialize a Pointer Before It Is Used</span><br><span class="line">Dealing with Uninitialized Pointers</span><br><span class="line">Pointer Usage Issues</span><br><span class="line">Test for NULL</span><br><span class="line">Misuse of the Dereference Operator</span><br><span class="line">Dangling Pointers</span><br><span class="line">Accessing Memory Outside the Bounds of an Array</span><br><span class="line">Calculating the Array Size Incorrectly</span><br><span class="line">Misusing the sizeof Operator</span><br><span class="line">Always Match Pointer Types</span><br><span class="line">Bounded Pointers</span><br><span class="line">String Security Issues</span><br><span class="line">Pointer Arithmetic and Structures</span><br><span class="line">Function Pointer Issues</span><br><span class="line">Memory Deallocation Issues</span><br><span class="line">Double Free</span><br><span class="line">Clearing Sensitive Data</span><br><span class="line">Using Static Analysis Tools</span><br><span class="line">Summary</span><br><span class="line">8.Odds and Ends</span><br><span class="line">Casting Pointers</span><br><span class="line">Accessing a Special Purpose Address</span><br><span class="line">Accessing a Port</span><br><span class="line">Accessing Memory using DMA</span><br><span class="line">Determining the Endianness of a Machine</span><br><span class="line">Aliasing， Strict Aliasing， and the restrict Keyword</span><br><span class="line">Using a Union to Represent a Value in Multiple Ways</span><br><span class="line">Strict Aliasing</span><br><span class="line">Using the restrict Keyword</span><br><span class="line">Threads and Pointers</span><br><span class="line">Sharing Pointers Between Threads</span><br><span class="line">Using Function Pointers to Support Callbacks</span><br><span class="line">Object—Oriented Techniques</span><br><span class="line">Creating and Using an Opaque Pointer</span><br><span class="line">Polymorphism in C</span><br><span class="line">Summary</span><br><span class="line">Index</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00H93ETKS/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00H93ETKS&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51PeEg58w8L._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>移动开发经典丛书 Android C++高级编程 使用NDK</title>
    <url>/2020/04/19/B00HRR3U5G/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 移动开发经典丛书 Android C++高级编程 使用NDK<br>作者信息： 作者: Onur Cinar [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Android是移动电话市场的主要角色而且其市场份额正在持续增长。它是第一个完整的、开放的、免费的移动平台，该平台给移动应用开发者提供了无限的机会。    《Android C++高级编程–使用NDK》（作者：辛纳）介绍了原生应用开发、可用的原生API以及故障排除技术的详细叙述，包括用按步骤的指导和屏幕截图以帮助Android开发人员迅速达到开发原生应用的目的。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章  Android平台上的C++入门</span><br><span class="line">第2章  深入了解Android NDK</span><br><span class="line">第3章  用JNI实现与原生代码通信</span><br><span class="line">第4章  使用SWIG自动生成JNI代码</span><br><span class="line">第5章  日志、调试及故障处理</span><br><span class="line">第6章  Bionic API入门</span><br><span class="line">第7章  原生线程</span><br><span class="line">第8章  POSIX Socket API：面向连接的通信</span><br><span class="line">第9章  POSIX Socket API：无连接的通信</span><br><span class="line">第10章  POSIX Socket API：本地通信</span><br><span class="line">第11章  支持C++</span><br><span class="line">第12章  原生图形AP</span><br><span class="line">第13章  原生音频API</span><br><span class="line">第14章  程序概要分析和NEON优化</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00HRR3U5G/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00HRR3U5G&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41TQWDfcC2L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>嗨翻C语言(英文)</title>
    <url>/2020/04/19/head-first-c/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 嗨翻C语言(英文)<br>作者信息： 作者: David Griffiths [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Ever wished you could learn C from a book? Head First C provides a complete learning experience for C and structured imperative programming. With a unique method that goes beyond syntax and how-to manuals, this guide not only teaches you the language, it helps you understand how to be a great programmer. You’ll learn key areas such as language basics, pointers and pointer arithmetic, and dynamic memory management. Advanced topics include multi-threading and network programming - topics typically covered on a college-level course. This book also features labs: in-depth projects intended to stretch your abilities, test your new skills, and build confidence. Head First C mimics the style of college-level C courses, making it ideal as an accessible textbook for students. We think your time is too valuable to waste struggling with new concepts. Using the latest research in cognitive science and learning theory to craft a multi-sensory learning experience, Head First C uses a visually rich format designed for the way your brain works, not a text-heavy approach that puts you to sleep.</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Head First C</span><br><span class="line">Dedication</span><br><span class="line">Advance Praise for Head First C</span><br><span class="line">Praise for other Head First books</span><br><span class="line">Authors of Head First C</span><br><span class="line">How to use this Book: Intro</span><br><span class="line">Who is this book for?</span><br><span class="line">We know what you’re thinking</span><br><span class="line">We know what your brain is thinking</span><br><span class="line">Metacognition: thinking about thinking</span><br><span class="line">Here’s what WE did</span><br><span class="line">Here’s what YOU can do to bend your brain into submission</span><br><span class="line">Read me</span><br><span class="line">The technical review team</span><br><span class="line">Acknowledgments</span><br><span class="line">Safari® Books Online</span><br><span class="line">1. Getting Started with C: Diving in</span><br><span class="line">C is a language for small, fast programs</span><br><span class="line">But what does a complete C program look like?</span><br><span class="line">But how do you run the program?</span><br><span class="line">Two types of command</span><br><span class="line">Here’s the code so far</span><br><span class="line">Card counting? In C?</span><br><span class="line">There’s more to booleans than equals…</span><br><span class="line">What’s the code like now?</span><br><span class="line">Pulling the ol’ switcheroo</span><br><span class="line">Sometimes once is not enough…</span><br><span class="line">Loops often follow the same structure…</span><br><span class="line">You use break to break out…</span><br><span class="line">Your C Toolbox</span><br><span class="line">2. Memory and Pointers: What are you pointing at?</span><br><span class="line">C code includes pointers</span><br><span class="line">Digging into memory</span><br><span class="line">Set sail with pointers</span><br><span class="line">Set sail sou’east, Cap’n</span><br><span class="line">Try passing a pointer to the variable</span><br><span class="line">Using memory pointers</span><br><span class="line">How do you pass a string to a function?</span><br><span class="line">Array variables are like pointers…</span><br><span class="line">What the computer thinks when it runs your code</span><br><span class="line">But array variables aren’t quite pointers</span><br><span class="line">Why arrays really start at 0</span><br><span class="line">Why pointers have types</span><br><span class="line">Using pointers for data entry</span><br><span class="line">Be careful with scanf()</span><br><span class="line">fgets() is an alternative to scanf()</span><br><span class="line">Anyone for three-card monte?</span><br><span class="line">Oops…there’s a memory problem…</span><br><span class="line">String literals can never be updated</span><br><span class="line">If you’re going to change a string, make a copy</span><br><span class="line">Memory memorizer</span><br><span class="line">Your C Toolbox</span><br><span class="line">2.5. Strings: String theory</span><br><span class="line">Desperately seeking Susan Frank</span><br><span class="line">Create an array of arrays</span><br><span class="line">Find strings containing the search text</span><br><span class="line">Using the strstr() function</span><br><span class="line">It’s time for a code review</span><br><span class="line">Array of arrays vs. array of pointers</span><br><span class="line">Your C Toolbox</span><br><span class="line">View Sample</span><br><span class="line">3. Creating Small Tools: Do one thing and do it well</span><br><span class="line">View Sample</span><br><span class="line">Small tools can solve big problems</span><br><span class="line">View Sample</span><br><span class="line">Here’s how the program should work</span><br><span class="line">View Sample</span><br><span class="line">But you’re not using files…</span><br><span class="line">View Sample</span><br><span class="line">You can use redirection</span><br><span class="line">View Sample</span><br><span class="line">You can redirect the Standard Input with &lt;…</span><br><span class="line">View Sample</span><br><span class="line">…and redirect the Standard Output with &gt;</span><br><span class="line">View Sample</span><br><span class="line">But there’s a problem with some of the data…</span><br><span class="line">View Sample</span><br><span class="line">Introducing the Standard Error</span><br><span class="line">View Sample</span><br><span class="line">By default, the Standard Error is sent to the display</span><br><span class="line">View Sample</span><br><span class="line">fprintf() prints to a data stream</span><br><span class="line">View Sample</span><br><span class="line">Let’s update the code to use fprintf()</span><br><span class="line">View Sample</span><br><span class="line">Small tools are flexible</span><br><span class="line">View Sample</span><br><span class="line">Don’t change the geo2json tool</span><br><span class="line">View Sample</span><br><span class="line">A different task needs a different tool</span><br><span class="line">View Sample</span><br><span class="line">Connect your input and output with a pipe</span><br><span class="line">View Sample</span><br><span class="line">The bermuda tool</span><br><span class="line">View Sample</span><br><span class="line">But what if you want to output to more than one file?</span><br><span class="line">View Sample</span><br><span class="line">Roll your own data streams</span><br><span class="line">View Sample</span><br><span class="line">There’s more to main()</span><br><span class="line">View Sample</span><br><span class="line">Overheard at the Head First Pizzeria</span><br><span class="line">View Sample</span><br><span class="line">Let the library do the work for you</span><br><span class="line">View Sample</span><br><span class="line">Your C Toolbox</span><br><span class="line">4. Using Multiple Source Files: Break it down, build it up</span><br><span class="line">Don’t put something big into something small</span><br><span class="line">Use casting to put floats into whole numbers</span><br><span class="line">Oh no…it’s the out-of-work actors…</span><br><span class="line">Let’s see what’s happened to the code</span><br><span class="line">Compilers don’t like surprises</span><br><span class="line">Split the declaration from the definition</span><br><span class="line">Creating your first header file</span><br><span class="line">If you have common features…</span><br><span class="line">You can split the code into separate files</span><br><span class="line">Compilation behind the scenes</span><br><span class="line">The shared code needs its own header file</span><br><span class="line">It’s not rocket science…or is it?</span><br><span class="line">Don’t recompile every file</span><br><span class="line">First, compile the source into object files</span><br><span class="line">It’s hard to keep track of the files</span><br><span class="line">Automate your builds with the make tool</span><br><span class="line">How make works</span><br><span class="line">Tell make about your code with a makefile</span><br><span class="line">Your C Toolbox</span><br><span class="line">C Lab 1: Arduino</span><br><span class="line">5. Structs, Unions, and Bitfields: Roll your own structures</span><br><span class="line">Sometimes you need to hand around a lot of data</span><br><span class="line">Cubicle conversation</span><br><span class="line">Create your own structured data types with a struct</span><br><span class="line">Just give them the fish</span><br><span class="line">Read a struct’s fields with the “.” operator</span><br><span class="line">Can you put one struct inside another?</span><br><span class="line">How do you update a struct?</span><br><span class="line">The code is cloning the turtle</span><br><span class="line">You need a pointer to the struct</span><br><span class="line">(t).age vs. t.age</span><br><span class="line">Sometimes the same type of thing needs different types of data</span><br><span class="line">A union lets you reuse memory space</span><br><span class="line">How do you use a union?</span><br><span class="line">An enum variable stores a symbol</span><br><span class="line">Sometimes you want control at the bit level</span><br><span class="line">Bitfields store a custom number of bits</span><br><span class="line">Your C Toolbox</span><br><span class="line">6. Data Structures and Dynamic Memory: Building bridges</span><br><span class="line">Do you need flexible storage?</span><br><span class="line">Linked lists are like chains of data</span><br><span class="line">Linked lists allow inserts</span><br><span class="line">Create a recursive structure</span><br><span class="line">Create islands in C…</span><br><span class="line">Inserting values into the list</span><br><span class="line">Use the heap for dynamic storage</span><br><span class="line">Give the memory back when you’re done</span><br><span class="line">Ask for memory with malloc()…</span><br><span class="line">Oh, no! It’s the out-of-work actors…</span><br><span class="line">Let’s fix the code using the strdup() function</span><br><span class="line">Free the memory when you’re done</span><br><span class="line">Exhibit A: the source code</span><br><span class="line">An overview of the SPIES system</span><br><span class="line">Software forensics: using valgrind</span><br><span class="line">Use valgrind repeatedly to gather more evidence</span><br><span class="line">Look at the evidence</span><br><span class="line">The fix on trial</span><br><span class="line">Your C Toolbox</span><br><span class="line">7. Advanced Functions: Turn your functions up to 11</span><br><span class="line">Looking for Mr. Right…</span><br><span class="line">Pass code to a function</span><br><span class="line">You need to tell find() the name of a function</span><br><span class="line">Every function name is a pointer to the function…</span><br><span class="line">…but there’s no function data type</span><br><span class="line">How to create function pointers</span><br><span class="line">Get it sorted with the C Standard Library</span><br><span class="line">Use function pointers to set the order</span><br><span class="line">Automating the Dear John letters</span><br><span class="line">Create an array of function pointers</span><br><span class="line">Make your functions streeeeeetchy</span><br><span class="line">Your C Toolbox</span><br><span class="line">8. Static and Dynamic Libraries: Hot-swappable code</span><br><span class="line">Code you can take to the bank</span><br><span class="line">Angle brackets are for standard headers</span><br><span class="line">But what if you want to share code?</span><br><span class="line">Sharing .h header files</span><br><span class="line">Share .o object files by using the full pathname</span><br><span class="line">An archive contains .o files</span><br><span class="line">Create an archive with the ar command…</span><br><span class="line">Finally, compile your other programs</span><br><span class="line">The Head First Gym is going global</span><br><span class="line">Calculating calories</span><br><span class="line">But things are a bit more complex…</span><br><span class="line">Programs are made out of lots of pieces…</span><br><span class="line">Dynamic linking happens at runtime</span><br><span class="line">Can you link .a at runtime?</span><br><span class="line">First, create an object file</span><br><span class="line">What you call your dynamic library depends on your platform</span><br><span class="line">Your C Toolbox</span><br><span class="line">C Lab 2: OpenCV</span><br><span class="line">9. Processes and System Calls: Breaking boundaries</span><br><span class="line">System calls are your hotline to the OS</span><br><span class="line">Then someone busted into the system…</span><br><span class="line">Security’s not the only problem</span><br><span class="line">The exec() functions give you more control</span><br><span class="line">There are many exec() functions</span><br><span class="line">The array functions: execv(), execvp(), execve()</span><br><span class="line">Passing environment variables</span><br><span class="line">Most system calls go wrong in the same way</span><br><span class="line">Read the news with RSS</span><br><span class="line">exec() is the end of the line for your program</span><br><span class="line">Running a child process with fork() + exec()</span><br><span class="line">Your C Toolbox</span><br><span class="line">10. Interprocess Communication: It’s good to talk</span><br><span class="line">Redirecting input and output</span><br><span class="line">A look inside a typical process</span><br><span class="line">Redirection just replaces data streams</span><br><span class="line">fileno() tells you the descriptor</span><br><span class="line">Sometimes you need to wait…</span><br><span class="line">Stay in touch with your child</span><br><span class="line">Connect your processes with pipes</span><br><span class="line">Case study: opening stories in a browser</span><br><span class="line">In the child</span><br><span class="line">In the parent</span><br><span class="line">Opening a web page in a browser</span><br><span class="line">The death of a process</span><br><span class="line">Catching signals and running your own code</span><br><span class="line">sigactions are registered with sigaction()</span><br><span class="line">Rewriting the code to use a signal handler</span><br><span class="line">Use kill to send signals</span><br><span class="line">Sending your code a wake-up call</span><br><span class="line">Your C Toolbox</span><br><span class="line">11. Sockets and Networking: There’s no place like 127.0.0.1</span><br><span class="line">The Internet knock-knock server</span><br><span class="line">Knock-knock server overview</span><br><span class="line">BLAB: how servers talk to the Internet</span><br><span class="line">A socket’s not your typical data stream</span><br><span class="line">Sometimes the server doesn’t start properly</span><br><span class="line">Why your mom always told you to check for errors</span><br><span class="line">Reading from the client</span><br><span class="line">The server can only talk to one person at a time</span><br><span class="line">You can fork() a process for each client</span><br><span class="line">Writing a web client</span><br><span class="line">Clients are in charge</span><br><span class="line">Create a socket for an IP address</span><br><span class="line">getaddrinfo() gets addresses for domains</span><br><span class="line">Your C Toolbox</span><br><span class="line">12. Threads: It’s a parallel world</span><br><span class="line">Tasks are sequential…or not…</span><br><span class="line">…and processes are not always the answer</span><br><span class="line">Simple processes do one thing at a time</span><br><span class="line">Employ extra staff: use threads</span><br><span class="line">How do you create threads?</span><br><span class="line">Create threads with pthread_create</span><br><span class="line">The code is not thread-safe</span><br><span class="line">You need to add traffic signals</span><br><span class="line">Use a mutex as a traffic signal</span><br><span class="line">Your C Toolbox</span><br><span class="line">C Lab 3: Blasteroids</span><br><span class="line">A. Leftovers: The top ten things (we didn’t cover)</span><br><span class="line">1. Operators</span><br><span class="line">2. Preprocessor directives</span><br><span class="line">3. The static keyword</span><br><span class="line">4. How big stuff is</span><br><span class="line">5. Automated testing</span><br><span class="line">6. More on gcc</span><br><span class="line">7. More on make</span><br><span class="line">8. Development tools</span><br><span class="line">9. Creating GUIs</span><br><span class="line">10. Reference material</span><br><span class="line">B. C Topics: Revision roundup</span><br><span class="line">Basics</span><br><span class="line">Pointers and memory</span><br><span class="line">Strings</span><br><span class="line">Data streams</span><br><span class="line">Data types</span><br><span class="line">Multiple files</span><br><span class="line">Structs</span><br><span class="line">Unions and bitfields</span><br><span class="line">Data structures</span><br><span class="line">Dynamic memory</span><br><span class="line">Advanced functions</span><br><span class="line">Static and dynamic libraries</span><br><span class="line">Processes and communication</span><br><span class="line">Sockets and networking</span><br><span class="line">Threads</span><br><span class="line">Index</span><br><span class="line">About the Authors</span><br><span class="line">Copyright</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/1449399916/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=1449399916&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51zILwVFM6L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>精通Android</title>
    <url>/2020/04/19/jing-tong-android/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 精通Android<br>作者信息： 作者: 克曼特内尼 [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Android是谷歌的开源移动开发平台。业已成为移动开发领域的主流。近几年。随着越来越多硬件供应商加入Andrroid操作系统的阵营，谷歌已经成为移动领域的新霸主。<br>克曼特内尼、麦克莱恩编著的《精通Android》是权威智慧的结晶，是备受推崇的Android参考书。作为Android 4.0 SDK（Android的第一个SDK）的编程指南。相较于上一版，本书不仅在结构上做了相应的调整，内容上更是与时俱进。增加了Android内部构件编程的相关知识。介绍了线程、进程、长期运行的服务、广播接收程序、闹钟管理器、设备配置变化和异步任务。用31章涵盖了100多个主题，原书配套网站<a href="http://www.androidbook.com上更是展示TAndroid" target="_blank" rel="noopener">www.androidbook.com上更是展示TAndroid</a> SDK的最新特性。<br>本书强调实用，突出趣味，寓教于乐。作者通过妙趣横生、切实可行的示例。向读者展示了如何使用谷歌最新的Android 4.0 SDK。为嵌入式设备、手机、平板电脑构建应用。如果你想投身Android移动开发，那么本书不容错过。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章Android计算平台简介</span><br><span class="line">1.1面向新PC的全新平台</span><br><span class="line">1.2 Android的历史</span><br><span class="line">1.3 Dalvik VM剖析</span><br><span class="line">1.4理解Android软件栈</span><br><span class="line">1.5使用Android SDK开发最终用户应用程序</span><br><span class="line">1.5.1 Android模拟器</span><br><span class="line">1.5.2 Android UI</span><br><span class="line">1.5.3 Android基础组件</span><br><span class="line">1.5.4高级UI概念</span><br><span class="line">1.5.5 Android Service组件</span><br><span class="line">1.5.6 Android媒体和电话组件</span><br><span class="line">1.5.7 Android Java包</span><br><span class="line">1.6利用Android源代码</span><br><span class="line">1.6.1 在线浏览Android源代码</span><br><span class="line">1.6.2使用Git下载Android源代码</span><br><span class="line">1.7本书的示例项目</span><br><span class="line">1.8小结</span><br><span class="line">第2章设置开发环境</span><br><span class="line">2.1设置环境</span><br><span class="line">2.1.1 下载JDK 6</span><br><span class="line">2.1.2下载Eclipse 3.6</span><br><span class="line">2.1.3 下裁Android SDK</span><br><span class="line">2.1.4命令行窗口</span><br><span class="line">2.1.5 安装ADT</span><br><span class="line">2.2了解基本组件</span><br><span class="line">2.2.1 View</span><br><span class="line">2.2.2 Activity</span><br><span class="line">2.2.3 Fragment</span><br><span class="line">2.2.4 Intent</span><br><span class="line">2.2.5 ContentProvider</span><br><span class="line">2.2.6 Service</span><br><span class="line">2.2.7 AndroidManifest.xml</span><br><span class="line">2.2.8 AVD</span><br><span class="line">2.3 Hello World！</span><br><span class="line">2.4 AVD</span><br><span class="line">2.5在真实设备上运行</span><br><span class="line">2.6剖析Android应用程序的结构</span><br><span class="line">2.7了解应用程序生命周期</span><br><span class="line">2.8简单调试</span><br><span class="line">2.9参考资料</span><br><span class="line">2.10小结</span><br><span class="line">2.1 1面试问题</span><br><span class="line">第3章使用Android资源</span><br><span class="line">3.1资源</span><br><span class="line">3.1.1字符串资源</span><br><span class="line">3.1.2布局资源</span><br><span class="line">3.1.3 资源引用语法</span><br><span class="line">3.1.4 定义资源ID供以后使用</span><br><span class="line">3.1.5 已编译和未编译的Android资源</span><br><span class="line">3.2 Android关键资源</span><br><span class="line">3.3使用任意XML资源文件</span><br><span class="line">3.4使用原始资源</span><br><span class="line">3.5使用资产</span><br><span class="line">3.6了解资源目录结构</span><br><span class="line">3.7资源和配置更改</span><br><span class="line">3.8参考资料URL</span><br><span class="line">第3章使用Android资源</span><br><span class="line">3.9小结</span><br><span class="line">3.10面试问题</span><br><span class="line">第4章ContentProvider</span><br><span class="line">4.1探索Android内置的ContentProvider</span><br><span class="line">4.1.1 在模拟器和可用设备上利用数据库</span><br><span class="line">4.1.2快速了解SQLite</span><br><span class="line">4.2 ContentProvider的架构</span><br><span class="line">4.2.1 Android内容URl的结构</span><br><span class="line">4.2.2 AndroidMIME类型的结构</span><br><span class="line">4.2.3 使用URl读取数据</span><br><span class="line">4.2.4使用游标</span><br><span class="line">4.2.5使用where子句</span><br><span class="line">4.2.6插入记录</span><br><span class="line">4.2.7 将文件添加到contentProvider中</span><br><span class="line">4.2.8更新和删除</span><br><span class="line">4.3实现ContentProvider</span><br><span class="line">4.3.1 计划数据库</span><br><span class="line">4.3.2扩展ContentProvider</span><br><span class="line">4.3.3履行MIME类型契约</span><br><span class="line">4.3.4实现query方法</span><br><span class="line">4.3.5实现insert方法</span><br><span class="line">4.3.6实现update方法</span><br><span class="line">4.3.7实现delete方法</span><br><span class="line">4.3.8 使用UriMatcher来解析URI</span><br><span class="line">4.3.9使用投影映射</span><br><span class="line">4.3.10 注册提供程序</span><br><span class="line">4.4练习图书提供程序</span><br><span class="line">4.4.1 添加图书</span><br><span class="line">4.4.2删除图书</span><br><span class="line">4.4.3 获取图书数量</span><br><span class="line">4.4.4显示图书列表</span><br><span class="line">4.5资源</span><br><span class="line">4.6小结</span><br><span class="line">4.7面试问题</span><br><span class="line">第5章 Intent</span><br><span class="line">5.1 Android Intent基础知识</span><br><span class="line">5.2 Android中可用的Intent</span><br><span class="line">5.3 Intent的组成</span><br><span class="line">5.3.1 Intent和数据URl</span><br><span class="line">5.3.2一般操作</span><br><span class="line">5.3.3使用extra信息</span><br><span class="line">5.3.4使用组件直接调用活动</span><br><span class="line">5.3.5 Intent类别</span><br><span class="line">5.3.6将Intent解析为组件的规则</span><br><span class="line">5.4练习使用ACTION PICK</span><br><span class="line">5.5练习使用GET—CONTENT操作</span><br><span class="line">5.6挂起的Intent</span><br><span class="line">5.7资源</span><br><span class="line">5.8小结</span><br><span class="line">5.9面试问题</span><br><span class="line">第6章构建用户界面和使用控件</span><br><span class="line">6.1 Android中的UI开发</span><br><span class="line">6.1.1 完全利用代码来构建UI</span><br><span class="line">6.1.2 完全使用XML构建UI</span><br><span class="line">6.1.3使用XML结合代码构建UI</span><br><span class="line">6.2 Android中的常见控件</span><br><span class="line">6.2.1文本控件</span><br><span class="line">6.2.2按钮控件</span><br><span class="line">6.2.3 ImageView控件</span><br><span class="line">6.2.4 日期和时间控件</span><br><span class="line">6.2.5 MapView控件</span><br><span class="line">6.3适配器</span><br><span class="line">6.3.1 SimpleCursorAdapter</span><br><span class="line">6.3.2 了解ArrayAdapter</span><br><span class="line">6.4结合使用适配器和AdapterView</span><br><span class="line">6.4.1基本的列表控件：ListView</span><br><span class="line">6.4.2 GridView控件</span><br><span class="line">6.4.3 Spinner控件</span><br><span class="line">6.4.4 Gallery控件</span><br><span class="line">6.4.5创建自定义适配器</span><br><span class="line">6.4.6 Android中的其他控件</span><br><span class="line">6.5样式和主题</span><br><span class="line">6.5.1 使用样式</span><br><span class="line">6.5.2使用主题</span><br><span class="line">6.6布局管理器</span><br><span class="line">6.6.1 LinearLayout布局管理器</span><br><span class="line">……</span><br><span class="line">第7章使用菜单</span><br><span class="line">第8章多用途的碎片</span><br><span class="line">第9章对话框</span><br><span class="line">第10章ActionBar</span><br><span class="line">第11章高级调试与分析</span><br><span class="line">第12章响应配置变化</span><br><span class="line">第13章首选项及保存状态</span><br><span class="line">第14章探索安全性和权限</span><br><span class="line">第15章构建和使用服务</span><br><span class="line">第16章包</span><br><span class="line">第17章处理程序</span><br><span class="line">第18章AsyncTask详解</span><br><span class="line">第19章广播接收程序和长期运行的服务</span><br><span class="line">第20章闹钟管理器</span><br><span class="line">第21章2D动画揭秘</span><br><span class="line">第22章地图和基于位置的服务</span><br><span class="line">第23章电话API</span><br><span class="line">第24章媒体框架</span><br><span class="line">第25章主屏幕部件</span><br><span class="line">第26章列表部件</span><br><span class="line">第27章触摸屏</span><br><span class="line">第28章实现拖放操作</span><br><span class="line">第29章传感器</span><br><span class="line">第30章联系人API</span><br><span class="line">第31章部署应用程序AndroidMarket</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00ASIN7G8/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00ASIN7G8&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41QYuchmDjL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>精彩绝伦的Android UI设计 响应式用户界面与设计模式</title>
    <url>/2020/04/19/B00FQEDTA8/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 精彩绝伦的Android UI设计 响应式用户界面与设计模式<br>作者信息： 作者: 莱特曼 (Juhani Lehtimaki) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Andriod UI设计领域的经典著作，Amazon五星级畅销书，内容系统全面，实战性极强，包含大量最佳实践    不仅详细讲解了Android应用UI设计需要掌握的Android平台相关的各项技术和特性，而且还全面总结了Android应用UI设计的方法、技巧、模式，以及反模式</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">译者序</span><br><span class="line">前言</span><br><span class="line">第一部分Android设计简介</span><br><span class="line">第1章用户界面设计和易用性入门</span><br><span class="line">1.1考虑技术与设计</span><br><span class="line">1.2理解心智模型</span><br><span class="line">1.3为用户设计</span><br><span class="line">1.4没有应用无所不精，选择适合自己的领域</span><br><span class="line">1.5你是专家，用户不是设计师</span><br><span class="line">1.6了解用户，为普通人设计</span><br><span class="line">1.7总结</span><br><span class="line">第2章不要马上开始编程</span><br><span class="line">2.1原型设计</span><br><span class="line">2.2设计工具</span><br><span class="line">2.3用户测试</span><br><span class="line">2.4总结</span><br><span class="line">第3章考虑为移动和触摸设备设计</span><br><span class="line">3.1为移动而设计</span><br><span class="line">3.2为触摸界面设计</span><br><span class="line">3.3总结</span><br><span class="line">第4章探索Android平台</span><br><span class="line">4.1Android平台的挑战</span><br><span class="line">4.2Android的版本</span><br><span class="line">4.3Android应用的发布</span><br><span class="line">4.4开源的意义是什么</span><br><span class="line">4.5总结</span><br><span class="line">第二部分Android平台的特性和UI组件</span><br><span class="line">第5章Android应用架构和在线指南</span><br><span class="line">5.1Android应用程序结构概览</span><br><span class="line">5.2Android项目结构概览</span><br><span class="line">5.3官方Android指南</span><br><span class="line">5.4总结</span><br><span class="line">第6章Android的意图系统</span><br><span class="line">6.1意图让应用程序相互协作</span><br><span class="line">6.2使用社交网络并分享</span><br><span class="line">6.3和浏览器一起工作</span><br><span class="line">6.4Android意图系统的工作原理</span><br><span class="line">6.5创建自定义行为</span><br><span class="line">6.6意图无处不在</span><br><span class="line">6.7意图与第三方API</span><br><span class="line">6.8总结</span><br><span class="line">第7章Android应用的导航结构</span><br><span class="line">7.1Android导航系统的组件：活动和意图</span><br><span class="line">7.2Android导航控件</span><br><span class="line">7.3总结</span><br><span class="line">第8章主界面应用小部件</span><br><span class="line">8.1主界面应用小部件的使用</span><br><span class="line">8.2更新应用小部件数据</span><br><span class="line">8.3应用小部件布局和功能</span><br><span class="line">8.4实现应用小部件</span><br><span class="line">8.5总结</span><br><span class="line">第9章通知及告知用户</span><br><span class="line">9.1Android通知方法</span><br><span class="line">9.2何时通知用户</span><br><span class="line">9.3何时不要通知用户</span><br><span class="line">9.4避免使用弹出框</span><br><span class="line">9.5从状态栏通知中获得更多信息</span><br><span class="line">9.6总结</span><br><span class="line">第10章物理按键、输入法和传感器的设计</span><br><span class="line">10.1触摸屏的设计</span><br><span class="line">10.2手机物理按键的设计</span><br><span class="line">10.3软键盘的设计</span><br><span class="line">10.4物理键盘设计</span><br><span class="line">10.5方向键和轨迹球设计</span><br><span class="line">10.6触控笔设计</span><br><span class="line">10.7声控设计</span><br><span class="line">10.8外接键盘、鼠标和触摸板的设计</span><br><span class="line">10.9智能附件的设计</span><br><span class="line">10.10传感器的设计</span><br><span class="line">10.11第二块屏幕的设计</span><br><span class="line">10.12总结</span><br><span class="line">第11章平台用户界面组件的设计</span><br><span class="line">11.1使用用户界面小部件</span><br><span class="line">11.2自定义用户界面小部件</span><br><span class="line">11.3调整排版</span><br><span class="line">11.4使用图标</span><br><span class="line">11.5使用动画和过渡效果</span><br><span class="line">11.6总结</span><br><span class="line">第三部分可扩展的Android设计</span><br><span class="line">第12章管理Android资源</span><br><span class="line">12.1使用Android资源</span><br><span class="line">12.2屏幕密度设计</span><br><span class="line">12.3屏幕大小和形状的设计</span><br><span class="line">12.4语言和地区设置</span><br><span class="line">12.5设备控件的设计</span><br><span class="line">12.6平台版本的设计</span><br><span class="line">12.7设备模式的设计</span><br><span class="line">12.8总结</span><br><span class="line">第13章Android应用布局</span><br><span class="line">13.1Android布局策略</span><br><span class="line">13.2用XML文件和代码布局</span><br><span class="line">13.3布局的管理</span><br><span class="line">13.4定义布局的尺寸</span><br><span class="line">13.5滚动条</span><br><span class="line">13.6z轴的布局顺序</span><br><span class="line">13.7内边距和外边距</span><br><span class="line">13.8导入与合并布局文件</span><br><span class="line">13.9自定义布局</span><br><span class="line">13.10Android开发工具和用户界面生成器</span><br><span class="line">13.11调试布局</span><br><span class="line">13.12总结</span><br><span class="line">第14章可缩放的图形</span><br><span class="line">14.1九宫格图片</span><br><span class="line">14.2绘图XML</span><br><span class="line">14.3用代码绘制</span><br><span class="line">14.4总结</span><br><span class="line">第15章超越可缩放——响应式设计</span><br><span class="line">15.1Android设备不仅仅只是手机</span><br><span class="line">15.2了解响应式设计</span><br><span class="line">15.3制作响应式用户界面的常见方法</span><br><span class="line">15.4总结</span><br><span class="line">第16章实现响应式用户界面</span><br><span class="line">16.1片段简介</span><br><span class="line">16.2片段和活动结构</span><br><span class="line">16.3移植现存的应用</span><br><span class="line">16.4示例程序</span><br><span class="line">16.5总结</span><br><span class="line">第四部分AndroidUI设计模式</span><br><span class="line">第17章用户界面设计模式简介</span><br><span class="line">17.1用户界面设计模式</span><br><span class="line">17.2使用UI设计模式的好处</span><br><span class="line">17.3Android设计指南中的设计模式</span><br><span class="line">17.4本书介绍的用户界面设计模式</span><br><span class="line">17.5总结</span><br><span class="line">第18章用户操作设计模式</span><br><span class="line">18.1使用操作栏模式</span><br><span class="line">18.2使用快捷操作设计模式</span><br><span class="line">18.3使用操作抽屉设计模式</span><br><span class="line">18.4使用下拉刷新设计模式</span><br><span class="line">18.5使用滑动忽略的手势</span><br><span class="line">18.6总结</span><br><span class="line">第19章导航和布局设计模式</span><br><span class="line">19.1使用层叠图库</span><br><span class="line">19.2使用仪表盘</span><br><span class="line">19.3使用工作空间</span><br><span class="line">19.4使用分拆视图</span><br><span class="line">19.5根据上下文扩展的设计模式</span><br><span class="line">19.6使用侧边导航</span><br><span class="line">19.7总结</span><br><span class="line">第20章数据设计模式</span><br><span class="line">20.1使用动态列表</span><br><span class="line">20.2使用图片占位符设计模式</span><br><span class="line">20.3非强制登录模式</span><br><span class="line">20.4使用拖动重排手柄模式</span><br><span class="line">20.5总结</span><br><span class="line">第21章用户界面设计反模式</span><br><span class="line">21.1避免使用启动界面</span><br><span class="line">21.2避免使用引导界面</span><br><span class="line">21.3避免使用确认窗口</span><br><span class="line">21.4避免在界面上使用Back按钮</span><br><span class="line">21.5避免使用菜单按钮</span><br><span class="line">21.6避免隐藏状态栏</span><br><span class="line">21.7避免为快捷操作使用滑动覆盖层</span><br><span class="line">21.8避免使用非Android的设计</span><br><span class="line">21.9总结</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00FQEDTA8/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00FQEDTA8&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41qXjPkbe0L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Accelerated C++中文版</title>
    <url>/2020/04/19/accelerated-cpp/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Accelerated C++中文版<br>作者信息： 作者: Andrew Koenig [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Accelerated C++中文版》给人的印象会如此深刻呢?这是因为：<br>它一开始就向读者教导那些最有用的概念，而不是那些简单的注释 读者很快就能够以此开始编程<br>它描述的是现实中的问题和解决方案，而不是单纯的语言特性 读者不但学习到了这些特性，而且还知道如何把它们应用到程序中去<br>它涵盖的范围同时包括了语言本身和标准库 读者可以从一开始就使用标准库来编写自己的程序<br>作者通过他们在美国斯坦福大学的教学经验证明了这种方法的有效性—在那里，学生们在他们的第一堂课中就学习到了如何编写真实的程序。<br>不管你是一个渴望开始学习C++编程的新手，还是一个已经使用C++多年并对它有了很深了解的老手，作者们独特的教学方法和经验都使得《Accelerated C++中文版》应该成为你书架中不可缺少的一个补充。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">“c++设计新思维”丛书前言</span><br><span class="line">译者序</span><br><span class="line">前言</span><br><span class="line">第0章　入门</span><br><span class="line">　0.1　注释</span><br><span class="line">　0.2 #include指令</span><br><span class="line">　0.3 main函数</span><br><span class="line">　0.4　花括号</span><br><span class="line">　0.5　使用标准库来输出</span><br><span class="line">　0.6 return语句</span><br><span class="line">　0.7　稍微深入分析“Hello，world！”程序</span><br><span class="line">　小结</span><br><span class="line">　练习</span><br><span class="line">第1章　使用字符串</span><br><span class="line">1.1　输入</span><br><span class="line">1.2　为名字装框输出</span><br><span class="line">小结</span><br><span class="line">练习</span><br><span class="line">第2章　循环和计数</span><br><span class="line">2.1　问题</span><br><span class="line">2.2　程序的总体结构</span><br><span class="line">2.3　输出任意多行</span><br><span class="line">2.3.1　while语句</span><br><span class="line">2.3.2　设计一个while语句</span><br><span class="line">2.4　输出一行</span><br><span class="line">2.4.1　输出边界字符</span><br><span class="line">2.4.2　输出非边界字符</span><br><span class="line">2.5　完整的框架程序</span><br><span class="line">2.5.1　简化重复的std：：</span><br><span class="line">　　2.5.2　使用for语句来简化</span><br><span class="line">　　2.5.3　精简测试</span><br><span class="line">　　2.5.4　整合结果</span><br><span class="line">　2.6　计数</span><br><span class="line">　小结</span><br><span class="line">练习</span><br><span class="line">第3章 使用批量数据</span><br><span class="line">　3.1　计算学生成绩</span><br><span class="line">　3.1.1　检测输入的结束</span><br><span class="line">　 3.1.2　循环不变式</span><br><span class="line">　3.2　使用中值取代平均值</span><br><span class="line">　 3.2.1 用vector保存数据集</span><br><span class="line">　3.2.2　生成输出</span><br><span class="line">　3.2.3　值得注意的地方</span><br><span class="line">小结</span><br><span class="line">练习</span><br><span class="line">第4章 组织程序和数据</span><br><span class="line">4.1　组织计算</span><br><span class="line">　4.1.1　查找中值</span><br><span class="line">　4.1.2　重新实现计算最终成绩的方法</span><br><span class="line">　 4.1.3　读取家庭作业成绩</span><br><span class="line">　 4.1.4　3种函数形参</span><br><span class="line">　4.1.5　使用函数来计算学生的成绩</span><br><span class="line">4.2　组织数据</span><br><span class="line">　 4.2.1 把一个学生的所有数据集合起来</span><br><span class="line">　4.2.2　处理学生记录</span><br><span class="line">　 4.2.3　生成报表</span><br><span class="line">4.3　把各部分程序连接起来</span><br><span class="line">4.4　把计算成绩程序分块</span><br><span class="line">4.5　修改后的计算成绩程序</span><br><span class="line">第5章　使用序列式容器并分析字符串</span><br><span class="line">第6章　使用库算法</span><br><span class="line">第7章　使用关联式容器</span><br><span class="line">第8章　编写泛型函数</span><br><span class="line">第9章　定义新类型</span><br><span class="line">第10章　管理内存和底层数据结构</span><br><span class="line">第11章　定义抽象数据类型</span><br><span class="line">第12章　使类的对象数值一样工作</span><br><span class="line">第13章　使用继承和动态绑定</span><br><span class="line">第14章　几乎自动的管理内存</span><br><span class="line">第15章　再看字符图形问题</span><br><span class="line">第16章　如何学习C++</span><br><span class="line">附录A　语言细节</span><br><span class="line">附录B　标准库概要</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00116IK5E/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00116IK5E&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51t05jRkIdL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual C#2008从入门到精通</title>
    <url>/2020/04/19/B001O0DI18/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Visual C#2008从入门到精通<br>作者信息： 作者: 夏普 (John sharp) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Visual C#2008从入门到精通》全书以下特点：沿袭深受读者欢迎的Step by Step典写作风格；资深专家John Sharp,再度演绎更SHARP的C#；覆盖面广，知识点新，在讲透C基础知识的同时充分展示C#新增特性；风靡全球，指导读者高效开发c#组件和windOWS应用程序的最佳指南。透过《Visual C#2008从入门到精通》，读者可在专家的悉心指导下学习并掌握Visual c#2008基础知识，一次一个步骤，循序渐进地掌握c#编程技术，从而开发出优秀的c#组件和windows应用程序。《Visual C#2008从入门到精通》重要主题：声明变量，编写语句，创建操作符和调用方法、捕捉和处理异常、通过析构函数和垃圾回收机制来管理资源、定义属性和索引器，处理事件、使用泛型来定义类型安全的类和集合、通过ADO．NET和语言集成查询(LINQ)来操作数据、创建交互式web应用程序，构建web服务。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第I部分  Visual C#和Visual Studio 2008概述</span><br><span class="line">第1章  欢迎进入C#编程世界3</span><br><span class="line">1.1  开始在Visual Studio 2008环境中编程3</span><br><span class="line">1.2  编写第一个程序7</span><br><span class="line">1.3  使用命名空间12</span><br><span class="line">1.4  创建图形应用程序14</span><br><span class="line">第1章快速参考23 </span><br><span class="line"></span><br><span class="line"> 第2章 使用变量、操作符和表达式25 2.1 理解语句25 2.2 使用标识符26 2.3 标识关键字26 2.4 使用变量27 2.4.1 命名变量27 2.4.2 声明变量28 2.5 使用基本数据类型28 2.6 使用算术操作符33 2.6.1 操作符和数据类型33 2.6.2 深入了解算术操作符34 2.6.3 控制优先级37 2.6.4 使用结合性对表达式进行求值37 2.6.5 结合性和赋值操作符38 2.7 变量的递增和递减38 2.8 声明隐式类型的局部变量40 第2章快速参考41</span><br><span class="line"></span><br><span class="line"> 第3章 方法和作用域42 3.1 声明方法42 3.1.1 指定方法声明语法42 3.1.2 写return语句43 3.2 调用方法45 3.3 使用作用域47 3.3.1 定义局部作用域47 3.3.2 定义类的作用域48 3.3.3 重载方法49 3.4 编写方法49 第3章快速参考56</span><br><span class="line"></span><br><span class="line"> 第4章 使用决策语句57 4.1 声明布尔变量57 4.2 使用布尔操作符58 4.2.1 理解相等和关系操作符58 4.2.2 理解条件逻辑操作符58 4.2.3 操作符的优先级和结合性总结60 4.3 使用if语句来做出决策60 4.3.1 理解if语句的语法61 4.3.2 使用代码块来对语句进行分组62 4.3.3 嵌套if语句62 4.4 使用switch语句67 4.4.1 理解switch语句的语法67 4.4.2 遵守switch语句的规则68 第4章快速参考71</span><br><span class="line"></span><br><span class="line"> 第5章 使用复合赋值和循环语句73 5.1 使用复合赋值操作符73 5.2 使用while语句74 5.3 编写for语句78 5.4 编写do语句80 第5章快速参考87</span><br><span class="line"></span><br><span class="line"> 第6章 管理错误和异常88 6.1 处理错误88 6.2 尝试代码和捕捉异常88 6.2.1 处理异常89 6.2.2 未处理的异常89 6.2.3 使用多个catch处理程序90 6.2.4 捕捉多个异常91 6.3 使用checked和unchecked整数运算95 6.3.1 编写checked语句95 6.3.2 编写checked表达式96 6.4 抛出异常97 6.5 使用finally块101 第6章快速参考102</span><br><span class="line"></span><br><span class="line"> 第II部分 理解C#语言 第7章 创建并管理类和对象107 7.1 理解分类107 7.2 封装的目的108 7.3 定义并使用类108 7.4 控制可访问性109 7.5 使用构造函数110 7.6 理解static方法和数据118 7.6.1 创建共享字段119 7.6.2 使用const关键字来创建static字段120 第7章快速参考124</span><br><span class="line"></span><br><span class="line"> 第8章 理解值和引用126 8.1 复制值类型的变量和类126 8.2 理解null值和可空值130 8.2.1 使用可空类型131 8.2.2 理解可为空类型的属性132 8.3 使用ref和out参数132 8.3.1 创建ref参数133 8.3.2 创建out参数134 8.4 计算机内存的组织方式136 8.5 System.Object类137 8.6 装箱138 8.7 拆箱139 8.8 数据类型的安全转换140 8.8.1 is操作符140 8.8.2 as操作符141 第8章快速参考143</span><br><span class="line"></span><br><span class="line"> 第9章 使用枚举和结构来创建值类型145 9.1 使用枚举145 9.1.1 声明枚举145 9.1.2 使用枚举146 9.1.3 选择枚举文字常量值146 9.1.4 选择枚举的基本类型147 9.2 使用结构149 9.2.1 声明结构151 9.2.2 理解结构和类的区别152 9.2.3 声明结构变量153 9.2.4 理解结构的初始化154 9.2.5 复制结构变量155 第9章快速参考158</span><br><span class="line"></span><br><span class="line"> 第10章 使用数组和集合160 10.1 什么是数组160 10.1.1 声明数组变量160 10.1.2 创建数组实例161 10.1.3 初始化数组变量162 10.1.4 创建隐式类型转换的数组163 10.1.5 访问单独的数组元素163 10.1.6 遍历数组164 10.1.7 复制数组165 10.2 什么是集合类166 10.2.1 ArrayList集合类168 10.2.2 Queue集合类170 10.2.3 Stack集合类170 10.2.4 Hashtable集合类171 10.2.5 SortedList集合类172 10.2.6 使用集合初始值列表173 10.2.7 比较数组和集合174 10.2.8 使用集合类来玩牌174 第10章快速参考179</span><br><span class="line"></span><br><span class="line"> 第11章 理解参数数组180 11.1 使用数组参数181 11.1.1 声明params数组182 11.1.2 使用params object[]183 11.1.3 Console.WriteLine方法184 11.1.4 使用params数组185 第11章快速参考188</span><br><span class="line"></span><br><span class="line"> 第12章 使用继承189 12.1 什么是继承189 12.2 使用继承190 12.2.1 基类和派生类190 12.2.2 调用基类构造函数191 12.2.3 类的赋值193 12.2.4 声明new方法194 12.2.5 声明virtual方法195 12.2.6 声明override方法196 12.2.7 理解protected访问199 12.3 理解扩展方法204 第12章快速参考207</span><br><span class="line"></span><br><span class="line"> 第13章 创建接口和定义抽象类209 13.1 理解接口209 13.2 接口的限制210 13.2.1 实现接口211 13.2.2 通过接口来引用一个类212 13.2.3 使用多个接口213 13.3 抽象类213 13.4 密封类215 13.5 实现可扩展的框架216 13.6 总结关键字组合223 第13章快速参考224</span><br><span class="line"></span><br><span class="line"> 第14章 使用垃圾回收和资源管理225 14.1 对象的生存期225 14.1.1 编写析构函数226 14.1.2 为什么要使用垃圾回收器228 14.1.3 垃圾回收器的工作机理229 14.1.4 慎用析构函数229 14.2 资源管理230 14.2.1 disposal方法230 14.2.2 异常安全的disposal方法230 14.2.3 using语句231 14.2.4 从析构函数中调用Dispose方法233 14.3 使代码为异常安全的234 第14章快速参考236</span><br><span class="line"></span><br><span class="line"> 第III部分 创建组件 第15章 实现属性以访问字段241 15.1 使用方法来实现封装241 15.2 什么是属性243 15.2.1 使用属性244 15.2.2 只读属性245 15.2.3 只写属性245 15.2.4 属性的可访问性246 15.3 理解属性的局限性247 15.4 在接口中声明属性248 15.5 生成自动属性251 15.6 使用属性来初始化对象252 第15章快速参考256</span><br><span class="line"></span><br><span class="line"> 第16章 使用索引器259 16.1 什么是索引器259 16.1.1 没有使用索引器的例子259 16.1.2 使用索引器的同一个例子261 16.1.3 理解索引器的accessor262 16.1.4 对比索引器和数组263 16.2 接口中的索引器265 16.3 在Windows应用程序中使用索引器266 第16章快速参考271</span><br><span class="line"></span><br><span class="line"> 第17章 中断程序流程并处理事件272 17.1 声明和使用委托272 17.1.1 自动化工厂的例子273 17.1.2 不使用委托来实现工厂273 17.1.3 使用委托来实现工厂274 17.1.4 使用委托276 17.2 Lambda表达式和委托279 17.2.1 创建方法适配器279 17.2.2 将lambda表达式作为适配器使用280 17.2.3 lambda表达式的形式281 17.3 启用事件通知282 17.3.1 声明事件282 17.3.2 订阅事件283 17.4 取消订阅事件284 17.5 理解WPF用户界面事件285 第17章快速参考288</span><br><span class="line"></span><br><span class="line"> 第18章 泛型概述291 18.1 object存在的问题291 18.2 泛型解决方案293 18.2.1 对比泛型类与泛化类295 18.2.2 泛型和约束295 18.3 创建泛型类295 18.3.1 二叉树理论295 18.3.2 使用泛型来构造二叉树类298 18.4 创建泛型方法307 第18章快速参考310</span><br><span class="line"></span><br><span class="line"> 第19章 枚举集合311 19.1 枚举集合中的元素311 19.1.1 手动实现枚举器312 19.1.2 实现IEnumerable接口316 19.2 使用迭代器来实现枚举器318 19.2.1 一个简单的迭代器318 19.2.2 使用迭代器为Tree类定义枚举器320 第19章快速参考322</span><br><span class="line"></span><br><span class="line"> 第20章 使用查询表达式来查询内存中的数据324 20.1 什么是语言集成查询324 20.2 在C#应用程序中使用LINQ325 20.2.1 选择数据326 20.2.2 筛选数据329 20.2.3 排序、分组和聚合数据329 20.2.4 联接数据331 20.2.5 使用查询操作符333 20.2.6 查询Tree对象中的数据334 20.2.7 LINQ和推迟求值339 第20章快速参考343</span><br><span class="line"></span><br><span class="line"> 第21章 操作符重载345 21.1 理解操作符345 21.1.1 操作符的限制345 21.1.2 重载的操作符346 21.1.3 创建对称操作符347 21.2 理解复合赋值349 21.3 声明递增操作符和递减操作符350结构和类中的操作符351 21.4 定义操作符对352 21.5 实现一个操作符353 21.6 理解转换操作符355 21.6.1 提供内建转换355 21.6.2 实现用户自定义的转换操作符356 21.6.3 再论创建对称操作符357 21.6.4 添加隐式转换操作符358 第21章快速参考360</span><br><span class="line"></span><br><span class="line"> 第IV部分 操纵Windows应用程序 第22章 Windows Presentation Foundation概述363 22.1 创建WPF应用程序363 22.2 在窗体上添加控件376 22.2.1 使用WPF控件376 22.2.2 动态更改属性384 22.3 处理WPF窗体中的事件388 第22章快速参考392</span><br><span class="line"></span><br><span class="line"> 第23章 使用菜单和对话框394 23.1 菜单设计原则和样式394 23.2 菜单和菜单事件395 23.2.1 创建菜单395 23.2.2 处理菜单事件400 23.3 快捷菜单405 23.4 Windows通用对话框409 第23章快速参考412</span><br><span class="line"></span><br><span class="line"> 第24章 执行校验414 24.1 验证数据414 24.2 示例：客户资料维护415 24.2.1 使用数据绑定来执行校验415 24.2.2 改变校验时机431 第24章快速参考434</span><br><span class="line"></span><br><span class="line"> 第V部分 管理数据 第25章 查询数据库中的信息439 25.1 使用ADO.NET查询数据库439 25.1.1 Northwind数据库440 25.1.2 创建数据库440 25.1.3 使用ADO.NET查询订单信息442 25.2 使用DLINQ查询数据库450 25.2.1 定义实体类450 25.2.2 创建并运行DLINQ查询452 25.2.3 推迟取回和立即取回454 25.2.4 联接表和创建关系454 25.2.5 再论推迟取回和立即取回458 25.2.6 定义自定义的DataContxt类459 25.2.7 用DLINQ查询订单信息460 第25章快速参考464</span><br><span class="line"></span><br><span class="line"> 第26章 使用数据绑定显示和编辑数据465 26.1 DLINQ和数据绑定465 26.2 用DLINQ修改数据478 26.2.1 更新现有数据478 26.2.2 处理冲突的更新479 26.2.3 添加和删除数据481 第26章快速参考488</span><br><span class="line"></span><br><span class="line"> 第VI部分 构建Web应用程序 第27章 ASP.NET概述491 27.1 将Internet作为一个基础结构来理解491 27.1.1 理解Web服务器请求和应答492 27.1.2 管理状态492 27.1.3 理解ASP.NET493 27.2 使用ASP.NET创建Web应用程序494 27.2 1 构建ASP.NET应用程序495 27.2.2 理解Server控件504 27.2.3 创建和使用主题511 第27章快速参考514</span><br><span class="line"></span><br><span class="line"> 第28章 理解Web窗体校验控件515 28.1 服务器端和客户端校验的比较515 28.1.1 在Web服务器校验数据515 28.1.2 在Web浏览器校验数据516 28.1.3 实现客户端校验517 28.2 第28章快速参考523</span><br><span class="line"></span><br><span class="line"> 第29章 保护网站安全并使用Web窗体访问数据524 29.1 理解安全性524 29.1.1 理解基于窗体的安全性524 29.2.2 实现基于窗体的安全性525 29.2 查询和显示数据531 29.2.1 理解Web窗体的GridView控件531 29.2.2 显示客户和订单历史信息532 29.2.3 分页显示数据535 29.3 编辑数据537 29.4 在窗体之间导航538 第29章快速参考544</span><br><span class="line"></span><br><span class="line"> 第30章 创建和使用Web服务546 30.1 Web服务的定义546 30.1.1 SOAP所扮演的角色547 30.1.2 Web 服务描述语言547 30.1.3 Web服务的非功能性需求548 30.1.4 Windows Communication Foundation的角色549 30.2 构建Web服务550 30.3 Web服务、客户端和代理558 30.3.1 支持SOAP：难的方法558 30.3.2 支持SOAP：简单的方法558 30.3.3 消费ProductsService Web服务559 第30章快速参考564 索引565</span><br><span class="line"></span><br><span class="line">   &lt;&#x2F;titem&gt;&lt;&#x2F;titem&gt;</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001O0DI18/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001O0DI18&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51nb99DmBYL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>C#深入详解:百问•百答•百例</title>
    <url>/2020/04/19/B0018YDW2A/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C#深入详解:百问•百答•百例<br>作者信息： 作者: 王寅永 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《C#深入详解:百问•百答•百例》内容丰富，结构清晰，通过300多个独家精彩实例和2个大型真实项目示例，帮助开发人员从实践中成长。《C#深入详解:百问•百答•百例》是C#初学者的入门指导书，同样适合具备一定编程经验的开发人员。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 .NET基础体系结构</span><br><span class="line">1.1 什么是.NET</span><br><span class="line">1.2 我们为什么需要.NET技术</span><br><span class="line">1.3 什么是.NET Framework</span><br><span class="line">1.4 .NET和J2EE的相同点和不同点</span><br><span class="line">1.5 .NET和C# 之间的关系</span><br><span class="line">1.6 C#语言的特点</span><br><span class="line">1.7 C#程序的编译运行</span><br><span class="line">1.7.1 什么是CLI</span><br><span class="line">1.7.2 什么是CLR</span><br><span class="line">1.7.3 什么是IL</span><br><span class="line">1.7.4 C#程序是如何编译运行的</span><br><span class="line">第2章 C#开发环境</span><br><span class="line">2.1 C#语言需要的开发工具</span><br><span class="line">2.2 软件的安装、卸载</span><br><span class="line">2.2.1 安装Visual Studio 2005需要的软、硬件配置</span><br><span class="line">2.2.2 安装Visual Studio 2005需要的权限设置</span><br><span class="line">2.2.3 并行安装Visual Studio版本</span><br><span class="line">2.2.4 进行.NET Framework版本的并行安装</span><br><span class="line">2.2.5 安装IIS</span><br><span class="line">2.2.6 安装Visual Studio 2005</span><br><span class="line">2.2.7 卸载</span><br><span class="line">2.3 Visual Studio 2005开发环境实际应用</span><br><span class="line">2.3.1 管理解决方案、项目和文件</span><br><span class="line">2.3.1.1 创建解决方案</span><br><span class="line">2.3.1.2 创建解决方案的目录</span><br><span class="line">2.3.1.3 更改或添加默认编辑器</span><br><span class="line">2.3.1.4 升级使用Visual Studio .NET2002或Visual Studio .NET2003创建的项目</span><br><span class="line">2.3.1.5 设置启动项目</span><br><span class="line">2.3.1.6 修改项目属性和配置设置</span><br><span class="line">2.3.1.7 添加新项目项</span><br><span class="line">2.3.1.8 复制项目</span><br><span class="line">2.3.1.9 删除或移除项目</span><br><span class="line">2.3.1.10 卸载和重新加载项目</span><br><span class="line">2.3.1.11 移动项</span><br><span class="line">2.3.1.12 刷新解决方案资源管理器中的项</span><br><span class="line">2.3.1.13 如何重命名解决方案、项目和项</span><br><span class="line">2.3.2 项目属性</span><br><span class="line">2.3.2.1 指定程序集信息</span><br><span class="line">2.3.2.2 更改程序集名称</span><br><span class="line">2.3.2.3 更改应用程序的命名空间</span><br><span class="line">2.3.2.4 启用或禁用编译器警告</span><br><span class="line">2.3.2.5 更改应用程序的生成位置</span><br><span class="line">2.3.2.6 为项目生成XML文档</span><br><span class="line">2.3.2.7 设置编译常量</span><br><span class="line">2.3.2.8 针对特定的CPU类型优化应用程序</span><br><span class="line">2.3.2.9 在Visual Studio中添加或移除引用</span><br><span class="line">2.3.2.10 设置引用的Copy Local属性</span><br><span class="line">2.3.2.11 添加或移除字符串资源</span><br><span class="line">2.3.2.12 访问设置事件</span><br><span class="line">2.3.2.13 对应用程序和部署清单进行签名</span><br><span class="line">2.3.2.14 对程序集进行签名</span><br><span class="line">2.3.2.15 设置引用路径</span><br><span class="line">2.3.2.16 设置生成属性</span><br><span class="line">2.3.2.17 指定生成事件</span><br><span class="line">2.3.3 编辑代码和资源文件</span><br><span class="line">2.3.3.1 选择和更改文本</span><br><span class="line">2.3.3.2 显示代码大纲和隐藏代码</span><br><span class="line">2.3.3.3 在编辑器中管理自动换行</span><br><span class="line">2.3.3.4 在编辑器中显示行号</span><br><span class="line">2.3.3.5 在编辑器中将URL显示为链接</span><br><span class="line">2.3.3.6 以递增方式搜索文档</span><br><span class="line">2.3.3.7 交互式搜索</span><br><span class="line">2.3.4 生成、调试和测试</span><br><span class="line">2.3.4.1 启用&#x2F;禁用实时调试</span><br><span class="line">2.3.4.2 设置简单断点</span><br><span class="line">2.3.4.3 启用SQL Server 2005调试</span><br><span class="line">2.3.4.4 更改应用程序调试的启动操作</span><br><span class="line">2.3.4.5 设置应用程序调试的启动选项</span><br><span class="line">2.3.4.6 启用远程调试</span><br><span class="line">第3章 编写第一个C#程序</span><br><span class="line">……</span><br><span class="line">第9章 项目实践</span><br><span class="line">附录A C#关键字</span><br><span class="line">附录B C#的错误码</span><br><span class="line">参考文献</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0018YDW2A/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0018YDW2A&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51fN8Bqq%2BiL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual C++2008入门经典</title>
    <url>/2020/04/19/B001TREP5O/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Visual C++2008入门经典<br>作者信息： 作者: 霍顿 (HORTON I.) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Visual C++2008入门经典》学习目标：<br>使用标准模板库（STL）来组织和操作本地C++程序中的数据<br>C++程序调试技术<br>构造Microsoft Windows应用程序的技术以及每个应用程序的基本元素<br>创建和使用常用控件构建应用程序的图形用户界面<br>使用MFC开发库<br>访问数据源的不同控件、控件的工作方式以及定制控件的方法<br>《Visual C++2008入门经典》适用于想学习如何为Windows操作系统编写C++程序的初学者，学习《Visual C++2008入门经典》内容无需任何编程基础。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 使用Visual C++ 2008编程</span><br><span class="line">第2章 数据、变量和计算</span><br><span class="line">第3章 判断和循环</span><br><span class="line">第4章 数组、字符串和指针</span><br><span class="line">第5章 程序结构（1）</span><br><span class="line">第6章 程序结构（2）</span><br><span class="line">第7章 自定义数据类型</span><br><span class="line">第8章 深入理解类</span><br><span class="line">第9章 类继承和虚函数</span><br><span class="line">第10章 标准模板库</span><br><span class="line">第11章 调试技术</span><br><span class="line">第12章 Windows编程的概念</span><br><span class="line">第13章 使用MFC编写Windows程序</span><br><span class="line">第14章 处理菜单和工具栏</span><br><span class="line">第15章 在窗口中绘图</span><br><span class="line">第16章 创建文档和改进视图</span><br><span class="line">第17章 使用对话框和控件</span><br><span class="line">第18章 存储和打印文档</span><br><span class="line">第19章 编写自己的DLL</span><br><span class="line">第20章 连接到数据源</span><br><span class="line">第21章 更新数据源</span><br><span class="line">第22章 Windows Forms应用程序进阶</span><br><span class="line">第23章 在Windows Forms 应用程序中访问数据源</span><br><span class="line">附录A C++关键字</span><br><span class="line">附录B ASCII码</span><br><span class="line">附录C Windows消息类型</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001TREP5O/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001TREP5O&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51oVl957mgL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法(C#语言版)(影印版)</title>
    <url>/2020/04/19/B0027VTNBM/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 数据结构与算法(C#语言版)(影印版)<br>作者信息： 作者: 麦克米兰 (Mcmillan.M) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《数据结构与算法(C#语言版)(影印版)》为大学计算机教育国外著名教材系列之一。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Preface page vii</span><br><span class="line">Chapter 1</span><br><span class="line">An Introduction to Collections, Generics, and the</span><br><span class="line">Timing Class 1</span><br><span class="line">Chapter 2</span><br><span class="line">Arrays and ArrayLists 26</span><br><span class="line">Chapter 3</span><br><span class="line">Basic Sorting Algorithms 42</span><br><span class="line">Chapter 4</span><br><span class="line">Basic Searching Algorithms SS</span><br><span class="line">Chapter 5</span><br><span class="line">Stacks and Queues 68</span><br><span class="line">Chapter 6</span><br><span class="line">The BitArray Class 94</span><br><span class="line">Chapter 7</span><br><span class="line">StringS, the String Class, and the StringBuilder Class 119</span><br><span class="line">Chapter 8</span><br><span class="line">Pattern Matching and T6xt Processing 147</span><br><span class="line">Chapter 9</span><br><span class="line">Building Dictionaries: The DictionaryBase Class and the</span><br><span class="line">SortedList Class 165</span><br><span class="line">Chapter 10</span><br><span class="line">Hashing and the Hashtable Class 176</span><br><span class="line">Chapter 11</span><br><span class="line">Link6d Lists 194</span><br><span class="line">Chapter 12</span><br><span class="line">Binary Trees and Binary Search Trees 218</span><br><span class="line">Chapter 13</span><br><span class="line">Sets 237</span><br><span class="line">Chapter 14</span><br><span class="line">Advanced Sorting Algorithms 249</span><br><span class="line">Chapter 15</span><br><span class="line">Advanced Data Structures and Algorithms for Searching 263</span><br><span class="line">Chapter 16</span><br><span class="line">Graphs and Graph Algorithms 283</span><br><span class="line">Chapter 17</span><br><span class="line">Advanced Algorithms 314</span><br><span class="line">Ref6rences 339</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0027VTNBM/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0027VTNBM&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51uGNA9HCFL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS Web设计高级教程(第2版)</title>
    <url>/2020/04/19/B002IIE01M/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： CSS Web设计高级教程(第2版)<br>作者信息： 作者: 施密特 (Schmitt.C.) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《CSS Web设计高级教程(第2版)》由浅入深地对基于Web标准的大规模专业级CSSWeb站点进行了研究，对一些常见问题提供了易于理解的解决方法，对如何高效开发以CSS驱动的专业级Web设计给出了实用的方案。《CSS Web设计高级教程(第2版)》主要内容使用含CSS的XHTML的最佳实践如何使博客在外观和感觉上焕然一新一个拥有数百万用户的Web站点的设计细节在Web站点中包含阴影、下拉菜单和嵌入式Flash内容的技术解决浏览器兼容问题和开发功能性导航结构的技巧通过CSS编码定制Web站点的方法如何创建HTMLEmail模板和基本HTML表格布局，以及CSS在文中所起的作用网格和布局对设计的重要性《CSS Web设计高级教程(第2版)》读者对象《CSS Web设计高级教程(第2版)》针对希望透彻了解如何用CSS仓，J建专业水平Web站点的Web开发人员。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 有关XHTML和CSS的最佳实例</span><br><span class="line">1.1 把结构和表现标记硬挤在一起</span><br><span class="line">1.2 学习并热衷于使用标记</span><br><span class="line">1.2.1 XHTML：新热点</span><br><span class="line">1.2.2 从结构提取样式</span><br><span class="line">1.3 CSS：添加样式层</span><br><span class="line">1.3.1 更好地了解选择符</span><br><span class="line">1.3.2 其他选择符</span><br><span class="line">1.3.3 多重声明组合</span><br><span class="line">1.3.4 对选择符进行分组</span><br><span class="line">1.3.5 继承</span><br><span class="line">1.3.6 综合应用</span><br><span class="line">1.4 了解层叠</span><br><span class="line">1.4.1 探寻样式来源</span><br><span class="line">1.4.2 根据优先级排序</span><br><span class="line">1.4.3 根据顺序排序</span><br><span class="line">1.5 把理论应用于实践</span><br><span class="line">1.5.1 基于可靠浏览器进行构建</span><br><span class="line">1.5.2 理性对待hack</span><br><span class="line">1.5.3 与hack有关的问题</span><br><span class="line">1.5.4 编写hack的技巧</span><br><span class="line">1.6 小结 </span><br><span class="line"></span><br><span class="line"> 第2章 GoogIe的blogger.com：翻转器和设计思想 2.1 设计人员访谈 2.2 CSS驱动的翻转器 2.2.1 改变链接的颜色和背景色（简单） 2.2.2 改变链接的颜色和背景色（复杂） 2.2.3 所要完成的工作 2.2.4 改变表格行的背景色 2.2.5 改变文本颜色 2.2.6 改变链接的背景位置 2.3 小结</span><br><span class="line"></span><br><span class="line"> 第3章 经典的美国职业高尔夫联盟锦标赛网站 3.1 阴影效果的实现 3.1.1 创建幻觉效果 3.1.2 使阴影更真实 3.2 创建CSS下拉菜单 3.2.1 定制下拉菜单位置 3.2.2 定制下拉菜单的样式 3.3 与Web标准兼容的Flash嵌入 3.3.1 使用Flash Satay方法 3.3.2 用JavaScript编写object&#x2F;embed标签 3.3 3 SWFObeject 3.4 小结</span><br><span class="line"></span><br><span class="line"> 第4章 佛罗里达大学主页UFL.edu 4.1 UF第一个Web站点回顾 4.1.1 对修改版本的反思 4.1.2 对目前网站的分析 4.2 网站定义 4.2.1 组建开发团队 4.2.2 从用户研究着手 4.2.3 自我检查 4.2.4 定义技术规范 4.3 构建主导航结构 4.3.1 XHTML 4.3.2 CSS 4.3.3 图像 4.3.4 实现细节 4.3.5 边框的构建 4.3.6 段落题头样式 4.3.7 列表样式 4.4 实现辅助导航 4.4.1 XHTML 4.4.2 CSS&quot; 4.5 再论Flash的嵌入 4.5.1 FlashSatay方法回顾 4.5.2 服务器端的FlashSatay检测 4.6 寻找设计中的失误 4.6.1 仅凭示例引导 4.6.2 “习惯势力”和“谁移动了我的输入框 4.7 小结</span><br><span class="line"></span><br><span class="line"> 第5章 StuffandNonsenseCSS切换策略 5.1 基础准备 5.2 CSS切换 5.3 工作机制 5.3.1 永久样式表 5.3.2 首选样式表 5.3.3 备选样式表 5.3.4 又一个(几乎)完全不能用的方案 5.4 目前的解决方案 5.4.1 转向JavaScript 5.4.2 PHP方案 5.5 超越浏览器的CSS 5.5.1 媒体类型：康复的开始 5.5.2 选择问题 5.6 StufandNonsense：创建一个更好的切换器 5.7 设计师AndyClarke访谈 5.8 小结</span><br><span class="line"></span><br><span class="line"> 第6章 CindyLicom的风险投资：博客修改山 6.1 博客 6.2 CSS：CindyLi开博客 6.3 设计要素 6.3.1 创建布局 6.3.2 对设计进行布局 6.4 创建站点 6.4.1 设计导航条 6.4.2 创建翻转图形 6.4.3 设置导航标记和css 6.4.4 整合翻转器 6.5 设置说话框 6.5.1 说话框编码 6.5.2 再次应用这种效果 6.5.3 添加Flickr徽章 6.6 复选框样式 6.7 小结</span><br><span class="line"></span><br><span class="line"> 第7章 AIGA辛辛那提分会：HTMLemail模板 7.1 HTMLEamil简介 7.2 制造模板 7.2.1 打印设计 7.2.2 创建HTML表格布局 7.2.3 对设计进行调整 7.2.4 对HTMLemail模板的CSS规则的效果分析 7.3 嵌入样式 7.4 为HTMLemail进行预处理 7.5 小结</span><br><span class="line"></span><br><span class="line"> 第8章 专业CSS图书网站：透明PNG图像的使用 8.1 PNG和浏览器支持 8.1.1 在IE6中使用PNG的图像过滤方案 8.1.2 在IE6中使用PNG的HTC脚本方案 8.1.3 PNG图像的颜色问题 8.2 使用Alpha透明 8.2.1 更好的阴影 8.2.2 使用彩色阴影 8.3 小结</span><br><span class="line"></span><br><span class="line"> 第9章 构建CSS布局 9.1 网格与布局 9.2 做打印所不能做的事 9.3 CSS定位基本原理 9.3.1 功能强大的绝对定位 9.3.2 在相对定位容器内的绝对定位 9.4 创建三栏：布局的基础 9.4.1 编写XHTML从模式到标记 9.4.2 样式层 9.4.3 解决浏览器错误 9.4.4 IE5x十／Win 9.5 设置边界：max－wido属性 9.6 小结</span><br><span class="line"></span><br><span class="line"> 附录A HTML4.01元素 附录B 从HTML到XHTML的转换规则 附录C CSS2.1 属性 附录D CSS故障排除指南</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B002IIE01M/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B002IIE01M&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51gCvSbSBGL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>Advanced C++</title>
    <url>/2020/04/19/advanced-cpp/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Advanced C++<br>作者信息： 作者: Coplien [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>假定读者已经具备C++基本知识，本书通过展示C++语言风格和习惯用法，帮助读者提升C++的程序设计经验。这些方法围绕C++支持的抽象机制实施的：抽象数据类型，继承结构中的组合类型，面向对象程序设计以及我重继承。本书还展示了C++语言间接支持的核心习惯用法，诸如虚拟构造函数、原型对象以及高级垃圾收集技术。<br>本书要点：<br>·展示了使用C++高级技术所获得的好处和潜在的缺陷。<br>·用少而精的例子展示如何有效地组合C++抽象机制。<br>·提供了大量面向对象设计转换成C++实现的准则。<br>·展示了如何用模板支持可重用性。<br>·描述了重要的大型系统开发问题，包括库结构的设计、异常处理和分布式处理。<br>·本书是C++系统程序员或应用程序员工作的必备手册。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">译者序</span><br><span class="line">序 言</span><br><span class="line">第1章 引言</span><br><span class="line">1. 1 C++语言演变的历史</span><br><span class="line">1. 2 处理复杂结构的习惯用法</span><br><span class="line">1. 3 对象</span><br><span class="line">1. 4 设计和语言</span><br><span class="line">练习</span><br><span class="line">第2章 数据抽象和抽象数据类型</span><br><span class="line">2. 1 类</span><br><span class="line">2. 2 对象转换</span><br><span class="line">2. 3 构造函数和析构函数</span><br><span class="line">2. 4 内联(inline)函数</span><br><span class="line">2. 5 静态数据成员的初始化</span><br><span class="line">2. 6 作用域和const</span><br><span class="line">2. 7 全局对象. 常数和静态类成员初始化次序</span><br><span class="line">2. 8 类对象成员函数的const执行</span><br><span class="line">2. 9 指向成员函数的指针</span><br><span class="line">2. 10 程序组织的习惯约定</span><br><span class="line">练习</span><br><span class="line">第3章 具体数据类型</span><br><span class="line">3. 1 传统规范类格式</span><br><span class="line">3. 2 作用域和访问控制</span><br><span class="line">3. 3 重载：重定义操作和函数的语义</span><br><span class="line">3. 4 类型转换</span><br><span class="line">3. 5 引用计数：使用&quot;可调内存&quot;变量</span><br><span class="line">3. 6 操作符new和delete</span><br><span class="line">3. 7 把初始化从实例化中分离出来</span><br><span class="line">练习</span><br><span class="line">第4章 继承性</span><br><span class="line">4. 1 简单继承</span><br><span class="line">4. 2 作用域和访问控制</span><br><span class="line">4. 3 构造函数和析构函数</span><br><span class="line">4. 4 类指针转换</span><br><span class="line">4. 5 类型选择域</span><br><span class="line">练习</span><br><span class="line">第5章 面向对象程序设计</span><br><span class="line">5. 1 C++运行时类型支持：虚拟函数</span><br><span class="line">5. 2 虚拟析构函数</span><br><span class="line">5. 3 虚拟函数和作用域</span><br><span class="line">5. 4 纯虚拟函数和抽象基类</span><br><span class="line">5. 5 信封和信件类</span><br><span class="line">5. 6 功能元件：作为对象的函数</span><br><span class="line">5. 7 多重继承</span><br><span class="line">5. 8 继承的规范格式</span><br><span class="line">5. 9 例子</span><br><span class="line">练习</span><br><span class="line">第6章 面向对象设计</span><br><span class="line">6. 1 类型和类</span><br><span class="line">6. 2 面向对象设计的实践活动</span><br><span class="line">6. 3 面向对象分析和领域分析</span><br><span class="line">6. 4 对象和类的关系</span><br><span class="line">6. 5 子类型. 继承和转发</span><br><span class="line">6. 6 子类型. 继承和独立性的经验规则</span><br><span class="line">练习</span><br><span class="line">第7章 重用和对象</span><br><span class="line">7. 1 所有模拟的分解放到何处</span><br><span class="line">7. 2 设计重用</span><br><span class="line">7. 3 4种代码重用机制</span><br><span class="line">7. 4 参数化类型或模板</span><br><span class="line">7. 5 私有继承：继承支持重用吗</span><br><span class="line">7. 6 存储重用</span><br><span class="line">7. 7 接口重用：变体</span><br><span class="line">7. 8 重用. 继承和转发</span><br><span class="line">7. 9 源代码重用结构的选择</span><br><span class="line">7. 10 在重用和对象上的概括</span><br><span class="line">练习</span><br><span class="line">第8章 C++中的样本程序设计</span><br><span class="line">8. 1 雇员样本的例子</span><br><span class="line">8. 2 样本和类属构造函数：样本共用的习惯用法</span><br><span class="line">8. 3 自主的类属构造函数</span><br><span class="line">8. 4 抽象基样本</span><br><span class="line">8. 5 关于样本习惯用法框架</span><br><span class="line">8. 6 相关的表示</span><br><span class="line">8. 7 样本和程序的管理</span><br><span class="line">练习</span><br><span class="line">第9章 在C++中模拟符号语言的风格</span><br><span class="line">9. 1 增量式C++开发</span><br><span class="line">9. 2 符号规范格式</span><br><span class="line">9. 3 通用收集类的例子</span><br><span class="line">9. 4 支持增量装入的代码和习惯用法</span><br><span class="line">9. 5 垃圾收集</span><br><span class="line">9. 6 基本类型的封装</span><br><span class="line">9. 7 在符号习惯用法下的多重方法</span><br><span class="line">练习</span><br><span class="line">第10章 动态多重继承</span><br><span class="line">10. 1 多重技术窗口系统的例子</span><br><span class="line">10. 2 防止误解的说明</span><br><span class="line">练习</span><br><span class="line">第11章 系统性问题</span><br><span class="line">11. 1 静态系统设计</span><br><span class="line">11. 2 动态系统设计</span><br><span class="line">练习</span><br><span class="line">附录A C++环境中的C</span><br><span class="line">A. 1 函数调用</span><br><span class="line">A. 2 函数参数表</span><br><span class="line">A. 3 函数原型</span><br><span class="line">A. 4 调用引用参数</span><br><span class="line">A. 5 参数个数不定</span><br><span class="line">A. 6 函数指针</span><br><span class="line">A. 7 const类型说明符</span><br><span class="line">A. 8 C代码的接口</span><br><span class="line">A. 9 操作符引用返回值</span><br><span class="line">练习</span><br><span class="line">附录B Shapes程序的C++代码</span><br><span class="line">附录C 符号的Shapes</span><br><span class="line">附录D C++中块结构程序设计</span><br><span class="line">D. 1 什么是块结构程序设计</span><br><span class="line">D. 2 构造基本块结构的C++程序设计</span><br><span class="line">D. 3 有深度嵌套作用域块的选择</span><br><span class="line">D. 4 块结构的视频游戏代码</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0011AN2TO/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0011AN2TO&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51XGz9YQEvL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员突击 VISUAL C#2008原理与系统开发</title>
    <url>/2020/04/19/B002M77TDA/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 程序员突击 VISUAL C#2008原理与系统开发<br>作者信息： 作者: 欧阳炜昊 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《程序员突击:VISUAL C#2008原理与系统开发》由清华大学出版社出版的。由浅入深、循序渐进，真正全面掌握系统开发技术。以真实的项目开发与实现为主线，对各个设计元素进行深入讲解。精选多个典型案例，并结合基础知识对系统进行分析、设计与编程实现。对主流框架进行详细分析并整合至真实项目中。强大的技术支持，读者可在学赛网社区“书评在线”版块中与作者进行直接交流。丰富的程序资源，读者也可以在希赛网下载中心或学赛网下载中心下载本书所有实例的源代码和实战项目的源代码。程序员突击系列。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一篇 步入Visual C# 2008开发的殿堂</span><br><span class="line">第1章 Visual C# 2008简介</span><br><span class="line">1.1 .NET平台和.NET框架概述</span><br><span class="line">1.1.1 .NET平台</span><br><span class="line">1.1.2 .NET框架</span><br><span class="line">1.2 Visual C# 2008开发环境</span><br><span class="line">1.2.1 Visual Studio 2008概述</span><br><span class="line">1.2.2 Visual C# 2008集成开发环境</span><br><span class="line">1.3 创建一个简单的Visual C# Windows应用程序</span><br><span class="line">1.4 小结 </span><br><span class="line"></span><br><span class="line"> 第2章 C#面向对象程序设计 2.1 类的概述 2.1.1 类的定义 2.1.2 创建类实例 2.1.3 类成员 2.1.4 构造函数 2.1.5 方法 2.1.6 字段与属性 2.1.7 如何使用命名空间来组织类 2.2 继承 2.3 多态 2.3.1 抽象类 2.3.2 密封类 2.4 接口 2.4.1 接口声明 2.4.2 接口实现 2.5 委托与事件 2.5.1 委托 2.5.2 事件 2.6 小结</span><br><span class="line"></span><br><span class="line"> 第二篇 苦练基本功 第3章 Windows窗体 3.1 Windows窗体简介 3.2 使用Windows窗体 3.2.1 创建窗体 3.2.2 设置窗体属性 3.2.3 调用方法 3.2.4 窗体的事件介绍 3.3 创建多文档界面应用程序 3.3.1 单文档界面和多文档界面应用程序 3.3.2 创建多文档界面应用程序 3.3.3 父窗体和子窗体的交互 3.4 小结</span><br><span class="line"></span><br><span class="line"> 第4章 使用Windows窗体基本控件 4.1 使用Windows窗体控件 4.1.1 根据功能选择Windows窗体控件 4.1.2 制作登录框 4.1.3 Label控件 4.1.4 TextBox控件 4.1.5 Button控件 4.2 选择类控件 4.2.1 个人资料填写程序 4.2.2 使用ListBox控件和ComboBox控件 4.2.3 使用CheckBox和RadioButton控件 4.2.4 使用GroupBox和Panel控件 4.3 菜单和工具栏 4.3.1 创建菜单 4.3.2 使用toolStrip控件 4.3.3 使用statusStrip控件 4.4 在Windows窗体应用程序中使用对话框 4.4.1 在VisuaI Studio .NET中选择对话框 4.4.2 在应用程序中显示对话框 4.4.3 DialogResult属性 4.5 文本编辑 4.5.1 RichTextBox控件简介 4.5.2 RichTextBox的主要属性 4.5.3 RichTextBox控件的主要方法 4.5.4 RichTextBox控件的主要事件 4.6 制作写字板 4.6.1 程序分析功能 4.6.2 控件属性设置 4.6.3 程序代码编写 4.6.4 程序总结 4.7 小结</span><br><span class="line"></span><br><span class="line"> 第5章 Windows窗体高级控件 5.1 视图列表类控件 5.1.1 使用ImageList控件 5.1.2 ListView控件 5.1.3 TreeView控件 5.1.4 制作员工资料管理器 5.2 验证用户输入 5.2.1 处理焦点 5.2.2 使用Validating事件验证控件 5.2.3 窗体级别的验证 5.2.4 ErrorProvider控件 5.3 在运行时添加控件 5.3.1 控件集合 5.3.2 在运行时添加控件 5.4 控件的组织 5.4.1 排列控件 5.4.2 设置Tab键顺序 5.4.3 锚定Windows窗体中的控件 5.4.4 停靠Windows窗体的控件 5.5 小结</span><br><span class="line"></span><br><span class="line"> 第6章 控件的高级应用 6.1 创建用户控件 6.1.1 创建控件的方式 6.1.2 提供并重载控件属性 6.1.3 触发并重载控件事件 6.1.4 测试控件 6.1.5 创建复合控件 6.2 为控件添加设计时支持 6.2.1 属性的属性(Property Pttribute) 6.2.2 内建在.NET框架中的设计时支持选项 6.3 控件许可 6.3.1 文件许可 6.3.2 启用控件许可 6.3.3 LicFileIficenseProvider在.NEI中的工作流程 6.4 小结</span><br><span class="line"></span><br><span class="line"> 第7章文件操作 7.1流 7.1.1.NET流的体系结构 7.1-2 Stream类 7.2 Reader和Writer 7.3基本文件I／O 7-3.1 FileStream类 7.3.2 File和Filelnfo类 7.3.3 Directory和：Directorylnfo类 7.3.4 FileSystemWatcher 7.3.5 独立存储 7.4 小结</span><br><span class="line"></span><br><span class="line"> 第8章图形图像处理 8.1 GDIl+简介 8.2 GDI十对象 8.2.1 Graphics对象 8.2.2 Graphics对象的方法 8.2.3 创建和使用Pen、Brush对象 8.3 绘制基本图形 8.3.1 绘制直线和矩形 8.3.2 绘制椭圆和弧线 8.3.3 绘制多边形 8.3.4. 画刷和填充的形状 8.4 图像处理 8.4.1 加载和显示图片 8.4.2 裁切和缩放图像 8.4.3 旋转、反射和扭曲图像 8.4.4 创建缩放图像 8.5 文本显示 8.5.1 使用Font对象 8.5.2 使用DrawString方法绘制文本 8.6 小结 …… 第9章 连接环境下的ADO.NET 第10章 非连接环境下访问数据库 第11章 报表和打印 第12章 调试、测试与部署</span><br><span class="line"></span><br><span class="line"> 第三篇 突出重围 项目实战 第13章 综合应用实例——考试管理系统</span><br><span class="line"></span><br><span class="line"> 第四篇 高级开发技术——Web服务 第14章 构建和使用Web服务</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B002M77TDA/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B002M77TDA&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51dn16P69FL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>C#本质论(第2版)</title>
    <url>/2020/04/19/B002VEDBHM/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C#本质论(第2版)<br>作者信息： 作者: 米凯利斯(Mark Michaelis) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《C#本质论(第2版)》语言简明透彻，不仅讨论了C#的类数据类型、运算符、方法、类等基本概念，也讲解了泛型、迭代器、反射、线程、互操作性等高级主题，还介绍了全新的语言集成查询（UNQ）技术.以及与其相关的扩展方法、隐-式类型的变量、分部方法、Lambda表达式、表达式树、匿名类型、标准查询操作符和查询表达式等重要内容。书中的代码示例、思维导图和语言对比等内容，都对介绍C#的强大特性起到了很好的辅助作用，从而使读者可以对C#有更为直观的认识。这样一件由作者精心打造的C#编程利器，让初学者可以在探索路上披荆斩棘.让开发者可以在工作中游刃有余。《C#本质论(第2版)》是微软技术代言人扛鼎之作，结合代码深入浅出探讨C#3．O的强大特性，C#开发必备利器。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 C#概述</span><br><span class="line">1.1　Hello，World　1</span><br><span class="line">1.2　C#语法基础　3</span><br><span class="line">1.2.1　C#关键字　3</span><br><span class="line">1.2.2　类型定义　4</span><br><span class="line">1.2.3　Main　5</span><br><span class="line">1.2.4　语句和语句分隔符　6</span><br><span class="line">1.2.5　空白　7</span><br><span class="line">1.3　使用变量　8</span><br><span class="line">1.3.1　数据类型　8</span><br><span class="line">1.3.2　变量的声明　9</span><br><span class="line">1.3.3　变量的赋值　9</span><br><span class="line">1.3.4　变量的使用　10</span><br><span class="line">1.4　控制台输入和输出　11</span><br><span class="line">1.4.1　从控制台获取输入　11</span><br><span class="line">1.4.2　将输出写入控制台　12</span><br><span class="line">1.5　注释　14</span><br><span class="line">1.6　托管执行和公共语言基础结构　15</span><br><span class="line">1.7　C#和.NET版本　17</span><br><span class="line">1.8　CIL和ILDASM　18</span><br><span class="line">1.9　小结　20 </span><br><span class="line"></span><br><span class="line"> 第2章　数据类型　21 2.1　基本数值类型　21 2.1.1　整数类型　21 2.1.2　浮点类型(float，clouble)　22 2.1.3　decimal类型　23 2.1.4　字面值　23 2.2　更多基本类型　27 2.2.1　布尔类型(bool)　27 2.2.2　字符类型(char)　27 2.2.3　字符串　29 2.3　null和void　34 2.3.1　null　35 2.3.2　void　35 2.4　类型的分类　37 2.4.1　值类型　37 2.4.2　引用类型　38 2.5　可空修饰符　39 2.6　数据类型之间的转换　39 2.6.1　显式转型　40 2.6.2　隐式转型　42 2.6.3　不进行转型的类型转换　43 2.7　数组　44 2.7.1　数组的声明　44 2.7.2　数组的实例化和赋值　45 2.7.3　数组的使用　48 2.7.4　字符串作为数组使用　53 2.7.5　常见错误　55 2.8　小结　55</span><br><span class="line"></span><br><span class="line"> 第3章　运算符和控制流　57 3.1　运算符　57 3.1.1　一元运算符正和负　58 3.1.2　二元算术运算符　58 3.1.3　圆括号运算符　64 3.1.4　赋值运算符　64 3.1.5　递增和递减运算符　65 3.1.6　常量表达式　68 3.2　流控制概述　68 3.2.1　if语句　70 3.2.2　嵌套if　70 3.3　代码块　72 3.4　作用域　74 3.5　布尔表达式　75 3.5.1　关系运算符和相等性运算符　76 3.5.2　逻辑布尔运算符　77 3.5.3　逻辑求反运算符　78 3.5.4　条件运算符　78 3.6　按位运算符　79 3.6.1　移位运算符　80 3.6.2　按位运算符　80 3.6.3　按位赋值运算符　82 3.6.4　按位取反运算符　83 3.7　控制流语句　83 3.7.1　while和do&#x2F;while循环　83 3.7.2　for循环　85 3.7.3　foreach循环　87 3.7.4　switch语句　89 3.8　跳转语句　91 3.8.1　break语句　91 3.8.2　continue语句　94 3.8.3　goto语句　95 3.9　C#预处理器指令　96 3.9.1　排除和包含代码　97 3.9.2　定义预处理器符号　98 3.9.3　生成错误和警告　98 3.9.4　关闭警告消息　99 3.9.5　nowarn:选项　99 3.9.6　指定行号　100 3.9.7　可视编辑器提示　100 3.10　小结　101</span><br><span class="line"></span><br><span class="line"> 第4章　方法和参数　103 4.1　方法的调用　104 4.1.1　命名空间　105 4.1.2　类型名称　106 4.1.3　作用域　106 4.1.4　方法名称　107 4.1.5　参数　107 4.1.6　方法返回值　107 4.1.7　语句与方法调用的比较　108 4.2　方法的声明　108 4.2.1　参数声明　110 4.2.2　方法返回值声明　110 4.3　using指令　111 4.4　Main()的返回值和参数　114 4.5　参数　116 4.5.1　值参数　117 4.5.2　引用参数(ref)　118 4.5.3　输出参数(out)　119 4.5.4　参数数组(params)　120 4.6　递归　122 4.7　方法重载　124 4.8　用异常实现基本错误处理　127 4.8.1　捕捉错误　128 4.8.2　使用throw语句报告错误　134 4.9　小结　136</span><br><span class="line"></span><br><span class="line"> 第5章　类　137 5.1　类的定义和实例化　140 5.2　实例字段　142 5.2.1　实例字段的声明　142 5.2.2　实例字段的访问　143 5.3　实例方法　144 5.4　使用this关键字　145 5.5　访问修饰符　151 5.6　属性　152 5.6.1　属性的声明　154 5.6.2　自动实现的属性　155 5.6.3　命名规范　157 5.6.4　提供属性验证　157 5.6.5　只读和只写属性　159 5.6.6　为getter和setter指定访问修饰符　160 5.6.7　属性作为虚字段使用　161 5.6.8　属性和方法调用不允许作为ref或out参数值使用　163 5.7　构造器　164 5.7.1　构造器的声明　164 5.7.2　默认构造器　165 5.7.3　对象初始化器　166 5.7.4　构造器的重载　167 5.7.5　使用this调用另一个构造器　168 5.8　静态　172 5.8.1　静态字段　172 5.8.2　静态方法　175 5.8.3　静态构造器　176 5.8.4　静态属性　177 5.8.5　静态类　178 5.9　扩展方法　180 5.10　封装数据　181 5.10.1　const　181 5.10.2　readonly　181 5.11　嵌套类　182 5.12　分部类　184 5.12.1　定义分部类　184 5.12.2　分部方法　185 5.13　小结　188</span><br><span class="line"></span><br><span class="line"> 第6章　继承　189 6.1　派生　189 6.1.1　基类型和派生类型之间的转型　192 6.1.2　private访问修饰符　193 6.1.3　protected访问修饰符　194 6.1.4　扩展方法　195 6.1.5　单一继承　195 6.1.6　密封类　197 6.2　基类的重写　198 6.2.1　virtual修饰符　198 6.2.2　new修饰符　202 6.2.3　sealed修饰符　205 6.2.4　base成员　206 6.2.5　构造器　206 6.3　抽象类　207 6.4　一切最终都从System.Object派生　212 6.5　使用is运算符验证基础类型　213 6.6　使用as运算符进行转换　213 6.7　小结　215</span><br><span class="line"></span><br><span class="line"> 第7章　接口　216 7.1　接口概述　216 7.2　通过接口来实现多态性　217 7.3　接口实现　222 7.3.1　显式成员实现　223 7.3.2　隐式成员实现　225 7.3.3　显式接口实现与隐式接口实现的比较　225 7.4　“实现类”与其接口之间的转型　226 7.5　接口继承　226 7.6　多接口继承　228 7.7　接口上的扩展方法　229 7.8　通过接口来实现多重继承　230 7.9　版本控制　232 7.10　接口与类的比较　234 7.11　小结　234</span><br><span class="line"></span><br><span class="line"> 第8章　值类型　235 8.1　结构　235 8.1.1　struct的初始化　238 8.1.2　default运算符的使用　240 8.1.3　值类型的继承和接口　240 8.2　装箱　240 8.3　枚举　245 8.3.1　枚举之间的类型兼容性　248 8.3.2　枚举和字符串之间的转换　249 8.3.3　枚举作为标志使用　249 8.4　小结　253</span><br><span class="line"></span><br><span class="line"> 第9章　合式类型　254 9.1　重写object的成员　254 9.1.1　重写ToString()　254 9.1.2　重写GetHashCode()　255 9.1.3　重写Equals()　257 9.1.4　相等性实现的指导原则　263 9.2　运算符重载　263 9.2.1　比较运算符　263 9.2.2　二元运算符　264 9.2.3　赋值运算符与二元运算符的结合　266 9.2.4　条件逻辑运算符　266 9.2.5　一元运算符　266 9.2.6　转换运算符　267 9.2.7　转换运算符的指导原则　269 9.3　引用其他程序集　269 9.3.1　更改程序集目标　269 9.3.2　引用程序集　270 9.3.3　类型封装　270 9.4　定义命名空间　272 9.5　XML注释　274 9.5.1　将XML注释与代码构造关联到一起　275 9.5.2　生成XML文档文件　277 9.6　垃圾回收　278 9.7　资源清理　280 9.7.1　终结器　280 9.7.2　使用using语句进行确定性终结　282 9.7.3　垃圾回收和终结　284 9.7.4　资源利用和终结的指导原则　285 9.8　小结　286</span><br><span class="line"></span><br><span class="line"> 第10章　异常处理　287 10.1　多异常类型　287 10.2　捕捉异常　288 10.3　常规catch块　290 10.4　异常处理的指导原则　291 10.5　定义自定义异常　293 10.6　小结　297</span><br><span class="line"></span><br><span class="line"> 第11章　泛型　298 11.1　如果C#没有泛型　298 11.2　泛型类型概述　303 11.2.1　泛型类的使用　303 11.2.2　简单泛型类的定义　305 11.2.3　泛型的优点　305 11.2.4　类型参数命名的指导原则　306 11.2.5　泛型接口和struct　306 11.2.6　构造器和终结器的定义　308 11.2.7　默认值的指定　309 11.2.8　多个类型参数　310 11.2.9　嵌套泛型类型　311 11.2.10　在“类型参数”兼容的前提下，泛型类的实例之间的类型兼容性　312 11.3　约束　312 11.3.1　接口约束　314 11.3.2　基类约束　316 11.3.3　struct&#x2F;class约束　317 11.3.4　多个约束　317 11.3.5　构造器约束　318 11.3.6　约束继承　318 11.4　泛型方法　322 11.4.1　类型推断　323 11.4.2　约束的指定　324 11.5　泛型的内部机制　325 11.5.1　基于值类型的泛型的实例化　327 11.5.2　基于引用类型的泛型的实例化　327 11.6　小结　328</span><br><span class="line"></span><br><span class="line"> 第12章　委托和Lambda表达式　329 12.1　委托概述　329 12.1.1　背景　329 12.1.2　委托数据类型　331 12.1.3　委托的内部机制　333 12.1.4　委托类型的定义　333 12.1.5　委托的实例化　334 12.2　匿名方法　338 12.3　系统定义的委托：Func　340 12.4　Lambda表达式　341 12.4.1　语句Lambda　342 12.4.2　表达式Lambda　344 12.4.3　外部变量　347 12.4.4　表达式树　350 12.5　小结　354</span><br><span class="line"></span><br><span class="line"> 第13章　事件　355 13.1　使用multicast委托来编码Observer模式　355 13.1.1　定义Subscriber方法　356 13.1.2　定义Publisher　357 13.1.3　连接Publisher和Subscriber　358 13.1.4　调用委托　359 13.1.5　检查空值　360 13.1.6　委托运算符　361 13.1.7　顺序调用　363 13.1.8　错误处理　365 13.1.9　方法返回值和传引用　367 13.2　事件　368 13.2.1　事件的作用　368 13.2.2　事件的声明　369 13.2.3　编码规范　370 13.2.4　泛型和委托　372 13.2.5　自定义事件的实现　375 13.3　小结　376</span><br><span class="line"></span><br><span class="line"> 第14章　支持标准查询运算符的集合接口　377 14.1　匿名类型和隐式局部变量声明　378 14.1.1　匿名类型　378 14.1.2　隐式类型的局部变量　379 14.1.3　匿名类型和隐式局部变量的更多注意事项　380 14.2　集合初始化器　383 14.3　是什么使类成为一个集合：IEnumerable　385 14.3.1　foreach和数组　385 14.3.2　foreach和IEnumerable　386 14.3.3　foreach循环内不要修改集合　389 14.4　标准查询运算符　390 14.4.1　使用Where()来筛选　393 14.4.2　使用Select()来投射　394 14.4.3　推迟执行　396 14.4.4　使用OrderBy()和ThenBy()来排序　398 14.4.5　使用Join()来执行内部联接　404 14.4.6　使用GroupJoin()实现一对多关系　407 14.4.7　调用SelectMany()　409 14.4.8　更多标准查询运算符　411 14.5　小结　414</span><br><span class="line"></span><br><span class="line"> 第15章　查询表达式　416 15.1　查询表达式概述　416 15.1.1　投射　418 15.1.2　筛选　423 15.1.3　排序　424 15.1.4　Let　425 15.1.5　分组　427 15.2　查询表达式作为方法调用　431 15.3　小结　432</span><br><span class="line"></span><br><span class="line"> 第16章　构建自定义集合　433 16.1　更多集合接口　434 16.1.1　IList与IDictionary　434 16.1.2　IComparable　435 16.1.3　ICollection　437 16.2　主要集合类　437 16.2.1　列表集合：List　437 16.2.2　字典集合：Dictionary　441 16.2.3　已排序集合：SortedDictionary和SortedList　445 16.2.4　栈集合：Stack　447 16.2.5　队列集合：Queue　447 16.2.6　链表：LinkedList　448 16.3　提供一个索引运算符　449 16.4　返回Null或者空集合　452 16.5　迭代器　452 16.5.1　迭代器的定义　453 16.5.2　迭代器语法　453 16.5.3　从迭代器yield值　454 16.5.4　迭代器和状态　456 16.5.5　更多的迭代器例子　457 16.5.6　将yield return语句放到循环中　459 16.5.7　取消更多的迭代：yield break　461 16.5.8　在单个类中创建多个迭代器　463 16.5.9　yield语句的特征　464 16.6　小结　464</span><br><span class="line"></span><br><span class="line"> 第17章　反射和attribute　465 17.1　反射　465 17.1.1　使用System.Type访问元数据　466 17.1.2　成员调用　468 17.1.3　泛型类型上的反射　472 17.2　attribute　475 17.2.1　自定义attribute　478 17.2.2　查找attribute　478 17.2.3　使用构造器来初始化attribute　479 17.2.4　System.AttributeUsage-Attribute　484 17.2.5　具名参数　485 17.3　小结　496</span><br><span class="line"></span><br><span class="line"> 第18章　多线程处理　497 18.1　独立线程的运行和控制　499 18.1.1　线程的启动　500 18.1.2　线程管理　501 18.2　向线程传递参数　502 18.3　线程池处理　506 18.4　未处理的异常　507 18.5　同步　509 18.5.1　使用Monitor来同步　511 18.5.2　使用lock关键字　512 18.5.3　lock对象的选择　514 18.5.4　为什么要避免在this和typeof(type)上锁定　514 18.5.5　将字段声明为volatile　514 18.5.6　使用System.Threading.Interlocked类　515 18.5.7　多个线程时的事件通知　516 18.5.8　同步设计最佳实践　517 18.5.9　更多的同步类型　518 18.6　计时器　522 18.7　小结　527</span><br><span class="line"></span><br><span class="line"> 第19章　多线程处理模式　528 19.1　Asynchronous Results模式　528 19.1.1　Asynchronous Results模式概述　529 19.1.2　向轮换线程传入数据以及从轮换线程传出数据　531 19.1.3　接收线程完成通知　536 19.1.4　传递任意状态　538 19.1.5　Asynchronous Results小结　540 19.2　Background Worker模式　541 19.2.1　模式的建立　543 19.2.2　异常处理　544 19.3　Windows窗体　544 19.4　小结　547</span><br><span class="line"></span><br><span class="line"> 第20章　平台互操作性和不安全的代码　548 20.1　平台调用　549 20.1.1　外部函数的声明　549 20.1.2　参数的数据类型　550 20.1.3　使用ref而不是指针　551 20.1.4　为顺序布局使用StructLayoutAttribute　551 20.1.5　错误处理　552 20.1.6　使用SafeHandle　554 20.1.7　外部函数的调用　556 20.1.8　用包装简化API调用　559 20.1.9　函数指针映射到委托　560 20.1.10　指导原则　560 20.2　指针和地址　560 20.2.1　不安全的代码　560 20.2.2　指针的声明　561 20.2.3　指针的赋值　563 20.2.4　指针的解引用　565 20.2.5　访问被引用物的类型的成员　566 20.3　小结　567</span><br><span class="line"></span><br><span class="line"> 第21章　CLI　569 21.1　CLI的定义　569 21.2　CLI实现　570 21.3　C#编译成机器码　571 21.4　运行时　572 21.4.1　垃圾回收　573 21.4.2　.NET的垃圾回收　573 21.4.3　类型安全　574 21.4.4　代码访问安全性　574 21.4.5　平台可移植性　574 21.4.6　性能　575 21.5　应用程序域　576 21.6　程序集、清单和模块　576 21.7　公共中间语言　578 21.8　公共类型系统　578 21.9　公共语言规范　579 21.10　基类库　579 21.11　元数据　579 21.12　小结　580</span><br><span class="line"></span><br><span class="line"> 附录A　下载和安装C#编译器与CLI平台　581 附录B　完整源代码清单　583 附录C　C# 3.0主题　609</span><br><span class="line"></span><br><span class="line">   &lt;&#x2F;t&gt;&lt;&#x2F;t&gt;&lt;&#x2F;t&gt;&lt;&#x2F;t&gt;&lt;&#x2F;tkey&gt;&lt;&#x2F;tkey&gt;&lt;&#x2F;t&gt;&lt;&#x2F;t&gt;&lt;&#x2F;t&gt;&lt;&#x2F;tkey&gt;&lt;&#x2F;t&gt;&lt;&#x2F;t&gt;&lt;&#x2F;t&gt;&lt;&#x2F;warn&gt;</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B002VEDBHM/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B002VEDBHM&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41xl6D6fwOL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows CE(C#)嵌入式应用开发</title>
    <url>/2020/04/19/B003OICLIE/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Windows CE(C#)嵌入式应用开发<br>作者信息： 作者: 王浩 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Windows CE(C#)嵌入式应用开发》：<br>中国软件行业协会嵌入式系统分会推荐教材<br>注重知识的基础性、系统性与全局性，兼顾前瞻性与引导性。<br>语言精练，应用案例丰富，讲解内容深入浅出。<br>体系完整，内容充实，注重应用性与实践性。<br>讲求实用，培养技能，提高素质，拓展视野。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">序</span><br><span class="line">前言</span><br><span class="line">第1章 Windows CE嵌入式系统 1</span><br><span class="line">1.1 Windows CE概述 1</span><br><span class="line">1.1.1 什么是Windows CE 1</span><br><span class="line">1.1.2 Windows CE平台主要开发特征 1</span><br><span class="line">1.1.3 Windows CE 应用领域 2</span><br><span class="line">1.1.4 Windows CE体系结构的特性 4</span><br><span class="line">1.2 基于Windows CE系统开发 6</span><br><span class="line">1.2.1 Windows CE开发内容 6</span><br><span class="line">1.2.2 Windows CE开发流程 8</span><br><span class="line">1.3 Windows CE开发工具 8</span><br><span class="line">1.3.1 Platform Builder for Windows CE 5.0 8</span><br><span class="line">1.3.2 VS.NET2005开发平台 10</span><br><span class="line">1.3.3 ActiveSync同步软件 11</span><br><span class="line">1.3.4 Windows CE远程工具 12</span><br><span class="line">第2章 Windows CE开发平台的组建 19</span><br><span class="line">2.1 Windows CE目标平台 19</span><br><span class="line">2.1.1 ARM9硬件开发平台简介 19</span><br><span class="line">2.1.2 平台硬件架构 20</span><br><span class="line">2.2 Windows CE操作系统定制 21</span><br><span class="line">2.2.1 Platform Builder 5.0安装与配置 21</span><br><span class="line">2.2.2 Platform Builder 5.0主界面简介 24</span><br><span class="line">2.2.3 定制Windows CE OS的过程 26</span><br><span class="line">2.2.4 Windows CE的编译过程 35</span><br><span class="line">2.2.5 Windows CE内核映像的下载与测试 37</span><br><span class="line">2.3 Windows CE应用开发环境构建 39</span><br><span class="line">2.3.1 VS.NET2005平台安装简介 39</span><br><span class="line">2.3.2 使用VS.NET2005构建基于Windows CE的C#应用程序 39</span><br><span class="line">2.3.3 在WinCE目标设备上部署C#应用程序 42</span><br><span class="line">2.3.4 Windows CE模拟器 48</span><br><span class="line">第3章 图形界面应用开发 55</span><br><span class="line">3.1 基于GDI屏幕绘图 55</span><br><span class="line">3.1.1 GDI+简介 55</span><br><span class="line">3.1.2 设备绘图表面 55</span><br><span class="line">3.1.3 绘图操作工具 57</span><br><span class="line">3.1.4 常用图形的绘制 58</span><br><span class="line">3.1.5 绘制文本 60</span><br><span class="line">3.1.6 绘制图像 61</span><br><span class="line">3.2 触摸屏的手写笔程序实例 63</span><br><span class="line">3.2.1 功能设计 63</span><br><span class="line">3.2.2 功能实现 64</span><br><span class="line">3.3 电子相册应用开发 72</span><br><span class="line">3.3.1 项目分析 72</span><br><span class="line">3.3.2 XML基础 73</span><br><span class="line">3.3.3 业务逻辑类的设计 77</span><br><span class="line">3.3.4 用户界面设计 80</span><br><span class="line">3.3.5 部署安装应用程序 94</span><br><span class="line">第4章 Windows CE下的数据库开发 98</span><br><span class="line">4.1 SQL Server Mobile设备端数据访问 98</span><br><span class="line">4.1.1 SQL Server Mobile简介 98</span><br><span class="line">4.1.2 SQL Server Mobile安装与配置 98</span><br><span class="line">4.2 ADO.NET数据访问 101</span><br><span class="line">4.2.1 ADO.NET概述 101</span><br><span class="line">4.2.2 使用ADO.NET进行数据访问 102</span><br><span class="line">4.3 通信录数据库应用实例 106</span><br><span class="line">4.3.1 项目功能设计 106</span><br><span class="line">4.3.2 数据库设计 107</span><br><span class="line">4.3.3 项目三层架构设计 112</span><br><span class="line">4.3.4 数据访问层功能实现 113</span><br><span class="line">4.3.5 业务逻辑层功能实现 116</span><br><span class="line">4.3.6 窗体功能实现 121</span><br><span class="line">第5章 SQL Server Mobile数据库同步应用 135</span><br><span class="line">5.1 远程数据同步简介 135</span><br><span class="line">5.2 SQL Server Mobile设备端与服务器端 135</span><br><span class="line">5.3 SQL Server Mobile数据同步开发环境搭建 136</span><br><span class="line">5.4 SQL Server Mobile的合并复制简介 141</span><br><span class="line">5.5 创建与配置基于Windows CE的合并复制 142</span><br><span class="line">5.5.1 创建快照代理用户账号及快照文件夹 142</span><br><span class="line">5.5.2 创建SQL Server 2005数据库的发布（Publication） 143</span><br><span class="line">5.5.3 发布数据库的权限设置 149</span><br><span class="line">5.5.4 创建发布数据库的快照 151</span><br><span class="line">5.5.5 配置IIS实现Web远程同步 153</span><br><span class="line">5.5.6 创建SQL Server Mobile数据库订阅 156</span><br><span class="line">5.6 创建SQL Server Mobile数据库同步应用程序 160</span><br><span class="line">5.6.1 创建基于Windows CE的同步应用程序项目工程 160</span><br><span class="line">5.6.2 相关类的功能实现 161</span><br><span class="line">5.6.3 窗体功能实现 166</span><br><span class="line">第6章 Windows CE串口通信应用 177</span><br><span class="line">6.1 串口通信基础 177</span><br><span class="line">6.1.1 串行通信简介 177</span><br><span class="line">6.1.2 RS-232接口特性 178</span><br><span class="line">6.1.3 串行数据传输 179</span><br><span class="line">6.2 GSM与GPRS 180</span><br><span class="line">6.2.1 GSM 180</span><br><span class="line">6.2.2 GPRS 180</span><br><span class="line">6.2.3 GPRS模块 181</span><br><span class="line">6.3 短信编解码 181</span><br><span class="line">6.3.1 AT指令简介 181</span><br><span class="line">6.3.2 UCS2短信编码 182</span><br><span class="line">6.3.3 UCS2短信解码 183</span><br><span class="line">6.3.4 通过超级终端进行GPRS通信测试 184</span><br><span class="line">6.4 短信收发系统设计 186</span><br><span class="line">6.4.1 短信收发系统功能模块设计 186</span><br><span class="line">6.4.2 短信收发系统开发架构 188</span><br><span class="line">6.5 短信业务类设计 189</span><br><span class="line">6.6 窗体设计与实现 201</span><br><span class="line">6.6.1 窗体功能设计 201</span><br><span class="line">6.6.2 窗体功能实现 201</span><br><span class="line">第7章 蓝牙通信应用 207</span><br><span class="line">7.1 蓝牙技术 207</span><br><span class="line">7.1.1 蓝牙技术简介 207</span><br><span class="line">7.1.2 蓝牙技术特点 208</span><br><span class="line">7.2 蓝牙协议栈的体系结构 208</span><br><span class="line">7.3 蓝牙应用编程 210</span><br><span class="line">7.3.1 蓝牙编程方式 210</span><br><span class="line">7.3.2 蓝牙套接字 210</span><br><span class="line">7.3.3 OBEX对象交换协议 211</span><br><span class="line">7.3.4 蓝牙编程环境安装与配置 212</span><br><span class="line">7.3.5 蓝牙应用程序开发 218</span><br><span class="line">附录 228</span><br><span class="line">参考文献 237</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B003OICLIE/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B003OICLIE&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51Kf77FAttL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>C#本质论(第3版)</title>
    <url>/2020/04/19/B003ZXBKQC/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C#本质论(第3版)<br>作者信息： 作者: 平均4.5 星  [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《C#本质论(第3版)》是学习C#语言的首选之作。涵盖了C#4.0的新特性。《C#本质论(第3版)》内容全面。组织合理，讲解清晰。作者通过丰富的示例和详尽的讲解，向读者全面展示了C#语言的语法基础、核心知识和高级主题。从泛型、委托和Lambda表达式，到集合、标准运算符和迭代器，从反射、特性和动态编程，到多线程、异步和并发.涉及C#语言的所有重要方面。全书每一章开头都会给出一幅“思维导图”。让读者对整章的知识脉络和概念关系能够一目了然，有助于理解和记忆。同时，针对不同层次和类型的读者，书中还分别给出了入行、迁移或者进阶的详细建议。作者对书中关键主题的精彩阐述和对最新语言特性的权威解释，也极大地提高了《C#本质论(第3版)》的“含金量”，令读者既能得游目骋怀之乐。又可收博观约取之效。全新升级版，涵盖C＃4.0,内容全面翔实，讲解精彩权威，C＃入门进阶的首先之作。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 C＃概述</span><br><span class="line">1.1 Hello  World</span><br><span class="line">1.2 C＃语法基础</span><br><span class="line">1.2.1 C＃关键字</span><br><span class="line">1.2.2 类型定义</span><br><span class="line">1.2.3 Main</span><br><span class="line">1.2.4 语句和语句分隔符</span><br><span class="line">1.2.5 空白</span><br><span class="line">1.3 使用变量</span><br><span class="line">1.3.1 数据类型</span><br><span class="line">1.3.2 变量的声明</span><br><span class="line">1.3.3 变量的赋值</span><br><span class="line">1.3.4 变量的使用</span><br><span class="line">1.4 控制台输入和输出</span><br><span class="line">1.4.1 从控制台获取输入</span><br><span class="line">1.4.2 将输出写入控制台</span><br><span class="line">1.5 注释</span><br><span class="line">1.6 托管执行和公共语言基础结构</span><br><span class="line">1.7 C＃和NET版本</span><br><span class="line">1.8 CIL和ILDASM</span><br><span class="line">1.9 小结 </span><br><span class="line"></span><br><span class="line"> 第2章 数据类型 2.1 基本数值类型 2.1.1 整数类型 2.1.2 浮点类型 2.1.3 decimal类型 2.1.4 字面值 2.2 更多基本类型 2.2.1 布尔类型 2.2.2 字符类型 2.2.3 字符串 2.3 null和void 2.3.1 null 2.3.2 void 2.4 类型的分类 2.4.1 值类型 2.4.2 引用类型 2.5 可空修饰符 2.6 数据类型之间的转换 2.6.1 显式转型 2.6.2 隐式转型 2.6.3 不进行转型的类型转换 2.7 数组 2.7.1 数组的声明 2.7.2 数组的实例化和赋值 2.7.3 数组的使用 2.7.4 字符串作为数组使用 2.7.5 常见错误 2.8 小结</span><br><span class="line"></span><br><span class="line"> 第3章 运算符和控制流 3.1 运算符 3.1.1 一元运算符正和负 3.1.2 二元算术运算符 3.1.3 圆括号运算符 3.1.4 赋值运算符 3.1.5 递增和递减运算符 3.1.6 常量表达式 3.2 流控制概述 3.2.1 if语句 3.2.2 嵌套if 3.3 代码块 3.4 作用域和声明空间 3.5 布尔表达式 3.5.1 关系运算符和相等性运算符 3.5.2 逻辑布尔运算符 3.5.3 逻辑求反运算符 3.5.4 条件运算符 3.5.5 空接合运算符 3.6 按位运算符 3.6.1 移位运算符 3.6.2 按位运算符 3.6.3 按位赋值运算符 3.6.4 按位取反运算符 3.7 控制流语句 3.7.1 whi.1 e和do／while循环 3.7.2 for循环 3.7.3 foreach循环 3.7.4 switch语句 3.8 跳转语句 3.8.1 break语句 3.8.2 continue语句 3.8.3 go to语句 3.9 c#预处理器指令 3.9.1 排除和包含代码 3.9.2 定义预处理器符号 3.9.3 生成错误和警告 3.9.4 关闭警告消息 3.9.5 nowarn：选项 3.9.6 指定行号 3.9.7 可视编辑器提示 3.10 小结</span><br><span class="line"></span><br><span class="line"> 第4章 方法和参数 4.1 方法的调用 4.1.1 命名空间 4.1.2 类型名称 4.1.3 作用域 4.1.4 方法名称 4.1.5 参数 4.1.6 方法返回值 4.1.7 语句与方法调用的比较 4.2 方法的声明 4.2.1 参数声明 4.2.2 方法返回值声明 4.3 uslng指令 4.4 Main（）的返回值和参数 4.5 参数 4.5.1 值参数 4.5.2 引用参数 4.5.3 输出参数 4.5.4 参数数组 4.6 递归 4.7 方法重载 4.8 可选参数 4.9 用异常实现基本错误处理 4.9.1 捕捉错误 4.9.2 使用throw语句报告错误 4.10 小结</span><br><span class="line"></span><br><span class="line"> 第5章 类 5.1 类的定义和实例化 5.2 实例字段 5.2.1 实例字段的声明 5.2.2 实例字段的访问 5.3 实例方法 5.4 使用this关键字 5.5 访问修饰符 5.6 属性 5.6.1 属性的声明 5.6.2 自动实现的属性 5.6.3 命名规范 5.6.4 提供属性验证 5.6.5 读和只写属性 5.6.6 为取值方法和赋值方法指定访问修饰符 5.6.7 属性作为虚字段使用 5.6.8 属性和方法调用不允许作为ref或out参数值使用 5.7 构造器 5.7.1 构造器的声明 5.7.2 默认构造器 5.7.3 对象初始化器 5.7.4 构造器的重载 5.7.5 使用this调用另一个构造器 5.8 静态成员 5.8.1 静态字段 5.8.2 静态方法 5.8.3 静态构造器 5.8.4 静态属性 5.8.5 静态类 5.9 扩展方法 5.10 封装数据 5.10.1 const 5.10.2 readonly 5.11 嵌套类 5.12 分部类 5.12.1 定义分部类 5.12.2 分部方法 5.13 小结</span><br><span class="line"></span><br><span class="line"> 第6章 继承 6.1 派生 6.1.1 基类型和派生类型之间的转型 6.1.2 private访问修饰符 6.1.3 protected访问修饰符 6.1.4 扩展方法 6.1.5 单一继承 6.1.6 密封类 6.2 基类的重写 6.2.1 virtual修饰符 6.2.2 new修饰符 6.2.3 sealed修饰符 6.2.4 base成员 6.2.5 构造器 6.3 抽象类 6.4 所有类都从System. object派生 6.5 使用is运算符验证基础类型 6,6使用as运算符进行转换 6.7 小结</span><br><span class="line"></span><br><span class="line"> 第7章 接口 7.1 接口概述 7.2 通过接口来实现多态性 7.3 接口实现 7.3.1 显式成员实现 7.3.2 隐式成员实现 7.3.3 显式接口实现与隐式接口实现的比较 7.4 “实现类”与其接口之间的转型 7.5 接口继承 7.6 多接口继承 7.7 接口上的扩展方法 7.8 通过接口来实现多重继承 7.9 版本控制 7.10 接口与类的比较 7.11 小结</span><br><span class="line"></span><br><span class="line"> 第8章 值类型 8.1 结构 8.1.1 struct的初始化 8.1.2 default运算符的使用 8.1.3 值类型的继承和接口 8.2 装箱 8.3 枚举 8.3.1 枚举之间的类型兼容性 8.3.2 枚举和字符串之间的转换 8.3.3 枚举作为标志使用 8.4 小结</span><br><span class="line"></span><br><span class="line"> 第9章 合式类型 9.1 重写object的成员 9.1.1 重写To String（） 9.1.2 重写GetHashCode（） 9.1.3 重写Equals（） 9.1.4 相等性实现的指导原则 9.2 运算符重载 9.2.1 比较运算符 9.2.2 二元运算符 9.2.3 赋值运算符与二元运算符的结合 9.2.4 条件逻辑运算符 9.2.5 一元运算符 9.2.6 转换运算符 9.2.7 转换运算符的指导原则 9.3 引用其他程序集 9.3.1 更改程序集目标 9.3.2 引用程序集 9.3.3 类型封装 9.4 定义命名空间 9.5 XML注释 9.5.1 将XML注释与代码构造关联到一起 9.5.2 生成XML文档文件 9.6 垃圾回收 9.7 资源清理 9.7.1 终结器 9.7.2 使用using语句进行确定性终结 9.7.3 垃圾回收和终结 9.7.4 资源利用和终结的指导原则 9.8 延迟初始化 9.9 小结</span><br><span class="line"></span><br><span class="line"> 第10章 异常处理 10.1 多异常类型 10.2 捕捉异常 10.3 常规catch块 10.4 异常处理的指导原则 10.5 定义自定义异常 10.6 小结</span><br><span class="line"></span><br><span class="line"> 第11章 泛型 11.1 如果C撑没有泛型 11.2 泛型类型概述 11.2.1 泛型类的使用 11.2.2 简单泛型类的定义 11.2.3 泛型的优点 11.2.4 类型参教命名的指导原则 11.2.5 泛型接口和struct 11.2.6 构造器和终结器的定义 11.2.7 默认值的指定 11.2.8 多个类型参数 11.2.9 元数 11.2.10 嵌套泛型类型 11.3 约束 11.3.1 接口约束 11.3.2 基类约束 11.3.3 struct／class约束 …… 第12章 委托和Lambda表达式 第13章 事件 第14章 支持标准查询运算符的集合接口 第15章 使用查询表达式的LINQ 第16章 构建自定义集合 第17章 反射、特性和动态编程 第18章 多线程处理 第19章 同步和更多多线程处理模式 第20章 平台互操作性的不安全的代码 第21章 CLI</span><br><span class="line"></span><br><span class="line">   &lt;&#x2F;warn&gt;</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B003ZXBKQC/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B003ZXBKQC&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41XmepgUeSL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>CLR via C#(第3版)</title>
    <url>/2020/04/19/B00426BTTY/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： CLR via C#(第3版)<br>作者信息： 作者: 瑞奇特 (Jeffrey Richter) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《CLR via C#(第3版)》深入、全面探讨.NET Framework、CLR和多核编程，广泛讨论Framework Class Library（FCL）核心类型，对泛型和线程处理等深奥难懂的开发概念提供权威、实用的指导自下而上，由浅入深掌握CLR和.NET的权威指南享有全球盛誉的编程专家Jeffrey Richter，这位与Microsoft.NET开发团队合作长达8年时间的资深顾问，在《CLR via C#(第3版)》中和读者分享他编程生涯中积累的所有丰富经验和心得，他的独到。睿智的见解，他的远见卓识，为开发人员构建健壮、可靠和具有良好响应能力的应用程序与组件奠定了良好的基础。<br>《CLR via C#(第3版)》重要主题：构建、部署应用程序、组件和共享程序集，并对它们进行版本管理；理解基元类型、值类型和引用类型的行为，从而最高效地定义和使用它们；使用泛型和接口来定义可重用的算法；高效使用特定的CLR类型——委托、枚举、定制attribute、数组和字符串；理解垃圾回收器是如何管理内存资源的；使用线程池、任务、取消、计时器和异步I／O操作来设计响应性强、稳定性高和伸缩性大的解决方案·借助于异常处理来进行状态管理·使用CLR寄宿AppDomain、程序集加载、反射和C＃的dynamic类型来构造具有动态扩展能力的应用程序。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第I部分 CLR基础</span><br><span class="line">第1章 CLR的执行模型</span><br><span class="line">1.1 将源代码编译成托管模块</span><br><span class="line">1.2 将托管模块合并成程序集</span><br><span class="line">1.3 加载公共语言运行时</span><br><span class="line">1.4 执行程序集的代码</span><br><span class="line">1.4.1 IL和验证</span><br><span class="line">1.4.2 不安伞的代码</span><br><span class="line">1.5 本地代码生成器：NGen.exe</span><br><span class="line">1.6 Framework类库</span><br><span class="line">1.7 通用类型系统</span><br><span class="line">1.8 公共语言规范</span><br><span class="line">1.9 与非托管代码的互操作性</span><br><span class="line">第2章 生成、打包、部署和管理应用程序及类型</span><br><span class="line">2.1.NETFramework部署目标</span><br><span class="line">2.2 将类型生成到模块中响应文件</span><br><span class="line">2.3元数据概述</span><br><span class="line">2.4 将模块合并成程序集</span><br><span class="line">2.4.1 使用Visual Studio IDE将程序集添加到项目中</span><br><span class="line">2.4 ：2使用程序集链接器</span><br><span class="line">2.4.3 为程序集添加资源文件</span><br><span class="line">2.5 程序集版本资源信息</span><br><span class="line">2.6 语言文化</span><br><span class="line">2.7 简单应用程序部署（私有部署的程序集）</span><br><span class="line">2.8 简单管理控制（配置）</span><br><span class="line">第3章 共享程序集和强命名程序集</span><br><span class="line">3.1 两种程序集，两种部署</span><br><span class="line">3.2 为程序集分配强名称</span><br><span class="line">3.3 全局程序集缓存</span><br><span class="line">3.4 在生成的程序集中引用一个强命名程序集</span><br><span class="line">3.5 强命名程序集能防范篡改</span><br><span class="line">3.6 延迟签名</span><br><span class="line">3.7 私有部署强命名程序集</span><br><span class="line">3.8 “运行时”如何解析类型引用</span><br><span class="line">3.9 高级管理控制（配置）发布者策略控制</span><br><span class="line">第II部分 设计类型</span><br><span class="line">第4章 类型基础</span><br><span class="line">4.1 所有类型都从System Object派生</span><br><span class="line">4.2 类型转换</span><br><span class="line">4.3 命名空间和程序集</span><br><span class="line">4.4 运行时的相互联系</span><br><span class="line">第5章 基元类型、引用类型和值类型</span><br><span class="line">5.1 编程语言的基元类型</span><br><span class="line">5.2 引用类型和值类型</span><br><span class="line">5.3 值类型的装箱和拆箱</span><br><span class="line">5.3.1 使用接口更改已装箱值类型中的字段（以及为什么不应该这样做）</span><br><span class="line">5.3.2 对象相等性和同一性</span><br><span class="line">5.4 对象哈希码</span><br><span class="line">5.5 dynamic基元类型</span><br><span class="line">第6章 类型和成员基础</span><br><span class="line">6.1 类型的各种成员</span><br><span class="line">6.2 类型的可见性</span><br><span class="line">友元程序集</span><br><span class="line">6.3 成员的可访问性</span><br><span class="line">6.4 静态类</span><br><span class="line">6.5 分部类、结构和接口</span><br><span class="line">6.6 组件、多态和版木控制</span><br><span class="line">6.6.1 CLR如何调用虚方法、属十和事件</span><br><span class="line">6.6.2 合理使用类型的可见性和成员的可访问性</span><br><span class="line">6.6.3对类型进行版本控制时的虚方法的处理</span><br><span class="line">第7章 常量和字段</span><br><span class="line">7.1 常量</span><br><span class="line">7.2字段</span><br><span class="line">第8章 方法</span><br><span class="line">8.1 实例构造器和类（引用类型）</span><br><span class="line">8.2 实例构造器和结构（值类型）</span><br><span class="line">8.3 类型构造器</span><br><span class="line">8.4 操作符重载方法</span><br><span class="line">8.5 转换操作符方法</span><br><span class="line">8.6 扩展方法</span><br><span class="line">8.6.1 规则和原则</span><br><span class="line">8.6.2 用扩展方法扩展各种类型</span><br><span class="line">8.6.3 Extension Attribute类</span><br><span class="line">8.7 分部方法</span><br><span class="line">第9章参数</span><br><span class="line">9.1 可选参数和命名参数</span><br><span class="line">9.1.1 规则和原则</span><br><span class="line">9.1.2 DefaultParameterValueAttribute和OptionalAttribute</span><br><span class="line">9.2 隐式类型的局部变量</span><br><span class="line">9.3 传引用的方式向方法传递参数</span><br><span class="line">9.4 向方法传递可变数量的参数</span><br><span class="line">9.5 参数和返回类型的指导原则</span><br><span class="line">9.6 常量性</span><br><span class="line">第10章 属性</span><br><span class="line">10.1 无参属性</span><br><span class="line">10.1.1 自动实现的属性</span><br><span class="line">10.1.2 合理定义属性</span><br><span class="line">10.1.3 对象和集合初始化器</span><br><span class="line">10.1.4 匿名类型</span><br><span class="line">10.1.5 SystemTuple类型</span><br><span class="line">l0.2 有参属性</span><br><span class="line">10.3 调用属性访问器方法时的性能</span><br><span class="line">10.4 属性访问器的可访问性</span><br><span class="line">10.5 泛型属性访问器方法</span><br><span class="line">第11章 事件</span><br><span class="line">11.1 设计要公开事件的类型</span><br><span class="line">11.1.1 第一步：定义类型来容纳所需要发送给事件通知接收名的附加信息</span><br><span class="line">11.1.2 第二步：定义事件成员</span><br><span class="line">11.1.3第三步：定义负责引发事件的方法来通知事件的登记对象</span><br><span class="line">11.1.4 第四步：定义方法将输入转化为期望事件</span><br><span class="line">11.2 编译器如何实现事件</span><br><span class="line">11.3 设计侦听事件的类型</span><br><span class="line">11.4 显式实现事件</span><br><span class="line">第12章 泛型</span><br><span class="line">12.1 Framework类库巾的泛型</span><br><span class="line">l2.2 Wintellect的PowerCollections库</span><br><span class="line">12.3泛型基础结构</span><br><span class="line">12.3.1 开放类型和封闭类型</span><br><span class="line">12.3.2 泛型类型和继承</span><br><span class="line">12.3.3泛型类型同一性</span><br><span class="line">12.3.4 代码爆炸</span><br><span class="line">12.4 泛型接口</span><br><span class="line">12.5 泛型委托</span><br><span class="line">12.6 委托和接口的逆变和协变泛型类型实参</span><br><span class="line">12.7 泛型方法</span><br><span class="line">12.8 泛型和其他成员</span><br><span class="line">12.9 可验证性和约束</span><br><span class="line">12.9.1 主要约束</span><br><span class="line">12.9.2 次要约束</span><br><span class="line">12.9 .3构造器约束</span><br><span class="line">12.9.4 其他可验证性问题</span><br><span class="line">第III部分 基本类型</span><br><span class="line">第13章接口</span><br><span class="line">13.1 类和接口继承</span><br><span class="line">13.2 定义接口</span><br><span class="line">13.3 继承接口</span><br><span class="line">13.4 关于调用接口方法的更多探讨</span><br><span class="line">13.5 隐式和显式接口方法实现（幕后发生的事情）</span><br><span class="line">13.6 泛型接口</span><br><span class="line">13.7 泛型和接口约束</span><br><span class="line">13.8 实现多个具有相同方法名和签名的接口</span><br><span class="line">13.9 用显式接口方法实现来增强编译时类型安全性</span><br><span class="line">13.10 谨慎使用显式接口方法实现</span><br><span class="line">13.11 设计：基类还是接口</span><br><span class="line">第14章 字符、字符串和文本处理</span><br><span class="line">14.1 字符</span><br><span class="line">14.2 System. String类型</span><br><span class="line">14.2.1 构造字符串</span><br><span class="line">14.2.2 字符串是不可变的</span><br><span class="line">14.2.3 比较字符串</span><br><span class="line">14.2.4 字符串留用</span><br><span class="line">14.2.5 字符串池</span><br><span class="line">14.2.6 检查字符串中的字符和文本元素</span><br><span class="line">14.2.7 其他字符串操作</span><br><span class="line">14.3高效率构造字符串</span><br><span class="line">14.3.1 构造String Builder对象</span><br><span class="line">14.3.2 StringBuilder的成员</span><br><span class="line">14.4 获取对象的字符串表示：ToString</span><br><span class="line">14.4.1 指定具体的格式和语言文化</span><br><span class="line">14.4 .2将多个对象格式成一个字符串</span><br><span class="line">14.4 .3提供定制格式化器</span><br><span class="line">14.5 解析字符串来获取对象：Parse</span><br><span class="line">14.6 编码：字符和字节的相互转换</span><br><span class="line">14.6.1 字符和字节流的编码和解码</span><br><span class="line">14.6.2 Base.6 4字符串编码和解码</span><br><span class="line">14.7 安全字符串</span><br><span class="line">第15章 枚举类型和位标志</span><br><span class="line">15.1 枚举类型</span><br><span class="line">15.2位标志</span><br><span class="line">15.3向枚举类型添加方法</span><br><span class="line">第16章 数组</span><br><span class="line">16.1 初始化数组元素</span><br><span class="line">16.2 数组转型</span><br><span class="line">16.3 所有数组都隐式派生自System Array</span><br><span class="line">16.4 所有数组都隐式实现。IEnumerablelcollection和IList</span><br><span class="line">16.5 数组的传递和返回</span><br><span class="line">16.6 创建下限非零的数组</span><br><span class="line">16.7 数组的访问性能</span><br><span class="line">16.8 不安伞的数组访问和固定大小的数组</span><br><span class="line">第17章 委托</span><br><span class="line">17.1 初识委托</span><br><span class="line">17.2用委托回调静态方法</span><br><span class="line">17.3用委托回调实例方法</span><br><span class="line">17.4 委托揭秘</span><br><span class="line">17.5 用委托回调许多方法（委托链）</span><br><span class="line">17.5.1 C舟对委托链的支持</span><br><span class="line">17.5 .2取得对委托链调用的更多控制</span><br><span class="line">17.6 委托定义太多（泛型委托）</span><br><span class="line">17.7 C#为委托提供的简化语法</span><br><span class="line">17.7.1 简化语法1：不需要构造委托对象</span><br><span class="line">17.7.2 简化语法2：不需要定义回调方法</span><br><span class="line">17.7 .3简化语法3：局部变量不需要手动包装到类中即可传给回调方法</span><br><span class="line">17.8 委托和反射</span><br><span class="line">第18章 定制attribute</span><br><span class="line">18.1 使用定制attribute</span><br><span class="line">18.2 定义自己的attribute类</span><br><span class="line">18.3 attribute的构造器和字段／属性的数据类型</span><br><span class="line">18.4 检测定制attribute</span><br><span class="line">18.5 两个attribute实例的相互匹配</span><br><span class="line">18.6 检测定制attribute时不创建从Attribute派生的对象</span><br><span class="line">18.7 条件attribute类</span><br><span class="line">第19章 可空值类型</span><br><span class="line">19.1 C#对可窄值类型的支持</span><br><span class="line">19.2 C＃的空接合操作符</span><br><span class="line">19.3 CLR对可空值类型的特殊支持</span><br><span class="line">19.3.1 可空值类型的装箱</span><br><span class="line">19.3.2 可空值类型的拆箱</span><br><span class="line">19.3 .3通过可空值类型调用Get Type</span><br><span class="line">19.3.4 通过可空值类型调用接口方法</span><br><span class="line">第Ⅳ部分 核心机制</span><br><span class="line">第20章 异常和状态管理</span><br><span class="line">20.1 定义“异常</span><br><span class="line">20.2 异常处理机制</span><br><span class="line">20.2.1 try块</span><br><span class="line">20.2.2 catch块</span><br><span class="line">20.2 .3finalb，块</span><br><span class="line">20.3System.Exception类</span><br><span class="line">20.4 FCL定义的异常类</span><br><span class="line">20.5 抛出异常</span><br><span class="line">20.6 定义自己的异常类</span><br><span class="line">20.7 用可靠性换取开发效率</span><br><span class="line">20.8 指导原则和最佳实践</span><br><span class="line">20.8.1 善用finally块</span><br><span class="line">20.8 12不要什么都捕捉</span><br><span class="line">20.8 .3得体地从异常中恢复</span><br><span class="line">20.8.4 发生不可恢复的异常时回滚部分完成的操作——维持状态</span><br><span class="line">20.8.5 隐藏实现细节来维系契约</span><br><span class="line">20.9 未处理的异常</span><br><span class="line">20.10 对异常进行调试</span><br><span class="line">20.11 异常处理的性能问题</span><br><span class="line">20.12 约束执行区域（CER）</span><br><span class="line">20.13 代码契约</span><br><span class="line">第21章 自动内存管理（垃圾回收）</span><br><span class="line">21.1 理解垃圾回收平台的基小工作原理</span><br><span class="line">21.2 垃圾回收算法</span><br><span class="line">……</span><br><span class="line">第22章 CLR寄宿和AppDomain</span><br><span class="line">第23章 程序集加载和反射</span><br><span class="line">第24章 运行时序列化</span><br><span class="line">第V部分 线程处理</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00426BTTY/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00426BTTY&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51JdjeZAQDL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>c#入门经典(第5版)</title>
    <url>/2020/04/19/B004EPZ43A/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： c#入门经典(第5版)<br>作者信息： 作者: 沃森 (Karli Watson) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《C#入门经典(第5版)》编辑推荐：非常权威的Visual C和.NET软件开发书籍。August 5，2010，The Value lnvestor。《C#入门经典(第5版)》是初出茅庐的编程新手的良师益友。富有经验的编程人员则可使用。《C#入门经典(第5版)》巩固学习.NET架构、C#、OOP、Windows窗体、Web服务和ASP.NET等领域的知识。《C#入门经典(第5版)》将为读者深入研究这些领域的高级主题奠定坚实基础。“试一试”练习都简明扼要。我目前仍在学习《C#入门经典(第5版)》，乐此不疲，陶醉其中。<br>Wrox畅销书，C#经典名著！<br>2009年度全行业优秀畅销书品种！<br>2006～2008年最畅销的C群入门教程！<br>2008年全国高校出版社优秀销为一等奖！<br>2006年最受读者喜爱的十大技术开发类图书！<br>2005年最权威的十大IT图书！<br>C#2010最新版。<br>Wrox编程图书。<br>十周年新装庆生。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第Ⅰ部分 C#语言</span><br><span class="line">第1章 C#简介 3</span><br><span class="line">1.1 .net framework的含义 3</span><br><span class="line">1.1.1 .net framework的内容 4</span><br><span class="line">1.1.2 使用.net framework编写应用程序 4</span><br><span class="line">1.2 C#的含义 7</span><br><span class="line">1.2.1 用C#能编写什么样的应用程序 7</span><br><span class="line">1.2.2 本书中的C# 8</span><br><span class="line">1.3 visual studio 2010 8</span><br><span class="line">1.3.1 visual studio 2010 express产品 9</span><br><span class="line">1.3.2 解决方案 9</span><br><span class="line">1.4 小结 9</span><br><span class="line">1.5 本章要点 10</span><br><span class="line">第2章 编写C#程序 11</span><br><span class="line">2.1 开发环境 12</span><br><span class="line">2.1.1 visual studio 2010 12</span><br><span class="line">2.1.2 visual C# 2010 express edition 14</span><br><span class="line">2.2 控制台应用程序 15</span><br><span class="line">2.2.1 solution explorer 19</span><br><span class="line">2.2.2 properties窗口 20</span><br><span class="line">2.2.3 error list窗口 20</span><br><span class="line">2.3 windows forms应用程序 21</span><br><span class="line">2.4 小结 25</span><br><span class="line">2.5 本章要点 25</span><br><span class="line">第3章 变量和表达式 27</span><br><span class="line">3.1 C#的基本语法 27</span><br><span class="line">3.2 C#控制台应用程序的基本结构 30</span><br><span class="line">3.3 变量 31</span><br><span class="line">3.3.1 简单类型 31</span><br><span class="line">3.3.2 变量的命名 35</span><br><span class="line">3.3.3 字面值 36</span><br><span class="line">3.3.4 变量的声明和赋值 38</span><br><span class="line">3.4 表达式 39</span><br><span class="line">3.4.1 数学运算符 39</span><br><span class="line">3.4.2 赋值运算符 43</span><br><span class="line">3.4.3 运算符的优先级 44</span><br><span class="line">3.4.4 名称空间 45</span><br><span class="line">3.5 小结 47</span><br><span class="line">3.6 练习 48</span><br><span class="line">3.7 本章要点 49</span><br><span class="line">第4章 流程控制 51</span><br><span class="line">4.1 布尔逻辑 51</span><br><span class="line">4.1.1 布尔赋值运算符 54</span><br><span class="line">4.1.2 按位运算符 55</span><br><span class="line">4.1.3 运算符优先级的更新 59</span><br><span class="line">4.2 goto语句 60</span><br><span class="line">4.3 分支 61</span><br><span class="line">4.3.1 三元运算符 61</span><br><span class="line">4.3.2 if语句 61</span><br><span class="line">4.3.3 switCh语句 65</span><br><span class="line">4.4 循环 68</span><br><span class="line">4.4.1 do循环 68</span><br><span class="line">4.4.2 while循环 71</span><br><span class="line">4.4.3 for循环 73</span><br><span class="line">4.4.4 循环的中断 77</span><br><span class="line">4.4.5 无限循环 78</span><br><span class="line">4.5 小结 78</span><br><span class="line">4.6 练习 79</span><br><span class="line">4.7 本章要点 79</span><br><span class="line">第5章 变量的更多内容 81</span><br><span class="line">5.1 类型转换 81</span><br><span class="line">5.1.1 隐式转换 82</span><br><span class="line">5.1.2 显式转换 83</span><br><span class="line">5.1.3 使用Convert命令进行显式转换 86</span><br><span class="line">5.2 复杂的变量类型 89</span><br><span class="line">5.2.1 枚举 89</span><br><span class="line">5.2.2 结构 93</span><br><span class="line">5.2.3 数组 96</span><br><span class="line">5.3 字符串的处理 102</span><br><span class="line">5.4 小结 106</span><br><span class="line">5.5 练习 107</span><br><span class="line">5.6 本章要点 108</span><br><span class="line">第6章 函数 109</span><br><span class="line">6.1 定义和使用函数 110</span><br><span class="line">6.1.1 返回值 111</span><br><span class="line">6.1.2 参数 113</span><br><span class="line">6.2 变量的作用域 120</span><br><span class="line">6.2.1 其他结构中变量的作用域 122</span><br><span class="line">6.2.2 参数和返回值与全局数据 124</span><br><span class="line">6.3 main( )函数 125</span><br><span class="line">6.4 结构函数 128</span><br><span class="line">6.5 函数的重载 128</span><br><span class="line">6.6 委托 130</span><br><span class="line">6.7 小结 133</span><br><span class="line">6.8 练习 133</span><br><span class="line">6.9 本章要点 134</span><br><span class="line">第7章 调试和错误处理 135</span><br><span class="line">7.1 vs和vce中的调试 135</span><br><span class="line">7.1.1 非中断(正常)模式下的调试 136</span><br><span class="line">7.1.2 中断模式下的调试 144</span><br><span class="line">7.2 错误处理 152</span><br><span class="line">7.2.1 try…catch…finally 153</span><br><span class="line">7.2.2 列出和配置异常 157</span><br><span class="line">7.2.3 异常处理的注意事项 158</span><br><span class="line">7.3 小结 159</span><br><span class="line">7.4 练习 159</span><br><span class="line">7.5 本章要点 159</span><br><span class="line">第8章 面向对象编程简介 161</span><br><span class="line">8.1 面向对象编程的含义 162</span><br><span class="line">8.1.1 对象的含义 162</span><br><span class="line">8.1.2 一切皆对象 165</span><br><span class="line">8.1.3 对象的生命周期 165</span><br><span class="line">8.1.4 静态和实例类成员 166</span><br><span class="line">8.2 oop技术 167</span><br><span class="line">8.2.1 接口 167</span><br><span class="line">8.2.2 继承 169</span><br><span class="line">8.2.3 多态性 171</span><br><span class="line">8.2.4 对象之间的关系 172</span><br><span class="line">8.2.5 运算符重载 173</span><br><span class="line">8.2.6 事件 174</span><br><span class="line">8.2.7 引用类型和值类型 174</span><br><span class="line">8.3 windows应用程序中的oop 175</span><br><span class="line">8.4 小结 177</span><br><span class="line">8.5 练习 177</span><br><span class="line">8.6 本章要点 178</span><br><span class="line">第9章 定义类 179</span><br><span class="line">9.1 C#中的类定义 179</span><br><span class="line">9.2 system.objeCt 184</span><br><span class="line">9.3 构造函数和析构函数 185</span><br><span class="line">9.4 vs和vCe中的oop工具 190</span><br><span class="line">9.4.1 Class view窗口 190</span><br><span class="line">9.4.2 对象浏览器 192</span><br><span class="line">9.4.3 添加类 193</span><br><span class="line">9.4.4 类图 194</span><br><span class="line">9.5 类库项目 196</span><br><span class="line">9.6 接口和抽象类 199</span><br><span class="line">9.7 结构类型 201</span><br><span class="line">9.8 浅度和深度复制 203</span><br><span class="line">9.9 小结 203</span><br><span class="line">9.10 练习 204</span><br><span class="line">9.11 本章要点 204</span><br><span class="line">第10章 定义类成员 205</span><br><span class="line">10.1 成员定义 205</span><br><span class="line">10.1.1 定义字段 206</span><br><span class="line">10.1.2 定义方法 206</span><br><span class="line">10.1.3 定义属性 207</span><br><span class="line">10.1.4 在类图中添加成员 212</span><br><span class="line">10.1.5 重构成员 215</span><br><span class="line">10.1.6 自动属性 216</span><br><span class="line">10.2 类成员的其他议题 217</span><br><span class="line">10.2.1 隐藏基类方法 217</span><br><span class="line">10.2.2 调用重写或隐藏的基类方法 219</span><br><span class="line">10.2.3 嵌套的类型定义 220</span><br><span class="line">10.3 接口的实现 220</span><br><span class="line">10.4 部分类定义 224</span><br><span class="line">10.5 部分方法定义 225</span><br><span class="line">10.6 示例应用程序 227</span><br><span class="line">10.6.1 规划应用程序 227</span><br><span class="line">10.6.2 编写类库 228</span><br><span class="line">10.6.3 类库的客户应用程序 235</span><br><span class="line">10.7 call hierarchy窗口 236</span><br><span class="line">10.8 小结 237</span><br><span class="line">10.9 练习 237</span><br><span class="line">10.10 本章要点 238</span><br><span class="line">第11章 集合、比较和转换 239</span><br><span class="line">11.1 集合 239</span><br><span class="line">11.1.1 使用集合 240</span><br><span class="line">11.1.2 定义集合 246</span><br><span class="line">11.1.3 索引符 247</span><br><span class="line">11.1.4 给Cardlib添加Cards集合 250</span><br><span class="line">11.1.5 关键字值集合和idiCtionary 252</span><br><span class="line">11.1.6 迭代器 254</span><br><span class="line">11.1.7 深复制 259</span><br><span class="line">11.1.8 给Cardlib添加深复制 261</span><br><span class="line">11.2 比较 263</span><br><span class="line">11.2.1 类型比较 263</span><br><span class="line">11.2.2 值比较 268</span><br><span class="line">11.3 转换 283</span><br><span class="line">11.3.1 重载转换运算符 284</span><br><span class="line">11.3.2 as运算符 285</span><br><span class="line">11.4 小结 286</span><br><span class="line">11.5 练习 286</span><br><span class="line">11.6 本章要点 287</span><br><span class="line">第12章 泛型 289</span><br><span class="line">12.1 泛型的概念 289</span><br><span class="line">12.2 使用泛型 291</span><br><span class="line">12.2.1 可空类型 291</span><br><span class="line">12.2.2 system.ColleCtions.generiC名称空间 297</span><br><span class="line">12.3 定义泛型类型 307</span><br><span class="line">12.3.1 定义泛型类 308</span><br><span class="line">12.3.2 定义泛型接口 319</span><br><span class="line">12.3.3 定义泛型方法 319</span><br><span class="line">12.3.4 定义泛型委托 321</span><br><span class="line">12.4 变体 321</span><br><span class="line">12.4.1 协变 322</span><br><span class="line">12.4.2 抗变 323</span><br><span class="line">12.5 小结 324</span><br><span class="line">12.6 练习 324</span><br><span class="line">12.7 本章要点 325</span><br><span class="line">第13章 其他oop技术 327</span><br><span class="line">13.1 ::运算符和全局名称空间限定符 327</span><br><span class="line">13.2 定制异常 329</span><br><span class="line">13.3 事件 331</span><br><span class="line">13.3.1 事件的含义 331</span><br><span class="line">13.3.2 处理事件 332</span><br><span class="line">13.3.3 定义事件 334</span><br><span class="line">13.4 扩展和使用Cardlib 343</span><br><span class="line">13.5 小结 351</span><br><span class="line">13.6 练习 352</span><br><span class="line">13.7 本章要点 352</span><br><span class="line">第14章 C#语言的改进 353</span><br><span class="line">14.1 初始化器 353</span><br><span class="line">14.1.1 对象初始化器 354</span><br><span class="line">14.1.2 集合初始化器 356</span><br><span class="line">14.2 类型推理 359</span><br><span class="line">14.3 匿名类型 360</span><br><span class="line">14.4 动态查找 364</span><br><span class="line">14.4.1 dynamiC类型 365</span><br><span class="line">14.4.2 idynamiCmetaobjeCtprovider 369</span><br><span class="line">14.5 高级方法参数 369</span><br><span class="line">14.5.1 可选参数 369</span><br><span class="line">14.5.2 命名参数 371</span><br><span class="line">14.5.3 命名参数和可选参数的规则 375</span><br><span class="line">14.6 扩展方法 375</span><br><span class="line">14.7 lambda表达式 379</span><br><span class="line">14.7.1 复习匿名方法 379</span><br><span class="line">14.7.2 把lambda表达式用于匿名方法 380</span><br><span class="line">14.7.3 lambda表达式的参数 383</span><br><span class="line">14.7.4 lambda表达式的语句体 384</span><br><span class="line">14.7.5 lambda表达式用作委托和表达式树 385</span><br><span class="line">14.7.6 lambda表达式和集合 386</span><br><span class="line">14.8 小结 388</span><br><span class="line">14.9 练习 389</span><br><span class="line">14.10 本章要点 390</span><br><span class="line">第Ⅱ部分 windows 编 程</span><br><span class="line">第15章 windows编程基础 393</span><br><span class="line">15.1 控件 393</span><br><span class="line">15.1.1 属性 394</span><br><span class="line">15.1.2 控件的定位、停靠和对齐 395</span><br><span class="line">15.1.3 anchor和dock属性 395</span><br><span class="line">15.1.4 事件 396</span><br><span class="line">15.2 button控件 398</span><br><span class="line">15.2.1 button控件的属性 398</span><br><span class="line">15.2.2 button控件的事件 398</span><br><span class="line">15.2.3 添加事件处理程序 399</span><br><span class="line">15.3 label和linklabel控件 400</span><br><span class="line">15.4 textbox控件 401</span><br><span class="line">15.4.1 textbox控件的属性 401</span><br><span class="line">15.4.2 textbox控件的事件 402</span><br><span class="line">15.4.3 添加事件处理程序 404</span><br><span class="line">15.5 radiobutton和CheCkbox控件 407</span><br><span class="line">15.5.1 radiobutton控件的属性 408</span><br><span class="line">15.5.2 radiobutton控件的事件 408</span><br><span class="line">15.5.3 CheCkbox控件的属性 408</span><br><span class="line">15.5.4 CheCkbox控件的事件 409</span><br><span class="line">15.5.5 groupbox控件 409</span><br><span class="line">15.6 riChtextbox控件 412</span><br><span class="line">15.6.1 riChtextbox控件的属性 412</span><br><span class="line">15.6.2 riChtextbox控件的事件 413</span><br><span class="line">15.7 listbox和CheCkedlistbox控件 418</span><br><span class="line">15.7.1 listbox控件的属性 418</span><br><span class="line">15.7.2 listbox控件的方法 419</span><br><span class="line">15.7.3 listbox控件的事件 420</span><br><span class="line">15.8 listview控件 422</span><br><span class="line">15.8.1 listview控件的属性 422</span><br><span class="line">15.8.2 listview控件的方法 424</span><br><span class="line">15.8.3 listview控件的事件 424</span><br><span class="line">15.8.4 listviewitem 425</span><br><span class="line">15.8.5 Columnheader 425</span><br><span class="line">15.8.6 imagelist控件 425</span><br><span class="line">15.9 tabControl控件 431</span><br><span class="line">15.9.1 tabControl控件的属性 432</span><br><span class="line">15.9.2 使用tabControl控件 432</span><br><span class="line">15.10 小结 434</span><br><span class="line">15.11 练习 434</span><br><span class="line">15.12 本章要点 434</span><br><span class="line">第16章 windows窗体的高级功能 435</span><br><span class="line">第17章 部署windows应用程序 465</span><br><span class="line">第Ⅲ部分 web 编 程</span><br><span class="line">第18章 asp.net web编程 503</span><br><span class="line">第19章 web服务 557</span><br><span class="line">第20章 部署web应用程序 581</span><br><span class="line">第Ⅳ部分 数 据 访 问</span><br><span class="line">第21章 文件系统数据 597</span><br><span class="line">第22章 xml 633</span><br><span class="line">第23章 linq简介 657</span><br><span class="line">第24章 应用linq 695</span><br><span class="line">第Ⅴ部分 其 他 技 术</span><br><span class="line">第25章 windows presentation</span><br><span class="line">第26章 windows Communication Foundation 787</span><br><span class="line">第27章 windows workflow foundation 819</span><br><span class="line">附录A 习题答案 839</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B004EPZ43A/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B004EPZ43A&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51bYpE1B1iL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象程序设计:C++语言描述(原书第2版)</title>
    <url>/2020/04/19/B0056E9HV8/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 面向对象程序设计:C++语言描述(原书第2版)<br>作者信息： 作者: 约翰逊鲍尔(Richard Johnsonbaugh) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《面向对象程序设计:C++语言描述(原书第2版)》深刻论述了C++语言的面向对象程序设计的各种技术。内容包括：面向对象编程方法、C++语言的各种特性、STLC++输入／输出流、MFC等。《面向对象程序设计:C++语言描述(原书第2版)》配备了大量的习题，并列举了易犯的错误及避免错误的方法，易于读者的学习。<br>《面向对象程序设计:C++语言描述(原书第2版)》特点：结构合理、高效：内容讲解由浅入深、循序渐进。内容充实、实用：涵盖C++主要知识点，并附有经典实训案例。语言严谨、精练：结合实训案例，内容介绍层层展开、环环相扣。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">出版者的话</span><br><span class="line">译者序</span><br><span class="line">前言</span><br><span class="line">第1章 面向对象编程</span><br><span class="line">1.1 面向过程的编程风格与面向对象的编程风格</span><br><span class="line">1.1.1 面向过程的编程风格</span><br><span class="line">1.1.2 面向对象的编程风格</span><br><span class="line">1.1.3 关系</span><br><span class="line">1.1.4 课后练习</span><br><span class="line">1.2 类与抽象数据类型</span><br><span class="line">1.2.1 信息隐藏</span><br><span class="line">1.2.2 封装</span><br><span class="line">1.2.3 抽象数据类型</span><br><span class="line">1.2.4 课后练习</span><br><span class="line">1.3 客户&#x2F;服务器模式与消息传递</span><br><span class="line">1.3.1 客户&#x2F;服务器模式</span><br><span class="line">1.3.2 消息传递与方法调用</span><br><span class="line">1.3.3 课后练习</span><br><span class="line">1.4 继承与多态</span><br><span class="line">1.4.1 继承</span><br><span class="line">1.4.2 多态</span><br><span class="line">1.4.3 多态与递归</span><br><span class="line">1.4.4 课后练习</span><br><span class="line">1.5 接口与组件</span><br><span class="line">1.5.1 接口</span><br><span class="line">1.5.2 组件</span><br><span class="line">1.5.3 课后练习</span><br><span class="line">第2章 从c到c++</span><br><span class="line">2.1 名字空间</span><br><span class="line">2.1.1 课后练习</span><br><span class="line">2.2 c++输入&#x2F;输出简介</span><br><span class="line">2.2.1 操纵符</span><br><span class="line">2.2.2 混合使用c和c++的输入&#x2F;输出</span><br><span class="line">2.2.3 课后练习</span><br><span class="line">2.3 文件</span><br><span class="line">2.3.1 测试文件的打开状态</span><br><span class="line">2.3.2 课后练习</span><br><span class="line">2.4 若干重要的c++特性</span><br><span class="line">2.4.1 强制类型转换</span><br><span class="line">2.4.2 常数</span><br><span class="line">2.4.3 数据类型bool</span><br><span class="line">2.4.4 枚举类型</span><br><span class="line">2.4.5 定义变量</span><br><span class="line">2.4.6 结构</span><br><span class="line">2.4.7 课后练习</span><br><span class="line">2.5 string类型</span><br><span class="line">2.5.1 定义string类型的变量</span><br><span class="line">2.5.2 转换为c风格的字符串</span><br><span class="line">2.5.3 字符串长度</span><br><span class="line">2.5.4 读写string</span><br><span class="line">2.5.5 赋值</span><br><span class="line">2.5.6 字符串的连接</span><br><span class="line">2.5.7 修改字符串</span><br><span class="line">2.5.8 提取子串</span><br><span class="line">2.5.9 查找</span><br><span class="line">2.5.10 字符串比较</span><br><span class="line">2.5.11 课后练习</span><br><span class="line">2.6 函数</span><br><span class="line">2.6.1 函数原型</span><br><span class="line">2.6.2 main函数</span><br><span class="line">2.6.3 引用</span><br><span class="line">2.6.4 引用调用</span><br><span class="line">2.6.5 引用返回</span><br><span class="line">2.6.6 内联函数</span><br><span class="line">2.6.7 函数默认参数</span><br><span class="line">2.6.8 函数重载</span><br><span class="line">2.6.9 函数签名</span><br><span class="line">2.6.10 课后练习</span><br><span class="line">2.7 new和delete操作符</span><br><span class="line">2.7.1 课后练习</span><br><span class="line">2.8 例外处理</span><br><span class="line">2.8.1 课后练习</span><br><span class="line">2.9 补充材料</span><br><span class="line">2.9.1 c++关键字</span><br><span class="line">2.9.2 无名名字空间</span><br><span class="line">2.9.3 无名联合</span><br><span class="line">2.9.4 成员选择符</span><br><span class="line">2.10 常见编程错误</span><br><span class="line">2.11 编程习题</span><br><span class="line">第3章 类</span><br><span class="line">3.1 类和对象</span><br><span class="line">3.1.1 类声明</span><br><span class="line">3.1.2 c++的信息隐藏机制</span><br><span class="line">3.1.3 成员选择符</span><br><span class="line">3.1.4 类范围</span><br><span class="line">3.1.5 关键字class和struct的区别</span><br><span class="line">3.1.6 类成员函数的定义</span><br><span class="line">3.1.7 在程序中使用类</span><br><span class="line">3.1.8 课后练习</span><br><span class="line">3.2 示例程序:堆栈类</span><br><span class="line">3.2.1 问题</span><br><span class="line">3.2.2 示例程序的输出</span><br><span class="line">3.2.3 解决方案</span><br><span class="line">3.2.4 类的实现</span><br><span class="line">3.2.5 代码分析</span><br><span class="line">3.2.6 程序设计建议</span><br><span class="line">3.2.7 课后练习</span><br><span class="line">3.3 效率和健壮性</span><br><span class="line">3.3.1 通过引用来传递和返回对象</span><br><span class="line">3.3.2 const类型参数的对象引用</span><br><span class="line">3.3.3 const成员函数</span><br><span class="line">3.3.4 对成员函数进行重载以便处理两种类型的字符串</span><br><span class="line">3.3.5 课后练习</span><br><span class="line">3.4 示例程序:时间标记类</span><br><span class="line">3.4.1 问题</span><br><span class="line">3.4.2 示例程序的输出</span><br><span class="line">3.4.3 解决方案</span><br><span class="line">3.4.4 类的实现</span><br><span class="line">3.4.5 代码分析</span><br><span class="line">3.4.6 程序设计建议</span><br><span class="line">3.4.7 课后练习</span><br><span class="line">3.5 构造函数与析构函数</span><br><span class="line">3.5.1 构造函数</span><br><span class="line">3.5.2 对象数组与默认构造函数</span><br><span class="line">3.5.3 通过构造函数约束对象的创建</span><br><span class="line">3.5.4 拷贝构造函数</span><br><span class="line">3.5.5 定义拷贝构造函数</span><br><span class="line">3.5.6 禁止通过传值方式传递和返回类对象</span><br><span class="line">3.5.7 转型构造函数</span><br><span class="line">3.5.8 转型构造函数与隐式类型转换</span><br><span class="line">3.5.9 构造函数初始化程序</span><br><span class="line">3.5.10 构造函数与操作符new和new[]</span><br><span class="line">3.5.11 析构函数</span><br><span class="line">3.5.12 课后练习</span><br><span class="line">3.6 示例程序:task类</span><br><span class="line">3.6.1 问题</span><br><span class="line">3.6.2 示例程序的输出</span><br><span class="line">3.6.3 解决方案</span><br><span class="line">3.6.4 类的实现</span><br><span class="line">3.6.5 代码分析</span><br><span class="line">3.6.6 课后练习</span><br><span class="line">3.7 类数据成员和类成员函数</span><br><span class="line">3.7.1 类数据成员</span><br><span class="line">3.7.2 类成员函数</span><br><span class="line">3.7.3 在成员函数内定义static变量</span><br><span class="line">3.7.4 课后练习</span><br><span class="line">3.8 指向对象的指针</span><br><span class="line">3.8.1 常量指针this</span><br><span class="line">3.8.2 课后练习</span><br><span class="line">3.9 常见编程错误</span><br><span class="line">3.10 编程习题</span><br><span class="line">第4章 继承</span><br><span class="line">4.1 引言</span><br><span class="line">4.1.1 课后练习</span><br><span class="line">4.2 基本概念和语法</span><br><span class="line">4.2.1 继承机制下的私有成员</span><br><span class="line">4.2.2 改变访问限制</span><br><span class="line">4.2.3 名字隐藏</span><br><span class="line">4.2.4 间接继承</span><br><span class="line">4.2.5 课后练习</span><br><span class="line">4.3 示例程序:影片跟踪管理</span><br><span class="line">4.3.1 问题</span><br><span class="line">4.3.2 示例程序的输出</span><br><span class="line">4.3.3 解决方案</span><br><span class="line">4.3.4 类的实现</span><br><span class="line">4.3.5 代码分析</span><br><span class="line">4.3.6 程序设计建议</span><br><span class="line">4.4 保护成员</span><br><span class="line">4.4.1 课后练习</span><br><span class="line">4.5 继承机制下的构造函数与析构函数</span><br><span class="line">4.5.1 继承机制下的构造函数</span><br><span class="line">4.5.2 派生类构造函数的规则</span><br><span class="line">4.5.3 继承机制下的析构函数</span><br><span class="line">4.5.4 课后练习</span><br><span class="line">4.6 示例程序:设计序列的类层次结构</span><br><span class="line">4.6.1 问题</span><br><span class="line">4.6.2 示例程序的输入与输出</span><br><span class="line">4.6.3 解决方案</span><br><span class="line">4.6.4 类的实现</span><br><span class="line">4.6.5 代码分析</span><br><span class="line">4.7 多继承</span><br><span class="line">4.7.1 继承和访问规则</span><br><span class="line">4.7.2 虚基类</span><br><span class="line">4.7.3 课后练习</span><br><span class="line">4.8 补充材料</span><br><span class="line">4.8.1 保护继承</span><br><span class="line">4.8.2 私有继承</span><br><span class="line">4.9 常见编程错误</span><br><span class="line">4.10 编程习题</span><br><span class="line">第5章 多态</span><br><span class="line">5.1 c++中的运行期绑定与编译期绑定</span><br><span class="line">5.1.1 c++多态的前提条件</span><br><span class="line">5.1.2 虚成员函数继承</span><br><span class="line">5.1.3 运行期绑定和虚成员函数表</span><br><span class="line">5.1.4 构造函数与析构函数</span><br><span class="line">5.1.5 虚析构函数</span><br><span class="line">5.1.6 对象成员函数和类成员函数</span><br><span class="line">5.1.7 课后练习</span><br><span class="line">5.2 示例程序:改进的影片跟踪管理</span><br><span class="line">5.2.1 问题</span><br><span class="line">5.2.2 示例程序的输入&#x2F;输出</span><br><span class="line">5.2.3 解决方案</span><br><span class="line">5.2.4 类的实现</span><br><span class="line">5.2.5 代码分析</span><br><span class="line">5.2.6 程序设计建议</span><br><span class="line">5.2.7 课后练习</span><br><span class="line">5.3 重载、覆盖和遮蔽</span><br><span class="line">5.3.1 重载</span><br><span class="line">5.3.2 覆盖</span><br><span class="line">5.3.3 遮蔽</span><br><span class="line">5.3.4 名字共享</span><br><span class="line">5.3.5 课后练习</span><br><span class="line">5.4 抽象基类</span><br><span class="line">5.4.1 抽象基类和纯虚成员函数</span><br><span class="line">5.4.2 定义纯虚成员函数的限制</span><br><span class="line">5.4.3 抽象基类的使用</span><br><span class="line">5.4.4 微软的iunknown接口</span><br><span class="line">5.4.5 课后练习</span><br><span class="line">5.5 运行期类型识别</span><br><span class="line">5.5.1 dynamic_cast操作符</span><br><span class="line">5.5.2 dynamic_cast的规则</span><br><span class="line">5.5.3 dynamic_cast与static_cast小结</span><br><span class="line">5.5.4 typeid操作符</span><br><span class="line">5.5.5 扩展rtti</span><br><span class="line">5.5.6 课后练习</span><br><span class="line">5.6 补充材料</span><br><span class="line">5.6.1 强多态和弱多态</span><br><span class="line">5.7 常见编程错误</span><br><span class="line">5.8 编程习题</span><br><span class="line">第6章 操作符重载</span><br><span class="line">6.1 基本操作符重载</span><br><span class="line">6.1.1 操作符的优先级和语法</span><br><span class="line">6.1.2 课后练习</span><br><span class="line">6.2 示例程序:复数类</span><br><span class="line">6.2.1 问题</span><br><span class="line">6.2.2 示例程序的输出</span><br><span class="line">6.2.3 解决方案</span><br><span class="line">6.2.4 类的实现</span><br><span class="line">6.2.5 代码分析</span><br><span class="line">6.2.6 课后练习</span><br><span class="line">6.3 用顶层函数进行操作符重载</span><br><span class="line">6.3.1 课后练习</span><br><span class="line">6.4 friend函数</span><br><span class="line">6.4.1 课后练习</span><br><span class="line">6.5 输入与输出操作符的重载</span><br><span class="line">6.5.1 课后练习</span><br><span class="line">6.6 赋值操作符的重载</span><br><span class="line">6.6.1 课后练习</span><br><span class="line">6.7 特殊操作符的重载</span><br><span class="line">6.7.1 下标操作符的重载</span><br><span class="line">6.7.2 函数调用操作符的重载</span><br><span class="line">6.7.3 自增与自减操作符的重载</span><br><span class="line">6.7.4 转型操作符</span><br><span class="line">6.7.5 课后练习</span><br><span class="line">6.8 示例程序:关联式数组</span><br><span class="line">6.8.1 问题</span><br><span class="line">6.8.2 示例程序的输入与输出</span><br><span class="line">6.8.3 解决方案</span><br><span class="line">6.8.4 类的实现</span><br><span class="line">6.8.5 代码分析</span><br><span class="line">6.8.6 课后练习</span><br><span class="line">6.9 内存管理操作符</span><br><span class="line">6.9.1 课后练习</span><br><span class="line">6.10 补充材料</span><br><span class="line">6.10.1 friend类</span><br><span class="line">6.11 常见编程错误</span><br><span class="line">6.12 编程习题</span><br><span class="line">第7章 模板与标准模板库</span><br><span class="line">7.1 模板的基本知识</span><br><span class="line">7.1.1 模板实例</span><br><span class="line">7.1.2 参数表中的模板类</span><br><span class="line">7.1.3 模板的函数式参数</span><br><span class="line">7.1.4 课后练习</span><br><span class="line">7.2 示例程序:模板堆栈类</span><br><span class="line">7.2.1 问题</span><br><span class="line">7.2.2 示例程序的输出</span><br><span class="line">7.2.3 解决方案</span><br><span class="line">7.2.4 类的实现</span><br><span class="line">7.2.5 代码分析</span><br><span class="line">7.2.6 程序设计建议</span><br><span class="line">7.2.7 断言</span><br><span class="line">7.2.8 课后练习</span><br><span class="line">7.3 标准模板库stl</span><br><span class="line">7.3.1 容器、算法和迭代器</span><br><span class="line">7.3.2 stl的优越性</span><br><span class="line">7.3.3 容器基础知识</span><br><span class="line">7.3.4 基本序列式容器:vector、deque和list</span><br><span class="line">7.3.5 vector、deque和list的效率比较</span><br><span class="line">7.3.6 基本的关联式容器:set、mult- iset、map和multimap</span><br><span class="line">7.3.7 容器适配器</span><br><span class="line">7.3.8 其他容器</span><br><span class="line">7.3.9 stl算法</span><br><span class="line">7.3.10 其他stl构件</span><br><span class="line">7.3.11 课后练习</span><br><span class="line">7.4 示例程序:证券业绩报表</span><br><span class="line">7.4.1 问题</span><br><span class="line">7.4.2 示例程序的输入与输出</span><br><span class="line">7.4.3 解决方案</span><br><span class="line">7.4.4 类的实现</span><br><span class="line">7.4.5 代码分析</span><br><span class="line">7.5 附加材料</span><br><span class="line">7.5.1 模板类与继承</span><br><span class="line">7.6 常见编程错误</span><br><span class="line">7.7 编程习题</span><br><span class="line">第8章 c++输入输出类层次</span><br><span class="line">8.1 概况</span><br><span class="line">8.1.1 输入输出库中的流类层次</span><br><span class="line">8.1.2 输入输出库中的缓冲类层次</span><br><span class="line">8.1.3 缓冲类层次与流类层次的关系</span><br><span class="line">8.1.4 模板的使用</span><br><span class="line">8.1.5 课后练习</span><br><span class="line">8.2 ios_base和basic_ios类</span><br><span class="line">8.2.1 ios_base</span><br><span class="line">8.2.2 basic_ios</span><br><span class="line">8.2.3 例外处理</span><br><span class="line">8.2.4 课后练习</span><br><span class="line">8.3 高层输入输出类</span><br><span class="line">8.3.1 basic_istream</span><br><span class="line">8.3.2 basic_ostream</span><br><span class="line">8.3.3 basic_iostream</span><br><span class="line">8.3.4 课后练习</span><br><span class="line">8.4 操纵器</span><br><span class="line">8.4.1 设计不带参数的操纵器</span><br><span class="line">8.4.2 设计带参数的操纵器</span><br><span class="line">8.4.3 课后练习</span><br><span class="line">8.5 文件输入输出类</span><br><span class="line">8.5.1 basic_ofstream</span><br><span class="line">8.5.2 basic_ifstream</span><br><span class="line">8.5.3 basic_fstream</span><br><span class="line">8.5.4 课后练习</span><br><span class="line">8.6 示例程序:随机存取文件类</span><br><span class="line">8.6.1 问题</span><br><span class="line">8.6.2 示例程序的输入与输出</span><br><span class="line">8.6.3 解决方案</span><br><span class="line">8.6.4 类的实现</span><br><span class="line">8.6.5 代码分析</span><br><span class="line">8.7 字符流输入&#x2F;输出类</span><br><span class="line">8.7.1 basic_ostringstream</span><br><span class="line">8.7.2 basic_istringstream</span><br><span class="line">8.7.3 basic_stringstream</span><br><span class="line">8.7.4 课后练习</span><br><span class="line">8.8 示例程序:高层拷贝函数</span><br><span class="line">8.8.1 问题</span><br><span class="line">8.8.2 解决方案</span><br><span class="line">8.8.3 类的实现</span><br><span class="line">8.8.4 代码分析</span><br><span class="line">8.8.5 课后练习</span><br><span class="line">8.9 缓冲区类</span><br><span class="line">8.9.1 basic_streambuf</span><br><span class="line">8.9.2 basic_filebuf</span><br><span class="line">8.9.3 basic_stringbuf</span><br><span class="line">8.9.4 课后练习</span><br><span class="line">8.10 补充材料</span><br><span class="line">8.11 常见编程错误</span><br><span class="line">8.12 编程习题</span><br><span class="line">第9章 mfc中的面向对象编程</span><br><span class="line">9.1 用mfc进行windows程序设计</span><br><span class="line">9.1.1 mfc编程的代码生成器</span><br><span class="line">9.1.2 课后练习</span><br><span class="line">9.2 mfc中的文档&#x2F;视图结构</span><br><span class="line">9.2.1 文档序列化</span><br><span class="line">9.2.2 课后练习</span><br><span class="line">9.3 示例程序:文档序列化</span><br><span class="line">9.3.1 问题</span><br><span class="line">9.3.2 示例程序的输出</span><br><span class="line">9.3.3 解决方案</span><br><span class="line">9.3.4 类的实现</span><br><span class="line">9.3.5 代码分析</span><br><span class="line">9.3.6 课后练习</span><br><span class="line">9.4 com</span><br><span class="line">9.4.1 可更改的服务器和不可变更的接口</span><br><span class="line">9.4.2 com接口的层次</span><br><span class="line">9.4.3 idispatch接口</span><br><span class="line">9.4.4 com程序的类型</span><br><span class="line">9.4.5 vc++对com的支持</span><br><span class="line">9.4.6 com和ole</span><br><span class="line">9.4.7 课后练习</span><br><span class="line">9.5 示例程序:自动化服务器与控制器</span><br><span class="line">9.5.1 问题</span><br><span class="line">9.5.2 示例程序的输出</span><br><span class="line">9.5.3 解决方案</span><br><span class="line">9.5.4 类的实现</span><br><span class="line">9.5.5 代码分析</span><br><span class="line">9.5.6 引用计数问题</span><br><span class="line">9.5.7 课后练习</span><br><span class="line">9.6 补充材料</span><br><span class="line">9.7 编程习题</span><br><span class="line">附录a ascii表</span><br><span class="line">附录b 用到的c++函数和成员函数</span><br><span class="line">附录c 奇数编号练习的提示及答案</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0056E9HV8/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0056E9HV8&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51o2FndC0yL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C#设计模式</title>
    <url>/2020/04/19/B005APNMJQ/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C#设计模式<br>作者信息： 作者: 库珀(James W.Cooper) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《C#设计模式》针对日常的软件开发问题，设计模式提供了一种优雅的、通用的可重用解决方案。程序员可以通过设计模式组织程序中的对象，使其更易于编写和修改。《C#设计模式》正是一本设计模式的实用指南，帮助你采用最常见的模式来编写C#程序。《C#设计模式》由James W. Cooper编著，首先简明扼要地介绍了C#、面向对象编程、继承和UML图，然后分章描述了23种设计模式及各自的使用场合，并阐明了模式在大型设计中的作用。每种模式的用法都配有相应的示例程序演示，这些程序收录在随书配套光盘中，可以直接运行、测试、编辑和使用。设计模式不难学!资深开发工程师20年经验心得，为你呈现……经过如下实践，设计模式将对你的工作产生深远影响。设计模式不仅可以提高工作效率，而且会成为C#程序设计中不可或缺的组成部分。将设计模式有效地应用于日常编程工作中，使用模式创建复杂、健壮的C#程序，采用UML图展示类之间的交互，使用设计模式提高编程技巧。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1部分 面向对象的C#编程</span><br><span class="line">第1章 什么是设计模式</span><br><span class="line">1.1 定义设计模式</span><br><span class="line">1.2 学习进程</span><br><span class="line">1.3 学习设计模式</span><br><span class="line">1.4 关于面向对象方法的说明</span><br><span class="line">1.5 C#设计模式</span><br><span class="line">1.6 本书的内容组织 </span><br><span class="line"></span><br><span class="line"> 第2章 C#语法 2.1 数据类型 2.2 数值与串之间的转换 2.3 声明多个变量 2.4 数值常量 2.5 字符常量 2.6 变量 2.7 用于初始化的连等号 2.8 一个简单的C#程序 2.9 算术运算符 2.10 递增和递减运算符 2.11 合并运算语句和赋值语句 2.12 C#中的判断 2.13 比较运算符 2.14 组合条件 2.15 最常见的错误 2.16 switch语句 2.17 C#的注释 2.18 有争议的三元运算符 2.19 C#中的循环语句 2.20 while循环 2.21 do-while语句 2.22 for循环 2.23 在for循环中根据需要声明变量 2.24 for循环语句中的逗号 2.25 C#与C的不同之处 2.26 C#与Java的不同之处 2.27 小结</span><br><span class="line"></span><br><span class="line"> 第3章 编写C#版的Windows程序 3.1 C#中的对象 3.2 受管语言和垃圾收集 3.3 C#中的类和命名空间 3.4 构建C#应用 3.5 用C#编写的最简单的窗口程序 3.6 Windows控件 3.6.1 标签(Label) 3.6.2 文本框(TextBox) 3.6.3 复选框(CheckBox) 3.6.4 按钮(Button) 3.6.5 单选按钮(Radio Button) 3.6.6 列表框(ListBox)和组合框(ComboBox) 3.6.7 项目集合(Item Collection) 3.6.8 菜单(Menu) 3.6.9 工具提示(ToolTjp) 3.7 Windows控件程序 3.8 小结 3.9 配套光盘上的程序</span><br><span class="line"></span><br><span class="line"> 第4章 在C#中使用类和对象 4.1 使用类的用意所在 4.2 一个简单的温度转换程序 4.3 构建一个Temperature类 4.4 把判断放入到Temperature类中 4.5 使用格式化类和值转换类 4.6 串的分词器类 4.7 作为对象的类 4.8 类包含 4.9 初始化 4.10 类和属性 4.11 C#编程风格 4.12 委派 4.13 索引器 4.14. 运算符重载 4.15 小结 4.16 配套光盘上的程序</span><br><span class="line"></span><br><span class="line"> 第5章 继承 5.1 构造函数 5.2 C#中的绘图和图形 5.3 使用继承 5.4 命名空间 5.5 公有的、私有的和受保护的 5.6 重载 5.7 virtual和override关键字 5.8 在派生类中重写方法 5.9 使用new关键字来替换方法 5.10 重写Windows控件 S.11 接口 5.12 抽象类 5.13 比较接口和抽象类 5.14 小结 5.15 配套光盘上的程序</span><br><span class="line"></span><br><span class="line"> 第6章 UML图 6.1 继承 6.2 接口 6.3 组合 6.4 注解 6.5 WithClass的UML图 6.6 C#工程文件</span><br><span class="line"></span><br><span class="line"> 第7章 C#中的数组、文件和异常</span><br><span class="line"></span><br><span class="line"> 第2部分 创建型模式 第8章 简单工厂模式 第9章 工厂方法 第10章 抽象工厂模式 第11章 单件模式 第12章 生成器模式 第13章 原型模式</span><br><span class="line"></span><br><span class="line"> 第3部分 结构型模式 第14章 适配器模式 第15章 桥接模式 第16章 组合模式 第17章 装饰器模式 第18章 外观模式 第19章 享元模式 第20章 代理模式</span><br><span class="line"></span><br><span class="line"> 第4部分 行为型模式 第21章 职责链 第22章 命令模式 第23章 解释器模式 第24章 迭代器模式 第25章 中介者模式 第26章 备忘录模式 第27章 观察者模式 第28章 状态模式 第29章 策略模式 第30章 模板方法模式 第31章 访问者模式</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B005APNMJQ/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B005APNMJQ&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51pJJP8dCKL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>写给Web开发人员看的HTML5教程</title>
    <url>/2020/04/19/B007HAOVXI/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 写给Web开发人员看的HTML5教程<br>作者信息： 作者: Klaus F?rster [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《写给Web开发人员看的HTML5教程》适合具有一定的HTML和JavaScript基础的Web开发人员阅读。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章Web标准概述</span><br><span class="line">1.1HTML5诞生始末</span><br><span class="line">1.2重大历史事件回顾</span><br><span class="line">1.3拣重要的说</span><br><span class="line">1.3.1有什么新特色？</span><br><span class="line">1.3.2去掉了什么？</span><br><span class="line">1.3.3XHTML呢？</span><br><span class="line">1.4现在我可以开始使用HTML5了吗？</span><br><span class="line">小结</span><br><span class="line">第2章文档结构和语义</span><br><span class="line">2.1页眉的header和hgroup标签</span><br><span class="line">2.2正文（article）内容</span><br><span class="line">2.3由footer和nav组成的页脚</span><br><span class="line">2.4由aside及section组成的工具栏</span><br><span class="line">2.5大纲算法</span><br><span class="line">2.6图形中的figure及figcaption</span><br><span class="line">2.7文档级别语义——更多新的标签</span><br><span class="line">2.7.1元素ruby、rt及rp</span><br><span class="line">2.7.2time元素</span><br><span class="line">2.7.3mark元素</span><br><span class="line">2.7.4wbr元素</span><br><span class="line">2.7.5略微改变的元素</span><br><span class="line">小结</span><br><span class="line">第3章智能表单</span><br><span class="line">3.1新的输入类型（inputtype）</span><br><span class="line">3.1.1输入类型tel及search</span><br><span class="line">3.1.2输入类型url及email</span><br><span class="line">3.1.3用datetime，date，month，week，time以及datetime—local表示日期和时间</span><br><span class="line">3.1.4输入类型number及range</span><br><span class="line">3.1.5输入类型color</span><br><span class="line">3.1.6新输入类型的实际应用</span><br><span class="line">3.2有用的表单属性</span><br><span class="line">3.2.1使用autofocus操作焦点</span><br><span class="line">3.2.2为文本使用placeholder占位符</span><br><span class="line">3.2.3使用required定义必填项</span><br><span class="line">3.2.4input元素中的更多属性</span><br><span class="line">3.3新的元素</span><br><span class="line">3.3.1使用meter显示度量</span><br><span class="line">3.3.2用progress显示任务进程</span><br><span class="line">3.3.3datalist选项列表</span><br><span class="line">3.3.4使用keygen处理密钥</span><br><span class="line">3.3.5用output进行计算</span><br><span class="line">3.4客户端表单验证</span><br><span class="line">3.4.1invalid事件</span><br><span class="line">3.4.2checkValidity函数</span><br><span class="line">3.4.3使用setCustomValidity（）进行错误处理</span><br><span class="line">3.4.4有效性验证总结</span><br><span class="line">3.4.5不做有效性验证也许更好？“formnovalidate”</span><br><span class="line">3.5案例：一张维修表单</span><br><span class="line">小结</span><br><span class="line">第4章视频与音频</span><br><span class="line">4.1第一个案例</span><br><span class="line">4.2video元素及其属性</span><br><span class="line">4.3视频编解码器</span><br><span class="line">4.3.1Ogg：Theora与Vorbis</span><br><span class="line">4.3.2MPEG—4：H.264与AAC</span><br><span class="line">4.3.3WebM：VP8与Vorbis</span><br><span class="line">4.4视频转换工具</span><br><span class="line">4.4.1FFmpeg</span><br><span class="line">4.4.2VLC</span><br><span class="line">4.4.3Firefogg</span><br><span class="line">4.4.4MiroVideoConverter</span><br><span class="line">4.5各种浏览器支持些什么格式</span><br><span class="line">4.6旧浏览器的过渡解决方案</span><br><span class="line">4.6.1mwEmbed</span><br><span class="line">4.6.2htm15media</span><br><span class="line">4.7视频与脚本——简单的视频播放器</span><br><span class="line">4.7.1视频整合</span><br><span class="line">4.7.2播放和暂停视频</span><br><span class="line">4.7.3显示及设定播放位置</span><br><span class="line">4.7.4快进和后退</span><br><span class="line">4.7.5选择电影场景</span><br><span class="line">4.7.6音量调节及静音</span><br><span class="line">4.7.8HTMLMediaElement接口中其他的属性及方法</span><br><span class="line">4.7.9媒体事件列表</span><br><span class="line">4.8关于音频</span><br><span class="line">小结</span><br><span class="line">第5章画布</span><br><span class="line">5.1案例</span><br><span class="line">5.2矩形</span><br><span class="line">5.3颜色及阴影</span><br><span class="line">5.4渐变</span><br><span class="line">5.5路径绘图</span><br><span class="line">5.5.1线条</span><br><span class="line">5.5.2Bézier曲线</span><br><span class="line">5.5.3弧线</span><br><span class="line">5.5.4矩形</span><br><span class="line">5.5.5轮廓、填充及剪切遮罩</span><br><span class="line">5.6文本</span><br><span class="line">5.6.1字体</span><br><span class="line">5.6.2水平锚点</span><br><span class="line">5.6.3垂直锚点</span><br><span class="line">5.6.4绘制及测量文本</span><br><span class="line">5.7内嵌图像</span><br><span class="line">5.8像素处理</span><br><span class="line">5.8.1使用ImageData对象</span><br><span class="line">5.8.2使用getImageData（）、createImageData（）及putImageData（）进行颜色处理</span><br><span class="line">5.9混合（Compositing）</span><br><span class="line">5.10图案（Pattern）</span><br><span class="line">5.11变换（Transformations）</span><br><span class="line">5.12用canvas.toDataURL（）进行Base64编码</span><br><span class="line">5.13save（）与restore（）</span><br><span class="line">5.14动画</span><br><span class="line">5.14.1彩色球体动画</span><br><span class="line">5.14.2用drawImage（）播放视频</span><br><span class="line">5.15还有遗漏吗？</span><br><span class="line">5.15.1isPointInPath（x，y）</span><br><span class="line">5.15.2Canvas的可访问性？</span><br><span class="line">5.15.3安全方面</span><br><span class="line">5.15.4浏览器支持</span><br><span class="line">5.15.5更多链接</span><br><span class="line">小结</span><br><span class="line">第6章SVG与MathML</span><br><span class="line">6.1MathML</span><br><span class="line">6.2SVG</span><br><span class="line">小结</span><br><span class="line">第7章地理定位</span><br><span class="line">7.1地理定位介绍</span><br><span class="line">7.1.1地理数据</span><br><span class="line">7.1.2在线地图服务</span><br><span class="line">7.2初体验：在浏览器中使用地理定位</span><br><span class="line">7.3定位的技术背景</span><br><span class="line">7.4OpenStreetMap上显示当前位置</span><br><span class="line">7.5使用GoogleMaps追踪位置</span><br><span class="line">7.6案例：Geonotes</span><br><span class="line">7.6.1操作</span><br><span class="line">7.6.2重要的代码片断</span><br><span class="line">7.7浏览器支持</span><br><span class="line">小结</span><br><span class="line">第8章Web存储及离线Web应用程序</span><br><span class="line">8.1存储</span><br><span class="line">8.1.1Storage接口</span><br><span class="line">8.1.2会话存储（sessionStorage）</span><br><span class="line">8.1.3本地存储（localStorage）</span><br><span class="line">8.1.4storage事件</span><br><span class="line">8.1.5调试</span><br><span class="line">8.2离线Web应用程序</span><br><span class="line">8.2.1缓存清单文件</span><br><span class="line">8.2.2离线状态及事件</span><br><span class="line">8.2.3调试</span><br><span class="line">8.3浏览器支持</span><br><span class="line">8.4案例：Clicktotick！</span><br><span class="line">8.4.1用户界面</span><br><span class="line">8.4.2管理界面</span><br><span class="line">8.4.3重要代码片段</span><br><span class="line">8.4.4扩展选项</span><br><span class="line">小结</span><br><span class="line">第9章网页套接字</span><br><span class="line">9.1WebSocket服务器</span><br><span class="line">9.2案例：广播服务器</span><br><span class="line">9.2.1广播客户端</span><br><span class="line">9.2.2广播服务器</span><br><span class="line">9.3案例：Battleships！（战列舰）</span><br><span class="line">小结</span><br><span class="line">第10章多线程</span><br><span class="line">10.1WebWorker介绍</span><br><span class="line">10.2查找闰年</span><br><span class="line">10.3配合Canvans计算海拔档案</span><br><span class="line">10.3.1重要代码清单</span><br><span class="line">小结</span><br><span class="line">第11章微数据</span><br><span class="line">11.1微数据语法</span><br><span class="line">11.1.1属性itemscope及itemprop</span><br><span class="line">11.1.2itemtype属性</span><br><span class="line">11.1.3itemid属性</span><br><span class="line">11.1.4itemref属性</span><br><span class="line">11.2微数据DOMAPI</span><br><span class="line">小结</span><br><span class="line">第12章写在最后：一些全局属性</span><br><span class="line">12.1class属性的变化</span><br><span class="line">12.2用“data—*”定义自定义属性</span><br><span class="line">12.3hidden属性</span><br><span class="line">12.4classList接口</span><br><span class="line">12.5通过draggable属性实现拖曳</span><br><span class="line">12.5.1拖曳与FileAPI相结合</span><br><span class="line">12.6属性contenteditable与spellcheck</span><br><span class="line">小结</span><br><span class="line">后记</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B007HAOVXI/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B007HAOVXI&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51TZtAkKKeL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解C#(第2版)</title>
    <url>/2020/04/19/B006OI9JUE/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 深入理解C#(第2版)<br>作者信息： 作者: Jon Skeet [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《深入理解C#(第2版)》是世界顶级技术专家“十年磨一剑”的经典之作，在C#和.NET领域享有盛誉。与其他泛泛介绍C#的书籍不同，本书深度探究C#的特性，并结合技术发展，引领读者深入C#的时空。作者Jon Skeet从语言设计的动机出发，介绍支持这些特性的核心概念。作者将新的语言特性放在C#语言发展的背景之上，用极富实际意义的示例，向读者展示编写代码和设计解决方案的最佳方式。同时作者将多年的C#开发经验与读者分享，读者可咀其精华、免走弯路，使程序设计水平更上一层楼。    本书是对第1版的全新修订，更详尽地阐述了C#的核心概念，并全面介绍了C# 4的新特性和代码契约。C# 4功能异常强大，掌握本书讲解的泛型、Lambda表达式、动态类型、LINQ、迭代器块和其他新特性后。读者可以实现无数神奇的功能，在C#的世界中大展宏图。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目　录 </span><br><span class="line"></span><br><span class="line"> 第一部分　基础知识</span><br><span class="line"></span><br><span class="line"> 第1章　C#开发的进化史　2 1.1　从简单的数据类型开始　3 1.1.1　C# 1中定义的产品类型　3 1.1.2　C# 2中的强类型集合　4 1.1.3　C# 3中自动实现的属性　5 1.1.4　C# 4中的命名实参　6 1.2　排序和过滤　7 1.2.1　按名称对产品进行排序　7 1.2.2　查询集合　10 1.3　处理未知数据　11 1.3.1　表示未知的价格　12 1.3.2　可选参数和默认值　12 1.4　LINQ简介　13 1.4.1　查询表达式和进程内查询　13 1.4.2　查询XML　14 1.4.3　LINQ to SQL　15 1.5　COM和动态类型　16 1.5.1　简化COM互操作　16 1.5.2　与动态语言互操作　17 1.6　剖析.NET平台　18 1.6.1　C#语言　18 1.6.2　运行时　19 1.6.3　框架库　19 1.7　怎样写出超炫的代码　19 1.7.1　采用代码段形式的全能代码　20 1.7.2　教学代码不是产品代码　21 1.7.3　你的新朋友：语言规范　21 1.8　小结　21</span><br><span class="line"></span><br><span class="line"> 第2章　C# 1所搭建的核心基础　23 2.1　委托　23 2.1.1　简单委托的构成　24 2.1.2　合并和删除委托　28 2.1.3　对事件的简单讨论　29 2.1.4　委托小结　30 2.2　类型系统的特征　31 2.2.1　C#在类型系统世界中的位置　31 2.2.2　C# 1的类型系统在什么时候不够用　34 2.2.3　类型系统特征总结　36 2.3　值类型和引用类型　36 2.3.1　现实世界中的值和引用　36 2.3.2　值类型和引用类型基础知识　37 2.3.3　走出误区　38 2.3.4　装箱和拆箱　40 2.3.5　值类型和引用类型小结　41 2.4　C# 1之外：构建于坚实基础之上的新特性　41 2.4.1　与委托有关的特性　41 2.4.2　与类型系统有关的特性　43 2.4.3　与值类型有关的特性　45 2.5　小结　46</span><br><span class="line"></span><br><span class="line"> 第二部分　C# 2：解决C# 1的问题</span><br><span class="line"></span><br><span class="line"> 第3章　用泛型实现参数化类型　48 3.1　为什么需要泛型　49 3.2　日常使用的简单泛型　50 3.2.1　通过例子来学习：泛型字典　50 3.2.2　泛型类型和类型参数　52 3.2.3　泛型方法和判读泛型声明　55 3.3　深化与提高　58 3.3.1　类型约束　58 3.3.2　泛型方法类型实参的类型推断　62 3.3.3　实现泛型　63 3.4　高级泛型　68 3.4.1　静态字段和静态构造函数　69 3.4.2　JIT编译器如何处理泛型　70 3.4.3　泛型迭代　72 3.4.4　反射和泛型　74 3.5　泛型在C#和其他语言中的限制　78 3.5.1　泛型可变性的缺乏　78 3.5.2　缺乏操作符约束或者“数值”约束　82 3.5.3　缺乏泛型属性、索引器和其他成员类型　83 3.5.4　同C++模板的对比　84 3.5.5　和Java泛型的对比　85 3.6　小结　86</span><br><span class="line"></span><br><span class="line"> 第4章　可空类型　88 4.1　没有值时怎么办　88 4.1.1　为什么值类型的变量不能是null　89 4.1.2　在C# 1中表示空值的模式　89 4.2　System.Nullable和System.Nullable　91 4.2.1　Nullable简介　91 4.2.2　Nullable装箱和拆箱　94 4.2.3　Nullable实例的相等性　95 4.2.4　来自非泛型Nullable类的支持　96 4.3　C# 2为可空类型提供的语法糖　96 4.3.1　?修饰符　97 4.3.2　使用null 进行赋值和比较　98 4.3.3　可空转换和操作符　99 4.3.4　可空逻辑　102 4.3.5　对可空类型使用as操作符　103 4.3.6　空合并操作符　104 4.4　可空类型的新奇用法　106 4.4.1　尝试一个不使用输出参数的操作　107 4.4.2　空合并操作符让比较不再痛苦　108 4.5　小结　111</span><br><span class="line"></span><br><span class="line"> 第5章　进入快速通道的委托　112 5.1　向笨拙的委托语法说拜拜　113 5.2　方法组转换　114 5.3　协变性和逆变性　115 5.3.1　委托参数的逆变性　116 5.3.2　委托返回类型的协变性　117 5.3.3　不兼容的风险　118 5.4　使用匿名方法的内联委托操作　119 5.4.1　从简单的开始：处理一个参数　119 5.4.2　匿名方法的返回值　121 5.4.3　忽略委托参数　123 5.5　在匿名方法中捕捉变量　124 5.5.1　定义闭包和不同的变量类型　124 5.5.2　测试被捕获的变量的行为　126 5.5.3　捕获变量到底有什么用处　127 5.5.4　捕获变量的延长生存期　127 5.5.5　局部变量实例化　128 5.5.6　共享和非共享的变量混合使用　130 5.5.7　捕获变量的使用规则和小结　132 5.6　小结　133</span><br><span class="line"></span><br><span class="line"> 第6章　实现迭代器的捷径　134 6.1　C# 1：手写迭代器的痛苦　135 6.2　C# 2：利用yield语句简化迭代器　137 6.2.1　迭代器块和yield return简介　137 6.2.2　观察迭代器的工作流程　139 6.2.3　进一步了解迭代器执行流程　141 6.2.4　具体实现中的奇特之处　144 6.3　真实的例子：迭代范围值　145 6.3.1　迭代时刻表中的日期　145 6.3.2　迭代文件中的行　146 6.3.3　使用迭代器块和谓词对项进行延迟筛选　148 6.4　使用CCR实现伪同步代码　150 6.5　小结　152</span><br><span class="line"></span><br><span class="line"> 第7章　结束C# 2的讲解：最后的一些特性　153 7.1　分部类型　154 7.1.1　在多个文件中创建一个类型　154 7.1.2　分部类型的使用　156 7.1.3　C# 3独有的分部方法　157 7.2　静态类型　159 7.3　独立的取值方法&#x2F;赋值方法属性访问器　161 7.4　命名空间别名　162 7.4.1　限定的命名空间别名　163 7.4.2　全局命名空间别名　164 7.4.3　外部别名　164 7.5　Pragma指令　166 7.5.1　警告pragma　166 7.5.2　校验和pragma　167 7.6　非安全代码中的固定大小的缓冲区　167 7.7　把内部成员暴露给选定的程序集　169 7.7.1　在简单情况下的友元程序集　169 7.7.2　为什么使用InternalsVisibleTo　170 7.7.3　InternalsVisibleTo和签名程序集　170 7.8　小结　171</span><br><span class="line"></span><br><span class="line"> 第三部分　C# 3：革新写代码的方式</span><br><span class="line"></span><br><span class="line"> 第8章　用智能的编译器来防错　174 8.1　自动实现的属性　175 8.2　隐式类型的局部变量　176 8.2.1　用var声明局部变量　177 8.2.2　隐式类型的限制　178 8.2.3　隐式类型的优缺点　179 8.2.4　建议　180 8.3　简化的初始化　180 8.3.1　定义示例类型　181 8.3.2　设置简单属性　182 8.3.3　为嵌入对象设置属性　183 8.3.4　集合初始化列表　184 8.3.5　初始化特性的应用　186 8.4　隐式类型的数组　187 8.5　匿名类型　188 8.5.1　第一次邂逅匿名类型　188 8.5.2　匿名类型的成员　190 8.5.3　投影初始化列表　191 8.5.4　重点何在　192 8.6　小结　193</span><br><span class="line"></span><br><span class="line"> 第9章　Lambda表达式和表达式树　194 9.1　作为委托的Lambda表达式　195 9.1.1　准备工作：Func委托类型简介　195 9.1.2　第一次转换成Lambda表达式　196 9.1.3　用单一表达式作为主体　197 9.1.4　隐式类型的参数列表　197 9.1.5　单一参数的快捷语法　198 9.2　使用List和事件的简单例子　199 9.2.1　对列表进行筛选、排序并设置其他操作　199 9.2.2　在事件处理程序中进行记录　201 9.3　表达式树　202 9.3.1　在程序中构建表达式树　202 9.3.2　将表达式树编译成委托　204 9.3.3　将C# Lambda表达式转换成表达式树　205 9.3.4　位于LINQ核心的表达式树　208 9.3.5　LINQ之外的表达式树　209 9.4　类型推断和重载决策发生的改变　211 9.4.1　改变的起因：精简泛型方法调用　211 9.4.2　推断匿名函数的返回类型　212 9.4.3　分两个阶段进行的类型推断　213 9.4.4　选择正确的被重载的方法　217 9.4.5　类型推断和重载决策　218 9.5　小结　219</span><br><span class="line"></span><br><span class="line"> 第10章　扩展方法　220 10.1　未引入扩展方法之前的状态　221 10.2　扩展方法的语法　223 10.2.1　声明扩展方法　223 10.2.2　调用扩展方法　224 10.2.3　扩展方法是怎样被发现的　225 10.2.4　在空引用上调用方法　226 10.3　.NET 3.5中的扩展方法　227 10.3.1　从Enumerable开始起步　228 10.3.2　用Where筛选并将方法调用链接到一起　229 10.3.3　插曲：似曾相识的Where方法　231 10.3.4　用Select方法和匿名类型进行投影　232 10.3.5　用OrderBy方法进行排序　232 10.3.6　涉及链接的实际例子　234 10.4　使用思路和原则　235 10.4.1　“扩展世界”和使接口更丰富　235 10.4.2　流畅接口　236 10.4.3　理智使用扩展方法　237 10.5　小结　238</span><br><span class="line"></span><br><span class="line"> 第11章　查询表达式和LINQ to Objects　240 11.1　LINQ介绍　241 11.1.1　LINQ中的基础概念　241 11.1.2　定义示例数据模型　245 11.2　简单的开始：选择元素　246 11.2.1　以数据源作为开始，以选择作为结束　246 11.2.2　作为查询表达式基础的编译器转换　247 11.2.3　范围变量和重要的投影　249 11.2.4　Cast、OfType和显式类型的范围变量　251 11.3　对序列进行过滤和排序　252 11.3.1　使用where子句进行过滤　253 11.3.2　退化的查询表达式　253 11.3.3　使用orderby子句进行排序　254 11.4　let子句和透明标识符　256 11.4.1　用let来进行中间计算　256 11.4.2　透明标识符　257 11.5　联接　258 11.5.1　使用join子句的内联接　258 11.5.2　使用join into子句进行分组联接　262 11.5.3　使用多个from子句进行交叉联接和合并序列　264 11.6　分组和延续　267 11.6.1　使用group by子句进行分组　267 11.6.2　查询延续　270 11.7　在查询表达式和点标记之间作出选择　272 11.7.1　需要使用点标记的操作　273 11.7.2　选择点标记　273 11.7.3　选择查询表达式　274 11.8　小结　275</span><br><span class="line"></span><br><span class="line"> 第12章　超越集合的LINQ　276 12.1　使用LINQ to SQL查询数据库　277 12.1.1　数据库和模型　277 12.1.2　用查询表达式访问数据库　279 12.1.3　包含联接的查询　281 12.2　用IQueryable和IQueryProvider进行转换　283 12.2.1　IQueryable和相关接口的介绍　283 12.2.2　模拟接口实现来记录调用　285 12.2.3　把表达式粘合在一起：Queryable的扩展方法　287 12.2.4　模拟实际运行的查询提供器　289 12.2.5　包装IQueryable　290 12.3　LINQ友好的API和LINQ to XML　290 12.3.1　LINQ to XML中的核心类型　290 12.3.2　声明式构造　292 12.3.3　查询单个节点　294 12.3.4　合并查询操作符　296 12.3.5　与LINQ和谐共处　297 12.4　用并行LINQ代替LINQ to Objects　297 12.4.1　在单线程中绘制曼德博罗特集　297 12.4.2　ParallelEnumerable、Parallel-Query和AsParallel　299 12.4.3　调整并行查询　300 12.5　使用LINQ to Rx反转查询模型　301 12.5.1　IObservable和IObserver　302 12.5.2　简单地开始　303 12.5.3　查询可观察对象　304 12.5.4　意义何在　306 12.6　扩展LINQ to Objects　306 12.6.1　设计和实现指南　307 12.6.2　示例扩展：选择随机元素　308 12.7　小结　309</span><br><span class="line"></span><br><span class="line"> 第四部分　C# 4：良好的交互性</span><br><span class="line"></span><br><span class="line"> 第13章　简化代码的微小修改　312 13.1　可选参数和命名实参　312 13.1.1　可选参数　313 13.1.2　命名实参　317 13.1.3　两者相结合　321 13.2　改善COM互操作性　324 13.2.1　在C# 4之前操纵Word是十分恐怖的　325 13.2.2　可选参数和命名实参的复仇　325 13.2.3　按值传递ref参数　326 13.2.4　调用命名索引器　327 13.2.5　链接主互操作程序集　328 13.3　接口和委托的泛型可变性　330 13.3.1　可变性的种类：协变性和逆变性　331 13.3.2　在接口中使用可变性　332 13.3.3　在委托中使用可变性　334 13.3.4　复杂情况　335 13.3.5　限制和说明　336 13.4　对锁和字段风格的事件的微小改变　339 13.4.1　健壮的锁　339 13.4.2　字段风格的事件　340 13.5　小结　341</span><br><span class="line"></span><br><span class="line"> 第14章　静态语言中的动态绑定　342 14.1　何谓，何时，为何，如何　343 14.1.1　何谓动态类型　343 14.1.2　动态类型什么时候有用，为什么　344 14.1.3　C# 4如何提供动态类型　345 14.2　关于动态的快速指南　345 14.3　动态类型示例　348 14.3.1　COM和Office　348 14.3.2　动态语言　350 14.3.3　纯托管代码中的动态类型　353 14.4　幕后原理　358 14.4.1　DLR简介　358 14.4.2　DLR核心概念　360 14.4.3　C#编译器如何处理动态　362 14.4.4　更加智能的C#编译器　365 14.4.5　动态代码的约束　368 14.5　实现动态行为　370 14.5.1　使用ExpandoObject　370 14.5.2　使用DynamicObject　374 14.5.3　实现IDynamicMetaObject-Provider　380 14.6　小结　383</span><br><span class="line"></span><br><span class="line"> 第15章　使用契约让代码更加清晰　385 15.1　未引入代码契约之前的状态　386 15.2　代码契约　387 15.2.1　前置条件　388 15.2.2　后置条件　389 15.2.3　固定条件　390 15.2.4　断言和假设　392 15.2.5　旧式契约　393 15.3　使用ccrewrite和ccrefgen重写二进制　394 15.3.1　简单重写　394 15.3.2　契约继承　395 15.3.3　契约引用程序集　398 15.3.4　失败行为　399 15.4　静态检查　401 15.4.1　开始静态检查　401 15.4.2　隐式职责　403 15.4.3　有选择性的检查　406 15.5　使用ccdocgen 将契约文档化　408 15.6　契约实战　410 15.6.1　契约中有什么　410 15.6.2　如何开始　411 15.6.3　无处不在的选项　412 15.7　小结　414</span><br><span class="line"></span><br><span class="line"> 第16章　何去何从　415 16.1　C#——传统与现代的结合　415 16.2　计算机科学和.NET　416 16.3　计算机世界　417 16.4　再会　417</span><br><span class="line"></span><br><span class="line"> 附录A　LINQ标准查询操作符　419 附录B　.NET中的泛型集合　430 附录C　版本总结　440</span><br><span class="line"></span><br><span class="line">   &lt;&#x2F;t&gt;&lt;&#x2F;t&gt;&lt;&#x2F;t&gt;&lt;&#x2F;t&gt;&lt;&#x2F;t&gt;&lt;&#x2F;t&gt;&lt;&#x2F;t&gt;&lt;&#x2F;t&gt;</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B006OI9JUE/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B006OI9JUE&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51c7FTV17VL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5移动Web开发指南</title>
    <url>/2020/04/19/B007PH53S0/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： HTML5移动Web开发指南<br>作者信息： 作者: 唐俊开 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《HTML5移动Web开发指南》是为从未接触过html5新技术但同时又对移动web技术感兴趣的读者而编写的。如果你有一定的html开发经验，将会更容易掌握html5知识。同时，如果你是如下几类人群之一，那么《HTML5移动Web开发指南》非常适合你阅读：1.有一定基础或者未来计划的职业是web前端开发工程师。2.具有一定html基础的ui设计师。3.web项目中的项目经理以及策划人员。4.对手机web开发技术感兴趣的开发者。5.开设计算机课程的高等院校及培训机构的师生。 此外，《HTML5移动Web开发指南》也适合熟悉java、php、asp.net等后端web技术的开发者阅读。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章移动互联网时代的Web技术</span><br><span class="line">1.1移动互联网的发展</span><br><span class="line">1.2智能手机发展迅速</span><br><span class="line">1.3智能手机的Web浏览器</span><br><span class="line">1.4移动Web应用的发展</span><br><span class="line">1.5基于HTML5的移动Web应用</span><br><span class="line">第2章移动设备HTML5页面布局</span><br><span class="line">2.1页面语义化简介</span><br><span class="line">2.1.1HTML5新语义元素概述</span><br><span class="line">2.1.2更多HTML5新元素</span><br><span class="line">2.2页面结构与移动设备的布局</span><br><span class="line">2.2.1常见的移动应用布局</span><br><span class="line">2.2.2使用HTML5创建标准的移动Web页面</span><br><span class="line">2.3本章小结</span><br><span class="line">第3章HTML5规范的本地存储</span><br><span class="line">3.1移动设备的支持</span><br><span class="line">3.2localStorage</span><br><span class="line">3.3sessionStorage</span><br><span class="line">3.4Storage事件监听</span><br><span class="line">3.5本章小结</span><br><span class="line">第4章移动Web的离线应用</span><br><span class="line">4.1离线Web概述</span><br><span class="line">4.1.1离线与缓存</span><br><span class="line">4.1.2离线的意义</span><br><span class="line">4.2移动设备的支持</span><br><span class="line">4.3applicationCache和manifest</span><br><span class="line">4.3.1manifest文件</span><br><span class="line">4.3.2applicationCache对象和事件</span><br><span class="line">4.4本章小结</span><br><span class="line">第5章移动设备的常见HTML5表单元素</span><br><span class="line">5.1丰富的表单属性</span><br><span class="line">5.2移动Web表单的input类型</span><br><span class="line">5.2.1search类型文本</span><br><span class="line">5.2.2email类型文本</span><br><span class="line">5.2.3number类型文本</span><br><span class="line">5.2.4range类型文本</span><br><span class="line">5.2.5tel类型文本</span><br><span class="line">5.2.6url类型文本</span><br><span class="line">5.2.7更多的类型</span><br><span class="line">5.3表单属性应用范围</span><br><span class="line">5.4本章小结</span><br><span class="line">第6章移动Web界面样式</span><br><span class="line">6.1CSS3</span><br><span class="line">6.2选择器</span><br><span class="line">6.2.1属性选择器</span><br><span class="line">6.2.2伪类选择器</span><br><span class="line">6.3 阴影</span><br><span class="line">6.3.1 box－shadow</span><br><span class="line">6.3.2text－shadow</span><br><span class="line">6.4背景</span><br><span class="line">6.4.1background－size</span><br><span class="line">6.4.2background—clip</span><br><span class="line">6.4.3background—origin</span><br><span class="line">6.4.4background</span><br><span class="line">6.5圆角边框</span><br><span class="line">6.6Media Queries移动设备样式</span><br><span class="line">6.6.1传统网站在iPhone上的显示问题</span><br><span class="line">6.6.2viewport设置适应移动设备屏幕大小</span><br><span class="line">6.6.3Media Queries如何工作</span><br><span class="line">6.6.4Media Queries语法总结</span><br><span class="line">6.6.5如何将官方网站移植成移动Web网站</span><br><span class="line">6.7本章小结</span><br><span class="line">第7章Geolocation地理定位</span><br><span class="line">7.1功能介绍</span><br><span class="line">7.2浏览器支持情况</span><br><span class="line">7.3如何使用Geolocation API</span><br><span class="line">7.3.1首次获取当前位置</span><br><span class="line">7.3.2监视移动设备的位置变化</span><br><span class="line">7.4本章小结</span><br><span class="line">第8章轻量级框架jQuery Mobile初探</span><br><span class="line">8.1jQuery Mobile概述</span><br><span class="line">8.2入门示例Hello World</span><br><span class="line">8.2.1部署文件</span><br><span class="line">8.2.2编码</span><br><span class="line">8.3基于HTML5的自定义属性驱动组件</span><br><span class="line">8.3.1dataset自定义属性</span><br><span class="line">8.3.2使用dataset属性驱动jQuery Mobile组件</span><br><span class="line">8.4页面与视图</span><br><span class="line">8.4.1标准的移动Web页面</span><br><span class="line">8.4.2移动设备的视图</span><br><span class="line">8.4.3多视图Web页面</span><br><span class="line">8.4.4改变页面标题的视图</span><br><span class="line">8.4.5视图切换动画</span><br><span class="line">8.4.6dialog对话框</span><br><span class="line">8.4.7页面主题</span><br><span class="line">8.5button按钮</span><br><span class="line">8.5.1button组件</span><br><span class="line">8.5.2具有icon图标的button组件</span><br><span class="line">8.5.3具有内联样式的button</span><br><span class="line">8.5.4具有分组功能的button按钮</span><br><span class="line">8.6Bar工具栏</span><br><span class="line">8.6.1如何使用工具栏</span><br><span class="line">8.6.2含有后退按钮的Header工具栏</span><br><span class="line">8.6.3多按钮的Footer工具栏</span><br><span class="line">8.6.4导航条工具栏</span><br><span class="line">8.6.5定义fixed工具栏</span><br><span class="line">8.6.6全屏模式工具栏</span><br><span class="line">8.7内容区域格式布局</span><br><span class="line">8.7.1网格布局</span><br><span class="line">8.7.2仿9宫格排列的按钮组例子</span><br><span class="line">8.7.3折叠块功能</span><br><span class="line">8.7.4创建具有手风琴效果的例子</span><br><span class="line">8.8Form表单</span><br><span class="line">8.8.1如何使用表单提交功能</span><br><span class="line">8.8.2HTML5文本框类型</span><br><span class="line">8.8.3HTML5搜索类型输入框</span><br><span class="line">8.8.4Slider类型</span><br><span class="line">8.8.5Toggle类型</span><br><span class="line">8.8.6单选按钮类型</span><br><span class="line">8.8.7复选框类型</span><br><span class="line">8.8.8下拉选择菜单</span><br><span class="line">8.9List列表</span><br><span class="line">8.9.1基本列表类型</span><br><span class="line">8.9.2普通链接列表</span><br><span class="line">8.9.3多层次嵌套列表</span><br><span class="line">8.9.4有序编号列表</span><br><span class="line">8.9.5只读列表</span><br><span class="line">8.9.6可分割按钮列表</span><br><span class="line">8.9.7列表的分隔符</span><br><span class="line">8.9.8列表搜索过滤器</span><br><span class="line">8.9.9含有气泡式计数的列表</span><br><span class="line">8.9.10显示列表项右侧文本格式的列表</span><br><span class="line">8.9.11列表项含有图标的列表</span><br><span class="line">8.9.12数据项含有图片的列表</span><br><span class="line">8.9.13内嵌列表</span><br><span class="line">8.9.14列表的性能问题</span><br><span class="line">8.10配置选项</span><br><span class="line">8.11Event事件</span><br><span class="line">8.11.1页面加载事件</span><br><span class="line">8.11.2其他事件类型</span><br><span class="line">8.12实用方法和工具</span><br><span class="line">8.12.1页面视图辅助工具</span><br><span class="line">8.12.2数据存储</span><br><span class="line">8.12.3地址路径辅助工具</span><br><span class="line">8.12.4loading显示／隐藏</span><br><span class="line">8.13主题系统</span><br><span class="line">8.14本章小结</span><br><span class="line">……</span><br><span class="line">第9章重量级富框架SENCHA TOUCH入门</span><br><span class="line">第10章跨平台的PHONEGAP应用介绍</span><br><span class="line">第11章构建基于HTML5的生活轨迹WEB APP</span><br><span class="line">第12章进阶之路</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B007PH53S0/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B007PH53S0&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec8.images-amazon.com/images/I/41umGZrMQyL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>论道HTML5</title>
    <url>/2020/04/19/B00812OXFC/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 论道HTML5<br>作者信息： 作者: 秀野堂主 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>中国人在HTML5领域领先日本和韩国，这是不争的事实。HTML5是未来网络世界向生活全面接轨的号角。本书的知识点与目前市面上的所有的HTML5都不一样，与《HTML5高级语言设计》相比，这本书是本土的，涵盖了WEBGL部分的，对所有API都详细介绍了。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 利用HTML5制作网站 1</span><br><span class="line">1.1 大多数人不了解HTML5时代的网页设计 1</span><br><span class="line">1.2 HTML5带来的网页结构、设计风格及理念的变化 3</span><br><span class="line">1.2.1 HTML4时代的几个特征 4</span><br><span class="line">1.2.2 一个典型的HTML5页面 4</span><br><span class="line">1.2.3 小结 6</span><br><span class="line">1.3 HTML5带来的标签变化 6</span><br><span class="line">1.3.1 什么是标签 6</span><br><span class="line">1.3.2 标签的分类 7</span><br><span class="line">1.3.3 近十几年来的HTML 9</span><br><span class="line">1.3.4 Web的变化趋势 9</span><br><span class="line">1.4 HTML5带来的表单数据内容进化 9</span><br><span class="line">1.4.1 数据提交格式的变化 10</span><br><span class="line">1.4.2 数据提交范围的变化 11</span><br><span class="line">1.4.3 表单数据类型的增加 12</span><br><span class="line">1.4.4 表单属性和验证方式的进化 13</span><br><span class="line">1.4.5 文件上传控件和重复模型的应用 14</span><br><span class="line">1.4.6 小结 14</span><br><span class="line">1.5 HTML5与SEO 15</span><br><span class="line">1.5.1 技术趋势 15</span><br><span class="line">1.5.2 搜索引擎服务商面临的问题 16</span><br><span class="line">1.5.3 SEO从业人员面临的问题 17</span><br><span class="line">1.5.4 SEO面临的几个社会问题 18</span><br><span class="line">1.6 HTML5的开发环境与调试环境 18</span><br><span class="line">1.6.1 HTML5编写工具 18</span><br><span class="line">1.6.2 JavaScript开发 19</span><br><span class="line">1.6.3 HTTP监控 19</span><br><span class="line">1.6.4 调试环境 20</span><br><span class="line">1.7 案例：HTML5网站建设 22</span><br><span class="line">1.7.1 需求的提出 22</span><br><span class="line">1.7.2 需求分析 22</span><br><span class="line">1.7.3 系统分析 22</span><br><span class="line">1.7.4 工程实现 23</span><br><span class="line">1.7.5 小结 27</span><br><span class="line">第2章 用CSS3完善网站 28</span><br><span class="line">2.1 文字模块 29</span><br><span class="line">2.1.1 文字阴影：text—shadow 29</span><br><span class="line">2.1.2 文字溢出：text—overflow 30</span><br><span class="line">2.1.3 文字换行：word—wrap 30</span><br><span class="line">2.2 颜色模块 31</span><br><span class="line">2.2.1 透明度：opacity 31</span><br><span class="line">2.2.2 HSL 33</span><br><span class="line">2.2.3 HSLA和RGBA 33</span><br><span class="line">2.3 边框模块 34</span><br><span class="line">2.3.1 边框圆角：border—radius 34</span><br><span class="line">2.3.2 边框颜色：border—color 36</span><br><span class="line">2.3.3 边框图像：border—image 37</span><br><span class="line">2.3.4 盒阴影：box—shadow 40</span><br><span class="line">2.4 用户界面模块 41</span><br><span class="line">2.4.1 盒倒影：box—reflect 41</span><br><span class="line">2.4.2 盒大小：box—sizing 41</span><br><span class="line">2.5 背景模块 42</span><br><span class="line">2.5.1 背景渐变 42</span><br><span class="line">2.5.2 background—origin 45</span><br><span class="line">2.5.3 background—clip 46</span><br><span class="line">2.5.4 background—size 47</span><br><span class="line">2.5.5 多背景 48</span><br><span class="line">2.5.6 遮罩 49</span><br><span class="line">2.6 动画模块 51</span><br><span class="line">2.6.1 transform 51</span><br><span class="line">2.6.2 transition 53</span><br><span class="line">2.6.3 animation 55</span><br><span class="line">2.7 区域模块 57</span><br><span class="line">2.7.1 故事线 58</span><br><span class="line">2.7.2 区域样式 60</span><br><span class="line">2.7.3 内容形状和环绕 60</span><br><span class="line">2.7.4 小结 62</span><br><span class="line">2.8 选择器 62</span><br><span class="line">2.8.1 结构伪类 63</span><br><span class="line">2.8.2 否定伪类 65</span><br><span class="line">2.8.3 状态伪类 65</span><br><span class="line">2.8.4 目标伪类 66</span><br><span class="line">2.8.5 其他选择器 66</span><br><span class="line">2.9 其他模块 68</span><br><span class="line">2.9.1 多栏布局 68</span><br><span class="line">2.9.2 弹性盒子布局 68</span><br><span class="line">2.9.3 网络字体 69</span><br><span class="line">2.9.4 媒介查询 70</span><br><span class="line">2.9.5 滤镜效果 70</span><br><span class="line">2.9.6 着色器 70</span><br><span class="line">2.10 使用CSS3美化网站 72</span><br><span class="line">2.10.1 右上角文字 73</span><br><span class="line">2.10.2 下载盒子 74</span><br><span class="line">2.10.3 图片格子 74</span><br><span class="line">2.10.4 中间盒子 74</span><br><span class="line">2.10.5 左右盒子 75</span><br><span class="line">2.10.6 居中背景 76</span><br><span class="line">2.10.7 载入效果 76</span><br><span class="line">2.10.8 页脚 77</span><br><span class="line">2.11 小结 77</span><br><span class="line">第3章 划时代的WebAPI 79</span><br><span class="line">3.1 传统Web模型与WebOS架构模型 79</span><br><span class="line">3.2 WebAPI的概要介绍 81</span><br><span class="line">3.3 Drag&amp;DropAPI 82</span><br><span class="line">3.3.1 以前的解决方案 82</span><br><span class="line">3.3.2 Drag&amp;DropAPI的优点 83</span><br><span class="line">3.3.3 如何检测浏览器是否支持Drag&amp;DropAPI 83</span><br><span class="line">3.3.4 Drag&amp;DropAPI的主要操作 84</span><br><span class="line">3.3.5 文件拖放上传实例 86</span><br><span class="line">3.4 HistoryAPI 87</span><br><span class="line">3.4.1 以前的解决方案 87</span><br><span class="line">3.4.2 现在的HistoryAPI 87</span><br><span class="line">3.5 CommunicationAPI 89</span><br><span class="line">3.5.1 以前解决跨源通信的方案 89</span><br><span class="line">3.5.2 XMLHttpRequestLevel2 90</span><br><span class="line">3.5.3 iframe和sandbox 91</span><br><span class="line">3.5.4 跨文档消息通信 92</span><br><span class="line">3.6 NotificationAPI 97</span><br><span class="line">3.6.1 如何检测浏览器是否支持NotificationAPI 97</span><br><span class="line">3.6.2 Web的Notification的状态 97</span><br><span class="line">3.6.3 让你的WebApp带着Notification跑 97</span><br><span class="line">3.7 audio标签和video标签 99</span><br><span class="line">3.7.1 audio标签 100</span><br><span class="line">3.7.2 video标签 102</span><br><span class="line">3.8 CanvasAPI 108</span><br><span class="line">3.8.1 以前的同类解决方案 109</span><br><span class="line">3.8.2 Canvas的优点 109</span><br><span class="line">3.8.3 检测浏览器是否支持Canvas 109</span><br><span class="line">3.8.4 Canvas主要操作 109</span><br><span class="line">3.9 WebSocketAPI 110</span><br><span class="line">3.10 WebWorkerAPI 111</span><br><span class="line">3.11 WebStorageAPI 111</span><br><span class="line">3.12 MicroData和语义网络 111</span><br><span class="line">3.12.1 MicroData的常见属性 112</span><br><span class="line">3.12.2 MicroData的例子 112</span><br><span class="line">3.12.3 MicroData与SEO——人类需要有序的信息 113</span><br><span class="line">3.12.4 语义网络的基本概念 113</span><br><span class="line">3.12.5 语义测试工具 114</span><br><span class="line">3.13 通用Base64方法 114</span><br><span class="line">3.13.1 编码 114</span><br><span class="line">3.13.2 解码 115</span><br><span class="line">3.13.3 应用 115</span><br><span class="line">3.14 WebDatabaseAPI 117</span><br><span class="line">3.14.1 WebSQLAPI 117</span><br><span class="line">3.14.2 IndexedDBAPI 121</span><br><span class="line">3.15 WebGL 124</span><br><span class="line">3.16 DeviceAPI系列 125</span><br><span class="line">3.16.1 GeolocationAPI 125</span><br><span class="line">3.16.2 FileAPI 128</span><br><span class="line">3.16.3 FileWriterAPI 132</span><br><span class="line">3.16.4 MediaCaptureAPI 132</span><br><span class="line">3.16.5 ContactAPI 133</span><br><span class="line">3.16.6 SystemInformationAPI 134</span><br><span class="line">3.16.7 CalendarAPI 137</span><br><span class="line">3.16.8 MessagingAPI 137</span><br><span class="line">3.17 小结 138</span><br><span class="line">第4章 Canvas2D 139</span><br><span class="line">4.1 什么是Canvas 139</span><br><span class="line">4.2 Canvas2D原理 140</span><br><span class="line">4.2.1 坐标系统说明 141</span><br><span class="line">4.2.2 属性说明 142</span><br><span class="line">4.3 绘制 143</span><br><span class="line">4.3.1 各类线条 143</span><br><span class="line">4.3.2 矩形 151</span><br><span class="line">4.3.3 三角形 152</span><br><span class="line">4.3.4 圆与扇形 153</span><br><span class="line">4.3.5 图片 155</span><br><span class="line">4.3.6 文字 158</span><br><span class="line">4.4 特效 160</span><br><span class="line">4.4.1 渐变 160</span><br><span class="line">4.4.2 阴影与透明 162</span><br><span class="line">4.5 基础操作中比较复杂的部分 162</span><br><span class="line">4.5.1 保存和恢复 163</span><br><span class="line">4.5.2 坐标转换 163</span><br><span class="line">4.5.3 旋转 164</span><br><span class="line">4.5.4 缩放 164</span><br><span class="line">4.5.5 变形 164</span><br><span class="line">4.5.6 组合 166</span><br><span class="line">4.5.7 裁剪 167</span><br><span class="line">4.5.8 像素操作 170</span><br><span class="line">4.6 动画 172</span><br><span class="line">4.6.1 左右运动 172</span><br><span class="line">4.6.2 上下运动 173</span><br><span class="line">4.6.3 圆心旋转运动 174</span><br><span class="line">4.6.4 抛物线运动 175</span><br><span class="line">4.6.5 渐变运动 175</span><br><span class="line">4.7 事件感应 176</span><br><span class="line">4.8 关于Canvas的一些经验 177</span><br><span class="line">4.8.1 回答两个问题 177</span><br><span class="line">4.8.2 避开浮点运算 178</span><br><span class="line">4.8.3 资源载入与双缓冲问题 178</span><br><span class="line">4.8.4 图片抗锯齿的原理及办法 179</span><br><span class="line">4.8.5 粒子系统的使用 181</span><br><span class="line">4.9 Web开发复古流 181</span><br><span class="line">4.10 小结 182</span><br><span class="line">第5章 HTML5和移动互联网开发 183</span><br><span class="line">5.1 移动互联网的现状与需求 183</span><br><span class="line">5.1.1 市场容量 184</span><br><span class="line">5.1.2 移动设备的特点 184</span><br><span class="line">5.1.3 移动设备的现状 185</span><br><span class="line">5.1.4 开发者生态圈 185</span><br><span class="line">5.1.5 可供选择的移动互联网开发平台 185</span><br><span class="line">5.2 HTML5在移动互联网上的开发示例 187</span><br><span class="line">5.2.1 一个HTML5开发者的基本配置 187</span><br><span class="line">5.2.2 欧朋浏览器H5版介绍 188</span><br><span class="line">5.2.3 重力传感设备 191</span><br><span class="line">5.2.4 电子罗盘开发 199</span><br><span class="line">5.2.5 Geolocation与LBS应用开发 203</span><br><span class="line">5.2.6 网页摄像与网络相册 207</span><br><span class="line">5.2.7 移动设备中的离线存储 214</span><br><span class="line">5.3 小结 215</span><br><span class="line">第6章 WebSocket开发应用 216</span><br><span class="line">6.1 WebSocket的那些事儿 216</span><br><span class="line">6.1.1 WebSocket的技术背景 217</span><br><span class="line">6.1.2 WebSocket的定义 218</span><br><span class="line">6.1.3 WebSocket通信模式解析 219</span><br><span class="line">6.1.4 WebSocket检测浏览器支持代码 220</span><br><span class="line">6.2 WebSocketAPI的内容 220</span><br><span class="line">6.2.1 属性 220</span><br><span class="line">6.2.2 URL 221</span><br><span class="line">6.2.3 事件 221</span><br><span class="line">6.3 客户端样例程序 222</span><br><span class="line">6.4 服务器端样例程序 222</span><br><span class="line">6.5 Ajax、长轮询、Comet之间的那些事儿 223</span><br><span class="line">6.5.1 Ajax 223</span><br><span class="line">6.5.2 长轮询 225</span><br><span class="line">6.5.3 Comet 226</span><br><span class="line">6.5.4 Ajax与WebSocket的多角度对比 227</span><br><span class="line">6.6 与WebSocket相关的几个概念 227</span><br><span class="line">6.6.1 SSJS 228</span><br><span class="line">6.6.2 Node.js 228</span><br><span class="line">6.7 开发基于WebSocket的通信示例 235</span><br><span class="line">6.7.1 聊天室 235</span><br><span class="line">6.7.2 服务器监控 239</span><br><span class="line">6.7.3 联机作图 243</span><br><span class="line">6.8 免费的WebSocket资源 247</span><br><span class="line">6.9 小结 248</span><br><span class="line">第7章 瘦服务器战略与云 249</span><br><span class="line">7.1 战略观察与未来10年的思考 249</span><br><span class="line">7.1.1 Web瘦服务器战略 249</span><br><span class="line">7.1.2 云 253</span><br><span class="line">7.1.3 计算能的思考 254</span><br><span class="line">7.2 WebStorage 255</span><br><span class="line">7.2.1 WebStorage的概念 255</span><br><span class="line">7.2.2 localStorage介绍与示例 255</span><br><span class="line">7.2.3 sessionStorage的介绍与示例 258</span><br><span class="line">7.2.4 浏览器端存储的方案和局限性 260</span><br><span class="line">7.3 离线应用 265</span><br><span class="line">7.3.1 判断浏览器是否在线 266</span><br><span class="line">7.3.2 离线应用的属性与方法 266</span><br><span class="line">7.3.3 manifest文件 267</span><br><span class="line">7.4 WebWorker 269</span><br><span class="line">7.4.1 Worker 270</span><br><span class="line">7.4.2 SharedWorker 273</span><br><span class="line">7.4.3 WebWorker小结 275</span><br><span class="line">7.5 一个云记事本的案例 276</span><br><span class="line">7.5.1 客户端逻辑分析 276</span><br><span class="line">7.5.2 客户端的实现 277</span><br><span class="line">7.5.3 工程实现的联想 279</span><br><span class="line">7.6 小结 279</span><br><span class="line">附录A HTML5标签、事件属性及其相关网站 281</span><br><span class="line">附录B 审慎对待各种框架 287</span><br><span class="line">附录C 统一开发常用交流术语 289</span><br><span class="line">附录D WebGL 294</span><br><span class="line">附录E CSS3模块列表 299</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00812OXFC/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00812OXFC&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41ITx7r1hBL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵程序设计丛书 HTML5程序设计(第2版)</title>
    <url>/2020/04/19/B0081E9X0K/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 图灵程序设计丛书 HTML5程序设计(第2版)<br>作者信息： 作者: 柳伯斯 (Peter Lubbers) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>1、超级畅销书《HTML5高级程序设计》升级版；2、引领下一代web开发潮流；3、全面涵盖开创性html5api</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 HTML5概述</span><br><span class="line">1.1 HTML5发展史</span><br><span class="line">1.2 关于2022年的那个神话</span><br><span class="line">1.3 谁在开发HTML5</span><br><span class="line">1.4 新的认识</span><br><span class="line">1.4.1 兼容性和存在即合理</span><br><span class="line">1.4.2 效率和用户优先</span><br><span class="line">1.4.3 化繁为简</span><br><span class="line">1.4.4 通用访问</span><br><span class="line">1.5 无插件范式</span><br><span class="line">1.6 HTML5的新功能</span><br><span class="line">1.6.1 新的DOCTYPE和字符集</span><br><span class="line">1.6.2 新元素和旧元素</span><br><span class="line">1.6.3 语义化标记</span><br><span class="line">1.6.4 使用Selectors API简化选取操作</span><br><span class="line">1.6.5 JavaScript日志和调试</span><br><span class="line">1.6.6 window.JSON</span><br><span class="line">1.6.7 DOM Level 3</span><br><span class="line">1.6.8 Monkeys、Squirrelfish和其他JavaScript引擎</span><br><span class="line">1.7 小结</span><br><span class="line">第2章 Canvas API</span><br><span class="line">2.1 HTML5 Canvas概述</span><br><span class="line">2.1.1历史</span><br><span class="line">2.1.2 canvas是什么</span><br><span class="line">2.1.3 canvas坐标</span><br><span class="line">2.1.4什么情况下不用canvas</span><br><span class="line">2.1.5替代内容</span><br><span class="line">2.1.6 CSS和canvas</span><br><span class="line">2.1.7浏览器对HTML5 Canvas的支持情况</span><br><span class="line">2.2 使用HTML5 Canvas API</span><br><span class="line">2.2.1检测浏览器支持情况</span><br><span class="line">2.2.2在页面中加入canvas</span><br><span class="line">2.2.3变换</span><br><span class="line">2.2.4路径</span><br><span class="line">2.2.5描边样式</span><br><span class="line">2.2.6填充样式</span><br><span class="line">2.2.7填充矩形区域</span><br><span class="line">2.2.8绘制曲线</span><br><span class="line">2.2.9在canvas中插入图片</span><br><span class="line">2.2.10渐变</span><br><span class="line">2.2.11背景图</span><br><span class="line">2.2.12缩放canvas对象</span><br><span class="line">2.2.13 Canvas变换</span><br><span class="line">2.2.14 Canvas文本</span><br><span class="line">2.2.15应用阴影</span><br><span class="line">2.2.16像素数据</span><br><span class="line">2.2.17 Canvas的安全机制</span><br><span class="line">2.3使用HTML5 Canvas创建应用</span><br><span class="line">2.3.1进阶功能之全页玻璃窗</span><br><span class="line">2.3.2进阶功能之为Canvas动画计时</span><br><span class="line">2.4小结</span><br><span class="line">第3章SVG</span><br><span class="line">3.1 SVG概述</span><br><span class="line">3.1.1历史</span><br><span class="line">3.1.2理解SVG</span><br><span class="line">3.1.3可缩放图形</span><br><span class="line">3.1.4使用SVG创建2D图形</span><br><span class="line">3.1.5在页面中添加SVG</span><br><span class="line">3.1.6简单的形状</span><br><span class="line">3.1.7变换SVG元素</span><br><span class="line">3.1.8复用内容</span><br><span class="line">3.1.9图案和渐变</span><br><span class="line">3.1.10 SVG路径</span><br><span class="line">3.1.11使用SVG文本</span><br><span class="line">3.1.12组合场景</span><br><span class="line">3.2使用SVG创建交互式应用</span><br><span class="line">3.2.1添加树</span><br><span class="line">3.2.2添加updateTrees函数</span><br><span class="line">3.2.3添加removeTree函数</span><br><span class="line">3.2.4添加CSS样式</span><br><span class="line">3.2.5最终代码</span><br><span class="line">3.3小结</span><br><span class="line">第4章音频和视频</span><br><span class="line">4.1 HTML5 Audio和Video概述</span><br><span class="line">4.1.1视频容器</span><br><span class="line">4.1.2音频和视频编解码器</span><br><span class="line">4.1.3 HTML5 Audio和Video的 限制</span><br><span class="line">4.1.4 audio元素和video元素的浏览器支持情况</span><br><span class="line">4.2使用HTML5 Audio和Video API</span><br><span class="line">4.2.1浏览器支持性检测</span><br><span class="line">4.2.2可访问性</span><br><span class="line">4.2.3理解媒体元素</span><br><span class="line">4.2.4使用audio元素</span><br><span class="line">4.2.5使用video元素</span><br><span class="line">4.2.6进阶功能</span><br><span class="line">4.3小结</span><br><span class="line">第5章 GeoIocation API</span><br><span class="line">5.1位置信息</span><br><span class="line">5.1.1纬度和经度坐标</span><br><span class="line">5.1.2位置信息从何而来</span><br><span class="line">5.1.3 IP地址地理定位数据</span><br><span class="line">5.1.4 GPS地理定位数据</span><br><span class="line">5.1.5 Wi-Fi地理定位数据</span><br><span class="line">5.1.6手机地理定位数据</span><br><span class="line">5.1.7用户自定义的地理定位数据</span><br><span class="line">5.2 HTML5 Geolocation的浏览器支持情况</span><br><span class="line">5.3隐私</span><br><span class="line">5.3.1触发隐私保护机制</span><br><span class="line">5.3.2处理位置信息</span><br><span class="line">5.4使用HTML5 Geolocation API</span><br><span class="line">5.4.1浏览器支持性检查</span><br><span class="line">5.4.2位置请求</span><br><span class="line">5.5使用HTML5 Geolocation构建应用</span><br><span class="line">5.5.1编写HTML显示代码</span><br><span class="line">5.5.2处理Geolocation数据</span><br><span class="line">5.5.3最终代码</span><br><span class="line">5.6进阶功能</span><br><span class="line">5.6.1现在的状态是什么</span><br><span class="line">5.6.2在Goolge Map上显示“我在这里”</span><br><span class="line">5.7小结</span><br><span class="line">第6章 Communication API</span><br><span class="line">6.1跨文档消息通信</span><br><span class="line">6.1.1理解源安全</span><br><span class="line">6.1.2跨文档消息通信的浏览器支持情况</span><br><span class="line">6.1.3使用postMessage API</span><br><span class="line">6.1.4使用postMessage API创建应用</span><br><span class="line">6.2 XMLHttpRequest Level 2</span><br><span class="line">6.2.1跨源XMLHttpRequest</span><br><span class="line">6.2.2进度事件</span><br><span class="line">6.2.3 HTML5XMLHttpRequest Level 2的浏览器支持情况</span><br><span class="line">6.2.4使用XMLHttpRequest API</span><br><span class="line">6.2.5创建XMLHttpRequest应用</span><br><span class="line">6.3进阶功能</span><br><span class="line">6.3.1结构化的数据</span><br><span class="line">6.3.2 FramebUSting</span><br><span class="line">6.4小结</span><br><span class="line">第7章WebSockets API</span><br><span class="line">7.1 WebSockets概述</span><br><span class="line">7.1.1实时和HTTP</span><br><span class="line">7.1.2解读WebSockets</span><br><span class="line">7.2编写简单的Echo WebSocket服务器</span><br><span class="line">7.3使用HTML5 WebSockets API</span><br><span class="line">7.3.1浏览器支持情况检测</span><br><span class="line">7.3.2 API的基本用法</span><br><span class="line">7.4创建HTML5 WebSockets应用程序</span><br><span class="line">7.4.1编写HTML文件</span><br><span class="line">7.4.2添加WebSocket代码</span><br><span class="line">7.4.3添加Geolocation代码</span><br><span class="line">7.4.4合并所有内容</span><br><span class="line">7.4.5最终代码</span><br><span class="line">7.5小结</span><br><span class="line">第8章Forms API</span><br><span class="line">8.1 HTML5 Forms概述</span><br><span class="line">8.1.1 HTML Forms与XForms</span><br><span class="line">8.1.2功能性表单</span><br><span class="line">8.1.3 HTML5 Forms的浏览器支持情况</span><br><span class="line">8.1.4输入型控件目录</span><br><span class="line">8.2使用HTML5 Forms API</span><br><span class="line">8.2.1新的表单特性和函数</span><br><span class="line">8.2.2表单验证</span><br><span class="line">8.2.3验证反馈</span><br><span class="line">8.3构建HTML5 Forms应用</span><br><span class="line">8.4小结</span><br><span class="line">第9章拖放</span><br><span class="line">9.1 Web拖放发展史</span><br><span class="line">9.2 HTML5拖放概述</span><br><span class="line">9.2.1蓝图</span><br><span class="line">9.2.2需要记住的事件</span><br><span class="line">9.2.3设置元素可拖动</span><br><span class="line">9.2.4传输和控制</span><br><span class="line">9.3构建拖放应用</span><br><span class="line">9.4拖放文件</span><br><span class="line">9.5进阶功能</span><br><span class="line">9.6小结</span><br><span class="line">第10章Web Workers API</span><br><span class="line">10.1 Web Workers的浏览器支持情况</span><br><span class="line">10.2使用Web Workers API</span><br><span class="line">10.2.1浏览器支持性检查</span><br><span class="line">10.2.2创建Web Workers</span><br><span class="line">10.2.3多个JavaScript文件的加载与执行</span><br><span class="line">10.2.4与HTML5 Web Workers通信</span><br><span class="line">10.3编写主页</span><br><span class="line">10.3.1处理错误</span><br><span class="line">10.3.2停止Web Workers</span><br><span class="line">10.3.3 Web Workers的嵌套使用</span><br><span class="line">10.3.4使用定时器</span><br><span class="line">10.3.5示例代码</span><br><span class="line">10.4构建Web Workers应用</span><br><span class="line">10.4.1编写blurjs辅助脚本</span><br><span class="line">10.4.2编写blur.html应用页面</span><br><span class="line">10.4.3编写blurWorker.js</span><br><span class="line">10.4.4与Web Worker通信</span><br><span class="line">10.4.5运行程序</span><br><span class="line">10.4.6示例代码</span><br><span class="line">10.5小结</span><br><span class="line">第11章Web Storage API</span><br><span class="line">11.1 HTML5 Web Storage概述</span><br><span class="line">11.2 Web Storage的浏览器支持情况</span><br><span class="line">11.3使用Web Storage API</span><br><span class="line">11.3.1检查浏览器的支持性</span><br><span class="line">11.3.2设置和获取数据</span><br><span class="line">11.3.3封堵数据泄漏</span><br><span class="line">11.3.4 localStorage与sessionStorage</span><br><span class="line">11.3.5 Web Storage API的其他特性和函数</span><br><span class="line">11.3.6更新Web Storage后的通信</span><br><span class="line">11.3.7探索Web Storage</span><br><span class="line">11.4构建Web Storage应用</span><br><span class="line">11.5浏览器数据库存储展望</span><br><span class="line">11.5.1 Web SQL Database</span><br><span class="line">11.5.2索引数据库API</span><br><span class="line">11.6进阶功能</span><br><span class="line">11.6.1 JSON对象的存储</span><br><span class="line">11.6.2共享窗口</span><br><span class="line">11.7小结</span><br><span class="line">第12章构建离线Web应用</span><br><span class="line">12.1 HTML5离线Web应用概述</span><br><span class="line">12.2使用HTML5离线Web应用API</span><br><span class="line">12.2.1检查浏览器的支持情况</span><br><span class="line">12.2.2搭建简单的离线应用程序</span><br><span class="line">12.2.3支持离线行为</span><br><span class="line">12.2.4 manifest文件</span><br><span class="line">12.2.5 applicationCache API</span><br><span class="line">12.2.6运行中的应用缓存</span><br><span class="line">12.3使用HTML5离线Web应用构建应用</span><br><span class="line">12.3.1创建记录资源的manifest文件</span><br><span class="line">12.3.2创建构成界面的HTML和CSS</span><br><span class="line">12.3.3创建离线JavaScript</span><br><span class="line">12.3.4检查applicationCache的支持情况</span><br><span class="line">12.3.5为Update按钮添加处理函数</span><br><span class="line">12.3.6添加Geolocation跟踪代码</span><br><span class="line">12.3.7添加Storage功能代码</span><br><span class="line">12.3.8添加离线事件处理程序</span><br><span class="line">12.4小结</span><br><span class="line">第13章HTML5未来展望</span><br><span class="line">13.1 HTML5的浏览器支持情况</span><br><span class="line">13.2 HTML未来的发展</span><br><span class="line">13.2.1 WebGL</span><br><span class="line">13.2.2设备</span><br><span class="line">13.2.3音频数据API</span><br><span class="line">13.2.4触摸屏设备事件</span><br><span class="line">13.2.5 P2P网络</span><br><span class="line">13.2.6最终方向</span><br><span class="line">13.3小结</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0081E9X0K/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0081E9X0K&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51IhO5-5YFL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>精彩绝伦的CSS</title>
    <url>/2020/04/19/B008F4VJ94/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 精彩绝伦的CSS<br>作者信息： 作者: 迈耶 (Eric A.Meyer) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《精彩绝伦的CSS》适合所有Web开发与设计人员学习参考。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分基本原理</span><br><span class="line">第1章工具</span><br><span class="line">1.1Firebug</span><br><span class="line">1.2Web Developer Toolbar</span><br><span class="line">1.3IE开发者工具栏</span><br><span class="line">1.4Dragonfly（Opera浏览器）</span><br><span class="line">1.5Web检查器（Safari浏览器）</span><br><span class="line">1.6XRAY</span><br><span class="line">1.7SelectORacle</span><br><span class="line">1.8诊断样式表</span><br><span class="line">1.9重启样式表</span><br><span class="line">1.10IE9.JS</span><br><span class="line">第2章选择器</span><br><span class="line">2.1伪类与伪元素</span><br><span class="line">2.2为目标元素添加样式</span><br><span class="line">2.3特殊性</span><br><span class="line">2.4重要性</span><br><span class="line">2.5省略简写属性值的关键词时会发生什么</span><br><span class="line">2.6选择性地覆盖简写属性</span><br><span class="line">2.7通用选择</span><br><span class="line">2.8ID还是类</span><br><span class="line">2.9ID与类共用</span><br><span class="line">2.10多类</span><br><span class="line">2.11简单的属性选择</span><br><span class="line">2.12类的属性选择</span><br><span class="line">2.13ID还是属性选择器</span><br><span class="line">2.14部分属性值选择</span><br><span class="line">2.15更多部分属性值选择</span><br><span class="line">2.16选择后代元素</span><br><span class="line">2.17模拟部分子选择</span><br><span class="line">2.18兄弟选择</span><br><span class="line">2.19生成内容</span><br><span class="line">第二部分核心技术</span><br><span class="line">第3章提示</span><br><span class="line">3.1验证</span><br><span class="line">3.2调整字体值的顺序</span><br><span class="line">3.3玩转行高</span><br><span class="line">3.4无单位的行高值</span><br><span class="line">3.5避免缺少样式的边框值</span><br><span class="line">3.6使用颜色控制边框外观</span><br><span class="line">3.7抑制元素的显示</span><br><span class="line">3.8抑制元素的可见性</span><br><span class="line">3.9将元素移出屏幕</span><br><span class="line">3.10图像替换</span><br><span class="line">3.11打印样式</span><br><span class="line">3.12开发打印样式</span><br><span class="line">3.13块级链接</span><br><span class="line">3.14外边距还是内边距</span><br><span class="line">3.15凸排列表</span><br><span class="line">3.16为列表添加标记</span><br><span class="line">3.17通过背景实现列表标记</span><br><span class="line">3.18生成列表标记</span><br><span class="line">3.19不可不知的容器</span><br><span class="line">3.20文档背景</span><br><span class="line">3.21服务器特定的CSS</span><br><span class="line">第4章布局</span><br><span class="line">4.1用轮廓代替边框</span><br><span class="line">4.2居中块状框</span><br><span class="line">4.3通过溢出遏制浮动</span><br><span class="line">4.4通过浮动遏制浮动</span><br><span class="line">4.5清除浮动</span><br><span class="line">4.6相邻清除</span><br><span class="line">4.7简单的两栏布局</span><br><span class="line">4.8简单的三栏布局</span><br><span class="line">4.9伪造栏布局</span><br><span class="line">4.10流式漂白布局</span><br><span class="line">4.11唯一布局</span><br><span class="line">4.12Holy Grail</span><br><span class="line">4.13流式网格</span><br><span class="line">4.14基于em的布局</span><br><span class="line">4.15文档流中的负外边距</span><br><span class="line">4.16在特定的上下文中使用定位</span><br><span class="line">4.17将元素推出包含块</span><br><span class="line">4.18固定的页头和页脚</span><br><span class="line">第5章效果</span><br><span class="line">5.1复杂的螺旋</span><br><span class="line">5.2CSS弹出框</span><br><span class="line">5.3CSS菜单</span><br><span class="line">5.4框冲切</span><br><span class="line">5.5CSS3预备圆角</span><br><span class="line">5.6CSS3圆角</span><br><span class="line">5.7CSS精灵</span><br><span class="line">5.8滑动门</span><br><span class="line">5.9裁切的滑动门</span><br><span class="line">5.10CSS视差</span><br><span class="line">5.11参差浮动</span><br><span class="line">5.12更好的参差浮动</span><br><span class="line">5.13图像的框</span><br><span class="line">5.14受限的图像</span><br><span class="line">第三部分前沿技术</span><br><span class="line">第6章表格</span><br><span class="line">6.1表头、主体和脚注</span><br><span class="line">6.2行标题</span><br><span class="line">6.3面向列的样式</span><br><span class="line">6.4表的映射</span><br><span class="line">6.5表的图形化</span><br><span class="line">第7章可预见的未来</span><br><span class="line">7.1为HTML5应用样式</span><br><span class="line">7.2像HTML5一样给类命名</span><br><span class="line">7.3媒体查询</span><br><span class="line">7.4为特定的子元素应用样式</span><br><span class="line">7.5为特定的列应用样式</span><br><span class="line">7.6RG Balpha颜色</span><br><span class="line">7.7HSL颜色和HSL alpha颜色</span><br><span class="line">7.8阴影样式</span><br><span class="line">7.9多背景</span><br><span class="line">7.10二维变换</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B008F4VJ94/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B008F4VJ94&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51CDtske1rL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer Plus中文版(第6版)</title>
    <url>/2020/04/19/B008A4XZRI/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C++ Primer Plus中文版(第6版)<br>作者信息： 作者: 蒂芬•普拉达 (Stephen Prata) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《C++ Primer Plus中文版(第6版)》是一本经久不衰的C++畅销经典教程，是第一本支持C++11新标准的程序设计图书，被誉为“开发人员学习C++的首选教程，没有之一”！ Amazon网站“Language”类销售排名第三的超级畅销书，之前版本在美国销售超10万！</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 预备知识</span><br><span class="line">1.1 C++简介</span><br><span class="line">1.2 C++简史</span><br><span class="line">1.2.1 C语言</span><br><span class="line">1.2.2 C语言编程原理</span><br><span class="line">1.2.3 面向对象编程</span><br><span class="line">1.2.4 C++和泛型编程</span><br><span class="line">1.2.5 C++的起源</span><br><span class="line">1.3 可移植性和标准</span><br><span class="line">1.3.1 C++的发展</span><br><span class="line">1.3.2 本书遵循的C++标准</span><br><span class="line">1.4 程序创建的技巧</span><br><span class="line">1.4.1 创建源代码文件</span><br><span class="line">1.4.2 编译和链接</span><br><span class="line">1.5 总结</span><br><span class="line">第2章 开始学习C++</span><br><span class="line">2.1 进入C++</span><br><span class="line">2.1.1 main（）函数</span><br><span class="line">2.1.2 C++注释</span><br><span class="line">2.1.3 C++预处理器和iostream文件</span><br><span class="line">2.1.4 头文件名</span><br><span class="line">2.1.5 名称空间</span><br><span class="line">2.1.6 使用cout进行C++输出</span><br><span class="line">2.1.7 C++源代码的格式化</span><br><span class="line">2.2 C++语句</span><br><span class="line">2.2.1 声明语句和变量</span><br><span class="line">2.2.2 赋值语句</span><br><span class="line">2.2.3 cout的新花样</span><br><span class="line">2.3 其他C++语句</span><br><span class="line">2.3.1 使用cin</span><br><span class="line">2.3.2 使用cout进行拼接</span><br><span class="line">2.3.3 类简介</span><br><span class="line">2.4 函数</span><br><span class="line">2.4.1 使用有返回值的函数</span><br><span class="line">2.4.2 函数变体</span><br><span class="line">2.4.3 用户定义的函数</span><br><span class="line">2.4.4 用户定义的有返回值的函数</span><br><span class="line">2.4.5 在多函数程序中使用using编译指令</span><br><span class="line">2.5 总结</span><br><span class="line">2.6 复习题</span><br><span class="line">2.7 编程练习</span><br><span class="line">第3章 处理数据</span><br><span class="line">3.1 简单变量</span><br><span class="line">3.1.1 变量名</span><br><span class="line">3.1.2 整型</span><br><span class="line">3.1.3 整型short、int、long和long long</span><br><span class="line">3.1.4 无符号类型</span><br><span class="line">3.1.5 选择整型类型</span><br><span class="line">3.1.6 整型字面值</span><br><span class="line">3.1.7 C++如何确定常量的类型</span><br><span class="line">3.1.8 char类型：字符和小整数</span><br><span class="line">3.1.9 bool类型</span><br><span class="line">3.2 const限定符</span><br><span class="line">3.3 浮点数</span><br><span class="line">3.3.1 书写浮点数</span><br><span class="line">3.3.2 浮点类型</span><br><span class="line">3.3.3 浮点常量</span><br><span class="line">3.3.4 浮点数的优缺点</span><br><span class="line">3.4 C++算术运算符</span><br><span class="line">3.4.1 运算符优先级和结合性</span><br><span class="line">3.4.2 除法分支</span><br><span class="line">3.4.3 求模运算符</span><br><span class="line">3.4.4 类型转换</span><br><span class="line">3.4.5 C++11中的auto声明</span><br><span class="line">3.5 总结</span><br><span class="line">3.6 复习题</span><br><span class="line">3.7 编程练习</span><br><span class="line">第4章 复合类型</span><br><span class="line">4.1 数组</span><br><span class="line">4.1.1 程序说明</span><br><span class="line">4.1.2 数组的初始化规则</span><br><span class="line">4.1.3 C++11数组初始化方法</span><br><span class="line">4.2 字符串</span><br><span class="line">4.2.1 拼接字符串常量</span><br><span class="line">4.2.2 在数组中使用字符串</span><br><span class="line">4.2.3 字符串输入</span><br><span class="line">4.2.4 每次读取一行字符串输入</span><br><span class="line">4.2.5 混合输入字符串和数字</span><br><span class="line">4.3 string类简介</span><br><span class="line">4.3.1 C++11字符串初始化</span><br><span class="line">4.3.2 赋值、拼接和附加</span><br><span class="line">4.3.3 string类的其他操作</span><br><span class="line">4.3.4 string类I&#x2F;O</span><br><span class="line">4.3.5 其他形式的字符串字面值</span><br><span class="line">4.4 结构简介</span><br><span class="line">4.4.1 在程序中使用结构</span><br><span class="line">4.4.2 C++11结构初始化</span><br><span class="line">4.4.3 结构可以将string类作为成员吗</span><br><span class="line">4.4.4 其他结构属性</span><br><span class="line">4.4.5 结构数组</span><br><span class="line">4.4.6 结构中的位字段</span><br><span class="line">4.5 共用体</span><br><span class="line">4.6 枚举</span><br><span class="line">4.6.1 设置枚举量的值</span><br><span class="line">4.6.2 枚举的取值范围</span><br><span class="line">4.7 指针和自由存储空间</span><br><span class="line">4.7.1 声明和初始化指针</span><br><span class="line">4.7.2 指针的危险</span><br><span class="line">4.7.3 指针和数字</span><br><span class="line">4.7.4 使用new来分配内存</span><br><span class="line">4.7.5 使用delete释放内存</span><br><span class="line">4.7.6 使用new来创建动态数组</span><br><span class="line">4.8 指针、数组和指针算术</span><br><span class="line">4.8.1 程序说明</span><br><span class="line">4.8.2 指针小结</span><br><span class="line">4.8.3 指针和字符串</span><br><span class="line">4.8.4 使用new创建动态结构</span><br><span class="line">4.8.5 自动存储、静态存储和动态存储</span><br><span class="line">4.9 类型组合</span><br><span class="line">4.10 数组的替代品</span><br><span class="line">4.10.1 模板类vector</span><br><span class="line">4.10.2 模板类array（C++11）</span><br><span class="line">4.10.3 比较数组、vector对象和array对象</span><br><span class="line">4.11 总结</span><br><span class="line">4.12 复习题</span><br><span class="line">4.13 编程练习</span><br><span class="line">第5章 循环和关系表达式</span><br><span class="line">5.1 for循环</span><br><span class="line">5.1.1 for循环的组成部分</span><br><span class="line">5.1.2 回到for循环</span><br><span class="line">5.1.3 修改步长</span><br><span class="line">5.1.4 使用for循环访问字符串</span><br><span class="line">5.1.5 递增运算符（++）和递减运算符（——）</span><br><span class="line">5.1.6 副作用和顺序点</span><br><span class="line">5.1.7 前缀格式和后缀格式</span><br><span class="line">5.1.8 递增&#x2F;递减运算符和指针</span><br><span class="line">5.1.9 组合赋值运算符</span><br><span class="line">5.1.10 复合语句（语句块）</span><br><span class="line">5.1.11 其他语法技巧——逗号运算符</span><br><span class="line">5.1.12 关系表达式</span><br><span class="line">5.1.13 赋值、比较和可能犯的错误</span><br><span class="line">5.1.14 C—风格字符串的比较</span><br><span class="line">5.1.15 比较string类字符串</span><br><span class="line">5.2 while循环</span><br><span class="line">5.2.1 for与while</span><br><span class="line">5.2.2 等待一段时间：编写延时循环</span><br><span class="line">5.3 do while循环</span><br><span class="line">5.4 基于范围的for循环（C++11）</span><br><span class="line">5.5 循环和文本输入</span><br><span class="line">5.5.1 使用原始的cin进行输入</span><br><span class="line">5.5.2 使用cin.get（char）进行补救</span><br><span class="line">5.5.3 使用哪一个cin.get（）</span><br><span class="line">5.5.4 文件尾条件</span><br><span class="line">5.5.5 另一个cin.get（）版本</span><br><span class="line">5.6 嵌套循环和二维数组</span><br><span class="line">5.6.1 初始化二维数组</span><br><span class="line">5.6.2 使用二维数组</span><br><span class="line">5.7 总结</span><br><span class="line">5.8 复习题</span><br><span class="line">5.9 编程练习</span><br><span class="line">第6章 分支语句和逻辑运算符</span><br><span class="line">6.1 if语句</span><br><span class="line">6.1.1 if else语句</span><br><span class="line">6.1.2 格式化if else语句</span><br><span class="line">6.1.3 if else if else结构</span><br><span class="line">6.2 逻辑表达式</span><br><span class="line">6.2.1 逻辑OR运算符：‖</span><br><span class="line">6.2.2 逻辑AND运算符：&amp;&amp;</span><br><span class="line">6.2.3 用&amp;&amp;来设置取值范围</span><br><span class="line">6.2.4 逻辑NOT运算符：！</span><br><span class="line">6.2.5 逻辑运算符细节</span><br><span class="line">6.2.6 其他表示方式</span><br><span class="line">6.3 字符函数库cctype</span><br><span class="line">6.4 ？：运算符</span><br><span class="line">6.5 switch语句</span><br><span class="line">6.5.1 将枚举量用作标签</span><br><span class="line">6.5.2 switch和if else</span><br><span class="line">6.6 break和continue语句</span><br><span class="line">6.7 读取数字的循环</span><br><span class="line">6.8 简单文件输入&#x2F;输出</span><br><span class="line">6.8.1 文本I&#x2F;O和文本文件</span><br><span class="line">6.8.2 写入到文本文件中</span><br><span class="line">6.8.3 读取文本文件</span><br><span class="line">6.9 总结</span><br><span class="line">6.10 复习题</span><br><span class="line">6.11 编程练习</span><br><span class="line">第7章 函数——C++的编程模块</span><br><span class="line">7.1 复习函数的基本知识</span><br><span class="line">7.1.1 定义函数</span><br><span class="line">7.1.2 函数原型和函数调用</span><br><span class="line">7.2 函数参数和按值传递</span><br><span class="line">7.2.1 多个参数</span><br><span class="line">7.2.2 另外一个接受两个参数的函数</span><br><span class="line">7.3 函数和数组</span><br><span class="line">7.3.1 函数如何使用指针来处理数组</span><br><span class="line">7.3.2 将数组作为参数意味着什么</span><br><span class="line">7.3.3 更多数组函数示例</span><br><span class="line">7.3.4 使用数组区间的函数</span><br><span class="line">7.3.5 指针和const</span><br><span class="line">7.4 函数和二维数组</span><br><span class="line">7.5 函数和C—风格字符串</span><br><span class="line">7.5.1 将C—风格字符串作为参数的函数</span><br><span class="line">7.5.2 返回C—风格字符串的函数</span><br><span class="line">7.6 函数和结构</span><br><span class="line">7.6.1 传递和返回结构</span><br><span class="line">7.6.2 另一个处理结构的函数示例</span><br><span class="line">7.6.3 传递结构的地址</span><br><span class="line">7.7 函数和string对象</span><br><span class="line">7.8 函数与array对象</span><br><span class="line">7.9 递归</span><br><span class="line">7.9.1 包含一个递归调用的递归</span><br><span class="line">7.9.2 包含多个递归调用的递归</span><br><span class="line">7.10 函数指针</span><br><span class="line">7.10.1 函数指针的基础知识</span><br><span class="line">7.10.2 函数指针示例</span><br><span class="line">7.10.3 深入探讨函数指针</span><br><span class="line">7.10.4 使用typedef进行简化</span><br><span class="line">7.11 总结</span><br><span class="line">7.12 复习题</span><br><span class="line">7.13 编程练习</span><br><span class="line">第8章 函数探幽</span><br><span class="line">8.1 C++内联函数</span><br><span class="line">8.2 引用变量</span><br><span class="line">8.2.1 创建引用变量</span><br><span class="line">8.2.2 将引用用作函数参数</span><br><span class="line">8.2.3 引用的属性和特别之处</span><br><span class="line">8.2.4 将引用用于结构</span><br><span class="line">8.2.5 将引用用于类对象</span><br><span class="line">8.2.6 对象、继承和引用</span><br><span class="line">8.2.7 何时使用引用参数</span><br><span class="line">8.3 默认参数</span><br><span class="line">8.4 函数重载</span><br><span class="line">8.4.1 重载示例</span><br><span class="line">8.4.2 何时使用函数重载</span><br><span class="line">8.5 函数模板</span><br><span class="line">8.5.1 重载的模板</span><br><span class="line">8.5.2 模板的局限性</span><br><span class="line">8.5.3 显式具体化</span><br><span class="line">8.5.4 实例化和具体化</span><br><span class="line">8.5.5 编译器选择使用哪个函数版本</span><br><span class="line">8.5.6 模板函数的发展</span><br><span class="line">8.6 总结</span><br><span class="line">8.7 复习题</span><br><span class="line">8.8 编程练习</span><br><span class="line">第9章 内存模型和名称空间</span><br><span class="line">9.1 单独编译</span><br><span class="line">9.2 存储持续性、作用域和链接性</span><br><span class="line">9.2.1 作用域和链接</span><br><span class="line">9.2.2 自动存储持续性</span><br><span class="line">9.2.3 静态持续变量</span><br><span class="line">9.2.4 静态持续性、外部链接性</span><br><span class="line">9.2.5 静态持续性、内部链接性</span><br><span class="line">9.2.6 静态存储持续性、无链接性</span><br><span class="line">9.2.7 说明符和限定符</span><br><span class="line">9.2.8 函数和链接性</span><br><span class="line">9.2.9 语言链接性</span><br><span class="line">9.2.10 存储方案和动态分配</span><br><span class="line">9.3 名称空间</span><br><span class="line">9.3.1 传统的C++名称空间</span><br><span class="line">9.3.2 新的名称空间特性</span><br><span class="line">9.3.3 名称空间示例</span><br><span class="line">9.3.4 名称空间及其前途</span><br><span class="line">9.4 总结</span><br><span class="line">9.5 复习题</span><br><span class="line">9.6 编程练习</span><br><span class="line">第10章 对象和类</span><br><span class="line">10.1 过程性编程和面向对象编程</span><br><span class="line">10.2 抽象和类</span><br><span class="line">10.2.1 类型是什么</span><br><span class="line">10.2.2 C++中的类</span><br><span class="line">10.2.3 实现类成员函数</span><br><span class="line">10.2.4 使用类</span><br><span class="line">10.2.5 修改实现</span><br><span class="line">10.2.6 小结</span><br><span class="line">10.3 类的构造函数和析构函数</span><br><span class="line">10.3.1 声明和定义构造函数</span><br><span class="line">10.3.2 使用构造函数</span><br><span class="line">10.3.3 默认构造函数</span><br><span class="line">10.3.4 析构函数</span><br><span class="line">10.3.5 改进Stock类</span><br><span class="line">10.3.6 构造函数和析构函数小结</span><br><span class="line">10.4 this指针</span><br><span class="line">10.5 对象数组</span><br><span class="line">10.6 类作用域</span><br><span class="line">10.6.1 作用域为类的常量</span><br><span class="line">10.6.2 作用域内枚举（C++11）</span><br><span class="line">10.7 抽象数据类型</span><br><span class="line">10.8 总结</span><br><span class="line">10.9 复习题</span><br><span class="line">10.10 编程练习</span><br><span class="line">第11章 使用类</span><br><span class="line">11.1 运算符重载</span><br><span class="line">11.2 计算时间：一个运算符重载示例</span><br><span class="line">11.2.1 添加加法运算符</span><br><span class="line">11.2.2 重载限制</span><br><span class="line">11.2.3 其他重载运算符</span><br><span class="line">11.3 友元</span><br><span class="line">11.3.1 创建友元</span><br><span class="line">11.3.2 常用的友元：重载11.4 重载运算符：作为成员函数还是非成员函数</span><br><span class="line">11.5 再谈重载：一个矢量类</span><br><span class="line">11.5.1 使用状态成员</span><br><span class="line">11.5.2 为Vector类重载算术运算符</span><br><span class="line">11.5.3 对实现的说明</span><br><span class="line">11.5.4 使用Vector类来模拟随机漫步</span><br><span class="line">11.6 类的自动转换和强制类型转换</span><br><span class="line">11.6.1 转换函数</span><br><span class="line">11.6.2 转换函数和友元函数</span><br><span class="line">11.7 总结</span><br><span class="line">11.8 复习题</span><br><span class="line">11.9 编程练习</span><br><span class="line">第12章 类和动态内存分配</span><br><span class="line">12.1 动态内存和类</span><br><span class="line">12.1.1 复习示例和静态类成员</span><br><span class="line">12.1.2 特殊成员函数</span><br><span class="line">12.1.3 回到Stringbad：复制构造函数的哪里出了问题</span><br><span class="line">12.1.4 Stringbad的其他问题： 赋值运算符</span><br><span class="line">12.2 改进后的新String类</span><br><span class="line">12.2.1 修订后的默认构造函数</span><br><span class="line">12.2.2 比较成员函数</span><br><span class="line">12.2.3 使用中括号表示法访问字符</span><br><span class="line">12.2.4 静态类成员函数</span><br><span class="line">12.2.5 进一步重载赋值运算符</span><br><span class="line">12.3 在构造函数中使用new时应注意的事项</span><br><span class="line">12.3.1 应该和不应该</span><br><span class="line">12.3.2 包含类成员的类的逐成员复制</span><br><span class="line">12.4 有关返回对象的说明</span><br><span class="line">12.4.1 返回指向const对象的引用</span><br><span class="line">12.4.2 返回指向非const对象的引用</span><br><span class="line">12.4.3 返回对象</span><br><span class="line">12.4.4 返回const对象</span><br><span class="line">12.5 使用指向对象的指针</span><br><span class="line">12.5.1 再谈new和delete</span><br><span class="line">12.5.2 指针和对象小结</span><br><span class="line">12.5.3 再谈定位new运算符</span><br><span class="line">12.6 复习各种技术</span><br><span class="line">12.6.1 重载12.6.2 转换函数</span><br><span class="line">12.6.3 其构造函数使用new的类</span><br><span class="line">12.7 队列模拟</span><br><span class="line">12.7.1 队列类</span><br><span class="line">12.7.2 Customer类</span><br><span class="line">12.7.3 ATM模拟</span><br><span class="line">12.8 总结</span><br><span class="line">12.9 复习题</span><br><span class="line">12.10 编程练习</span><br><span class="line">第13章 类继承</span><br><span class="line">13.1 一个简单的基类</span><br><span class="line">13.1.1 派生一个类</span><br><span class="line">13.1.2 构造函数：访问权限的考虑</span><br><span class="line">13.1.3 使用派生类</span><br><span class="line">13.1.4 派生类和基类之间的特殊关系</span><br><span class="line">13.2 继承：is—a关系</span><br><span class="line">13.3 多态公有继承</span><br><span class="line">13.4 静态联编和动态联编</span><br><span class="line">13.4.1 指针和引用类型的兼容性</span><br><span class="line">13.4.2 虚成员函数和动态联编</span><br><span class="line">13.4.3 有关虚函数注意事项</span><br><span class="line">13.5 访问控制：protected</span><br><span class="line">13.6 抽象基类</span><br><span class="line">13.6.1 应用ABC概念</span><br><span class="line">13.6.2 ABC理念</span><br><span class="line">13.7 继承和动态内存分配</span><br><span class="line">13.7.1 第一种情况：派生类不使用new</span><br><span class="line">13.7.2 第二种情况：派生类使用new</span><br><span class="line">13.7.3 使用动态内存分配和友元的继承示例</span><br><span class="line">13.8 类设计回顾</span><br><span class="line">13.8.1 编译器生成的成员函数</span><br><span class="line">13.8.2 其他的类方法</span><br><span class="line">13.8.3 公有继承的考虑因素</span><br><span class="line">13.8.4 类函数小结</span><br><span class="line">13.9 总结</span><br><span class="line">13.10 复习题</span><br><span class="line">13.11 编程练习</span><br><span class="line">……</span><br><span class="line">第14章 C++中的代码重用</span><br><span class="line">第15章 友元、异常和其他</span><br><span class="line">第16章 string类和标准模板库</span><br><span class="line">第17章 输入、输出和文件</span><br><span class="line">第18章 探讨C++新标准</span><br><span class="line">附录A 计数系统</span><br><span class="line">附录B C++保留字</span><br><span class="line">附录C ASCII字符集</span><br><span class="line">附录D 运算符优先级</span><br><span class="line">附录E 其他运算符</span><br><span class="line">附录F 模板类string</span><br><span class="line">附录G 标准模板库方法和函数</span><br><span class="line">附录H 精选读物和网上资源</span><br><span class="line">附录I 转换为ISO标准C++</span><br><span class="line">附录J 复习题答案</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B008A4XZRI/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B008A4XZRI&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51BY5L-jhyL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Head First HTML5 Programming(英文版)</title>
    <url>/2020/04/19/B009CJ57XU/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Head First HTML5 Programming(英文版)<br>作者信息： 作者: 埃里克•弗里曼 (Eric Freeman) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Head First HTML5 Programming(中文版)》编辑推荐：HTML5是“Web的未来”，这种说法是不是听过很多次？如果你真的想了解构成HTML5的技术家族，读读弗里曼和罗布森编写的《Head First HTML5 Programming(中文版)》吧！《Head First HTML5 Programming(中文版)》是关于HTML5的权威指南，从初学者到有经验的开发人员都能从中受益。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">引子</span><br><span class="line">1 认识HTML5：欢迎来到Web镇</span><br><span class="line">2 介绍JavaScript和DOM：一点点代码</span><br><span class="line">3 事件、处理程序，诸如此类：一点点交互</span><br><span class="line">4 JavaScript函数和对象：正式JavaScript</span><br><span class="line">5 实现HTML位置感知：地理定位</span><br><span class="line">6 与Web交流：喜欢社交的应用</span><br><span class="line">7 秀出你的艺术天份：画布</span><br><span class="line">8 不再是父辈的老电视：视频……以及特邀演员“画布”</span><br><span class="line">9 在本地存储：Web存储</span><br><span class="line">10 运用javascript：Web工作线程</span><br><span class="line">附录：（我们没有谈到的）十大主题</span><br><span class="line">索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B009CJ57XU/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B009CJ57XU&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51XtuZrlM3L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5秘籍</title>
    <url>/2020/04/19/B009DFCZAQ/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： HTML5秘籍<br>作者信息： 作者: Matthew MacDonald [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《HTML5秘籍》是Missing Manual系列图书经典著作，提供全面通俗的HTML5学习指南，《失控》作者凯文•凯利称《HTML5秘籍》是入门指南最为明智的选择。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分认识新语言</span><br><span class="line">第1章HTML5简介</span><br><span class="line">1.1 HTML5的故事</span><br><span class="line">1.1.1 XHTML 1.0更严格的标准</span><br><span class="line">1.1.2 XHTML 2：意想不到的失败</span><br><span class="line">1.1.3 HTML5：起死回生</span><br><span class="line">1.1.4HTML：活着的语言</span><br><span class="line">1.2 HTML5的三个主要原理</span><br><span class="line">1.2.1不破坏Web</span><br><span class="line">1.2.2修补牛蹄子路</span><br><span class="line">1.2.3实用至上</span><br><span class="line">1.3 HTML5标记初体验</span><br><span class="line">1.3.1 HTML5文档类型</span><br><span class="line">1.3.2字符编码</span><br><span class="line">1.3.3页面语言</span><br><span class="line">1.3.4添加样式表</span><br><span class="line">1.3.5添加JaVaScript</span><br><span class="line">1.3.6最终结果</span><br><span class="line">1.4 HTML5语法</span><br><span class="line">1.4.1放松的规则</span><br><span class="line">1.4.2 HTML5验证</span><br><span class="line">1.4.3 XHTML的回归</span><br><span class="line">1.5 HTML5元素家族</span><br><span class="line">1.5.1新增的元素</span><br><span class="line">1.5.2删除的元素</span><br><span class="line">1.5.3改变的元素</span><br><span class="line">1.5.4调整的元素</span><br><span class="line">1.5.5标准化的元素</span><br><span class="line">1.6今天开始用HTML5</span><br><span class="line">1.6.1了解浏览器支持情况</span><br><span class="line">1.6.2浏览器装机情况统计</span><br><span class="line">1.6.3通过Modernizr检测功能</span><br><span class="line">1.6.4使用腻子脚本”填补功能</span><br><span class="line">缺陷</span><br><span class="line">第2章构造网页的新方式</span><br><span class="line">2.1语义元素</span><br><span class="line">2.2改造传统的HTML页面</span><br><span class="line">2.2.1构造页面的老办法</span><br><span class="line">2.2.2使用HTML5构造页面_</span><br><span class="line">2.2.3用 标注副标题 2.2.4用 添加插图 2.2.5用 添加附注 2.3浏览器对语义元素的支持情况 2.4使用语义元素设计站点 2.4.1理解 2.4.2用 标注导航链接 2.4.3理解 2.4.4理解区块 2.5 HTML5纲要 2.5.1如何查看纲要 2.5.2基本纲要 2.5.3分块元素 2.5.4解决一个纲要问题 第3章有意义的标记 3.1回顾语义元素 3.1.1使用标注日期和时间 3.1.2使用标注JavaScript返回值 3.1.3使用标注突显文本 3.2其他语义标准 3.2.1 ARIA 3.2.2 RDFa 3.2.3 Microformats 3.2.4 Microdata 3.3GOogle Rich Snippets 3.3.1增强搜索结果 3.3.2菜谱搜索引擎 第二部分制作新网页 第4章Web表单 4.1理解表单 4.2传统表单翻新 4.2.1通过占位符文本添加提示 4.2.2焦点：挑选正确的起点 4.3验证：阻止错误 4.3.1HTML5验证的原理 4.3.2关闭验证 4.3.3验证样式挂钩 4.3.4使用正则表达式 4.3.5自定义验证 4.3.6浏览器对验证的支持 4.4新的输入控件 4.4.1电子邮件地址 4.4.2网址 4.4.3搜索框 4.4.4电话号码 4.4.5数值 4.4.6滑动条 4.4.7日期和时间 4.4.8颜色 4.5新元素 4.5.1使用显示输入建议 4.5.2进度条和计量条 4.5.3使用和 创建工具条和菜单 4.6网页中的HTML编辑器 4.6.1使用contentEditable编辑元素 4.6.2使用designMode编辑页面 第5章音频与视频 5.1理解今天的视频 5.2 HTML5音频与视频 5.2.1使用 播放点噪音 5.2.2了解 5.3格式之争与后备措施 5.3.1谈谈格式 5.3.2浏览器对体格式的支持情况 5.3.3多种格式：如何讨好每一款浏览器 5.3.4使用元素 5.3.5以Flash作后备 5.4使用JavaScript控制播放器 5.4.1添加音效 5.4.2创建自定义视频播放器 5.4.3 JavaScript媒体播放器 5.4.4字幕与无障碍性 第6章基本Canvas绘图 6.1Canvas起步 6.1.1画直线 6.1.2路径与形状 6.1.3绘制曲线 6.1.4变换 6.1.5透明度 6.2构建基本的画图程序 6.2.1准备工作 6.2.2在画布上绘图 6.2.3将画布保存为图像 6.3浏览器对Canvas的支持情况 6.3.1填平补齐Canvas 6.3.2 Canvas后备及功能检测 第7章高级Canvas技术 7.1高级Canvas绘图 7.1.1绘制图像 7.1.2裁剪、切割和伸缩图片 7.1.3绘制文本 7.2阴影与填充 7.2.1添加阴影 7.2.2填充图案 7.2.3填充渐变 7.2.4综合示例：绘制图解 7.3赋予图形交互能力。 7.3.1记录绘制的内容 7.3.2基于坐标的碰撞检测 7.4给Canvas添加动画 7.4.1基本的动画 7.4.2多物体动画 7.5实例：迷宫游戏 7.5.1布置迷宫 7.5.2让笑脸动起来 7.5.3基于像素颜色的碰撞检测 第8章使用CSS3 8.1使用CSS3 8.1.1选择一：用能用的 8.1.2选择二：将CSS功能作为 增强 8.1.3选择三：Modemizr 8.1.4特定于浏览器的样式 8.2Web排版 8.2.1Web字体格式 8.2.2使用字体包 8.2.3使用谷歌的Web字体 8.2.4使用自己的字体 8.2.5多栏文本 8.3适用不同的设备 8.3.1媒体查询 8.3.2高级媒体查询 8.3.3替换整个样式表 8.3.4识别移动设备 8.4多变的盒子 8.4.1透明盒子 8.4.2圆角盒子 8.4.3背景盒子 8.4.4阴影盒子 8.4.5渐变盒子 8.5创建过渡效果 8.5.1基本的颜色过渡 8.5.2更多的过渡思路 8.5.3变换 第三部分构建桌面式Web应用 第9章数据存储 9.1Web存储简介 9.1.1存储数据 9.1.2实战：保存游戏中的最后位置 9.1.3浏览器对Web存储的支持情况 9.2深入Web存储 9.2.1删除数据项 9,2.2查找所有数据项 9.2.3保存数值和日期 9.2.4保存对象 9.2.5响应存储变化 9.3读取文件 9.3.1取得文件 9.3.2浏览器对File API的支持情况 9.3.3读取文本文件 9.3.4替换标准上传控件 9.3.5一次读取多个文件 9.3.6读取图片文件 第10章离线应用 10.1通过描述文件缓存资源 10.1.1创建描述文件 10.1.2使用描述文件 10.1.3把描述文件放到Web服务器 10.1.4更新描述文件 10.1.5浏览器对离线应用的支持情况 10.2实用缓存技术 10.2.1访问未缓存的文件 10.2.2添加后备内容 10.2.3检测连接 10.2.4通过JavaScript指定更新 第11章与Web服务器通信 11.1向Web服务器发送消息 11.1.1 XMLHttpRequest对象 11.1.2向Web服务器提问 11.1.3取得新内容 11.2服务器发送事件 11.2.1消息格式 11.2.2通过服务器脚本发送消息 11.2.3在网页中处理消息 11.2.4轮询服务器端事件 11.3Web Socket 11.3.1访问Web Socket 11.32简单的Web Socket客户端 11.3.3使用现成的Web Socket服务器 第12章更酷的JavaScript技术 12.1地理定位 12.1.1地理定位的基本原理 12.1.2查找访客的坐标 12.1.3处理错误 12.1.4设置地理定位选项 12.1.5显示地图 12.1.6跟踪访客移动 12.2 Web WOrkers 12.2.1费时的任务 12.2.2把任务放在后台 12.2.3处理Worker错误 12.2.4取消后台任务 12.2.5传递复杂消息 12.3历史管理 12.3.1URL问题 12.3.2以往的解决方案：Hashbang URL 12.3.3 HTML5的方案：会话历史 12.3.4浏览器对会话历史的支持情况 第四部分附录 附录A CSS简明教程 附录B JavaScript简明教程   &lt;&#x2F;source&gt;&lt;&#x2F;video&gt;&lt;&#x2F;audio&gt;</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B009DFCZAQ/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B009DFCZAQ&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41gDiImucAL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ GUI Qt 4编程(第2版)</title>
    <url>/2020/04/19/B00D3CU7MI/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C++ GUI Qt 4编程(第2版)<br>作者信息： 作者: 布兰切特 (Jasmin Blanchette) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《C++ GUI Qt 4编程(第2版)》讲授的大量Qt4编程原理和实践，都可以轻易将其应用于Qt4.4、Qt4.5及后续版本的Qt程序的开发过程中。《C++ GUI Qt 4编程(第2版)》适合对Qt编程感兴趣的程序员及广大计算机编程爱好者阅读，也可作为相关机构的培训教材。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分Qt基础</span><br><span class="line">第1章Qt入门</span><br><span class="line">1.1HelloQt</span><br><span class="line">1.2建立连接</span><br><span class="line">1.3窗口部件的布局</span><br><span class="line">1.4使用参考文档</span><br><span class="line">第2章创建对话框</span><br><span class="line">2.1子类化QDialog</span><br><span class="line">2.2深入介绍信号和槽</span><br><span class="line">2.3快速设计对话框</span><br><span class="line">2.4改变形状的对话框</span><br><span class="line">2.5动态对话框</span><br><span class="line">2.6内置的窗口部件类和对话框类</span><br><span class="line">第3章创建主窗口</span><br><span class="line">3.1子类化QMainWindow</span><br><span class="line">3.2创建菜单和工具栏</span><br><span class="line">3.3设置状态栏</span><br><span class="line">3.4实现File菜单</span><br><span class="line">3.5使用对话框</span><br><span class="line">3.6存储设置</span><br><span class="line">3.7多文档</span><br><span class="line">3.8程序启动画面</span><br><span class="line">第4章实现应用程序的功能</span><br><span class="line">4.1中央窗口部件</span><br><span class="line">4.2子类化QTableWidget</span><br><span class="line">4.3载入和保存</span><br><span class="line">4.4实现Edit菜单</span><br><span class="line">4.5实现其他菜单</span><br><span class="line">4.6子类化QTableWidgetItem</span><br><span class="line">第5章创建自定义窗口部件</span><br><span class="line">5.1自定义Qt窗口部件</span><br><span class="line">5.2子类化QWidget</span><br><span class="line">5.3在Qt设计师中集成自定义窗口部件</span><br><span class="line">5.4双缓冲</span><br><span class="line">第二部分Qt中级</span><br><span class="line">第6章布局管理</span><br><span class="line">6.1在窗体中摆放窗口部件</span><br><span class="line">6.2分组布局</span><br><span class="line">6.3切分窗口</span><br><span class="line">6.4滚动区域</span><br><span class="line">6.5停靠窗口和工具栏</span><br><span class="line">6.6多文档界面</span><br><span class="line">第7章事件处理</span><br><span class="line">7.1重新实现事件处理器</span><br><span class="line">7.2安装事件过滤器</span><br><span class="line">7.3处理密集时的响应保持</span><br><span class="line">第8章二维图形</span><br><span class="line">8.1用QPainter绘图</span><br><span class="line">8.2坐标系统变换</span><br><span class="line">8.3用QImage高质量绘图</span><br><span class="line">8.4基于项的图形视图</span><br><span class="line">8.5打印</span><br><span class="line">第9章拖放</span><br><span class="line">9.1使拖放生效</span><br><span class="line">9.2支持自定义拖动类型</span><br><span class="line">9.3剪贴板处理技术</span><br><span class="line">第10章项视图类</span><br><span class="line">10.1使用项视图的简便类</span><br><span class="line">10.2使用预定义模型</span><br><span class="line">10.3实现自定义模型</span><br><span class="line">10.4实现自定义委托</span><br><span class="line">第11章容器类</span><br><span class="line">11.1连续容器</span><br><span class="line">11.2关联容器</span><br><span class="line">11.3通用算法</span><br><span class="line">11.4字符串、字节数组和变量</span><br><span class="line">第12章输入与输出</span><br><span class="line">12.1读取和写入二进制数据</span><br><span class="line">12.2读取和写入文本</span><br><span class="line">12.3遍历目录</span><br><span class="line">12.4嵌入资源</span><br><span class="line">12.5进程间通信</span><br><span class="line">第13章数据库</span><br><span class="line">13.1连接和查询</span><br><span class="line">13.2查看表</span><br><span class="line">13.3使用窗体编辑记录</span><br><span class="line">13.4在表中显示数据</span><br><span class="line">第14章多线程</span><br><span class="line">14.1创建线程</span><br><span class="line">14.2同步线程</span><br><span class="line">14.3与主线程通信</span><br><span class="line">14.4在次线程中使用Qt的类</span><br><span class="line">第15章网络</span><br><span class="line">15.1写FTP客户端</span><br><span class="line">15.2写HTTP客户端</span><br><span class="line">15.3写TCP客户&#x2F;服务器应用程序</span><br><span class="line">15.4发送和接收UDP数据报</span><br><span class="line">第16章XML</span><br><span class="line">16.1使用QXmlStreamReader读取XML</span><br><span class="line">16.2用DOM读取XML</span><br><span class="line">16.3使用SAX读取XML</span><br><span class="line">16.4写入XML</span><br><span class="line">第17章提供在线帮助</span><br><span class="line">17.1工具提示、状态提示和“What’s This？”帮助</span><br><span class="line">17.2利用Web浏览器提供在线帮助</span><br><span class="line">17.3将QTextBrowser作为简单的帮助引擎</span><br><span class="line">17.4使用QtAssistant提供强大的在线帮助</span><br><span class="line">第三部分Qt高级</span><br><span class="line">第18章国际化</span><br><span class="line">18.1使用Unicode</span><br><span class="line">18.2让应用程序感知翻译</span><br><span class="line">18.3动态切换语言</span><br><span class="line">18.4翻译应用程序</span><br><span class="line">第19章自定义外观</span><br><span class="line">19.1使用Qt样式表</span><br><span class="line">19.2子类化QStyle</span><br><span class="line">第20章三维图形</span><br><span class="line">20.1使用OpenGL绘图</span><br><span class="line">20.2OpenGL和QPainter的结合</span><br><span class="line">20.3使用帧缓存对象生成叠加</span><br><span class="line">第21章创建插件</span><br><span class="line">21.1利用插件扩展Qt</span><br><span class="line">21.2使应用程序感知插件</span><br><span class="line">21.3编写应用程序的插件</span><br><span class="line">第22章应用程序脚本</span><br><span class="line">22.1ECMAScript语言概述</span><br><span class="line">22.2使用脚本扩展Qt应用程序</span><br><span class="line">22.3使用脚本实现GUI扩展</span><br><span class="line">22.4使用脚本自动化处理任务</span><br><span class="line">第23章平台相关特性</span><br><span class="line">23.1连接本地的应用程序编程接口</span><br><span class="line">23.2在Windows上使用ActiveX</span><br><span class="line">23.3处理X11会话管理</span><br><span class="line">第24章嵌入式编程</span><br><span class="line">24.1从Qt&#x2F;EmbeddedLinux开始</span><br><span class="line">24.2自定义Qt&#x2F;EmbeddedLinux</span><br><span class="line">24.3Qt应用程序与Qtopia的集成</span><br><span class="line">24.4使用Qtopia的API</span><br><span class="line">第四部分附录</span><br><span class="line">附录AQt的获取和安装</span><br><span class="line">A.1协议说明</span><br><span class="line">A.2Qt&#x2F;Windows的安装</span><br><span class="line">A.3Qt&#x2F;Mac的安装</span><br><span class="line">A.4Qt&#x2F;X11的安装</span><br><span class="line">附录B编译Qt应用程序</span><br><span class="line">B.1使用qmake</span><br><span class="line">B.2使用第三方编译工具</span><br><span class="line">附录CQtJambi简介</span><br><span class="line">C.1QtJambi入门</span><br><span class="line">C.2在EclipseIDE中使用QtJambi</span><br><span class="line">C.3在QtJambi中集成C＋＋组件</span><br><span class="line">附录D面向Java和C#程序员的C＋＋简介</span><br><span class="line">D.1C＋＋入门</span><br><span class="line">D.2主要语言之间的差异</span><br><span class="line">D.3C＋＋标准库</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00D3CU7MI/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00D3CU7MI&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51TGJlwPNyL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解C++11 C++11新特性解析与应用</title>
    <url>/2020/04/19/B00D678VHS/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 深入理解C++11 C++11新特性解析与应用<br>作者信息： 作者: Michael Wong [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《深入理解C++11:C++11新特性解析与应用》编辑推荐：C++标准委员会成员和IBM XL编译器中国开发团队共同撰写，权威性毋庸置疑。系统、深入、详尽地讲解了C++11新标准中的新语言特性、新标准库特性、对原有特性的改进，以及所有这些新特性的应用。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">免责声明</span><br><span class="line">序</span><br><span class="line">前言</span><br><span class="line">第1章新标准的诞生1</span><br><span class="line">1.1曙光：C++11标准的诞生1</span><br><span class="line">1.1.1C++11&#x2F;C++0x（以及C11&#x2F;C1x）——新标准诞生1</span><br><span class="line">1.1.2什么是C++11&#x2F;C++0x2</span><br><span class="line">1.1.3新C++语言的设计目标3</span><br><span class="line">1.2今时今日的C++5</span><br><span class="line">1.2.1C++的江湖地位5</span><br><span class="line">1.2.2C++11语言变化的领域5</span><br><span class="line">1.3C++11特性的分类7</span><br><span class="line">1.4C++特性一览11</span><br><span class="line">1.4.1稳定性与兼容性之间的抉择11</span><br><span class="line">1.4.2更倾向于使用库而不是扩展语言来实现特性12</span><br><span class="line">1.4.3更倾向于通用的而不是特殊的手段来实现特性13</span><br><span class="line">1.4.4专家新手一概支持13</span><br><span class="line">1.4.5增强类型的安全性14</span><br><span class="line">1.4.6与硬件紧密合作14</span><br><span class="line">1.4.7开发能够改变人们思维方式的特性15</span><br><span class="line">1.4.8融入编程现实16</span><br><span class="line">1.5本书的约定17</span><br><span class="line">1.5.1关于一些术语的翻译17</span><br><span class="line">1.5.2关于代码中的注释17</span><br><span class="line">1.5.3关于本书中的代码示例与实验平台18</span><br><span class="line">第2章保证稳定性和兼容性19</span><br><span class="line">2.1保持与C99兼容19</span><br><span class="line">2.1.1预定义宏19</span><br><span class="line">2.1.2_func预定义标识符20 2.1.3_Pragma操作符22 2.1.4变长参数的宏定义以及VA_ARGS_22</span><br><span class="line">2.1.5宽窄字符串的连接23</span><br><span class="line">2.2longlong整型23</span><br><span class="line">2.3扩展的整型25</span><br><span class="line">2.4宏_cplusplus26</span><br><span class="line">2.5静态断言27</span><br><span class="line">2.5.1断言：运行时与预处理时27</span><br><span class="line">2.5.2静态断言与static_assert28</span><br><span class="line">2.6noexcept修饰符与noexcept操作符32</span><br><span class="line">2.7快速初始化成员变量36</span><br><span class="line">2.8非静态成员的sizeof39</span><br><span class="line">2.9扩展的friend语法40</span><br><span class="line">2.10final&#x2F;override控制44</span><br><span class="line">2.11模板函数的默认模板参数48</span><br><span class="line">2.12外部模板50</span><br><span class="line">2.12.1为什么需要外部模板50</span><br><span class="line">2.12.2显式的实例化与外部模板的声明52</span><br><span class="line">2.13局部和匿名类型作模板实参54</span><br><span class="line">2.14本章小结55</span><br><span class="line">第3章通用为本，专用为末57</span><br><span class="line">3.1继承构造函数57</span><br><span class="line">3.2委派构造函数62</span><br><span class="line">3.3右值引用：移动语义和完美转发68</span><br><span class="line">3.3.1指针成员与拷贝构造68</span><br><span class="line">3.3.2移动语义69</span><br><span class="line">3.3.3左值、右值与右值引用75</span><br><span class="line">3.3.4std：move：强制转化为右值80</span><br><span class="line">3.3.5移动语义的一些其他问题82</span><br><span class="line">3.3.6完美转发85</span><br><span class="line">3.4显式转换操作符89</span><br><span class="line">3.5列表初始化92</span><br><span class="line">3.5.1初始化列表92</span><br><span class="line">3.5.2防止类型收窄96</span><br><span class="line">3.6POD类型98</span><br><span class="line">3.7非受限联合体106</span><br><span class="line">3.8用户自定义字面量110</span><br><span class="line">3.9内联名字空间113</span><br><span class="line">3.10模板的别名118</span><br><span class="line">3.11一般化的SFINEA规则119</span><br><span class="line">3.12本章小结121</span><br><span class="line">第4章新手易学，老兵易用123</span><br><span class="line">4.1右尖括号&gt;的改进123</span><br><span class="line">4.2auto类型推导124</span><br><span class="line">4.2.1静态类型、动态类型与类型推导124</span><br><span class="line">4.2.2auto的优势126</span><br><span class="line">4.2.3auto的使用细则130</span><br><span class="line">4.3decltype134</span><br><span class="line">4.3.1typeid与decltype134</span><br><span class="line">4.3.2decltype的应用136</span><br><span class="line">4.3.3decltype推导四规则140</span><br><span class="line">4.3.4cv限制符的继承与冗余的符号143</span><br><span class="line">4.4追踪返回类型145</span><br><span class="line">4.4.1追踪返回类型的引入145</span><br><span class="line">4.4.2使用追踪返回类型的函数146</span><br><span class="line">4.5基于范围的for循环150</span><br><span class="line">4.6本章小结153</span><br><span class="line">第5章提高类型安全155</span><br><span class="line">5.1强类型枚举155</span><br><span class="line">5.1.1枚举：分门别类与数值的名字155</span><br><span class="line">5.1.2有缺陷的枚举类型156</span><br><span class="line">5.1.3强类型枚举以及C++11对原有枚举类型的扩展160</span><br><span class="line">5.2堆内存管理：智能指针与垃圾回收163</span><br><span class="line">5.2.1显式内存管理163</span><br><span class="line">5.2.2C++11的智能指针164</span><br><span class="line">5.2.3垃圾回收的分类167</span><br><span class="line">5.2.4C++与垃圾回收169</span><br><span class="line">5.2.5C++11与最小垃圾回收支持170</span><br><span class="line">5.2.6垃圾回收的兼容性172</span><br><span class="line">5.3本章小结173</span><br><span class="line">第6章提高性能及操作硬件的能力174</span><br><span class="line">6.1常量表达式174</span><br><span class="line">6.1.1运行时常量性与编译时常量性174</span><br><span class="line">6.1.2常量表达式函数176</span><br><span class="line">6.1.3常量表达式值178</span><br><span class="line">6.1.4常量表达式的其他应用180</span><br><span class="line">6.2变长模板183</span><br><span class="line">6.2.1变长函数和变长的模板参数183</span><br><span class="line">6.2.2变长模板：模板参数包和函数参数包185</span><br><span class="line">6.2.3变长模板：进阶189</span><br><span class="line">6.3原子类型与原子操作196</span><br><span class="line">6.3.1并行编程、多线程与C++11196</span><br><span class="line">6.3.2原子操作与C++11原子类型197</span><br><span class="line">6.3.3内存模型，顺序一致性与memory_order203</span><br><span class="line">6.4线程局部存储214</span><br><span class="line">6.5快速退出：quick_exit与at_quick_exit216</span><br><span class="line">6.6本章小结219</span><br><span class="line">第7章为改变思考方式而改变220</span><br><span class="line">7.1指针空值—nullptr220</span><br><span class="line">7.1.1指针空值：从0到NULL，再到nullptr220</span><br><span class="line">7.1.2nullptr和nullptr_t223</span><br><span class="line">7.1.3一些关于nullptr规则的讨论225</span><br><span class="line">7.2默认函数的控制227</span><br><span class="line">7.2.1类与默认函数227</span><br><span class="line">7.2.2“&#x3D;default”与“&#x3D;deleted”230</span><br><span class="line">7.3lambda函数234</span><br><span class="line">7.3.1lambda的一些历史234</span><br><span class="line">7.3.2C++11中的lambda函数235</span><br><span class="line">7.3.3lambda与仿函数238</span><br><span class="line">7.3.4lambda的基础使用240</span><br><span class="line">7.3.5关于lambda的一些问题及有趣的实验243</span><br><span class="line">7.3.6lambda与STL247</span><br><span class="line">7.3.7更多的一些关于lambda的讨论254</span><br><span class="line">7.4本章小结256</span><br><span class="line">第8章融入实际应用258</span><br><span class="line">8.1对齐支持258</span><br><span class="line">8.1.1数据对齐258</span><br><span class="line">8.1.2C++11的alignof和alignas261</span><br><span class="line">8.2通用属性267</span><br><span class="line">8.2.1语言扩展到通用属性267</span><br><span class="line">8.2.2C++11的通用属性268</span><br><span class="line">8.2.3预定义的通用属性270</span><br><span class="line">8.3Unicode支持274</span><br><span class="line">8.3.1字符集、编码和Unicode274</span><br><span class="line">8.3.2C++11中的Unicode支持276</span><br><span class="line">8.3.3关于Unicode的库支持280</span><br><span class="line">8.4原生字符串字面量284</span><br><span class="line">8.5本章小结286</span><br><span class="line">附录AC++11对其他标准的不兼容项目287</span><br><span class="line">附录B弃用的特性294</span><br><span class="line">附录C编译器支持301</span><br><span class="line">附录D相关资源304</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00D678VHS/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00D678VHS&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41QxXGGrinL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C#图解教程(第4版)</title>
    <url>/2020/04/19/B00DMS8OKA/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C#图解教程(第4版)<br>作者信息： 作者: 索利斯 (Daniel M.Solis) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>大家时间都很宝贵，三分钟就能理解的技术细节，干嘛要花三个小时？！C#图解教程(第4版)被誉为C#入门图书中的“神书”，是高效、深入掌握C#的不二之选！“想通过学习C#为你的编程生涯打下坚实的基础？这本书是我发自内心推荐给你的。”为什么那么多C#学习者对《C#图解教程》有口皆碑，令这本书一版再版，长销不衰？因为作者创造了一种全新的可视化叙述方式。他在书中通过把大量的图、表和代码片段有机结合，把很多同类书需要好几页才能讲清楚的技术细节，形象、直观、一目了然地呈现在读者眼前。不管你信不信，很多技术细节只有通过图示才能讲得这么清晰、透彻！</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 C#和.NET框架 1</span><br><span class="line">1.1 在.NET之前 1</span><br><span class="line">1.1.1 20世纪90年代末的Windows编程 1</span><br><span class="line">1.1.2 下一代平台服务的目标 2</span><br><span class="line">1.2 .NET时代 2</span><br><span class="line">1.2.1 .NET框架的组成 2</span><br><span class="line">1.2.2 大大改进的编程环境 3</span><br><span class="line">1.3 编译成CIL 5</span><br><span class="line">1.4 编译成本机代码并执行 6</span><br><span class="line">1.5 CLR 7</span><br><span class="line">1.6 CLI 8</span><br><span class="line">1.7 各种缩写 9</span><br><span class="line">1.8 C#的演化 9</span><br><span class="line">第2章 C#编程概述 10</span><br><span class="line">2.1 一个简单的C#程序 10</span><br><span class="line">2.2 标识符 12</span><br><span class="line">2.3 关键字 12</span><br><span class="line">2.4 Main：程序的起始点 13</span><br><span class="line">2.5 空白 13</span><br><span class="line">2.6 语句 14</span><br><span class="line">2.7 从程序中输出文本 15</span><br><span class="line">2.7.1 Write 15</span><br><span class="line">2.7.2 WriteLine 15</span><br><span class="line">2.7.3 格式字符串 16</span><br><span class="line">2.7.4 多重标记和值 16</span><br><span class="line">2.7.5 格式化数字字符串 17</span><br><span class="line">2.8 注释：为代码添加注解 20</span><br><span class="line">2.8.1 关于注释的补充 21</span><br><span class="line">2.8.2 文档注释 21</span><br><span class="line">2.8.3 注释类型总结 22</span><br><span class="line">第3章 类型、存储和变量 23</span><br><span class="line">3.1 C#程序是一组类型声明 23</span><br><span class="line">3.2 类型是一种模板 24</span><br><span class="line">3.3 实例化类型 24</span><br><span class="line">3.4 数据成员和函数成员 25</span><br><span class="line">3.5 预定义类型 26</span><br><span class="line">3.6 用户定义类型 27</span><br><span class="line">3.7 栈和堆 28</span><br><span class="line">3.7.1 栈 28</span><br><span class="line">3.7.2 堆 29</span><br><span class="line">3.8 值类型和引用类型 30</span><br><span class="line">3.8.1 存储引用类型对象的成员 31</span><br><span class="line">3.8.2 C#类型的分类 31</span><br><span class="line">3.9 变量 32</span><br><span class="line">3.9.1 变量声明 32</span><br><span class="line">3.9.2 多变量声明 34</span><br><span class="line">3.9.3 使用变量的值 34</span><br><span class="line">3.10 静态类型和dynamic关键字 34</span><br><span class="line">3.11 可空类型 35</span><br><span class="line">第4章 类的基本概念 36</span><br><span class="line">4.1 类的概述 36</span><br><span class="line">4.2 程序和类：一个快速示例 37</span><br><span class="line">4.3 声明类 38</span><br><span class="line">4.4 类成员 38</span><br><span class="line">4.4.1 字段 38</span><br><span class="line">4.4.2 方法 40</span><br><span class="line">4.5 创建变量和类的实例 41</span><br><span class="line">4.6 为数据分配内存 41</span><br><span class="line">4.7 实例成员 42</span><br><span class="line">4.8 访问修饰符 43</span><br><span class="line">4.9 从类的内部访问成员 45</span><br><span class="line">4.10 从类的外部访问成员 46</span><br><span class="line">4.11 综合应用 47</span><br><span class="line">第5章 方法 49</span><br><span class="line">5.1 方法的结构 49</span><br><span class="line">5.2 方法体内部的代码执行 50</span><br><span class="line">5.3 本地变量 51</span><br><span class="line">5.3.1 类型推断和var关键字 52</span><br><span class="line">5.3.2 嵌套块中的本地变量 52</span><br><span class="line">5.4 本地常量 53</span><br><span class="line">5.5 控制流 54</span><br><span class="line">5.6 方法调用 55</span><br><span class="line">5.7 返回值 56</span><br><span class="line">5.8 返回语句和void方法 57</span><br><span class="line">5.9 参数 59</span><br><span class="line">5.9.1 形参 59</span><br><span class="line">5.9.2 实参 59</span><br><span class="line">5.10 值参数 61</span><br><span class="line">5.11 引用参数 63</span><br><span class="line">5.12 引用类型作为值参数和引用参数 65</span><br><span class="line">5.13 输出参数 68</span><br><span class="line">5.14 参数数组 70</span><br><span class="line">5.14.1 方法调用 71</span><br><span class="line">5.14.2 用数组作为实参 73</span><br><span class="line">5.15 参数类型总结 74</span><br><span class="line">5.16 方法重载 74</span><br><span class="line">5.17 命名参数 75</span><br><span class="line">5.18 可选参数 76</span><br><span class="line">5.19 栈帧 79</span><br><span class="line">5.20 递归 81</span><br><span class="line">第6章 深入理解类 83</span><br><span class="line">6.1 类成员 83</span><br><span class="line">6.2 成员修饰符的顺序 84</span><br><span class="line">6.3 实例类成员 85</span><br><span class="line">6.4 静态字段 86</span><br><span class="line">6.5 从类的外部访问静态成员 86</span><br><span class="line">6.5.1 静态字段示例 87</span><br><span class="line">6.5.2 静态成员的生存期 87</span><br><span class="line">6.6 静态函数成员 88</span><br><span class="line">6.7 其他静态类成员类型 89</span><br><span class="line">6.8 成员常量 90</span><br><span class="line">6.9 常量与静态量 90</span><br><span class="line">6.10 属性 91</span><br><span class="line">6.10.1 属性声明和访问器 92</span><br><span class="line">6.10.2 属性示例 93</span><br><span class="line">6.10.3 使用属性 94</span><br><span class="line">6.10.4 属性和关联字段 94</span><br><span class="line">6.10.5 执行其他计算 96</span><br><span class="line">6.10.6 只读和只写属性 96</span><br><span class="line">6.10.7 属性与公共字段 97</span><br><span class="line">6.10.8 计算只读属性示例 97</span><br><span class="line">6.10.9 自动实现属性 98</span><br><span class="line">6.10.10 静态属性 99</span><br><span class="line">6.11 实例构造函数 100</span><br><span class="line">6.11.1 带参数的构造函数 101</span><br><span class="line">6.11.2 默认构造函数 102</span><br><span class="line">6.12 静态构造函数 102</span><br><span class="line">6.13 对象初始化语句 104</span><br><span class="line">6.14 析构函数 105</span><br><span class="line">6.15 readonly修饰符 105</span><br><span class="line">6.16 this关键字 106</span><br><span class="line">6.17 索引器 107</span><br><span class="line">6.17.1 什么是索引器 108</span><br><span class="line">6.17.2 索引器和属性 108</span><br><span class="line">6.17.3 声明索引器 109</span><br><span class="line">6.17.4 索引器的set访问器 110</span><br><span class="line">6.17.5 索引器的get访问器 110</span><br><span class="line">6.17.6 关于索引器的补充 111</span><br><span class="line">6.17.7 为Employee示例声明索引器 111</span><br><span class="line">6.17.8 另一个索引器的示例 112</span><br><span class="line">6.17.9 索引器重载 113</span><br><span class="line">6.18 访问器的访问修饰符 114</span><br><span class="line">6.19 分部类和分部类型 115</span><br><span class="line">6.20 分部方法 116</span><br><span class="line">第7章 类和继承 118</span><br><span class="line">7.1 类继承 118</span><br><span class="line">7.2 访问继承的成员 119</span><br><span class="line">7.3 所有类都派生自object类 120</span><br><span class="line">7.4 屏蔽基类的成员 121</span><br><span class="line">7.5 基类访问 123</span><br><span class="line">7.6 使用基类的引用 124</span><br><span class="line">7.6.1 虚方法和覆写方法 125</span><br><span class="line">7.6.2 覆写标记为override的方法 127</span><br><span class="line">7.6.3 覆盖其他成员类型 130</span><br><span class="line">7.7 构造函数的执行 130</span><br><span class="line">7.7.1 构造函数初始化语句 132</span><br><span class="line">7.7.2 类访问修饰符 134</span><br><span class="line">7.8 程序集间的继承 134</span><br><span class="line">7.9 成员访问修饰符 136</span><br><span class="line">7.9.1 访问成员的区域 137</span><br><span class="line">7.9.2 公有成员的可访问性 138</span><br><span class="line">7.9.3 私有成员的可访问性 138</span><br><span class="line">7.9.4 受保护成员的可访问性 138</span><br><span class="line">7.9.5 内部成员的可访问性 139</span><br><span class="line">7.9.6 受保护内部成员的可访问性 139</span><br><span class="line">7.9.7 成员访问修饰符小结 140</span><br><span class="line">7.10 抽象成员 141</span><br><span class="line">7.11 抽象类 142</span><br><span class="line">7.11.1 抽象类和抽象方法的示例 142</span><br><span class="line">7.11.2 抽象类的另一个例子 143</span><br><span class="line">7.12 密封类 144</span><br><span class="line">7.13 静态类 144</span><br><span class="line">7.14 扩展方法 145</span><br><span class="line">7.15 命名约定 148</span><br><span class="line">第8章 表达式和运算符 150</span><br><span class="line">8.1 表达式 150</span><br><span class="line">8.2 字面量 151</span><br><span class="line">8.2.1 整数字面量 152</span><br><span class="line">8.2.2 实数字面量 153</span><br><span class="line">8.2.3 字符字面量 153</span><br><span class="line">8.2.4 字符串字面量 154</span><br><span class="line">8.3 求值顺序 156</span><br><span class="line">8.3.1 优先级 156</span><br><span class="line">8.3.2 结合性 157</span><br><span class="line">8.4 简单算术运算符 157</span><br><span class="line">8.5 求余运算符 158</span><br><span class="line">8.6 关系比较运算符和相等比较运算符 159</span><br><span class="line">8.7 递增运算符和递减运算符 160</span><br><span class="line">8.8 条件逻辑运算符 162</span><br><span class="line">8.9 逻辑运算符 163</span><br><span class="line">8.10 移位运算符 164</span><br><span class="line">8.11 赋值运算符 165</span><br><span class="line">8.12 条件运算符 167</span><br><span class="line">8.13 一元算术运算符 168</span><br><span class="line">8.14 用户定义的类型转换 169</span><br><span class="line">8.15 运算符重载 172</span><br><span class="line">8.15.1 运算符重载的限制 172</span><br><span class="line">8.15.2 运算符重载的示例 173</span><br><span class="line">8.16 typeof运算符 174</span><br><span class="line">8.17 其他运算符 176</span><br><span class="line">第9章 语句 177</span><br><span class="line">9.1 什么是语句 177</span><br><span class="line">9.2 表达式语句 178</span><br><span class="line">9.3 控制流语句 179</span><br><span class="line">9.4 if语句 179</span><br><span class="line">9.5 if…else语句 180</span><br><span class="line">9.6 while循环 181</span><br><span class="line">9.7 do循环 182</span><br><span class="line">9.8 for循环 183</span><br><span class="line">9.8.1 for语句中变量的作用域 185</span><br><span class="line">9.8.2 初始化和迭代表达式中的多表达式 185</span><br><span class="line">9.9 switch语句 186</span><br><span class="line">9.9.1 分支示例 187</span><br><span class="line">9.9.2 switch语句的补充 188</span><br><span class="line">9.9.3 分支标签 189</span><br><span class="line">9.10 跳转语句 189</span><br><span class="line">9.11 break语句 190</span><br><span class="line">9.12 continue语句 190</span><br><span class="line">9.13 标签语句 191</span><br><span class="line">9.13.1 标签 191</span><br><span class="line">9.13.2 标签语句的作用域 192</span><br><span class="line">9.14 goto语句 192</span><br><span class="line">9.15 using语句 193</span><br><span class="line">9.15.1 资源的包装使用 194</span><br><span class="line">9.15.2 using语句的示例 195</span><br><span class="line">9.15.3 多个资源和嵌套 196</span><br><span class="line">9.15.4 using语句的另一种形式 197</span><br><span class="line">9.16 其他语句 197</span><br><span class="line">第10章 结构 198</span><br><span class="line">10.1 什么是结构 198</span><br><span class="line">10.2 结构是值类型 199</span><br><span class="line">10.3 对结构赋值 200</span><br><span class="line">10.4 构造函数和析构函数 201</span><br><span class="line">10.4.1 实例构造函数 201</span><br><span class="line">10.4.2 静态构造函数 202</span><br><span class="line">10.4.3 构造函数和析构函数小结 203</span><br><span class="line">10.5 字段初始化语句是不允许的 203</span><br><span class="line">10.6 结构是密封的 203</span><br><span class="line">10.7 装箱和拆箱 203</span><br><span class="line">10.8 结构作为返回值和参数 204</span><br><span class="line">10.9 关于结构的其他信息 204</span><br><span class="line">第11章 枚举 205</span><br><span class="line">11.1 枚举 205</span><br><span class="line">11.1.1 设置底层类型和显式值 206</span><br><span class="line">11.1.2 隐式成员编号 207</span><br><span class="line">11.2 位标志 208</span><br><span class="line">11.2.1 Flags特性 210</span><br><span class="line">11.2.2 使用位标志的示例 212</span><br><span class="line">11.3 关于枚举的补充 213</span><br><span class="line">第12章 数组 216</span><br><span class="line">12.1 数组 216</span><br><span class="line">12.1.1 定义 216</span><br><span class="line">12.1.2 重要细节 217</span><br><span class="line">12.2 数组的类型 217</span><br><span class="line">12.3 数组是对象 218</span><br><span class="line">12.4 一维数组和矩形数组 219</span><br><span class="line">12.5 实例化一维数组或矩形数组 220</span><br><span class="line">12.6 访问数组元素 220</span><br><span class="line">12.7 初始化数组 221</span><br><span class="line">12.7.1 显式初始化一维数组 222</span><br><span class="line">12.7.2 显式初始化矩形数组 222</span><br><span class="line">12.7.3 初始化矩形数组的语法点 223</span><br><span class="line">12.7.4 快捷语法 223</span><br><span class="line">12.7.5 隐式类型数组 223</span><br><span class="line">12.7.6 综合内容 224</span><br><span class="line">12.8 交错数组 224</span><br><span class="line">12.8.1 声明交错数组 225</span><br><span class="line">12.8.2 快捷实例化 225</span><br><span class="line">12.8.3 实例化交错数组 226</span><br><span class="line">12.8.4 交错数组中的子数组 227</span><br><span class="line">12.9 比较矩形数组和交错数组 228</span><br><span class="line">12.10 foreach语句 229</span><br><span class="line">12.10.1 迭代变量是只读的 230</span><br><span class="line">12.10.2 foreach语句和多维数组 231</span><br><span class="line">12.11 数组协变 232</span><br><span class="line">12.12 数组继承的有用成员 233</span><br><span class="line">12.13 比较数组类型 236</span><br><span class="line">第13章 委托 237</span><br><span class="line">13.1 什么是委托 237</span><br><span class="line">13.2 委托概述 239</span><br><span class="line">13.3 声明委托类型 240</span><br><span class="line">13.4 创建委托对象 241</span><br><span class="line">13.5 给委托赋值 242</span><br><span class="line">13.6 组合委托 243</span><br><span class="line">13.7 为委托添加方法 243</span><br><span class="line">13.8 从委托移除方法 244</span><br><span class="line">13.9 调用委托 244</span><br><span class="line">13.10 委托的示例 245</span><br><span class="line">13.11 调用带返回值的委托 246</span><br><span class="line">13.12 调用带引用参数的委托 247</span><br><span class="line">13.13 匿名方法 248</span><br><span class="line">13.13.1 使用匿名方法 249</span><br><span class="line">13.13.2 匿名方法的语法 249</span><br><span class="line">13.13.3 变量和参数的作用域 250</span><br><span class="line">13.14 Lambda表达式 252</span><br><span class="line">第14章 事件 255</span><br><span class="line">14.1 发布者和订阅者 255</span><br><span class="line">14.2 源代码组件概览 257</span><br><span class="line">14.3 声明事件 257</span><br><span class="line">14.4 订阅事件 258</span><br><span class="line">14.5 触发事件 259</span><br><span class="line">14.6 标准事件的用法 261</span><br><span class="line">14.6.1 通过扩展EventArgs来传递数据 262</span><br><span class="line">14.6.2 移除事件处理程序 264</span><br><span class="line">14.7 事件访问器 265</span><br><span class="line">第15章 接口 267</span><br><span class="line">15.1 什么是接口 267</span><br><span class="line">15.2 声明接口 272</span><br><span class="line">15.3 实现接口 273</span><br><span class="line">15.4 接口是引用类型 275</span><br><span class="line">15.5 接口和as运算符 276</span><br><span class="line">15.6 实现多个接口 276</span><br><span class="line">15.7 实现具有重复成员的接口 277</span><br><span class="line">15.8 多个接口的引用 279</span><br><span class="line">15.9 派生成员作为实现 280</span><br><span class="line">15.10 显式接口成员实现 281</span><br><span class="line">15.11 接口可以继承接口 283</span><br><span class="line">15.12 不同类实现一个接口的示例 284</span><br><span class="line">第16章 转换 286</span><br><span class="line">16.1 什么是转换 286</span><br><span class="line">16.2 隐式转换 287</span><br><span class="line">16.3 显式转换和强制转换 288</span><br><span class="line">16.4 转换的类型 289</span><br><span class="line">16.5 数字的转换 290</span><br><span class="line">16.5.1 隐式数字转换 290</span><br><span class="line">16.5.2 溢出检测上下文 291</span><br><span class="line">16.5.3 显式数字转换 292</span><br><span class="line">16.6 引用转换 295</span><br><span class="line">16.6.1 隐式引用转换 296</span><br><span class="line">16.6.2 显式引用转换 297</span><br><span class="line">16.6.3 有效显式引用转换 298</span><br><span class="line">16.7 装箱转换 299</span><br><span class="line">16.7.1 装箱是创建副本 300</span><br><span class="line">16.7.2 装箱转换 300</span><br><span class="line">16.8 拆箱转换 301</span><br><span class="line">16.9 用户自定义转换 302</span><br><span class="line">16.9.1 用户自定义转换的约束 302</span><br><span class="line">16.9.2 用户自定义转换的示例 302</span><br><span class="line">16.9.3 评估用户自定义转换 304</span><br><span class="line">16.9.4 多步用户自定义转换的示例 304</span><br><span class="line">16.10 is运算符 305</span><br><span class="line">16.11 as运算符 30</span><br><span class="line">第17章 泛型 308</span><br><span class="line">17.1 什么是泛型 308</span><br><span class="line">17.2 C#中的泛型 310</span><br><span class="line">17.3 泛型类 311</span><br><span class="line">17.4 声明泛型类 312</span><br><span class="line">17.5 创建构造类型 312</span><br><span class="line">17.6 创建变量和实例 313</span><br><span class="line">17.6.1 使用泛型的栈的示例 315</span><br><span class="line">17.6.2 比较泛型和非泛型栈 316</span><br><span class="line">17.7 类型参数的约束 317</span><br><span class="line">17.7.1 Where子句 317</span><br><span class="line">17.7.2 约束类型和次序 318</span><br><span class="line">17.8 泛型方法 319</span><br><span class="line">17.8.1 声明泛型方法 319</span><br><span class="line">17.8.2 调用泛型方法 320</span><br><span class="line">17.8.3 泛型方法的示例 321</span><br><span class="line">17.9 扩展方法和泛型类 322</span><br><span class="line">17.10 泛型结构 323</span><br><span class="line">17.11 泛型委托 323</span><br><span class="line">17.12 泛型接口 325</span><br><span class="line">17.12.1 使用泛型接口的示例 326</span><br><span class="line">17.12.2 泛型接口的实现必须唯一 327</span><br><span class="line">17.13 协变 328</span><br><span class="line">17.14 逆变 330</span><br><span class="line">17.14.1 接口的协变和逆变 332</span><br><span class="line">17.14.2 有关可变性的更多内容 333</span><br><span class="line">第18章 枚举器和迭代器 335</span><br><span class="line">18.1 枚举器和可枚举类型 335</span><br><span class="line">18.2 IEnumerator接口 337</span><br><span class="line">18.3 泛型枚举接口 341</span><br><span class="line">18.4 迭代器 343</span><br><span class="line">18.4.1 迭代器块 343</span><br><span class="line">18.4.2 使用迭代器来创建枚举器 344</span><br><span class="line">18.4.3 使用迭代器来创建可枚举类型 346</span><br><span class="line">18.5 常见迭代器模式 347</span><br><span class="line">18.6 产生多个可枚举类型 348</span><br><span class="line">18.7 将迭代器作为属性 349</span><br><span class="line">18.8 迭代器实质 350</span><br><span class="line">第19章 LINQ 352</span><br><span class="line">19.1 什么是LINQ 352</span><br><span class="line">19.2 LINQ提供程序 353</span><br><span class="line">19.3 方法语法和查询语法 355</span><br><span class="line">19.4 查询变量 356</span><br><span class="line">19.5 查询表达式的结构 357</span><br><span class="line">19.5.1 from子句 358</span><br><span class="line">19.5.2 join子句 359</span><br><span class="line">19.5.3 什么是联结 360</span><br><span class="line">19.5.4 查询主体中的from let where片段 362</span><br><span class="line">19.5.5 orderby子句 365</span><br><span class="line">19.5.6 select group子句 366</span><br><span class="line">19.5.7 查询中的匿名类型 367</span><br><span class="line">19.5.8 group子句 368</span><br><span class="line">19.5.9 查询延续：into子句 369</span><br><span class="line">19.6 标准查询运算符 370</span><br><span class="line">19.6.1 标准查询运算符的签名 373</span><br><span class="line">19.6.2 查询表达式和标准查询运算符 374</span><br><span class="line">19.6.3 将委托作为参数 375</span><br><span class="line">19.6.4 LINQ预定义的委托类型 376</span><br><span class="line">19.6.5 使用委托参数的示例 377</span><br><span class="line">19.6.6 使用Lambda表达式参数的示例 378</span><br><span class="line">19.7 LINQtoXML 379</span><br><span class="line">19.7.1 标记语言 379</span><br><span class="line">19.7.2 XML基础 379</span><br><span class="line">19.7.3 XML类 381</span><br><span class="line">19.7.4 使用XML特性 387</span><br><span class="line">19.7.5 节点的其他类型 389</span><br><span class="line">19.7.6 使用LINQtoXML的LINQ查询 390</span><br><span class="line">第20章 异步编程 393</span><br><span class="line">20.1 什么是异步 393</span><br><span class="line">20.2 async&#x2F;await特性的结构 398</span><br><span class="line">20.3 什么是异步方法 399</span><br><span class="line">20.3.1 异步方法的控制流 402</span><br><span class="line">20.3.2 await表达式 404</span><br><span class="line">20.3.3 取消一个异步操作 407</span><br><span class="line">20.3.4 异常处理和await表达式 409</span><br><span class="line">20.3.5 在调用方法中同步地等待任务 410</span><br><span class="line">20.3.6 在异步方法中异步地等待任务 413</span><br><span class="line">20.3.7 Task.Delay方法 415</span><br><span class="line">20.4 在GUI程序中执行异步操作 416</span><br><span class="line">20.5 使用异步Lambda表达式 420</span><br><span class="line">20.6 完整的GUI程序 421</span><br><span class="line">20.7 BackgroundWorker类 423</span><br><span class="line">20.8 并行循环 428</span><br><span class="line">20.9 其他异步编程模式 430</span><br><span class="line">20.10 Begin Invoke和End Invoke 431</span><br><span class="line">20.10.1 等待—直到结束模式 432</span><br><span class="line">20.10.2 Async Result类 433</span><br><span class="line">20.10.3 轮询模式 434</span><br><span class="line">20.10.4 回调模式 435</span><br><span class="line">20.11 计时器 438</span><br><span class="line">第21章 命名空间和程序集 440</span><br><span class="line">21.1 引用其他程序集 440</span><br><span class="line">21.2 命名空间 444</span><br><span class="line">21.2.1 命名空间名称 447</span><br><span class="line">21.2.2 命名空间的补充 447</span><br><span class="line">21.2.3 命名空间跨文件伸展 448</span><br><span class="line">21.2.4 嵌套命名空间 449</span><br><span class="line">21.3 using指令 450</span><br><span class="line">21.3.1 using命名空间指令 450</span><br><span class="line">21.3.2 using别名指令 451</span><br><span class="line">21.4 程序集的结构 451</span><br><span class="line">21.5 程序集标识符 453</span><br><span class="line">21.6 强命名程序集 453</span><br><span class="line">21.7 程序集的私有方式部署 455</span><br><span class="line">21.8 共享程序集和GAC 455</span><br><span class="line">21.8.1 把程序集安装到GAC 455</span><br><span class="line">21.8.2 GAC内的并肩执行 456</span><br><span class="line">21.9 配置文件 457</span><br><span class="line">21.10 延迟签名 457</span><br><span class="line">第22章 异常 459</span><br><span class="line">22.1 什么是异常 459</span><br><span class="line">22.2 try语句 460</span><br><span class="line">22.3 异常类 461</span><br><span class="line">22.4 catch子句 462</span><br><span class="line">22.5 使用特定catch子句的示例 462</span><br><span class="line">22.6 catch子句段 463</span><br><span class="line">22.7 finally块 464</span><br><span class="line">22.8 为异常寻找处理程序 465</span><br><span class="line">22.9 更进一步搜索 466</span><br><span class="line">22.9.1 一般法则 466</span><br><span class="line">22.9.2 搜索调用栈的示例 467</span><br><span class="line">22.10 抛出异常 469</span><br><span class="line">22.11 不带异常对象的抛出 470</span><br><span class="line">第23章 预处理指令 472</span><br><span class="line">23.1 什么是预处理指令 472</span><br><span class="line">23.2 基本规则 472</span><br><span class="line">23.3 #define和#undef指令 473</span><br><span class="line">23.4 条件编译 474</span><br><span class="line">23.5 条件编译结构 475</span><br><span class="line">23.6 诊断指令 476</span><br><span class="line">23.7 行号指令 477</span><br><span class="line">23.8 区域指令 478</span><br><span class="line">23.9 #pragmawarning指令 479</span><br><span class="line">第24章 反射和特性 480</span><br><span class="line">24.1 元数据和反射 480</span><br><span class="line">24.2 Type类 480</span><br><span class="line">24.3 获取Type对象 482</span><br><span class="line">24.4 什么是特性 484</span><br><span class="line">24.5 应用特性 485</span><br><span class="line">24.6 预定义的保留的特性 485</span><br><span class="line">24.6.1 Obsolete特性 485</span><br><span class="line">24.6.2 Conditional特性 486</span><br><span class="line">24.6.3 调用者信息特性 488</span><br><span class="line">24.6.4 Debugger StepThrough特性 488</span><br><span class="line">24.6.5 其他预定义特性 489</span><br><span class="line">24.7 有关应用特性的更多内容 490</span><br><span class="line">24.7.1 多个特性 490</span><br><span class="line">24.7.2 其他类型的目标 490</span><br><span class="line">24.7.3 全局特性 491</span><br><span class="line">24.8 自定义特性 491</span><br><span class="line">24.8.1 声明自定义特性 492</span><br><span class="line">24.8.2 使用特性的构造函数 492</span><br><span class="line">24.8.3 指定构造函数 492</span><br><span class="line">24.8.4 使用构造函数 493</span><br><span class="line">24.8.5 构造函数中的位置参数和命名参数 493</span><br><span class="line">24.8.6 限制特性的使用 494</span><br><span class="line">24.8.7 自定义特性的最佳实践 495</span><br><span class="line">24.9 访问特性 496</span><br><span class="line">24.9.1 使用Is Defined方法 496</span><br><span class="line">24.9.2 使用Get Custom Attributes方法 497</span><br><span class="line">第25章 其他主题 499</span><br><span class="line">25.1 概述 499</span><br><span class="line">25.2 字符串 499</span><br><span class="line">25.3 使用String Builder类 501</span><br><span class="line">25.4 把字符串解析为数据值 502</span><br><span class="line">25.5 关于可空类型的更多内容 503</span><br><span class="line">25.5.1 为可空类型赋值 505</span><br><span class="line">25.5.2 使用空接合运算符 505</span><br><span class="line">25.5.3 使用可空用户自定义类型 506</span><br><span class="line">25.6 Main方法 508</span><br><span class="line">25.7 文档注释 509</span><br><span class="line">25.7.1 插入文档注释 510</span><br><span class="line">25.7.2 使用其他XML标签 510</span><br><span class="line">25.8 嵌套类型 511</span><br><span class="line">25.8.1 嵌套类的示例 512</span><br><span class="line">25.8.2 可见性和嵌套类型 513</span><br><span class="line">25.9 析构函数和dispose模式 514</span><br><span class="line">25.9.1 标准dispose模式 515</span><br><span class="line">25.9.2 比较构造函数和析构函数 517</span><br><span class="line">25.10 和COM的互操作 518</span><br><span class="line">索引 521</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00DMS8OKA/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00DMS8OKA&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51d0RxPDdrL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>WPF编程宝典 使用C#2012和.NET 4.5(第4版)</title>
    <url>/2020/04/19/B00EQWESA6/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： WPF编程宝典 使用C#2012和.NET 4.5(第4版)<br>作者信息： 作者: 麦克唐纳 (Matthew MacDonald) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>WPF权威著作，内容更新至C# 2012和.NET 4.5</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第Ⅰ部分基础知识</span><br><span class="line">第1章WPF概述</span><br><span class="line">1.1Windows图形演化</span><br><span class="line">1.1.1DirectX：新的图形引擎</span><br><span class="line">1.1.2硬件加速与WPF</span><br><span class="line">1.2WPF：高级API</span><br><span class="line">1.3分辨率无关性</span><br><span class="line">1.3.1WPF单位</span><br><span class="line">1.3.2系统DPI</span><br><span class="line">1.3.3位图和矢量图形</span><br><span class="line">1.4WPF体系结构</span><br><span class="line">1.5WPF4.5</span><br><span class="line">1.5.1WPF工具包</span><br><span class="line">1.5.2VisualStudio2012</span><br><span class="line">1.6小结16</span><br><span class="line">第2章XAML</span><br><span class="line">2.1理解XAML</span><br><span class="line">2.1.1WPF之前的图形用户界面</span><br><span class="line">2.1.2XAML变体</span><br><span class="line">2.1.3XAML编译</span><br><span class="line">2.2XAML基础</span><br><span class="line">2.2.1XAML名称空间</span><br><span class="line">2.2.2代码隐藏类</span><br><span class="line">2.3XAML中的属性和事件</span><br><span class="line">2.3.1简单属性与类型转换器</span><br><span class="line">2.3.2复杂属性</span><br><span class="line">2.3.3标记扩展</span><br><span class="line">2.3.4附加属性</span><br><span class="line">2.3.5嵌套元素</span><br><span class="line">2.3.6特殊字符与空白</span><br><span class="line">2.3.7事件</span><br><span class="line">2.3.8完整的EightBallAnswer示例</span><br><span class="line">2.4使用其他名称空间中的类型</span><br><span class="line">2.5加载和编译XAML</span><br><span class="line">2.5.1只使用代码</span><br><span class="line">2.5.2使用代码和未经编译的XAML</span><br><span class="line">2.5.3使用代码和编译过的XAML</span><br><span class="line">2.5.4只使用XAML</span><br><span class="line">2.6小结</span><br><span class="line">第3章布局</span><br><span class="line">3.1理解WPF中的布局</span><br><span class="line">3.1.1WPF布局原则</span><br><span class="line">3.1.2布局过程</span><br><span class="line">3.1.3布局容器</span><br><span class="line">3.2使用StackPanel面板进行简单布局</span><br><span class="line">3.2.1布局属性</span><br><span class="line">3.2.2对齐方式</span><br><span class="line">3.2.3边距</span><br><span class="line">3.2.4最小尺寸、最大尺寸以及显式地设置尺寸</span><br><span class="line">3.2.5Border控件</span><br><span class="line">3.3WrapPanel和DockPanel面板</span><br><span class="line">3.3.1WrapPanel面板</span><br><span class="line">3.3.2DockPanel面板</span><br><span class="line">3.3.3嵌套布局容器</span><br><span class="line">3.4Grid面板</span><br><span class="line">3.4.1调整行和列</span><br><span class="line">3.4.2布局舍入</span><br><span class="line">3.4.3跨越行和列</span><br><span class="line">3.4.4分割窗口</span><br><span class="line">3.4.5共享尺寸组</span><br><span class="line">3.4.6UniformGrid面板</span><br><span class="line">3.5使用Canvas面板进行基于坐标的布局</span><br><span class="line">3.5.1Z顺序</span><br><span class="line">3.5.2lnkCanvas元素</span><br><span class="line">3.6布局示例</span><br><span class="line">3.6.1列设置</span><br><span class="line">3.6.2动态内容</span><br><span class="line">3.6.3组合式用户界面</span><br><span class="line">3.7小结</span><br><span class="line">第4章依赖项属性</span><br><span class="line">4.1理解依赖项属性</span><br><span class="line">4.1.1定义依赖项属性</span><br><span class="line">4.1.2注册依赖项属性</span><br><span class="line">4.1.3添加属性包装器</span><br><span class="line">4.1.4WPF使用依赖项属性的方式</span><br><span class="line">4.1.5共享的依赖项属性</span><br><span class="line">4.1.6附加的依赖项属性</span><br><span class="line">4.2属性验证</span><br><span class="line">4.2.1验证回调</span><br><span class="line">4.2.2强制回调</span><br><span class="line">4.3小结</span><br><span class="line">第5章路由事件</span><br><span class="line">5.1理解路由事件</span><br><span class="line">5.1.1定义、注册和封装路由事件</span><br><span class="line">5.1.2共享路由事件</span><br><span class="line">5.1.3引发路由事件</span><br><span class="line">5.1.4处理路由事件</span><br><span class="line">5.2事件路由</span><br><span class="line">5.2.1RoutedEventArgs类</span><br><span class="line">5.2.2冒泡路由事件</span><br><span class="line">5.2.3处理挂起的事件</span><br><span class="line">5.2.4附加事件</span><br><span class="line">5.2.5隧道路由事件</span><br><span class="line">5.3WPF事件</span><br><span class="line">5.3.1生命周期事件</span><br><span class="line">5.3.2输入事件</span><br><span class="line">5.4键盘输入</span><br><span class="line">5.4.1处理按键事件</span><br><span class="line">5.4.2焦点</span><br><span class="line">5.4.3获取键盘状态</span><br><span class="line">5.5鼠标输入</span><br><span class="line">5.5.1鼠标单击</span><br><span class="line">5.5.2捕获鼠标</span><br><span class="line">5.5.3鼠标拖放</span><br><span class="line">5.6多点触控输入</span><br><span class="line">5.6.1多点触控的输入层次</span><br><span class="line">5.6.2原始触控</span><br><span class="line">5.6.3操作</span><br><span class="line">5.6.4惯性</span><br><span class="line">5.7小结</span><br><span class="line">第Ⅱ部分进一步研究WPF</span><br><span class="line">第6章控件</span><br><span class="line">6.1控件类</span><br><span class="line">6.1.1背景画刷和前景画刷</span><br><span class="line">6.1.2字体</span><br><span class="line">6.1.3鼠标光标</span><br><span class="line">6.2内容控件</span><br><span class="line">6.2.1Content属性</span><br><span class="line">6.2.2对齐内容</span><br><span class="line">6.2.3WPF内容原则</span><br><span class="line">6.2.4标签</span><br><span class="line">6.2.5按钮</span><br><span class="line">6.2.6工具提示</span><br><span class="line">6.3特殊容器</span><br><span class="line">6.3.1ScrollViewer</span><br><span class="line">6.3.2GroupBox</span><br><span class="line">6.3.3TabItem</span><br><span class="line">6.3.4Expander</span><br><span class="line">6.4文本控件</span><br><span class="line">6.4.1多行文本</span><br><span class="line">6.4.2选择文本</span><br><span class="line">6.4.3拼写检查</span><br><span class="line">6.4.4PasswordBox</span><br><span class="line">6.5列表控件</span><br><span class="line">6.5.1ListBox</span><br><span class="line">6.5.2ComboBox</span><br><span class="line">6.6基于范围的控件</span><br><span class="line">6.6.1Slider</span><br><span class="line">6.6.2ProgressBar</span><br><span class="line">6.7日期控件</span><br><span class="line">6.8小结</span><br><span class="line">第7章Application类</span><br><span class="line">7.1应用程序的生命周期</span><br><span class="line">7.1.1创建Application对象</span><br><span class="line">7.1.2派生自定义的Application类</span><br><span class="line">7.1.3应用程序的关闭方式</span><br><span class="line">7.1.4应用程序事件</span><br><span class="line">7.2Application类的任务</span><br><span class="line">7.2.1显示初始界面</span><br><span class="line">7.2.2处理命令行参数</span><br><span class="line">7.2.3访问当前Application对象</span><br><span class="line">7.2.4在窗口之间进行交互</span><br><span class="line">7.2.5单实例应用程序</span><br><span class="line">7.3程序集资源</span><br><span class="line">7.3.1添加资源</span><br><span class="line">7.3.2检索资源</span><br><span class="line">7.3.3packURI</span><br><span class="line">7.3.4内容文件</span><br><span class="line">7.4本地化</span><br><span class="line">7.4.1构建能够本地化的用户界面</span><br><span class="line">7.4.2使应用程序为本地化做好准备</span><br><span class="line">7.4.3管理翻译过程</span><br><span class="line">7.5小结</span><br><span class="line">第8章元素绑定</span><br><span class="line">8.1将元素绑定到一起</span><br><span class="line">8.1.1绑定表达式</span><br><span class="line">8.1.2绑定错误</span><br><span class="line">8.1.3绑定模式</span><br><span class="line">8.1.4使用代码创建绑定</span><br><span class="line">8.1.5使用代码检索绑定</span><br><span class="line">8.1.6多绑定</span><br><span class="line">8.1.7绑定更新</span><br><span class="line">8.1.8绑定延迟</span><br><span class="line">8.2绑定到非元素对象</span><br><span class="line">8.2.1Source属性</span><br><span class="line">8.2.2RelativeSource属性</span><br><span class="line">8.2.3DataContext属性</span><br><span class="line">8.3小结</span><br><span class="line">第9章命令</span><br><span class="line">9.1理解命令</span><br><span class="line">9.2WPF命令模型</span><br><span class="line">9.2.1ICommand接口</span><br><span class="line">9.2.2RoutedCommand类</span><br><span class="line">9.2.3RoutedUICommand类</span><br><span class="line">9.2.4命令库</span><br><span class="line">9.3执行命令</span><br><span class="line">9.3.1命令源</span><br><span class="line">9.3.2命令绑定</span><br><span class="line">9.3.3使用多命令源</span><br><span class="line">9.3.4微调命令文本</span><br><span class="line">9.3.5直接调用命令</span><br><span class="line">9.3.6禁用命令</span><br><span class="line">9.3.7具有内置命令的控件</span><br><span class="line">9.4高级命令</span><br><span class="line">9.4.1自定义命令</span><br><span class="line">9.4.2在不同位置使用相同的命令</span><br><span class="line">9.4.3使用命令参数</span><br><span class="line">9.4.4跟踪和翻转命令</span><br><span class="line">9.5小结</span><br><span class="line">第10章资源</span><br><span class="line">10.1资源基础</span><br><span class="line">10.1.1资源集合</span><br><span class="line">10.1.2资源的层次</span><br><span class="line">10.1.3静态资源和动态资源</span><br><span class="line">10.1.4非共享资源</span><br><span class="line">10.1.5通过代码访问资源</span><br><span class="line">10.1.6应用程序资源</span><br><span class="line">10.1.7系统资源</span><br><span class="line">10.2资源字典</span><br><span class="line">10.2.1创建资源字典</span><br><span class="line">10.2.2使用资源字典</span><br><span class="line">10.2.3在程序集之间共享资源</span><br><span class="line">10.3小结</span><br><span class="line">第11章样式和行为</span><br><span class="line">11.1样式基础</span><br><span class="line">11.1.1创建样式对象</span><br><span class="line">11.1.2设置属性</span><br><span class="line">11.1.3关联事件处理程序</span><br><span class="line">11.1.4多层样式</span><br><span class="line">11.1.5通过类型自动应用样式</span><br><span class="line">11.2触发器</span><br><span class="line">11.2.1简单触发器</span><br><span class="line">11.2.2事件触发器</span><br><span class="line">11.3行为</span><br><span class="line">11.3.1获取行为支持</span><br><span class="line">11.3.2理解行为模型</span><br><span class="line">11.3.3创建行为</span><br><span class="line">11.3.4使用行为</span><br><span class="line">11.3.5Blend中的设计时行为支持</span><br><span class="line">11.4小结</span><br><span class="line">第Ⅲ部分图画和动画</span><br><span class="line">第12章形状、画刷和变换</span><br><span class="line">12.1理解形状</span><br><span class="line">12.1.1Shape类</span><br><span class="line">12.1.2矩形和椭圆</span><br><span class="line">12.1.3改变形状的尺寸和放置形状</span><br><span class="line">12.1.4使用Viewbox控件缩放形状</span><br><span class="line">12.1.5直线</span><br><span class="line">12.1.6折线</span><br><span class="line">12.1.7多边形</span><br><span class="line">12.1.8直线线帽和直线交点</span><br><span class="line">12.1.9点划线</span><br><span class="line">12.1.10像素对齐</span><br><span class="line">12.2画刷289</span><br><span class="line">12.2.1SolidColorBrush画刷</span><br><span class="line">12.2.2LinearGradientBrush画刷</span><br><span class="line">12.2.3RadialGradientBrush画刷</span><br><span class="line">12.2.4ImageBrush画刷</span><br><span class="line">12.2.5平铺的ImageBrush画刷</span><br><span class="line">12.2.6VisualBrush画刷</span><br><span class="line">12.2.7BitmapCacheBrush画刷</span><br><span class="line">12.3变换</span><br><span class="line">12.3.1变换形状</span><br><span class="line">12.3.2变换元素</span><br><span class="line">12.4透明</span><br><span class="line">12.4.1使元素半透明</span><br><span class="line">12.4.2透明掩码</span><br><span class="line">12.5小结</span><br><span class="line">第13章几何图形和图画</span><br><span class="line">13.1路径和几何图形</span><br><span class="line">13.1.1直线、矩形和椭圆图形</span><br><span class="line">13.1.2使用GeometryGroup组合形状309</span><br><span class="line">13.1.3使用CombinedGeometry融合几何图形</span><br><span class="line">13.1.4使用PathGeometry绘制曲线和直线</span><br><span class="line">13.1.5微语言几何图形</span><br><span class="line">13.1.6使用几何图形进行剪裁</span><br><span class="line">13.2图画</span><br><span class="line">13.2.1显示图画</span><br><span class="line">13.2.2导出插图</span><br><span class="line">13.3小结</span><br><span class="line">第14章效果和可视化对象</span><br><span class="line">14.1可视化对象</span><br><span class="line">14.1.1绘制可视化对象</span><br><span class="line">14.1.2在元素中封装可视化对象</span><br><span class="line">14.1.3命中测试</span><br><span class="line">14.1.4复杂的命中测试</span><br><span class="line">14.2效果</span><br><span class="line">14.2.1BlurEffect类</span><br><span class="line">14.2.2DropShadowEffect类</span><br><span class="line">14.2.3ShaderEffect类</span><br><span class="line">14.3WriteableBitmap类</span><br><span class="line">14.3.1生成位图</span><br><span class="line">14.3.2写入WriteableBitmap对象</span><br><span class="line">14.3.3更高效的像素写入</span><br><span class="line">14.4小结</span><br><span class="line">第15章动画基础</span><br><span class="line">15.1理解WPF动画</span><br><span class="line">15.1.1基于时间的动画</span><br><span class="line">15.1.2基于属性的动画</span><br><span class="line">15.2基本动画</span><br><span class="line">15.2.1Animation类</span><br><span class="line">15.2.2使用代码创建动画</span><br><span class="line">15.2.3同时发生的动画</span><br><span class="line">15.2.4动画的生命周期</span><br><span class="line">15.2.5Timeline类</span><br><span class="line">15.3故事板</span><br><span class="line">15.3.1故事板</span><br><span class="line">15.3.2事件触发器</span><br><span class="line">15.3.3重叠动画</span><br><span class="line">15.3.4同步的动画</span><br><span class="line">15.3.5控制播放</span><br><span class="line">15.3.6监视动画进度</span><br><span class="line">15.4动画缓动</span><br><span class="line">15.4.1使用缓动函数</span><br><span class="line">15.4.2在动画开始时应用缓动与在动画结束时应用缓动</span><br><span class="line">15.4.3缓动函数类</span><br><span class="line">15.4.4创建自定义缓动函数</span><br><span class="line">15.5动画性能</span><br><span class="line">15.5.1期望的帧率</span><br><span class="line">15.5.2位图缓存</span><br><span class="line">15.6小结</span><br><span class="line">第16章高级动画</span><br><span class="line">16.1动画类型回顾</span><br><span class="line">16.1.1动态变换</span><br><span class="line">16.1.2动态改变画刷</span><br><span class="line">16.1.3动态改变像素着色器</span><br><span class="line">16.2关键帧动画</span><br><span class="line">16.2.1离散的关键帧动画</span><br><span class="line">16.2.2缓动关键帧</span><br><span class="line">16.2.3样条关键帧动画</span><br><span class="line">16.3基于路径的动画</span><br><span class="line">16.4基于帧的动画</span><br><span class="line">16.5使用代码创建故事板</span><br><span class="line">16.5.1创建主窗口</span><br><span class="line">16.5.2创建Bomb用户控件</span><br><span class="line">16.5.3投弹</span><br><span class="line">16.5.4拦截炸弹</span><br><span class="line">16.5.5统计炸弹和清理工作</span><br><span class="line">16.6小结</span><br><span class="line">第Ⅳ部分模板和自定义元素</span><br><span class="line">第Ⅴ部分数据</span><br><span class="line">第Ⅵ窗口、页面和富控件</span><br><span class="line">第Ⅶ部分文档和打印</span><br><span class="line">第28章文档793</span><br><span class="line">第Ⅷ部分其他主题</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00EQWESA6/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00EQWESA6&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51veuHC%2B5xL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer(中文版)(第5版)</title>
    <url>/2020/04/19/B00ESUIL0O/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C++ Primer(中文版)(第5版)<br>作者信息： 作者: 斯坦利·李普曼 (Stanley B. Lippman) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《C++ Primer(中文版)(第5版)》编辑推荐：一书在手，架构无忧；三十位一线架构师真知实践；百位顶级架构师献计献策；十万文字尽显架构精华。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 开始</span><br><span class="line">1.1 编写一个简单的C++程序</span><br><span class="line">1.1.1 编译、运行程序</span><br><span class="line">1.2 初识输入输出</span><br><span class="line">1.3 注释简介</span><br><span class="line">1.4 控制流</span><br><span class="line">1.4.1 while语句</span><br><span class="line">1.4.2 for语句</span><br><span class="line">1.4.3 读取数量不定的输入数据</span><br><span class="line">1.4.4 if语句</span><br><span class="line">1.5 类简介</span><br><span class="line">1.5.1 Sales_item类</span><br><span class="line">1.5.2 初识成员函数</span><br><span class="line">1.6 书店程序</span><br><span class="line">小结</span><br><span class="line">术语表</span><br><span class="line">第Ⅰ部分 C++基础</span><br><span class="line">第2章 变量和基本类型</span><br><span class="line">2.1 基本内置类型</span><br><span class="line">2.1.1 算术类型</span><br><span class="line">2.1.2 类型转换</span><br><span class="line">2.1.3 字面值常量</span><br><span class="line">2.2 变量</span><br><span class="line">2.2.1 变量定义</span><br><span class="line">2.2.2 变量声明和定义的关系</span><br><span class="line">2.2.3 标识符</span><br><span class="line">2.2.4 名字的作用域</span><br><span class="line">2.3 复合类型</span><br><span class="line">2.3.1 引用</span><br><span class="line">2.3.2 指针</span><br><span class="line">2.3.3 理解复合类型的声明</span><br><span class="line">2.4 const限定符</span><br><span class="line">2.4.1 const的引用</span><br><span class="line">2.4.2 指针和const</span><br><span class="line">2.4.3 顶层const</span><br><span class="line">2.4.4 constexpr和常量表达式</span><br><span class="line">2.5 处理类型</span><br><span class="line">2.5.1 类型别名</span><br><span class="line">2.5.2 auto类型说明符</span><br><span class="line">2.5.3 decltype类型指示符</span><br><span class="line">2.6 自定义数据结构</span><br><span class="line">2.6.1 定义Sales_data类型</span><br><span class="line">2.6.2 使用Sales_data类</span><br><span class="line">2.6.3 编写自己的头文件</span><br><span class="line">小结</span><br><span class="line">术语表</span><br><span class="line">第3章 字符串、向量和数组</span><br><span class="line">3.1 命名空间的using声明</span><br><span class="line">3.2 标准库类型string</span><br><span class="line">3.2.1 定义和初始化string对象</span><br><span class="line">3.2.2 string对象上的操作</span><br><span class="line">3.2.3 处理string对象中的字符</span><br><span class="line">3.3 标准库类型vector</span><br><span class="line">3.3.1 定义和初始化vector对象</span><br><span class="line">3.3.2 向vector对象中添加元素</span><br><span class="line">3.3.3 其他vector操作</span><br><span class="line">3.4 迭代器介绍</span><br><span class="line">3.4.1 使用迭代器</span><br><span class="line">3.4.2 迭代器运算</span><br><span class="line">3.5 数组</span><br><span class="line">3.5.1 定义和初始化内置数组</span><br><span class="line">3.5.2 访问数组元素</span><br><span class="line">3.5.3 指针和数组</span><br><span class="line">3.5.4 C风格字符串</span><br><span class="line">3.5.5 与旧代码的接口</span><br><span class="line">3.6 多维数组</span><br><span class="line">小结</span><br><span class="line">术语表</span><br><span class="line">第4章 表达式</span><br><span class="line">4.1 基础</span><br><span class="line">4.1.1 基本概念</span><br><span class="line">4.1.2 优先级与结合律</span><br><span class="line">4.1.3 求值顺序</span><br><span class="line">4.2 算术运算符</span><br><span class="line">4.3 逻辑和关系运算符</span><br><span class="line">4.4 赋值运算符</span><br><span class="line">4.5 递增和递减运算符</span><br><span class="line">4.6 成员访问运算符</span><br><span class="line">4.7 条件运算符</span><br><span class="line">4.8 位运算符</span><br><span class="line">4.9 sizeof运算符</span><br><span class="line">4.10 逗号运算符</span><br><span class="line">4.11 类型转换</span><br><span class="line">4.11.1 算术转换</span><br><span class="line">4.11.2 其他隐式类型转换</span><br><span class="line">4.11.3 显式转换</span><br><span class="line">4.12 运算符优先级表</span><br><span class="line">小结</span><br><span class="line">术语表</span><br><span class="line">第5章 语句</span><br><span class="line">5.1 简单语句</span><br><span class="line">5.2 语句作用域</span><br><span class="line">5.3 条件语句</span><br><span class="line">5.3.1 if语句</span><br><span class="line">5.3.2 switch语句</span><br><span class="line">5.4 迭代语句</span><br><span class="line">5.4.1 while语句</span><br><span class="line">5.4.2 传统的for语句</span><br><span class="line">5.4.3 范围for语句</span><br><span class="line">5.4.4 do while语句</span><br><span class="line">5.5 跳转语句</span><br><span class="line">5.5.1 break语句</span><br><span class="line">5.5.2 continue语句</span><br><span class="line">5.5.3 goto语句</span><br><span class="line">5.6 TRY语句块和异常处理</span><br><span class="line">5.6.1 throw表达式</span><br><span class="line">5.6.2 try语句块</span><br><span class="line">5.6.3 标准异常</span><br><span class="line">小结</span><br><span class="line">术语表</span><br><span class="line">第6章 函数</span><br><span class="line">6.1 函数基础</span><br><span class="line">6.1.1 局部对象</span><br><span class="line">6.1.2 函数声明</span><br><span class="line">6.1.3 分离式编译</span><br><span class="line">6.2 参数传递</span><br><span class="line">6.2.1 传值参数</span><br><span class="line">6.2.2 传引用参数</span><br><span class="line">6.2.3 const形参和实参</span><br><span class="line">6.2.4 数组形参</span><br><span class="line">6.2.5 main：处理命令行选项</span><br><span class="line">6.2.6 含有可变形参的函数</span><br><span class="line">6.3 返回类型和return语句</span><br><span class="line">6.3.1 无返回值函数</span><br><span class="line">6.3.2 有返回值函数</span><br><span class="line">6.3.3 返回数组指针</span><br><span class="line">6.4 函数重载</span><br><span class="line">6.4.1 重载与作用域</span><br><span class="line">6.5 特殊用途语言特性</span><br><span class="line">6.5.1 默认实参</span><br><span class="line">6.5.2 内联函数和constexpr函数</span><br><span class="line">6.5.3 调试帮助</span><br><span class="line">6.6 函数匹配</span><br><span class="line">6.6.1 实参类型转换</span><br><span class="line">6.7 函数指针</span><br><span class="line">小结</span><br><span class="line">术语表</span><br><span class="line">第7章 类</span><br><span class="line">7.1 定义抽象数据类型</span><br><span class="line">7.1.1 设计Sales_data类</span><br><span class="line">7.1.2 定义改进的Sales_data类</span><br><span class="line">7.1.3 定义类相关的非成员函数</span><br><span class="line">7.1.4 构造函数</span><br><span class="line">7.1.5 拷贝、赋值和析构</span><br><span class="line">7.2 访问控制与封装</span><br><span class="line">7.2.1 友元</span><br><span class="line">7.3 类的其他特性</span><br><span class="line">7.3.1 类成员再探</span><br><span class="line">7.3.2 返回*this的成员函数</span><br><span class="line">7.3.3 类类型</span><br><span class="line">7.3.4 友元再探</span><br><span class="line">7.4 类的作用域</span><br><span class="line">7.4.1 名字查找与类的作用域</span><br><span class="line">7.5 构造函数再探</span><br><span class="line">7.5.1 构造函数初始值列表</span><br><span class="line">7.5.2 委托构造函数</span><br><span class="line">7.5.3 默认构造函数的作用</span><br><span class="line">7.5.4 隐式的类类型转换</span><br><span class="line">7.5.5 聚合类</span><br><span class="line">7.5.6 字面值常量类</span><br><span class="line">7.6 类的静态成员</span><br><span class="line">小结</span><br><span class="line">术语表</span><br><span class="line">……</span><br><span class="line">第Ⅱ部 C++标准库</span><br><span class="line">第Ⅲ部分 类设计者的工具</span><br><span class="line">第Ⅳ部分 高级主题</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00ESUIL0O/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00ESUIL0O&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41peEJ7ONOL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>清华大学计算机系列教材:数据结构(C++语言版)(第3版)</title>
    <url>/2020/04/19/B00FEC2GYM/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 清华大学计算机系列教材:数据结构(C++语言版)(第3版)<br>作者信息： 作者: 邓俊辉 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《清华大学计算机系列教材:数据结构(C++语言版)(第3版)》习题解析涵盖验证型、拓展型、反思型、实践型和研究型习题，总计290余道大题、525道小题，激发读者的求知欲，培养自学能力和独立思考习惯。主教材和习题解析共计配有340多组、400余幅插图结合简练的叙述，40多张表格列举简明的规范、过程及要点，280余段代码及算法配合详尽而简洁的注释，使深奥抽象的概念和过程得以具体化且便于理解和记忆；推荐20余册经典的专著与教材，提供40余篇重点的学术论文，便于读者进一步钻研和拓展。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 绪论</span><br><span class="line">1.1 计算机与算法</span><br><span class="line">1.2 复杂度度量</span><br><span class="line">1.3 复杂度分析</span><br><span class="line">1.4递归 1.5 抽象数据类型 第2章 向量 2.1 从数组到向量 2.2 接口 2.3 构造与析构 2.4 动态空间管理 2.5 常规向量 2.6 有序向量 2.7排序与下界</span><br><span class="line">2.8 排序器</span><br><span class="line">第3章 列表</span><br><span class="line">3.1 从向量到列表</span><br><span class="line">3.2 接口</span><br><span class="line">3.3 列表</span><br><span class="line">3.4 有序列表</span><br><span class="line">3.5 排序器</span><br><span class="line">第4章 栈与队列</span><br><span class="line">4.1 栈</span><br><span class="line">4.2 栈与递归</span><br><span class="line">4.3 栈的典型应用</span><br><span class="line">4.4试探回溯法 4.5 队列 4.6 队列应用 第5章 二叉树 5.1 二叉树及其表示 5.2 编码树 5.3 二叉树的实现 5.4 遍历 5.5 Huffmann 编码 第6章 图 6.1 概述 6.2 抽象数据类型 6.3 邻接矩阵 6.4 邻接表 6.5 图遍历算法概述 6.6 广度优先搜索 6.7 深度优先搜索 6.8 拓扑排序 6.9双连通域分解</span><br><span class="line">6.10 优先级搜索</span><br><span class="line">6.11 最小支撑树</span><br><span class="line">6.12 最短路径</span><br><span class="line">第7章 搜索树</span><br><span class="line">7.1 查找</span><br><span class="line">7.2 二叉搜索树</span><br><span class="line">7.3 平衡二叉搜索树</span><br><span class="line">7.4 AVL 树</span><br><span class="line">第8章 高级搜索树 高级搜索树</span><br><span class="line">8.1 伸展树</span><br><span class="line">8.2 B—树</span><br><span class="line">8.3红黑树 8.4kd—树</span><br><span class="line">第9章 词典</span><br><span class="line">9.1 词典 ADTADTADT</span><br><span class="line">9.2跳转表 9.3 散列表 9.4散列应用</span><br><span class="line">第10章 优先级队列</span><br><span class="line">10.1 优先级队列 ADT</span><br><span class="line">10.2 堆</span><br><span class="line">10.3左式堆 第11章 串 11.1 串及匹配 11.2 蛮力算法 11.3 KMP算法 11.4BM 算法</span><br><span class="line">11.5Karp—Rabin算法 第12章 排序 12.1 快速排序 12.2选取与中位数</span><br><span class="line">12.3*希尔排序</span><br><span class="line">附录</span><br><span class="line">参考文献</span><br><span class="line">插图索引</span><br><span class="line">表格索引</span><br><span class="line">算法索引</span><br><span class="line">代码索引</span><br><span class="line">关键词索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00FEC2GYM/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00FEC2GYM&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41UZVGZWg9L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Clojure编程乐趣</title>
    <url>/2020/04/19/B00G6T9BB8/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Clojure编程乐趣<br>作者信息： 作者: 福格斯 (Michael Fogus) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>如果曾亲见数十行JAVA活ruby浓缩成寥寥数行clojure代码，你便不难理解为何本书作者称clojure为一种有趣的语言。《Clojure编程乐趣》包括以下内容：●● 什么是Clojure 以及为什么要使用Clojure；●● 如何使用宏；●● 如何做出优雅的应用设计；●● 函数式编程惯用法。如果你是具有其他程序设计背景的程序员，那么《Clojure编程乐趣》就是为你而编写的。你无需Clojure 和Lisp 的经验。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1部分 基础</span><br><span class="line">第1章 Clojure哲学</span><br><span class="line">1.1 Clojure之道</span><br><span class="line">1.1.1 简单</span><br><span class="line">1.1.2 专注</span><br><span class="line">1.1.3 实用</span><br><span class="line">1.1.4 清晰</span><br><span class="line">1.1.5 一致</span><br><span class="line">1.2 为何（又一种）Lisp</span><br><span class="line">1.2.1 优美</span><br><span class="line">1.2.2 极度灵活</span><br><span class="line">1.2.3 代码即数据</span><br><span class="line">1.3 函数式编程</span><br><span class="line">1.3.1 一个可行的函数式编程定义</span><br><span class="line">1.3.2 函数式编程的内涵</span><br><span class="line">1.4 Clojure为何不是面向对象的</span><br><span class="line">1.4.1 定义术语</span><br><span class="line">1.4.2 命令式“烘烤”</span><br><span class="line">1.4.3 OOP提供的大多数东西，Clojure也有</span><br><span class="line">1.5 小结</span><br><span class="line">第2章 Clojure疾风式教程</span><br><span class="line">2.1 标量</span><br><span class="line">2.1.1 数字</span><br><span class="line">2.1.2 整数</span><br><span class="line">2.1.3 浮点数</span><br><span class="line">2.1.4 有理数</span><br><span class="line">2.1.5 符号</span><br><span class="line">2.1.6 关键字</span><br><span class="line">2.1.7 字符串</span><br><span class="line">2.1.8 字符</span><br><span class="line">2.2 组合起来：集合</span><br><span class="line">2.2.1 list</span><br><span class="line">2.2.2 vector</span><br><span class="line">2.2.3 map</span><br><span class="line">2.2.4 set</span><br><span class="line">2.3 付诸实现：函数</span><br><span class="line">2.3.1 调用函数</span><br><span class="line">2.3.2 定义函数</span><br><span class="line">2.3.3 用def和defn简化函数定义</span><br><span class="line">2.3.4 以#（）定义原位（in—place）函数</span><br><span class="line">2.4 var</span><br><span class="line">2.5 局部量、循环和block</span><br><span class="line">2.5.1 block</span><br><span class="line">2.5.2 局部量</span><br><span class="line">2.5.3 循环</span><br><span class="line">2.6 防止发生：quote</span><br><span class="line">2.6.1 求值</span><br><span class="line">2.6.2 quote</span><br><span class="line">2.6.3 反quote</span><br><span class="line">2.6.4 反quote拼接</span><br><span class="line">2.6.5 auto—gensym</span><br><span class="line">2.7 与Java互操作</span><br><span class="line">2.7.1 访问静态类成员</span><br><span class="line">2.7.2 创建Java实例</span><br><span class="line">2.7.3 用运算符访问Java实例成员</span><br><span class="line">2.7.4 设置Java实例属性</span><br><span class="line">2.7.5 …宏</span><br><span class="line">2.7.6 doto宏</span><br><span class="line">2.7.7 定义类</span><br><span class="line">2.8 异常环境</span><br><span class="line">2.9 命名空间</span><br><span class="line">2.9.1 用ns创建命名空间</span><br><span class="line">2.9.2 用：require加载其他命名空间</span><br><span class="line">2.9.3 用：use加载和创建映射</span><br><span class="line">2.9.4 用：refer创建映射</span><br><span class="line">2.9.5 用：import加载Java类</span><br><span class="line">2.10 小结</span><br><span class="line">第3章 小试牛刀</span><br><span class="line">3.1 真值</span><br><span class="line">3.1.1 什么是真</span><br><span class="line">3.1.2 不要创建布尔对象</span><br><span class="line">3.1.3 nil vs.false</span><br><span class="line">3.2 小心翼翼nil双关</span><br><span class="line">3.3 解构</span><br><span class="line">3.3.1 你的任务，你应该选择接受</span><br><span class="line">3.3.2 解构vector</span><br><span class="line">3.3.3 解构map</span><br><span class="line">3.3.4 解构函数参数</span><br><span class="line">3.3.5 解构vs.访问器方法</span><br><span class="line">3.4 用REPL做试验</span><br><span class="line">3.4.1 试验seq</span><br><span class="line">3.4.2 试验图形化</span><br><span class="line">3.4.3 知识汇总</span><br><span class="line">3.4.4 出错之时</span><br><span class="line">3.4.5 只为乐趣</span><br><span class="line">3.5 小结</span><br><span class="line">第2部分 数据类型</span><br><span class="line">第4章 标量</span><br><span class="line">4.1 理解精度</span><br><span class="line">4.1.1 截断（Truncation）</span><br><span class="line">4.1.2 提升（Promotion）</span><br><span class="line">4.1.3 上溢（Overflow）</span><br><span class="line">4.1.4 下溢（Underflow）</span><br><span class="line">4.1.5 舍入错误（Rounding errors）</span><br><span class="line">4.2 有理数</span><br><span class="line">4.2.1 为什么是有理数</span><br><span class="line">4.2.2 怎样才是有理数</span><br><span class="line">4.2.3 有理数的合理性</span><br><span class="line">4.3 使用关键字的时机</span><br><span class="line">4.3.1 关键字与符号有怎样的差别</span><br><span class="line">4.3.2 限定关键字</span><br><span class="line">4.4 符号解析</span><br><span class="line">4.4.1 元数据</span><br><span class="line">4.4.2 符号与命名空间</span><br><span class="line">4.4.3 Lisp—1</span><br><span class="line">4.5 正则表达式——第二个问题</span><br><span class="line">4.5.1 语法</span><br><span class="line">4.5.2 函数</span><br><span class="line">4.5.3 小心可变匹配器（matcher）</span><br><span class="line">4.6 总结</span><br><span class="line">第5章 组合数据类型</span><br><span class="line">5.1 持久化、序列和复杂度</span><br><span class="line">5.1.1 “你一直用着这个词。我认为，这并不意味着它就是你以为的含义”</span><br><span class="line">5.1.2 序列术语及其含义</span><br><span class="line">5.1.3 大O</span><br><span class="line">5.2 vector：创建和使用其各种变体</span><br><span class="line">5.2.1 构建vector</span><br><span class="line">5.2.2 大vector</span><br><span class="line">5.2.3 vector当做栈</span><br><span class="line">5.2.4 使用vector而非reverse</span><br><span class="line">5.2.5 子vector</span><br><span class="line">5.2.6 vector当做MapEntry</span><br><span class="line">5.2.7 vector不是什么</span><br><span class="line">5.3 list：Clojure代码form的数据结构</span><br><span class="line">5.3.1 像Lisp那样的list</span><br><span class="line">5.3.2 list当做栈</span><br><span class="line">5.3.3 list不是什么</span><br><span class="line">5.4 如何使用持久化队列</span><br><span class="line">5.4.1 什么都没有的队列</span><br><span class="line">5.4.2 入队</span><br><span class="line">5.4.3 获取</span><br><span class="line">5.4.4 出队</span><br><span class="line">5.5 持久化set</span><br><span class="line">5.5.1 Clojure set的基本属性</span><br><span class="line">5.5.2 用sorted—set保持set的顺序</span><br><span class="line">5.5.3 contains？</span><br><span class="line">5.5.4 clojure.set</span><br><span class="line">5.6 思考map</span><br><span class="line">5.6.1 hash map</span><br><span class="line">5.6.2 以有序map保持键值的顺序</span><br><span class="line">5.6.3 用数组map保持插入顺序</span><br><span class="line">5.7 知识汇总：在序列里查找某项的位置</span><br><span class="line">5.8 小结</span><br><span class="line">第3部分 函数式编程</span><br><span class="line">第6章 惰性与不变性</span><br><span class="line">6.1 关于不变性</span><br><span class="line">6.1.1 定义不变性</span><br><span class="line">6.1.2 固步自封—不变性</span><br><span class="line">6.2 设计一个持久化玩具</span><br><span class="line">6.3 惰性</span><br><span class="line">6.3.1 以“逻辑与”熟悉惰性</span><br><span class="line">6.3.2 理解lazy—seq的秘诀</span><br><span class="line">6.3.3 丢掉头</span><br><span class="line">6.3.4 采用无限序列</span><br><span class="line">6.3.5 delay和force宏</span><br><span class="line">6.3.6 知识汇总：一个惰性的快速排序程序</span><br><span class="line">6.4 小结</span><br><span class="line">第7章 函数式编程</span><br><span class="line">7.1 各种形式的函数</span><br><span class="line">7.1.1 一等函数</span><br><span class="line">7.1.2 高阶函数</span><br><span class="line">7.1.3 纯函数</span><br><span class="line">7.1.4 命名实参</span><br><span class="line">7.1.5 使用前置条件和后置条件约束函数</span><br><span class="line">7.2 闭包</span><br><span class="line">7.3 递归思考</span><br><span class="line">7.3.1 普通递归</span><br><span class="line">7.3.2 尾递归和recur</span><br><span class="line">7.3.3 勿忘trampoline</span><br><span class="line">7.3.4 延续传递风格</span><br><span class="line">7.4 知识汇总：A寻路 7.4.1 A实现</span><br><span class="line">7.4.2 A*实现的笔记</span><br><span class="line">7.5 小结</span><br><span class="line">第4部分 大规模设计</span><br><span class="line">第8章 宏</span><br><span class="line">8.1 数据即代码即数据</span><br><span class="line">8.1.1 语法quote、反quote和拼接</span><br><span class="line">8.1.2 宏之经验谈</span><br><span class="line">8.2 定义控制结构</span><br><span class="line">8.2.1 不用语法quote定义控制结构</span><br><span class="line">8.2.2 使用语法quote和反quote定义控制结构</span><br><span class="line">8.3 组合form的宏</span><br><span class="line">8.4 使用宏改变form</span><br><span class="line">8.5 使用宏控制符号解析</span><br><span class="line">8.5.1 回指</span><br><span class="line">8.5.2 （具有争议地）有用的选择性名字捕获</span><br><span class="line">8.6 使用宏管理资源</span><br><span class="line">8.7 知识汇总：返回函数的宏</span><br><span class="line">8.8 小结</span><br><span class="line">第9章 组合数据与代码</span><br><span class="line">9.1 命名空间</span><br><span class="line">9.1.1 创建命名空间</span><br><span class="line">9.1.2 只暴露所需</span><br><span class="line">9.1.3 声明性包含和排除</span><br><span class="line">9.2 以通用设计模式探索Clojure多重方法</span><br><span class="line">9.2.1 组成部分</span><br><span class="line">9.2.2 用法</span><br><span class="line">9.2.3 以多重方法拯救</span><br><span class="line">9.2.4 处理继承行为的特别继承</span><br><span class="line">9.2.5 解析层次中的冲突</span><br><span class="line">9.2.6 真正的最大功率任意分发</span><br><span class="line">9.3 类型、协议和记录</span><br><span class="line">9.3.1 记录</span><br><span class="line">9.3.2 协议</span><br><span class="line">9.3.3 用deftype从更原始的基础开始构建</span><br><span class="line">9.4 知识汇总：国际象棋移动的流畅构建器</span><br><span class="line">9.4.1 Java实现</span><br><span class="line">9.4.2 Clojure实现</span><br><span class="line">9.5 小结</span><br><span class="line">第10章 Java.next</span><br><span class="line">10.1 使用proxy动态生成对象</span><br><span class="line">10.2 Clojure gen—class和GUI程序设计</span><br><span class="line">10.2.1 命名空间作为类的规范</span><br><span class="line">10.2.2 以Clojure探索用户界面设计与开发</span><br><span class="line">10.3 Clojure同Java数组的关系</span><br><span class="line">10.3.1 数组的类型：原生与引用</span><br><span class="line">10.3.2 数组可变性</span><br><span class="line">10.3.3 那个不幸的命名约定</span><br><span class="line">10.3.4 多维数组</span><br><span class="line">10.3.5 调用可变方法／构造函数</span><br><span class="line">10.4 所有Clojure函数都实现</span><br><span class="line">10.4.1 java.util.Comparator</span><br><span class="line">10.4.2 java.lang.Runnable</span><br><span class="line">10.4.3 java.util.concurrent.Callable</span><br><span class="line">10.5 在Java API里使用Clojure数据结构</span><br><span class="line">10.5.1 java.util.List</span><br><span class="line">10.5.2 java.lang.Comparable</span><br><span class="line">10.5.3 java.util.RandomAccess</span><br><span class="line">10.5.4 java.util.Collection</span><br><span class="line">10.5.5 java.util.Set</span><br><span class="line">10.6 definterface</span><br><span class="line">10.7 慎用异常</span><br><span class="line">10.7.1 一点异常的背景</span><br><span class="line">10.7.2 运行时异常vs.编译时异常</span><br><span class="line">10.7.3 处理异常</span><br><span class="line">10.7.4 定制异常</span><br><span class="line">10.8 小结</span><br><span class="line">第11章 变化</span><br><span class="line">11.1 软件事务性内存，包括多版本并发控制和快照隔离</span><br><span class="line">11.1.1 事务</span><br><span class="line">11.1.2 嵌入式事务</span><br><span class="line">11.1.3 STM使其简单的事情</span><br><span class="line">11.1.4 潜在缺陷</span><br><span class="line">11.1.5 让STM不高兴的事</span><br><span class="line">11.2 使用Ref的时机</span><br><span class="line">11.2.1 使用alter进行可协调的、同步的改变</span><br><span class="line">11.2.2 以commute进行可交换的改变</span><br><span class="line">11.2.3 以ref—set进行普通改变</span><br><span class="line">11.2.4 用ensure修正写入偏差</span><br><span class="line">11.2.5 压力之下的Ref</span><br><span class="line">11.3 使用Agent的时机</span><br><span class="line">11.3.1 进程内并发模型vs分布式并发模型</span><br><span class="line">11.3.2 用Agent控制I／O</span><br><span class="line">11.3.3 send和send—off之间的差异</span><br><span class="line">11.3.4 错误处理</span><br><span class="line">11.3.5 何时不用Agent</span><br><span class="line">11.4 使用Atom的时机</span><br><span class="line">11.4.1 跨线程共享</span><br><span class="line">11.4.2 在事务里使用Atom</span><br><span class="line">11.5 使用lock的时机</span><br><span class="line">11.5.1 使用锁进行安全变化</span><br><span class="line">11.5.2 使用Java的显式锁</span><br><span class="line">11.6 使用future的时机</span><br><span class="line">11.7 使用promise的时机</span><br><span class="line">11.7.1 以promise进行并行任务</span><br><span class="line">11.7.2 回调API到阻塞API</span><br><span class="line">11.7.3 确定性死锁</span><br><span class="line">11.8 并行</span><br><span class="line">11.8.1 pvalues</span><br><span class="line">11.8.2 pmap</span><br><span class="line">11.8.3 pcalls</span><br><span class="line">11.9 var和动态绑定</span><br><span class="line">11.9.1 binding宏</span><br><span class="line">11.9.2 创建命名var</span><br><span class="line">11.9.3 创建匿名var</span><br><span class="line">11.9.4 动态作用域</span><br><span class="line">11.10 小结</span><br><span class="line">……</span><br><span class="line">第5部分 杂项考量</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00G6T9BB8/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00G6T9BB8&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51yB8NVqXML._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>clojure</tag>
      </tags>
  </entry>
  <entry>
    <title>C#高级编程(第8版)</title>
    <url>/2020/04/19/B00FFQ6L3O/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C#高级编程(第8版)<br>作者信息： 作者: 内格尔 (Christian Nagel) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>内格尔编著的《C#高级编程(第8版.NET开发经典名著)》旨在帮助有经验的程序员，更新和提升他们使用C#和.NET 4.5编写Windows应用程序、Web app和Metro apps等方面的技能。书中提供了丰富的有关中、高级功能的信息，包括了职业开发人员需要了解和应用C#进行工作的全部知识。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第Ⅰ部分C#语言</span><br><span class="line">第1章.NET体系结构</span><br><span class="line">1.1C#与.NET的关系</span><br><span class="line">1.2公共语言运行库</span><br><span class="line">1.2.1平台无关性</span><br><span class="line">1.2.2提高性能</span><br><span class="line">1.2.3语言的互操作性</span><br><span class="line">1.3中间语言</span><br><span class="line">1.3.1面向对象和接口的支持</span><br><span class="line">1.3.2不同的值类型和引用类型</span><br><span class="line">1.3.3强数据类型化</span><br><span class="line">1.3.4通过异常处理错误</span><br><span class="line">1.3.5特性的使用</span><br><span class="line">1.4程序集</span><br><span class="line">1.4.1私有程序集</span><br><span class="line">1.4.2共享程序集</span><br><span class="line">1.4.3反射</span><br><span class="line">1.4.4并行编程</span><br><span class="line">1.4.5异步编程</span><br><span class="line">1.5.NETFramework类</span><br><span class="line">1.6名称空间</span><br><span class="line">1.7用C#创建.NET应用程序</span><br><span class="line">1.7.1创建ASP.NET应用程序</span><br><span class="line">1.7.2使用WPF</span><br><span class="line">1.7.3Windows8应用程序</span><br><span class="line">1.7.4Windows服务</span><br><span class="line">1.7.5WCF</span><br><span class="line">1.7.6WindowsWF</span><br><span class="line">1.8C#在.NET企业体系结构中的作用</span><br><span class="line">1.9小结</span><br><span class="line">第2章核心C#</span><br><span class="line">2.1C#基础</span><br><span class="line">2.2第一个C#程序</span><br><span class="line">2.2.1代码</span><br><span class="line">2.2.2编译并运行程序</span><br><span class="line">2.2.3详细介绍</span><br><span class="line">2.3变量</span><br><span class="line">2.3.1变量的初始化</span><br><span class="line">2.3.2类型推断</span><br><span class="line">2.3.3变量的作用域</span><br><span class="line">2.3.4常量</span><br><span class="line">2.4预定义数据类型</span><br><span class="line">2.4.1值类型和引用类型</span><br><span class="line">2.4.2CTS类型</span><br><span class="line">2.4.3预定义的值类型</span><br><span class="line">2.4.4预定义的引用类型</span><br><span class="line">2.5流控制</span><br><span class="line">2.5.1条件语句</span><br><span class="line">2.5.2循环</span><br><span class="line">2.5.3跳转语句</span><br><span class="line">2.6枚举</span><br><span class="line">2.7名称空间</span><br><span class="line">2.7.1using语句</span><br><span class="line">2.7.2名称空间的别名</span><br><span class="line">2.8Main（）方法</span><br><span class="line">2.8.1多个Main（）方法</span><br><span class="line">2.8.2给Main（）方法传递参数</span><br><span class="line">2.9有关编译C#文件的更多内容</span><br><span class="line">2.10控制台I&#x2F;O</span><br><span class="line">2.11使用注释</span><br><span class="line">2.11.1源文件中的内部注释</span><br><span class="line">2.11.2XML文档</span><br><span class="line">2.12C#预处理器指令</span><br><span class="line">2.12.1#define和#undef</span><br><span class="line">2.12.2#if、#elif、#else和#endif</span><br><span class="line">2.12.3#warning和#error</span><br><span class="line">2.12.4#region和#endregion</span><br><span class="line">2.12.5#line</span><br><span class="line">2.12.6#pragma</span><br><span class="line">2.13C#编程规则</span><br><span class="line">2.13.1关于标识符的规则</span><br><span class="line">2.13.2用法约定</span><br><span class="line">2.14小结</span><br><span class="line">第3章对象和类型</span><br><span class="line">3.1创建及使用类</span><br><span class="line">3.2类和结构</span><br><span class="line">3.3类</span><br><span class="line">3.3.1数据成员</span><br><span class="line">3.3.2函数成员</span><br><span class="line">3.3.3只读字段</span><br><span class="line">3.4匿名类型</span><br><span class="line">3.5结构</span><br><span class="line">3.5.1结构是值类型</span><br><span class="line">3.5.2结构和继承</span><br><span class="line">3.5.3结构的构造函数</span><br><span class="line">3.6弱引用</span><br><span class="line">3.7部分类</span><br><span class="line">3.8静态类</span><br><span class="line">3.9Object类</span><br><span class="line">3.9.1System.Object（）方法</span><br><span class="line">3.9.2ToString（）方法</span><br><span class="line">3.10扩展方法</span><br><span class="line">3.11小结</span><br><span class="line">第4章继承</span><br><span class="line">4.1继承</span><br><span class="line">4.2继承的类型</span><br><span class="line">4.2.1实现继承和接口继承</span><br><span class="line">4.2.2多重继承</span><br><span class="line">4.2.3结构和类</span><br><span class="line">4.3实现继承</span><br><span class="line">4.3.1虚方法</span><br><span class="line">4.3.2隐藏方法</span><br><span class="line">4.3.3调用函数的基类版本</span><br><span class="line">4.3.4抽象类和抽象函数</span><br><span class="line">4.3.5密封类和密封方法</span><br><span class="line">4.3.6派生类的构造函数</span><br><span class="line">4.4修饰符</span><br><span class="line">4.4.1可见性修饰符</span><br><span class="line">4.4.2其他修饰符</span><br><span class="line">4.5接口</span><br><span class="line">4.5.1定义和实现接口</span><br><span class="line">4.5.2派生的接口</span><br><span class="line">4.6小结</span><br><span class="line">第5章泛型</span><br><span class="line">5.1泛型概述</span><br><span class="line">5.1.1性能</span><br><span class="line">5.1.2类型安全</span><br><span class="line">5.1.3二进制代码的重用</span><br><span class="line">5.1.4代码的扩展</span><br><span class="line">5.1.5命名约定</span><br><span class="line">5.2创建泛型类</span><br><span class="line">5.3泛型类的功能</span><br><span class="line">5.3.1默认值</span><br><span class="line">5.3.2约束</span><br><span class="line">5.3.3继承</span><br><span class="line">5.3.4静态成员</span><br><span class="line">5.4泛型接口</span><br><span class="line">5.4.1协变和抗变</span><br><span class="line">5.4.2泛型接口的协变</span><br><span class="line">5.4.3泛型接口的抗变</span><br><span class="line">5.5泛型结构</span><br><span class="line">5.6泛型方法</span><br><span class="line">5.6.1泛型方法示例</span><br><span class="line">5.6.2带约束的泛型方法</span><br><span class="line">5.6.3带委托的泛型方法</span><br><span class="line">5.6.4泛型方法规范</span><br><span class="line">5.7小结</span><br><span class="line">第6章数组</span><br><span class="line">6.1同一类型和不同类型的多个对象</span><br><span class="line">6.2简单数组</span><br><span class="line">6.2.1数组的声明</span><br><span class="line">6.2.2数组的初始化</span><br><span class="line">6.2.3访问数组元素</span><br><span class="line">6.2.4使用引用类型</span><br><span class="line">6.3多维数组</span><br><span class="line">6.4锯齿数组</span><br><span class="line">6.5Array类</span><br><span class="line">6.5.1创建数组</span><br><span class="line">6.5.2复制数组</span><br><span class="line">6.5.3排序</span><br><span class="line">6.6数组作为参数</span><br><span class="line">6.6.1数组协变</span><br><span class="line">6.6.2ArraySegment</span><br><span class="line">6.7枚举</span><br><span class="line">6.7.1IEnumerator接口</span><br><span class="line">6.7.2foreach语句</span><br><span class="line">6.7.3yield语句</span><br><span class="line">6.8元组</span><br><span class="line">6.9结构比较</span><br><span class="line">6.10小结</span><br><span class="line">第7章运算符和类型强制转换</span><br><span class="line">7.1运算符和类型转换</span><br><span class="line">7.2运算符</span><br><span class="line">7.2.1运算符的简化操作</span><br><span class="line">7.2.2运算符的优先级</span><br><span class="line">7.3类型的安全性</span><br><span class="line">7.3.1类型转换</span><br><span class="line">7.3.2装箱和拆箱</span><br><span class="line">7.4比较对象的相等性</span><br><span class="line">7.4.1比较引用类型的相等性</span><br><span class="line">7.4.2比较值类型的相等性</span><br><span class="line">7.5运算符重载</span><br><span class="line">7.5.1运算符的工作方式</span><br><span class="line">7.5.2运算符重载的示例：Vector结构</span><br><span class="line">7.6用户定义的类型强制转换</span><br><span class="line">7.6.1实现用户定义的类型强制转换</span><br><span class="line">7.6.2多重类型强制转换</span><br><span class="line">7.7小结</span><br><span class="line">第8章委托、Lambda表达式</span><br><span class="line">和事件</span><br><span class="line">8.1引用方法</span><br><span class="line">8.2委托</span><br><span class="line">8.2.1声明委托</span><br><span class="line">8.2.2使用委托</span><br><span class="line">8.2.3简单的委托示例</span><br><span class="line">8.2.4Action和Func委托</span><br><span class="line">8.2.5BubbleSorter示例</span><br><span class="line">8.2.6多播委托</span><br><span class="line">8.2.7匿名方法</span><br><span class="line">8.3Lambda表达式</span><br><span class="line">8.3.1参数</span><br><span class="line">8.3.2多行代码</span><br><span class="line">8.3.3闭包</span><br><span class="line">8.3.4使用foreach语句的闭包</span><br><span class="line">8.4事件</span><br><span class="line">8.4.1事件发布程序</span><br><span class="line">8.4.2事件侦听器</span><br><span class="line">8.4.3弱事件</span><br><span class="line">8.5小结</span><br><span class="line">第9章字符串和正则表达式</span><br><span class="line">9.1System.String类</span><br><span class="line">9.1.1创建字符串</span><br><span class="line">9.1.2StringBuilder成员</span><br><span class="line">9.1.3格式字符串</span><br><span class="line">9.2正则表达式</span><br><span class="line">9.2.1正则表达式概述</span><br><span class="line">9.2.2RegularExpressionsPlayaround示例</span><br><span class="line">9.2.3显示结果</span><br><span class="line">9.2.4匹配、组合和捕获</span><br><span class="line">9.3小结</span><br><span class="line">第10章集合</span><br><span class="line">10.1概述</span><br><span class="line">10.2集合接口和类型</span><br><span class="line">10.3列表</span><br><span class="line">10.3.1创建列表</span><br><span class="line">10.3.2只读集合</span><br><span class="line">10.4队列</span><br><span class="line">10.5栈</span><br><span class="line">10.6链表</span><br><span class="line">10.7有序列表</span><br><span class="line">10.8字典</span><br><span class="line">10.8.1键的类型</span><br><span class="line">10.8.2字典示例</span><br><span class="line">10.8.3Lookup类</span><br><span class="line">10.8.4有序字典</span><br><span class="line">10.9集</span><br><span class="line">10.10可观察的集合</span><br><span class="line">10.11位数组</span><br><span class="line">10.11.1BitArray类</span><br><span class="line">10.11.2BitVector32结构</span><br><span class="line">10.12并发集合</span><br><span class="line">10.12.1创建管道</span><br><span class="line">10.12.2使用Blocking—Collection</span><br><span class="line">10.12.3使用Concurrent—Dictionary</span><br><span class="line">10.12.4完成管道</span><br><span class="line">10.13性能</span><br><span class="line">10.14小结</span><br><span class="line">第11章LINQ</span><br><span class="line">11.1LINQ概述</span><br><span class="line">11.1.1列表和实体</span><br><span class="line">11.1.2LINQ查询</span><br><span class="line">11.1.3扩展方法</span><br><span class="line">11.1.4推迟查询的执行</span><br><span class="line">11.2标准的查询操作符</span><br><span class="line">11.2.1筛选</span><br><span class="line">11.2.2用索引筛选</span><br><span class="line">11.2.3类型筛选</span><br><span class="line">11.2.4复合的from子句</span><br><span class="line">11.2.5排序</span><br><span class="line">11.2.6分组</span><br><span class="line">11.2.7对嵌套的对象分组</span><br><span class="line">11.2.8内连接</span><br><span class="line">11.2.9左外连接</span><br><span class="line">11.2.10组连接</span><br><span class="line">11.2.11集合操作</span><br><span class="line">11.2.12合并</span><br><span class="line">11.2.13分区</span><br><span class="line">11.2.14聚合操作符</span><br><span class="line">11.2.15转换操作符</span><br><span class="line">11.2.16生成操作符</span><br><span class="line">11.3并行LINQ</span><br><span class="line">11.3.1并行查询</span><br><span class="line">11.3.2分区器</span><br><span class="line">11.3.3取消</span><br><span class="line">11.4表达式树</span><br><span class="line">11.5LINQ提供程序</span><br><span class="line">11.6小结</span><br><span class="line">第12章动态语言扩展</span><br><span class="line">12.1DLR</span><br><span class="line">12.2dynamic类型</span><br><span class="line">12.3包含DLRScriptRuntime</span><br><span class="line">12.4DynamicObject和ExpandoObject</span><br><span class="line">12.4.1DynamicObject</span><br><span class="line">12.4.2ExpandoObject</span><br><span class="line">12.5小结</span><br><span class="line">第13章异步编程</span><br><span class="line">13.1异步编程的重要性</span><br><span class="line">13.2异步模式</span><br><span class="line">13.2.1同步调用</span><br><span class="line">13.2.2异步模式</span><br><span class="line">13.2.3基于事件的异步模式</span><br><span class="line">13.2.4基于任务的异步模式</span><br><span class="line">13.3异步编程的基础</span><br><span class="line">13.3.1创建任务</span><br><span class="line">13.3.2调用异步方法</span><br><span class="line">13.3.3延续任务</span><br><span class="line">13.3.4同步上下文</span><br><span class="line">13.3.5使用多个异步方法</span><br><span class="line">13.3.6转换异步模式</span><br><span class="line">13.4错误处理</span><br><span class="line">13.4.1异步方法的异常处理</span><br><span class="line">13.4.2多个异步方法的异常处理</span><br><span class="line">13.4.3AggregateException类</span><br><span class="line">13.5取消</span><br><span class="line">13.5.1开始取消任务</span><br><span class="line">13.5.2使用框架特性取消任务</span><br><span class="line">13.5.3取消自定义任务</span><br><span class="line">13.6小结</span><br><span class="line">第14章内存管理和指针</span><br><span class="line">14.1内存管理</span><br><span class="line">14.2后台内存管理</span><br><span class="line">14.2.1值数据类型</span><br><span class="line">14.2.2引用数据类型</span><br><span class="line">14.2.3垃圾回收</span><br><span class="line">14.3释放非托管的资源</span><br><span class="line">14.3.1析构函数</span><br><span class="line">14.3.2IDisposable接口</span><br><span class="line">14.3.3实现IDisposable接口和析构函数</span><br><span class="line">14.4不安全的代码</span><br><span class="line">14.4.1用指针直接访问内存</span><br><span class="line">14.4.2指针示例：PointerPlayground</span><br><span class="line">14.4.3使用指针优化性能</span><br><span class="line">14.5小结</span><br><span class="line">第15章反射</span><br><span class="line">15.1在运行期间处理和检查代码</span><br><span class="line">15.2自定义特性</span><br><span class="line">15.2.1编写自定义特性</span><br><span class="line">15.2.2自定义特性示例：WhatsNewAttributes</span><br><span class="line">15.3反射</span><br><span class="line">15.3.1System.Type类</span><br><span class="line">15.3.2TypeView示例</span><br><span class="line">15.3.3Assembly类</span><br><span class="line">15.3.4完成WhatsNewAttributes示例</span><br><span class="line">15.4小结</span><br><span class="line">第16章错误和异常</span><br><span class="line">16.1简介</span><br><span class="line">16.2异常类</span><br><span class="line">16.3捕获异常</span><br><span class="line">16.3.1实现多个catch块</span><br><span class="line">16.3.2在其他代码中捕获异常</span><br><span class="line">16.3.3System.Exception属性</span><br><span class="line">16.3.4没有处理异常时所发生的情况</span><br><span class="line">16.3.5嵌套的try块</span><br><span class="line">16.4用户定义的异常类</span><br><span class="line">16.4.1捕获用户定义的异常</span><br><span class="line">16.4.2抛出用户定义的异常</span><br><span class="line">16.4.3定义用户定义的异常类</span><br><span class="line">16.5调用者信息</span><br><span class="line">16.6小结</span><br><span class="line">第Ⅱ部分VisualStudio</span><br><span class="line">第17章VisualStudio2012</span><br><span class="line">17.1用VisualStudio2012进行工作</span><br><span class="line">17.1.1项目文件的改进</span><br><span class="line">17.1.2VisualStudio的版本</span><br><span class="line">17.1.3VisualStudio设置</span><br><span class="line">17.2创建项目</span><br><span class="line">17.2.1面向多个版本的.NETFramework</span><br><span class="line">17.2.2选择项目类型</span><br><span class="line">17.3浏览并编写项目</span><br><span class="line">17.3.1SolutionExplorer</span><br><span class="line">17.3.2用代码编辑器进行工作</span><br><span class="line">17.3.3学习和理解其他窗口</span><br><span class="line">17.3.4排列窗口</span><br><span class="line">17.4构建项目</span><br><span class="line">17.4.1构建、编译和生成</span><br><span class="line">17.4.2调试版本和发布版本</span><br><span class="line">17.4.3选择配置</span><br><span class="line">17.4.4编辑配置</span><br><span class="line">17.5调试代码</span><br><span class="line">17.5.1设置断点</span><br><span class="line">17.5.2使用数据提示和调试器可视化工具</span><br><span class="line">17.5.3监视和修改变量</span><br><span class="line">17.5.4异常</span><br><span class="line">17.5.5多线程</span><br><span class="line">17.5.6IntelliTrace</span><br><span class="line">17.6重构工具</span><br><span class="line">17.7体系结构工具</span><br><span class="line">17.7.1依赖项关系图</span><br><span class="line">17.7.2层关系图</span><br><span class="line">17.8分析应用程序</span><br><span class="line">17.8.1序列图</span><br><span class="line">17.8.2探查器</span><br><span class="line">17.8.3ConcurrencyVisualizer</span><br><span class="line">17.8.4CodeAnalysis</span><br><span class="line">17.8.5CodeMetrics</span><br><span class="line">17.9单元测试</span><br><span class="line">17.9.1创建单元测试</span><br><span class="line">17.9.2运行单元测试</span><br><span class="line">17.9.3预期异常</span><br><span class="line">17.9.4测试全部代码路径</span><br><span class="line">17.9.5外部依赖</span><br><span class="line">17.9.6FakesFramework</span><br><span class="line">17.10Windows8、WCF、WF等</span><br><span class="line">17.10.1使用VisualStudio2012生成WCF应用程序</span><br><span class="line">17.10.2使用VisualStudio2012生成WF应用程序</span><br><span class="line">17.10.3使用VisualStudio2012生成WindowsStore应用程序</span><br><span class="line">17.11小结</span><br><span class="line">第18章部署</span><br><span class="line">18.1部署是应用程序生命周期的一部分</span><br><span class="line">18.2部署的规划</span><br><span class="line">18.2.1部署选项</span><br><span class="line">18.2.2部署要求</span><br><span class="line">18.2.3部署.NET运行库</span><br><span class="line">18.3传统的部署选项</span><br><span class="line">18.3.1xcopy部署</span><br><span class="line">18.3.2xcopy和Web应用程序</span><br><span class="line">18.3.3WindowsInstaller</span><br><span class="line">18.4ClickOnce</span><br><span class="line">18.4.1ClickOnce操作</span><br><span class="line">18.4.2发布ClickOnce应用程序</span><br><span class="line">18.4.3ClickOnce设置</span><br><span class="line">18.4.4ClickOnce文件的应用程序缓存</span><br><span class="line">18.4.5应用程序的安装</span><br><span class="line">18.4.6ClickOnce部署API</span><br><span class="line">18.5Web部署</span><br><span class="line">18.5.1Web应用程序</span><br><span class="line">18.5.2配置文件</span><br><span class="line">18.5.3创建WebDeploy包</span><br><span class="line">18.6Windows8应用程序</span><br><span class="line">18.6.1创建应用程序包</span><br><span class="line">18.6.2WindowsAppCertificationKit</span><br><span class="line">18.6.3旁加载</span><br><span class="line">18.6.4Windows部署API</span><br><span class="line">18.7小结</span><br><span class="line">第Ⅲ部分基础</span><br><span class="line">第19章程序集</span><br><span class="line">19.1程序集的含义</span><br><span class="line">19.1.1程序集的功能</span><br><span class="line">19.1.2程序集的结构</span><br><span class="line">19.1.3程序集清单</span><br><span class="line">19.1.4名称空间、程序集和组件</span><br><span class="line">19.1.5私有程序集和共享程序集</span><br><span class="line">19.1.6附属程序集</span><br><span class="line">19.1.7查看程序集</span><br><span class="line">19.2构建程序集</span><br><span class="line">19.2.1创建模块和程序集</span><br><span class="line">19.2.2程序集的特性</span><br><span class="line">19.2.3创建和动态加载程序集</span><br><span class="line">19.3应用程序域</span><br><span class="line">19.4共享程序集</span><br><span class="line">19.4.1强名</span><br><span class="line">19.4.2使用强名获得完整性</span><br><span class="line">19.4.3全局程序集缓存</span><br><span class="line">19.4.4创建共享程序集</span><br><span class="line">19.4.5创建强名</span><br><span class="line">19.4.6安装共享程序集</span><br><span class="line">19.4.7使用共享程序集</span><br><span class="line">19.4.8程序集的延迟签名</span><br><span class="line">19.4.9引用</span><br><span class="line">19.4.10本机映像生成器</span><br><span class="line">19.5配置.NET应用程序</span><br><span class="line">19.5.1配置类别</span><br><span class="line">19.5.2绑定程序集</span><br><span class="line">19.6版本问题</span><br><span class="line">19.6.1版本号</span><br><span class="line">19.6.2通过编程方式获取版本</span><br><span class="line">19.6.3绑定到程序集版本</span><br><span class="line">19.6.4发行者策略文件</span><br><span class="line">19.6.5运行库的版本</span><br><span class="line">19.7在不同的技术之间共享程序集</span><br><span class="line">19.7.1共享源代码</span><br><span class="line">19.7.2可移植类库</span><br><span class="line">19.8小结</span><br><span class="line">第20章诊断</span><br><span class="line">20.1诊断概述</span><br><span class="line">20.2代码协定</span><br><span class="line">20.2.1前提条件</span><br><span class="line">20.2.2后置条件</span><br><span class="line">20.2.3不变量</span><br><span class="line">20.2.4纯粹性</span><br><span class="line">20.2.5接口的协定</span><br><span class="line">20.2.6简写</span><br><span class="line">20.2.7协定和遗留代码</span><br><span class="line">20.3跟踪</span><br><span class="line">20.3.1跟踪源</span><br><span class="line">20.3.2跟踪开关</span><br><span class="line">20.3.3跟踪侦听器</span><br><span class="line">20.3.4筛选器</span><br><span class="line">20.3.5相关性</span><br><span class="line">20.3.6使用ETW进行跟踪</span><br><span class="line">20.4事件日志</span><br><span class="line">20.4.1事件日志体系结构</span><br><span class="line">20.4.2事件日志类</span><br><span class="line">20.4.3创建事件源</span><br><span class="line">20.4.4写入事件日志</span><br><span class="line">20.4.5资源文件</span><br><span class="line">20.5性能监视</span><br><span class="line">20.5.1性能监视类</span><br><span class="line">20.5.2性能计数器生成器</span><br><span class="line">20.5.3添加PerformanceCounter组件</span><br><span class="line">20.5.4perfmon.exe</span><br><span class="line">20.6小结</span><br><span class="line">第21章任务、线程和同步</span><br><span class="line">21.1概述</span><br><span class="line">21.2Parallel类</span><br><span class="line">21.2.1用Parallel.For（）方法循环</span><br><span class="line">21.2.2使用Parallel.ForEach（）方法循环</span><br><span class="line">21.2.3通过Parallel.Invoke（）方法调用多个方法</span><br><span class="line">21.3任务</span><br><span class="line">21.3.1启动任务</span><br><span class="line">21.3.2Future——任务的结果</span><br><span class="line">21.3.3连续的任务</span><br><span class="line">21.3.4任务层次结构</span><br><span class="line">21.4取消架构</span><br><span class="line">21.4.1Parallel.For（）方法的取消</span><br><span class="line">21.4.2任务的取消</span><br><span class="line">21.5线程池</span><br><span class="line">21.6Thread类</span><br><span class="line">21.6.1给线程传递数据</span><br><span class="line">21.6.2后台线程</span><br><span class="line">21.6.3线程的优先级</span><br><span class="line">21.6.4控制线程</span><br><span class="line">21.7线程问题</span><br><span class="line">21.7.1争用条件</span><br><span class="line">21.7.2死锁</span><br><span class="line">21.8同步</span><br><span class="line">21.8.1lock语句和线程安全</span><br><span class="line">21.8.2Interlocked类</span><br><span class="line">21.8.3Monitor类</span><br><span class="line">21.8.4SpinLock结构</span><br><span class="line">21.8.5WaitHandle基类</span><br><span class="line">21.8.6Mutex类</span><br><span class="line">21.8.7Semaphore类</span><br><span class="line">21.8.8Events类</span><br><span class="line">21.8.9Barrier类</span><br><span class="line">21.8.10ReaderWriterLockSlim类</span><br><span class="line">21.9Timer类</span><br><span class="line">21.10数据流</span><br><span class="line">21.10.1使用动作块</span><br><span class="line">21.10.2源和目标数据块</span><br><span class="line">21.10.3连接块</span><br><span class="line">21.11小结</span><br><span class="line">第22章安全性</span><br><span class="line">22.1概述</span><br><span class="line">22.2身份验证和授权</span><br><span class="line">22.2.1标识和Principal</span><br><span class="line">22.2.2角色</span><br><span class="line">22.2.3声明基于角色的安全性</span><br><span class="line">22.2.4声称</span><br><span class="line">22.2.5客户端应用程序服务</span><br><span class="line">22.3加密</span><br><span class="line">22.3.1签名</span><br><span class="line">22.3.2交换密钥和安全传输</span><br><span class="line">22.4资源的访问控制</span><br><span class="line">22.5代码访问安全性</span><br><span class="line">22.5.1第2级安全透明性</span><br><span class="line">22.5.2权限</span><br><span class="line">22.6使用证书发布代码</span><br><span class="line">22.7小结</span><br><span class="line">第23章互操作</span><br><span class="line">23.1.NET和COM技术</span><br><span class="line">23.1.1元数据</span><br><span class="line">23.1.2释放内存</span><br><span class="line">23.1.3接口</span><br><span class="line">23.1.4方法绑定</span><br><span class="line">23.1.5数据类型</span><br><span class="line">23.1.6注册</span><br><span class="line">23.1.7线程</span><br><span class="line">23.1.8错误处理</span><br><span class="line">23.1.9事件</span><br><span class="line">23.1.10封送</span><br><span class="line">23.2在.NET客户端中使用COM组件</span><br><span class="line">23.2.1创建一个COM组件</span><br><span class="line">23.2.2创建运行库可调用包装</span><br><span class="line">23.2.3使用RCW</span><br><span class="line">23.2.4通过动态语言扩展使用COM服务</span><br><span class="line">23.2.5线程问题</span><br><span class="line">23.2.6添加连接点</span><br><span class="line">23.3在COM客户端中使用.NET组件</span><br><span class="line">23.3.1COM可调用包装</span><br><span class="line">23.3.2创建.NET组件</span><br><span class="line">23.3.3创建一个类型库</span><br><span class="line">23.3.4COM互操作特性</span><br><span class="line">23.3.5COM注册</span><br><span class="line">23.3.6创建COM客户端应用程序</span><br><span class="line">23.3.7添加连接点</span><br><span class="line">23.3.8使用sink对象创建客户端</span><br><span class="line">23.3.9平台调用</span><br><span class="line">23.4小结</span><br><span class="line">第24章文件和注册表操作</span><br><span class="line">24.1文件和注册表</span><br><span class="line">24.2管理文件系统</span><br><span class="line">24.2.1表示文件和文件夹的.NET类</span><br><span class="line">24.2.2Path类</span><br><span class="line">24.2.3FileProperties示例</span><br><span class="line">24.3移动、复制和删除文件</span><br><span class="line">24.3.1FilePropertiesAndMovement示例</span><br><span class="line">24.3.2FilePropertiesAndMovement示例的代码</span><br><span class="line">24.4读写文件</span><br><span class="line">24.4.1读取文件</span><br><span class="line">24.4.2写入文件</span><br><span class="line">24.4.3流</span><br><span class="line">24.4.4缓存的流</span><br><span class="line">24.4.5使用FileStream类读写二进制文件</span><br><span class="line">24.4.6读写文本文件</span><br><span class="line">24.5映射内存的文件</span><br><span class="line">24.6读取驱动器信息</span><br><span class="line">24.7文件的安全性</span><br><span class="line">24.7.1从文件中读取ACL</span><br><span class="line">24.7.2从目录中读取ACL</span><br><span class="line">24.7.3添加和删除文件中的ACL项</span><br><span class="line">24.8读写注册表</span><br><span class="line">24.8.1注册表</span><br><span class="line">24.8.2.NET注册表类</span><br><span class="line">24.9读写独立存储器</span><br><span class="line">24.10小结</span><br><span class="line">第25章事务处理</span><br><span class="line">25.1简介</span><br><span class="line">25.2概述</span><br><span class="line">25.2.1事务处理阶段</span><br><span class="line">25.2.2ACID属性</span><br><span class="line">25.3数据库和实体类</span><br><span class="line">25.4传统的事务</span><br><span class="line">25.4.1ADO.NET事务</span><br><span class="line">25.4.2System.Enterprise—Services</span><br><span class="line">25.5System.Transactions</span><br><span class="line">25.5.1可提交的事务</span><br><span class="line">25.5.2事务处理的升级</span><br><span class="line">25.5.3依赖事务</span><br><span class="line">25.5.4环境事务</span><br><span class="line">25.6隔离级别</span><br><span class="line">25.7自定义资源管理器</span><br><span class="line">25.8文件系统事务</span><br><span class="line">25.9小结</span><br><span class="line">第26章网络</span><br><span class="line">26.1网络</span><br><span class="line">26.2WebClient类</span><br><span class="line">26.2.1下载文件</span><br><span class="line">26.2.2基本的WebClient示例</span><br><span class="line">26.2.3上传文件</span><br><span class="line">26.3WebRequest类和WebResponse类</span><br><span class="line">26.3.1身份验证</span><br><span class="line">26.3.2使用代理</span><br><span class="line">26.3.3异步页面请求</span><br><span class="line">26.4把输出结果显示为HTML页面</span><br><span class="line">26.4.1从应用程序中进行简单的Web浏览</span><br><span class="line">26.4.2启动InternetExplorer实例</span><br><span class="line">26.4.3给应用程序提供更多IE类型的功能</span><br><span class="line">26.4.4使用WebBrowser控件打印</span><br><span class="line">26.4.5显示所请求页面的代码</span><br><span class="line">26.4.6WebRequest类和WebResponse类的层次结构</span><br><span class="line">26.5实用工具类</span><br><span class="line">26.5.1URI</span><br><span class="line">26.5.2IP地址和DNS名称</span><br><span class="line">26.6较低层的协议</span><br><span class="line">26.6.1使用SmtpClient</span><br><span class="line">26.6.2使用TCP类</span><br><span class="line">26.6.3TcpSend和TcpReceive示例</span><br><span class="line">26.6.4TCP和UDP</span><br><span class="line">26.6.5UDP类</span><br><span class="line">26.6.6Socket类</span><br><span class="line">26.6.7WebSocket</span><br><span class="line">26.7小结</span><br><span class="line">第27章Windows服务</span><br><span class="line">27.1Windows服务</span><br><span class="line">27.2Windows服务的体系结构</span><br><span class="line">27.2.1服务程序</span><br><span class="line">27.2.2服务控制程序</span><br><span class="line">27.2.3服务配置程序</span><br><span class="line">27.2.4Windows服务的类</span><br><span class="line">27.3创建Windows服务程序</span><br><span class="line">27.3.1创建服务的核心功能</span><br><span class="line">27.3.2QuoteClient示例</span><br><span class="line">27.3.3Windows服务程序</span><br><span class="line">27.3.4线程化和服务</span><br><span class="line">27.3.5服务的安装</span><br><span class="line">27.3.6安装程序</span><br><span class="line">27.4Windows服务的监控和控制</span><br><span class="line">27.4.1MMC管理单元</span><br><span class="line">27.4.2net.exe实用程序</span><br><span class="line">27.4.3sc.exe实用程序</span><br><span class="line">27.4.4VisualStudioServerExplorer</span><br><span class="line">27.4.5编写自定义ServiceController类</span><br><span class="line">27.5故障排除和事件日志</span><br><span class="line">27.6小结</span><br><span class="line">第28章本地化</span><br><span class="line">28.1全球市场</span><br><span class="line">28.2System.Globalization名称空间</span><br><span class="line">28.2.1Unicode问题</span><br><span class="line">28.2.2区域性和区域</span><br><span class="line">28.2.3使用区域性</span><br><span class="line">28.2.4排序</span><br><span class="line">28.3资源</span><br><span class="line">28.3.1创建资源文件</span><br><span class="line">28.3.2资源文件生成器</span><br><span class="line">28.3.3ResourceWriter</span><br><span class="line">28.3.4使用资源文件</span><br><span class="line">28.3.5System.Resources名称空间</span><br><span class="line">28.4使用VisualStudio的WindowsForms本地化</span><br><span class="line">28.4.1通过编程方式修改区域性</span><br><span class="line">28.4.2使用自定义资源消息</span><br><span class="line">28.4.3资源的自动回退</span><br><span class="line">28.4.4外包翻译</span><br><span class="line">28.5ASP.NETWebForms的本地化</span><br><span class="line">28.6用WPF本地化</span><br><span class="line">28.6.1用于WPF的.NET资源</span><br><span class="line">28.6.2XAML资源字典</span><br><span class="line">28.7自定义资源读取器</span><br><span class="line">28.7.1创建DatabaseResource—Reader类</span><br><span class="line">28.7.2创建DatabaseResource—Set类</span><br><span class="line">28.7.3创建DatabaseResource—Manager类</span><br><span class="line">28.7.4DatabaseResourceReader的客户端应用程序</span><br><span class="line">28.8创建自定义区域性</span><br><span class="line">28.9用WindowsStore应用程序进行本地化</span><br><span class="line">28.9.1使用资源</span><br><span class="line">28.9.2使用多语言应用程序工具集进行本地化</span><br><span class="line">28.10小结</span><br><span class="line">第29章核心XAML</span><br><span class="line">29.1XAML的作用</span><br><span class="line">29.2概述</span><br><span class="line">29.2.1元素如何映射到.NET对象上</span><br><span class="line">29.2.2使用自定义.NET类</span><br><span class="line">29.2.3把属性用作特性</span><br><span class="line">29.2.4把属性用作元素</span><br><span class="line">29.2.5基本的.NET类型</span><br><span class="line">29.2.6使用集合和XAML</span><br><span class="line">29.2.7用XAML代码调用构造函数</span><br><span class="line">29.3依赖属性</span><br><span class="line">29.3.1创建依赖属性</span><br><span class="line">29.3.2强制值回调</span><br><span class="line">29.3.3值变更回调和事件</span><br><span class="line">29.3.4事件的冒泡和隧道</span><br><span class="line">29.4附加属性</span><br><span class="line">29.5标记扩展</span><br><span class="line">29.6创建自定义标记扩展</span><br><span class="line">29.7XAML定义的标记扩展</span><br><span class="line">29.8读写XAML</span><br><span class="line">29.9小结</span><br><span class="line">第30章ManagedExtensibilityFramework</span><br><span class="line">30.1概述</span><br><span class="line">30.2MEF的体系结构</span><br><span class="line">30.2.1使用属性的MEF</span><br><span class="line">30.2.2基于约定的部件注册</span><br><span class="line">30.3定义协定</span><br><span class="line">30.4导出部件</span><br><span class="line">30.4.1创建部件</span><br><span class="line">30.4.2导出属性和方法</span><br><span class="line">30.4.3导出元数据</span><br><span class="line">30.4.4使用元数据进行惰性加载</span><br><span class="line">30.5导入部件</span><br><span class="line">30.5.1导入连接</span><br><span class="line">30.5.2部件的惰性加载</span><br><span class="line">30.5.3用惰性实例化的部件读取元数据</span><br><span class="line">30.6容器和出口提供程序</span><br><span class="line">30.7类别</span><br><span class="line">30.8小结</span><br><span class="line">第31章Windows运行库</span><br><span class="line">31.1概述</span><br><span class="line">31.1.1.NET与Windows运行库的比较</span><br><span class="line">31.1.2名称空间</span><br><span class="line">31.1.3元数据</span><br><span class="line">31.1.4语言投射</span><br><span class="line">31.1.5Windows运行库中的类型</span><br><span class="line">31.2Windows运行库组件</span><br><span class="line">31.2.1集合</span><br><span class="line">31.2.2流</span><br><span class="line">31.2.3委托与事件</span><br><span class="line">31.2.4异步操作</span><br><span class="line">31.3Windows8应用程序</span><br><span class="line">31.4Windows8应用程序的生命周期</span><br><span class="line">31.4.1Windows8应用程序的执行状态</span><br><span class="line">31.4.2SuspensionManager</span><br><span class="line">31.4.3导航状态</span><br><span class="line">31.4.4测试暂停</span><br><span class="line">31.4.5页面状态</span><br><span class="line">31.5Windows8应用程序的设置</span><br><span class="line">31.6摄像头功能</span><br><span class="line">31.7小结</span><br><span class="line">第Ⅳ部分数据</span><br><span class="line">第32章核心ADO.NET</span><br><span class="line">32.1ADO.NET概述</span><br><span class="line">32.1.1名称空间</span><br><span class="line">32.1.2共享类</span><br><span class="line">32.1.3数据库专用类</span><br><span class="line">32.2使用数据库连接</span><br><span class="line">32.2.1管理连接字符串</span><br><span class="line">32.2.2高效地使用连接</span><br><span class="line">32.2.3事务</span><br><span class="line">32.3命令</span><br><span class="line">32.3.1执行命令</span><br><span class="line">32.3.2调用存储过程</span><br><span class="line">32.4快速数据访问：数据读取器</span><br><span class="line">32.5异步数据访问：使用Task和await</span><br><span class="line">32.6管理数据和关系：DataSet类</span><br><span class="line">32.6.1数据表</span><br><span class="line">32.6.2数据列</span><br><span class="line">32.6.3数据关系</span><br><span class="line">32.6.4数据约束</span><br><span class="line">32.7XML架构：用XSD生成代码</span><br><span class="line">32.8填充DataSet类</span><br><span class="line">32.8.1用数据适配器填充DataSet</span><br><span class="line">32.8.2从XML中填充DataSet类</span><br><span class="line">32.9持久化DataSet类的修改</span><br><span class="line">32.9.1通过数据适配器进行更新</span><br><span class="line">32.9.2写入XML输出结果</span><br><span class="line">32.10使用ADO.NET</span><br><span class="line">32.10.1分层开发</span><br><span class="line">32.10.2生成SQLServer的键</span><br><span class="line">32.10.3命名约定</span><br><span class="line">32.11小结</span><br><span class="line">第33章ADO.NETEntityFramework</span><br><span class="line">33.1用EntityFramework编程</span><br><span class="line">33.2EntityFramework映射</span><br><span class="line">33.2.1逻辑层</span><br><span class="line">33.2.2概念层</span><br><span class="line">33.2.3映射层</span><br><span class="line">33.2.4连接字符串</span><br><span class="line">33.3实体</span><br><span class="line">33.4对象上下文</span><br><span class="line">33.5关系</span><br><span class="line">33.5.1一个层次结构一个表</span><br><span class="line">33.5.2一种类型一个表</span><br><span class="line">33.5.3懒惰加载、延迟加载和预先加载</span><br><span class="line">33.6查询数据</span><br><span class="line">33.6.1EntitySQL</span><br><span class="line">33.6.2对象查询</span><br><span class="line">33.6.3LINQtoEntities</span><br><span class="line">33.7把数据写入数据库</span><br><span class="line">33.7.1对象跟踪</span><br><span class="line">33.7.2改变信息</span><br><span class="line">33.7.3附加和分离实体</span><br><span class="line">33.7.4存储实体的变化</span><br><span class="line">33.8使用POCO对象</span><br><span class="line">33.8.1定义实体类型</span><br><span class="line">33.8.2创建数据上下文</span><br><span class="line">33.8.3查询和更新</span><br><span class="line">33.9使用CodeFirst编程模型</span><br><span class="line">33.9.1定义实体类型</span><br><span class="line">33.9.2创建数据上下文</span><br><span class="line">33.9.3创建数据库，存储实体</span><br><span class="line">33.9.4数据库</span><br><span class="line">33.9.5查询数据</span><br><span class="line">33.9.6定制数据库的生成</span><br><span class="line">33.10小结</span><br><span class="line">第34章处理XML</span><br><span class="line">34.1XML</span><br><span class="line">34.2.NET支持的XML标准</span><br><span class="line">34.3System.Xml名称空间</span><br><span class="line">34.4使用System.Xml类</span><br><span class="line">34.5读写流格式的XML</span><br><span class="line">34.5.1使用XmlReader类</span><br><span class="line">34.5.2使用XmlReader类进行验证</span><br><span class="line">34.5.3使用XmlWriter类</span><br><span class="line">34.6在.NET中使用DOM</span><br><span class="line">34.7使用XPathNavigator类</span><br><span class="line">34.7.1System.Xml.XPath名称空间</span><br><span class="line">34.7.2System.Xml.Xsl名称空间</span><br><span class="line">34.7.3调试XSLT</span><br><span class="line">34.8XML和ADO.NET</span><br><span class="line">34.8.1将ADO.NET数据转换为XML文档</span><br><span class="line">34.8.2把XML文档转换为ADO.NET数据</span><br><span class="line">34.9在XML中序列化对象</span><br><span class="line">34.10LINQtoXML和.NET</span><br><span class="line">34.11使用不同的XML对象</span><br><span class="line">34.11.1XDocument对象</span><br><span class="line">34.11.2XElement对象</span><br><span class="line">34.11.3XNamespace对象</span><br><span class="line">34.11.4XComment对象</span><br><span class="line">34.11.5XAttribute对象</span><br><span class="line">34.12使用LINQ查询XML文档</span><br><span class="line">34.12.1查询静态的XML文档</span><br><span class="line">34.12.2查询动态的XML文档</span><br><span class="line">34.13XML文档的更多查询技术</span><br><span class="line">34.13.1读取XML文档</span><br><span class="line">34.13.2写入XML文档</span><br><span class="line">34.14小结</span><br><span class="line">第Ⅴ部分显示</span><br><span class="line">第35章核心WPF</span><br><span class="line">35.1理解WPF</span><br><span class="line">35.1.1名称空间</span><br><span class="line">35.1.2类层次结构</span><br><span class="line">35.2形状</span><br><span class="line">35.3几何图形</span><br><span class="line">35.4变换</span><br><span class="line">35.5画笔</span><br><span class="line">35.5.1SolidColorBrush</span><br><span class="line">35.5.2LinearGradientBrush</span><br><span class="line">35.5.3RadialGradientBrush</span><br><span class="line">35.5.4DrawingBrush</span><br><span class="line">35.5.5ImageBrush</span><br><span class="line">35.5.6VisualBrush</span><br><span class="line">35.6控件</span><br><span class="line">35.6.1简单控件</span><br><span class="line">35.6.2内容控件</span><br><span class="line">35.6.3带标题的内容控件</span><br><span class="line">35.6.4项控件</span><br><span class="line">35.6.5带标题的项控件</span><br><span class="line">35.6.6修饰</span><br><span class="line">35.7布局</span><br><span class="line">35.7.1StackPanel</span><br><span class="line">35.7.2WrapPanel</span><br><span class="line">35.7.3Canvas</span><br><span class="line">35.7.4DockPanel</span><br><span class="line">35.7.5Grid</span><br><span class="line">35.8样式和资源</span><br><span class="line">35.8.1样式</span><br><span class="line">35.8.2资源</span><br><span class="line">35.8.3系统资源</span><br><span class="line">35.8.4从代码中访问资源</span><br><span class="line">35.8.5动态资源</span><br><span class="line">35.8.6资源字典</span><br><span class="line">35.9触发器</span><br><span class="line">35.9.1属性触发器</span><br><span class="line">35.9.2多触发器</span><br><span class="line">35.9.3数据触发器</span><br><span class="line">35.10模板</span><br><span class="line">35.10.1控件模板</span><br><span class="line">35.10.2数据模板</span><br><span class="line">35.10.3样式化列表框</span><br><span class="line">35.10.4ItemTemplate</span><br><span class="line">35.10.5列表框元素的控件模板</span><br><span class="line">35.11动画</span><br><span class="line">35.11.1时间轴</span><br><span class="line">35.11.2非线性动画</span><br><span class="line">35.11.3事件触发器</span><br><span class="line">35.11.4关键帧动画</span><br><span class="line">35.12可见状态管理器</span><br><span class="line">35.12.1可见的状态</span><br><span class="line">35.12.2变换</span><br><span class="line">35.133—D</span><br><span class="line">35.13.1模型</span><br><span class="line">35.13.2照相机</span><br><span class="line">35.13.3光线</span><br><span class="line">35.13.4旋转</span><br><span class="line">35.14小结</span><br><span class="line">第36章用WPF编写业务</span><br><span class="line">应用程序</span><br><span class="line">36.1概述</span><br><span class="line">36.2菜单和功能区控件</span><br><span class="line">36.2.1菜单控件</span><br><span class="line">36.2.2功能区控件</span><br><span class="line">36.3Commanding</span><br><span class="line">36.3.1定义命令</span><br><span class="line">36.3.2定义命令源</span><br><span class="line">36.3.3命令绑定</span><br><span class="line">36.4数据绑定</span><br><span class="line">36.4.1BooksDemo应用程序内容</span><br><span class="line">36.4.2用XAML绑定</span><br><span class="line">36.4.3简单对象的绑定</span><br><span class="line">36.4.4更改通知</span><br><span class="line">36.4.5对象数据提供程序</span><br><span class="line">36.4.6列表绑定</span><br><span class="line">36.4.7主从绑定</span><br><span class="line">36.4.8多绑定</span><br><span class="line">36.4.9优先绑定</span><br><span class="line">36.4.10值的转换</span><br><span class="line">36.4.11动态添加列表项</span><br><span class="line">36.4.12动态添加选项卡中的项</span><br><span class="line">36.4.13数据模板选择器</span><br><span class="line">36.4.14绑定到XML上</span><br><span class="line">36.4.15绑定的验证</span><br><span class="line">36.5TreeView</span><br><span class="line">36.6DataGrid</span><br><span class="line">36.6.1自定义列</span><br><span class="line">36.6.2行的细节</span><br><span class="line">36.6.3用DataGrid进行分组</span><br><span class="line">36.6.4实时成型</span><br><span class="line">36.7小结</span><br><span class="line">第37章用WPF创建文档</span><br><span class="line">37.1简介</span><br><span class="line">37.2文本元素</span><br><span class="line">37.2.1字体</span><br><span class="line">37.2.2TextEffect</span><br><span class="line">37.2.3内联</span><br><span class="line">37.2.4块</span><br><span class="line">37.2.5列表</span><br><span class="line">37.2.6表</span><br><span class="line">37.2.7块的锚定</span><br><span class="line">37.3流文档</span><br><span class="line">37.4固定文档</span><br><span class="line">37.5XPS文档</span><br><span class="line">37.6打印</span><br><span class="line">37.6.1用PrintDialog打印</span><br><span class="line">37.6.2打印可见元素</span><br><span class="line">37.7小结</span><br><span class="line">第38章Windows8应用程序</span><br><span class="line">38.1概述</span><br><span class="line">38.2Windows8的现代UI设计</span><br><span class="line">38.2.1内容，不是chrome设计</span><br><span class="line">38.2.2快速流畅</span><br><span class="line">38.2.3可读性</span><br><span class="line">38.3示例应用程序的核心功能</span><br><span class="line">38.3.1文件和目录</span><br><span class="line">38.3.2应用程序数据</span><br><span class="line">38.3.3应用程序页面</span><br><span class="line">38.4应用程序工具栏</span><br><span class="line">38.5启动与导航</span><br><span class="line">38.6布局的变化</span><br><span class="line">38.7存储</span><br><span class="line">38.7.1定义数据协定</span><br><span class="line">38.7.2写入移动数据</span><br><span class="line">38.7.3读取数据</span><br><span class="line">38.7.4写入图像</span><br><span class="line">38.7.5读取图像</span><br><span class="line">38.8选择器</span><br><span class="line">38.9共享协定</span><br><span class="line">38.9.1共享源</span><br><span class="line">38.9.2共享目标</span><br><span class="line">38.10Tile</span><br><span class="line">38.11小结</span><br><span class="line">第39章核心ASP.NET</span><br><span class="line">39.1用于Web应用程序的.NETFramework</span><br><span class="line">39.1.1ASP.NETWebForms</span><br><span class="line">39.1.2ASP.NETWebPages</span><br><span class="line">39.1.3ASP.NETMVC</span><br><span class="line">39.2Web技术</span><br><span class="line">39.2.1HTML</span><br><span class="line">39.2.2CSS</span><br><span class="line">39.2.3JavaScript和jQuery</span><br><span class="line">39.3托管和配置</span><br><span class="line">39.4处理程序和模块</span><br><span class="line">39.4.1创建自定义处理程序</span><br><span class="line">39.4.2ASP.NET处理程序</span><br><span class="line">39.4.3创建自定义模块</span><br><span class="line">39.4.4通用模块</span><br><span class="line">39.5全局的应用程序类</span><br><span class="line">39.6请求和响应</span><br><span class="line">39.6.1使用HttpRequest对象</span><br><span class="line">39.6.2使用HttpResponse对象</span><br><span class="line">39.7状态管理</span><br><span class="line">39.7.1视图状态</span><br><span class="line">39.7.2cookie</span><br><span class="line">39.7.3会话</span><br><span class="line">39.7.4应用程序状态</span><br><span class="line">39.7.5缓存</span><br><span class="line">39.7.6配置文件</span><br><span class="line">39.8成员和角色</span><br><span class="line">39.8.1配置成员</span><br><span class="line">39.8.2使用成员API</span><br><span class="line">39.8.3启用角色API</span><br><span class="line">39.9小结</span><br><span class="line">第40章ASP.NETWebForms</span><br><span class="line">40.1概述</span><br><span class="line">40.2ASPX页面模型</span><br><span class="line">40.2.1添加控件</span><br><span class="line">40.2.2使用事件</span><br><span class="line">40.2.3使用回送</span><br><span class="line">40.2.4使用自动回送</span><br><span class="line">40.2.5回送到其他页面</span><br><span class="line">40.2.6定义强类型化的跨页面回送</span><br><span class="line">40.2.7使用页面事件</span><br><span class="line">40.2.8ASPX代码</span><br><span class="line">40.2.9服务器端控件</span><br><span class="line">40.3母版页</span><br><span class="line">40.3.1创建母版页</span><br><span class="line">40.3.2使用母版页</span><br><span class="line">40.3.3在内容页中定义母版页内容</span><br><span class="line">40.4导航</span><br><span class="line">40.4.1站点地图</span><br><span class="line">40.4.2Menu控件</span><br><span class="line">40.4.3菜单路径</span><br><span class="line">40.5验证用户输入</span><br><span class="line">40.5.1使用验证控件</span><br><span class="line">40.5.2使用验证摘要</span><br><span class="line">40.5.3验证组</span><br><span class="line">40.6访问数据</span><br><span class="line">40.6.1使用EntityFramework</span><br><span class="line">40.6.2使用EntityDataSource</span><br><span class="line">40.6.3排序和编辑</span><br><span class="line">40.6.4定制列</span><br><span class="line">40.6.5在网格中使用模板</span><br><span class="line">40.6.6定制对象上下文的创建过程</span><br><span class="line">40.6.7对象数据源</span><br><span class="line">40.7安全性</span><br><span class="line">40.7.1启用表单身份验证</span><br><span class="line">40.7.2登录控件</span><br><span class="line">40.8Ajax</span><br><span class="line">40.8.1ASP.NETAJAX的概念</span><br><span class="line">40.8.2ASP.NETAJAX网站示例</span><br><span class="line">40.8.3支持ASP.NETAJAX的网站配置</span><br><span class="line">40.8.4添加ASP.NETAJAX功能</span><br><span class="line">40.9小结</span><br><span class="line">第41章ASP.NETMVC</span><br><span class="line">41.1ASP.NETMVC概述</span><br><span class="line">41.2定义路由</span><br><span class="line">41.2.1添加路由</span><br><span class="line">41.2.2路由约束</span><br><span class="line">41.3创建控制器</span><br><span class="line">41.3.1动作方法</span><br><span class="line">41.3.2参数</span><br><span class="line">41.3.3返回数据</span><br><span class="line">41.4创建视图</span><br><span class="line">41.4.1向视图传递数据</span><br><span class="line">41.4.2Razor语法</span><br><span class="line">41.4.3强类型视图</span><br><span class="line">41.4.4布局</span><br><span class="line">41.4.5部分视图</span><br><span class="line">41.5从客户端提交数据</span><br><span class="line">41.5.1模型绑定器</span><br><span class="line">41.5.2注释和验证</span><br><span class="line">41.6HTMLHelper</span><br><span class="line">41.6.1简单的Helper</span><br><span class="line">41.6.2使用模型数据</span><br><span class="line">41.6.3定义HTML特性</span><br><span class="line">41.6.4创建列表</span><br><span class="line">41.6.5强类型化的Helper</span><br><span class="line">41.6.6编辑器扩展</span><br><span class="line">41.6.7创建自定义Helper</span><br><span class="line">41.6.8模板</span><br><span class="line">41.7创建数据驱动的应用程序</span><br><span class="line">41.7.1定义模型</span><br><span class="line">41.7.2创建控制器和视图</span><br><span class="line">41.8动作过滤器</span><br><span class="line">41.9身份验证和授权</span><br><span class="line">41.9.1登录模型</span><br><span class="line">41.9.2登录控制器</span><br><span class="line">41.9.3登录视图</span><br><span class="line">41.10ASP.NETWebAPI</span><br><span class="line">41.10.1使用EntityFrameworkCode—First进行数据访问</span><br><span class="line">41.10.2为ASP.NETWebAPI定义路由</span><br><span class="line">41.10.3控制器实现</span><br><span class="line">41.10.4使用jQuery的客户端应用程序</span><br><span class="line">41.11小结</span><br><span class="line">第42章ASP.NET动态数据</span><br><span class="line">42.1概述</span><br><span class="line">42.2创建动态数据Web应用程序</span><br><span class="line">42.2.1配置Scaffolding</span><br><span class="line">42.2.2查看结果</span><br><span class="line">42.3定制动态数据网站</span><br><span class="line">42.3.1控制框架</span><br><span class="line">42.3.2定制模板</span><br><span class="line">42.3.3配置路由</span><br><span class="line">42.4小结</span><br><span class="line">第Ⅵ部分通信</span><br><span class="line">第43章WCF</span><br><span class="line">43.1WCF概述</span><br><span class="line">43.1.1SOAP</span><br><span class="line">43.1.2WSDL</span><br><span class="line">43.1.3REST</span><br><span class="line">43.1.4JSON</span><br><span class="line">43.2创建简单的服务和客户端</span><br><span class="line">43.2.1定义服务和数据协定</span><br><span class="line">43.2.2数据访问</span><br><span class="line">43.2.3服务的实现</span><br><span class="line">43.2.4WCF服务宿主和WCF测试客户端</span><br><span class="line">43.2.5自定义服务宿主</span><br><span class="line">43.2.6WCF客户端</span><br><span class="line">43.2.7诊断</span><br><span class="line">43.2.8与客户端共享协定程序集</span><br><span class="line">43.3协定</span><br><span class="line">43.3.1数据协定</span><br><span class="line">43.3.2版本问题</span><br><span class="line">43.3.3服务协定</span><br><span class="line">43.3.4消息协定</span><br><span class="line">43.3.5错误协定</span><br><span class="line">43.4服务的行为</span><br><span class="line">43.5绑定</span><br><span class="line">43.5.1标准的绑定</span><br><span class="line">43.5.2标准绑定的特性</span><br><span class="line">43.5.3Web套接字</span><br><span class="line">43.6宿主</span><br><span class="line">43.6.1自定义宿主</span><br><span class="line">43.6.2WAS宿主</span><br><span class="line">43.6.3预配置的宿主类</span><br><span class="line">43.7客户端</span><br><span class="line">43.7.1使用元数据</span><br><span class="line">43.7.2共享类型</span><br><span class="line">43.8双工通信</span><br><span class="line">43.8.1双工通信的协定</span><br><span class="line">43.8.2双工通信的服务</span><br><span class="line">43.8.3双工通信的客户端应用程序</span><br><span class="line">43.9路由</span><br><span class="line">43.9.1示例应用程序</span><br><span class="line">43.9.2路由接口</span><br><span class="line">43.9.3WCF路由服务</span><br><span class="line">43.9.4为失败使用路由器</span><br><span class="line">43.9.5改变协定的桥梁</span><br><span class="line">43.9.6过滤器的类型</span><br><span class="line">43.10小结</span><br><span class="line">第44章WCF数据服务</span><br><span class="line">44.1概述</span><br><span class="line">44.2包含CLR对象的自定义宿主</span><br><span class="line">44.2.1CLR对象</span><br><span class="line">44.2.2数据模型</span><br><span class="line">44.2.3数据服务</span><br><span class="line">44.2.4驻留服务</span><br><span class="line">44.2.5其他服务操作</span><br><span class="line">44.3HTTP客户端应用程序</span><br><span class="line">44.4使用WCF数据服务和ADO.NETEntityFramework</span><br><span class="line">44.4.1ASP.NET宿主和EDM</span><br><span class="line">44.4.2使用WCF数据服务客户库</span><br><span class="line">44.5小结</span><br><span class="line">第45章WindowsWF4</span><br><span class="line">45.1工作流概述</span><br><span class="line">45.2HelloWorld示例</span><br><span class="line">45.3活动</span><br><span class="line">45.3.1If活动</span><br><span class="line">45.3.2InvokeMethod活动</span><br><span class="line">45.3.3Parallel活动</span><br><span class="line">45.3.4Delay活动</span><br><span class="line">45.3.5Pick活动</span><br><span class="line">45.4自定义活动</span><br><span class="line">45.4.1活动的验证</span><br><span class="line">45.4.2设计器</span><br><span class="line">45.4.3自定义复合活动</span><br><span class="line">45.5工作流</span><br><span class="line">45.5.1实参和变量</span><br><span class="line">45.5.2WorkflowApplication</span><br><span class="line">45.5.3存放WCF工作流</span><br><span class="line">45.5.4工作流的版本</span><br><span class="line">45.5.5驻留设计器</span><br><span class="line">45.6小结</span><br><span class="line">第46章对等网络</span><br><span class="line">46.1P2P网络概述</span><br><span class="line">46.1.1客户端—服务器体系结构</span><br><span class="line">46.1.2P2P体系结构</span><br><span class="line">46.1.3P2P体系结构的挑战</span><br><span class="line">46.1.4P2P术语</span><br><span class="line">46.1.5P2P解决方案</span><br><span class="line">46.2PNRP</span><br><span class="line">46.3构建P2P应用程序</span><br><span class="line">46.4小结</span><br><span class="line">第47章消息队列</span><br><span class="line">47.1概述</span><br><span class="line">47.1.1使用消息队列的场合</span><br><span class="line">47.1.2消息队列功能</span><br><span class="line">47.2MessageQueuing产品</span><br><span class="line">47.3消息队列体系结构</span><br><span class="line">47.3.1消息</span><br><span class="line">47.3.2消息队列</span><br><span class="line">47.4MessageQueuing管理工具</span><br><span class="line">47.4.1创建消息队列</span><br><span class="line">47.4.2消息队列属性</span><br><span class="line">47.5消息队列的编程实现</span><br><span class="line">47.5.1创建消息队列</span><br><span class="line">47.5.2查找队列</span><br><span class="line">47.5.3打开已知队列</span><br><span class="line">47.5.4发送消息</span><br><span class="line">47.5.5接收消息</span><br><span class="line">47.6课程订单应用程序</span><br><span class="line">47.6.1课程订单类库</span><br><span class="line">47.6.2课程订单消息发送程序</span><br><span class="line">47.6.3发送优先级和可恢复的消息</span><br><span class="line">47.6.4课程订单消息接收应用程序</span><br><span class="line">47.7接收结果</span><br><span class="line">47.7.1确认队列</span><br><span class="line">47.7.2响应队列</span><br><span class="line">47.8事务队列</span><br><span class="line">47.9消息队列和WCF</span><br><span class="line">47.9.1带数据协定的实体类</span><br><span class="line">47.9.2WCF服务协定</span><br><span class="line">47.9.3WCF消息接收应用程序</span><br><span class="line">47.9.4WCF消息发送应用程序</span><br><span class="line">47.10消息队列的安装</span><br><span class="line">47.11小结</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00FFQ6L3O/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00FFQ6L3O&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51qC36vUOZL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵程序设计丛书 HTML5权威指南</title>
    <url>/2020/04/19/B00H706BIG/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 图灵程序设计丛书 HTML5权威指南<br>作者信息： 作者: 弗里曼 (Adam Freeman) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>作为下一代Web标准，HTML5致力于为互联网开发者搭建更加便捷、开放的沟通平台。业界普遍认为，在未来几年内，HTML5无疑将成为移动互联网领域的主宰者。《HTML5权威指南》是系统学习网页设计和移动设计的权威参考图书。它涵盖创建标准兼容、语义化的新一代HTML5网站的所有基础知识，并囊括实现HTML5核心语言的HTML5生态系统和相关API。全书精彩呈现500多个实战代码示例及主流浏览器实现效果图，贴心汇聚HTML5和CSS3中所有属性、元素和函数的简明参考表。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分 开篇</span><br><span class="line">第1章 HTML5背景知识 1</span><br><span class="line">1.1 HTML的历史 2</span><br><span class="line">1.1.1 JavaScript出场 2</span><br><span class="line">1.1.2 浏览器战争的结束 3</span><br><span class="line">1.1.3 插件称雄 3</span><br><span class="line">1.1.4 语义HTML浮出水面 3</span><br><span class="line">1.1.5 发展态势：HTML标准滞后于其使用 4</span><br><span class="line">1.2 HTML5简介 4</span><br><span class="line">1.2.1 新标准 4</span><br><span class="line">1.2.2 引入原生多媒体支持 5</span><br><span class="line">1.2.3 引入可编程内容 5</span><br><span class="line">1.2.4 引入语义Web 6</span><br><span class="line">1.3 HTML5现况 6</span><br><span class="line">1.3.1 浏览器对HTML5的支持情况 6</span><br><span class="line">1.3.2 网站对HTML5的支持情况 6</span><br><span class="line">1.4 本书结构 6</span><br><span class="line">1.5 HTML5的更多信息 7</span><br><span class="line">1.6 小结 7</span><br><span class="line">第2章 准备工作 8</span><br><span class="line">2.1 挑选浏览器 8</span><br><span class="line">2.2 挑选HTML编辑器 9</span><br><span class="line">2.3 挑选Web服务器 9</span><br><span class="line">2.4 获取Node.js 9</span><br><span class="line">2.5 获取示例代码 10</span><br><span class="line">2.6 小结 10</span><br><span class="line">第3章 初探HTML 11</span><br><span class="line">3.1 使用元素 12</span><br><span class="line">3.1.1 了解本章用到的元素 13</span><br><span class="line">3.1.2 使用空元素 14</span><br><span class="line">3.1.3 使用自闭合标签 14</span><br><span class="line">3.1.4 使用虚元素 14</span><br><span class="line">3.2 使用元素属性 16</span><br><span class="line">3.2.1 一个元素应用多个属性 16</span><br><span class="line">3.2.2 使用布尔属性 16</span><br><span class="line">3.2.3 使用自定义属性 17</span><br><span class="line">3.3 创建HTML文档 17</span><br><span class="line">3.3.1 外层结构 18</span><br><span class="line">3.3.2 元数据 19</span><br><span class="line">3.3.3 内容 19</span><br><span class="line">3.3.4 父元素、子元素、后代元素和兄弟元素 20</span><br><span class="line">3.3.5 了解元素类型 20</span><br><span class="line">3.4 使用HTML实体 21</span><br><span class="line">3.5 HTML5全局属性 21</span><br><span class="line">3.5.1 accesskey属性 21</span><br><span class="line">3.5.2 class属性 22</span><br><span class="line">3.5.3 contenteditable属性 25</span><br><span class="line">3.5.4 contextmenu属性 25</span><br><span class="line">3.5.5 dir属性 26</span><br><span class="line">3.5.6 draggable属性 26</span><br><span class="line">3.5.7 dropzone属性 26</span><br><span class="line">3.5.8 hidden属性 26</span><br><span class="line">3.5.9 id属性 28</span><br><span class="line">3.5.10 lang属性 29</span><br><span class="line">3.5.11 spellcheck属性 29</span><br><span class="line">3.5.12 style属性 30</span><br><span class="line">3.5.13 tabindex属性 30</span><br><span class="line">3.5.14 title属性 31</span><br><span class="line">3.6 有用的HTML工具 32</span><br><span class="line">3.7 小结 32</span><br><span class="line">第4章 初探CSS 33</span><br><span class="line">4.1 定义和应用样式 33</span><br><span class="line">4.1.1 了解本章所用的CSS属性 34</span><br><span class="line">4.1.2 使用元素内嵌样式 34</span><br><span class="line">4.1.3 使用文档内嵌样式 35</span><br><span class="line">4.1.4 使用外部样式表 37</span><br><span class="line">4.2 样式的层叠和继承 40</span><br><span class="line">4.2.1 浏览器样式 40</span><br><span class="line">4.2.2 用户样式 41</span><br><span class="line">4.2.3 样式如何层叠 42</span><br><span class="line">4.2.4 用重要样式调整层叠次序 42</span><br><span class="line">4.2.5 根据具体程度和定义次序解决同级样式冲突 43</span><br><span class="line">4.2.6 继承 46</span><br><span class="line">4.3 CSS中的颜色 48</span><br><span class="line">4.4 CSS中的长度 49</span><br><span class="line">4.4.1 绝对长度 50</span><br><span class="line">4.4.2 相对长度 51</span><br><span class="line">4.5 其他CSS单位 56</span><br><span class="line">4.5.1 使用CSS角度 56</span><br><span class="line">4.5.2 使用CSS时间 57</span><br><span class="line">4.6 测试CSS特性的支持情况 57</span><br><span class="line">4.7 有用的CSS工具 57</span><br><span class="line">4.7.1 浏览器样式报告 57</span><br><span class="line">4.7.2 用SelectorGadget生成选择器 58</span><br><span class="line">4.7.3 用LESS改进CSS 59</span><br><span class="line">4.7.4 使用CSS框架 59</span><br><span class="line">4.8 小结 59</span><br><span class="line">第5章 初探JavaScript 60</span><br><span class="line">5.1 准备使用JavaScript 61</span><br><span class="line">5.2 使用语句 62</span><br><span class="line">5.3 定义和使用函数 63</span><br><span class="line">5.3.1 定义带参数的函数 63</span><br><span class="line">5.3.2 定义会返回结果的函数 64</span><br><span class="line">5.4 使用变量和类型 65</span><br><span class="line">5.4.1 使用基本类型 66</span><br><span class="line">5.4.2 创建对象 67</span><br><span class="line">5.4.3 使用对象 69</span><br><span class="line">5.5 使用JavaScript运算符 73</span><br><span class="line">5.5.1 相等和等同运算符 73</span><br><span class="line">5.5.2 显式类型转换 76</span><br><span class="line">5.6 使用数组 78</span><br><span class="line">5.6.1 使用数组字面量 79</span><br><span class="line">5.6.2 读取和修改数组内容 80</span><br><span class="line">5.6.3 枚举数组内容 80</span><br><span class="line">5.6.4 使用内置的数组方法 81</span><br><span class="line">5.7 处理错误 81</span><br><span class="line">5.8 比较undefined和null值 83</span><br><span class="line">5.8.1 检查变量或属性是否为undefined或null 85</span><br><span class="line">5.8.2 区分null和undefined 85</span><br><span class="line">5.9 常用的JavaScript工具 86</span><br><span class="line">5.9.1 使用JavaScript调试器 86</span><br><span class="line">5.9.2 使用JavaScript库 86</span><br><span class="line">5.10 小结 87</span><br><span class="line">第二部分 HTML元素</span><br><span class="line">第6章 HTML5元素背景知识 90</span><br><span class="line">6.1 语义与呈现分离 90</span><br><span class="line">6.2 元素选用原则 91</span><br><span class="line">6.2.1 少亦可为多 91</span><br><span class="line">6.2.2 别误用元素 91</span><br><span class="line">6.2.3 具体为佳，一以贯之 91</span><br><span class="line">6.2.4 对用户不要想当然 92</span><br><span class="line">6.3 元素说明体例 92</span><br><span class="line">6.4 元素速览 92</span><br><span class="line">6.4.1 文档和元数据元素 92</span><br><span class="line">6.4.2 文本元素 93</span><br><span class="line">6.4.3 对内容分组 94</span><br><span class="line">6.4.4 划分内容 95</span><br><span class="line">6.4.5 制表 95</span><br><span class="line">6.4.6 创建表单 96</span><br><span class="line">6.4.7 嵌入内容 96</span><br><span class="line">6.5 未实现的元素 97</span><br><span class="line">6.6 小结 97</span><br><span class="line">第7章 创建HTML文档 98</span><br><span class="line">7.1 构筑基本的文档结构 99</span><br><span class="line">7.1.1 DOCTYPE元素 99</span><br><span class="line">7.1.2 html元素 99</span><br><span class="line">7.1.3 head元素 100</span><br><span class="line">7.1.4 body元素 101</span><br><span class="line">7.2 用元数据元素说明文档 102</span><br><span class="line">7.2.1 设置文档标题 102</span><br><span class="line">7.2.2 设置相对URL的解析基准 103</span><br><span class="line">7.2.3 用元数据说明文档 104</span><br><span class="line">7.2.4 定义CSS样式 108</span><br><span class="line">7.2.5 指定外部资源 112</span><br><span class="line">7.3 使用脚本元素 116</span><br><span class="line">7.3.1 script元素 117</span><br><span class="line">7.3.2 noscript元素 123</span><br><span class="line">7.4 小结 125</span><br><span class="line">第8章 标记文字 126</span><br><span class="line">8.1 生成超链接 127</span><br><span class="line">8.1.1 生成指向外部的超链接 128</span><br><span class="line">8.1.2 使用相对URL 129</span><br><span class="line">8.1.3 生成内部超链接 129</span><br><span class="line">8.1.4 设定浏览环境 130</span><br><span class="line">8.2 用基本的文字元素标记内容 131</span><br><span class="line">8.2.1 表示关键词和产品名称 131</span><br><span class="line">8.2.2 加以强调 132</span><br><span class="line">8.2.3 表示外文词语或科技术语 133</span><br><span class="line">8.2.4 表示不准确或校正 134</span><br><span class="line">8.2.5 表示重要的文字 135</span><br><span class="line">8.2.6 为文字添加下划线 136</span><br><span class="line">8.2.7 添加小号字体内容 137</span><br><span class="line">8.2.8 添加上标和下标 138</span><br><span class="line">8.3 换行 139</span><br><span class="line">8.3.1 强制换行 139</span><br><span class="line">8.3.2 指明可以安全换行的建议位置 141</span><br><span class="line">8.4 表示输入和输出 142</span><br><span class="line">8.5 使用标题引用、引文、定义和缩写 143</span><br><span class="line">8.5.1 表示缩写 143</span><br><span class="line">8.5.2 定义术语 144</span><br><span class="line">8.5.3 引用来自他处的内容 145</span><br><span class="line">8.5.4 引用其他作品的标题 146</span><br><span class="line">8.6 使用语言元素 147</span><br><span class="line">8.6.1 ruby、rt和rp元素 147</span><br><span class="line">8.6.2 bdo元素 149</span><br><span class="line">8.6.3 bdi元素 150</span><br><span class="line">8.7 其他文本元素 152</span><br><span class="line">8.7.1 表示一段一般性的内容 152</span><br><span class="line">8.7.2 突出显示文本 153</span><br><span class="line">8.7.3 表示添加和删除的内容 155</span><br><span class="line">8.7.4 表示时间和日期 156</span><br><span class="line">8.8 小结 157</span><br><span class="line">第9章 组织内容 158</span><br><span class="line">9.1 为什么要对内容分组 158</span><br><span class="line">9.2 建立段落 159</span><br><span class="line">9.3 使用div元素 161</span><br><span class="line">9.4 使用预先编排好格式的内容 163</span><br><span class="line">9.5 引用他处内容 164</span><br><span class="line">9.6 添加主题分隔 166</span><br><span class="line">9.7 将内容组织为列表 169</span><br><span class="line">9.7.1 ol元素 169</span><br><span class="line">9.7.2 ul元素 171</span><br><span class="line">9.7.3 li元素 172</span><br><span class="line">9.7.4 生成说明列表 173</span><br><span class="line">9.7.5 生成自定义列表 174</span><br><span class="line">9.8 使用插图 176</span><br><span class="line">9.9 小结 178</span><br><span class="line">第10章 文档分节 179</span><br><span class="line">10.1 添加基本的标题 179</span><br><span class="line">10.2 隐藏子标题 182</span><br><span class="line">10.3 生成节 185</span><br><span class="line">10.4 添加首部和尾部 188</span><br><span class="line">10.5 添加导航区域 191</span><br><span class="line">10.6 使用article 194</span><br><span class="line">10.7 生成附注栏 198</span><br><span class="line">10.8 提供联系信息 201</span><br><span class="line">10.9 生成详情区域 202</span><br><span class="line">10.10 小结 205</span><br><span class="line">第11章 表格元素 206</span><br><span class="line">11.1 生成基本的表格 206</span><br><span class="line">11.2 添加表头单元格 209</span><br><span class="line">11.3 为表格添加结构 211</span><br><span class="line">11.3.1 表示表头和表格主题 212</span><br><span class="line">11.3.2 添加表脚 214</span><br><span class="line">11.4 制作不规则表格 216</span><br><span class="line">11.5 把表头与单元格关联起来 220</span><br><span class="line">11.6 为表格添加标题 221</span><br><span class="line">11.7 处理列 223</span><br><span class="line">11.8 设置表格边框 228</span><br><span class="line">11.9 小结 230</span><br><span class="line">第12章 表单 231</span><br><span class="line">12.1 制作基本表单 232</span><br><span class="line">12.1.1 定义表单 233</span><br><span class="line">12.1.2 查看表单数据 234</span><br><span class="line">12.2 配置表单 236</span><br><span class="line">12.2.1 配置表单的action属性 236</span><br><span class="line">12.2.2 配置HTTP方法属性 237</span><br><span class="line">12.2.3 配置数据编码 237</span><br><span class="line">12.2.4 控制表单的自动完成功能 239</span><br><span class="line">12.2.5 指定表单反馈信息的目标显示位置 240</span><br><span class="line">12.2.6 设置表单名称 242</span><br><span class="line">12.3 在表单中添加说明标签 242</span><br><span class="line">12.4 自动聚焦到某个input元素 244</span><br><span class="line">12.5 禁用单个input元素 245</span><br><span class="line">12.6 对表单元素编组 246</span><br><span class="line">12.6.1 为fieldset元素添加说明标签 248</span><br><span class="line">12.6.2 用fieldset禁用整组input元素 249</span><br><span class="line">12.7 使用button元素 250</span><br><span class="line">12.7.1 用button元素提交表单 251</span><br><span class="line">12.7.2 用button元素重置表单 252</span><br><span class="line">12.7.3 把button作为一般元素使用 253</span><br><span class="line">12.8 使用表单外的元素 254</span><br><span class="line">12.9 小结 254</span><br><span class="line">第13章 定制input元素 255</span><br><span class="line">13.1 用input元素输入文字 256</span><br><span class="line">13.1.1 设定元素大小 256</span><br><span class="line">13.1.2 设置初始值和占位式提示 258</span><br><span class="line">13.1.3 使用数据列表 259</span><br><span class="line">13.1.4 生成只读或被禁用的文本框 262</span><br><span class="line">13.1.5 指定文字方向数据的名称 263</span><br><span class="line">13.2 用input元素输入密码 263</span><br><span class="line">13.3 用input元素生成按钮 266</span><br><span class="line">13.4 用input元素为输入数据把关 267</span><br><span class="line">13.4.1 用input元素获取数值 268</span><br><span class="line">13.4.2 用input元素获取指定范围内的数值 270</span><br><span class="line">13.4.3 用input元素获取布尔型输入 271</span><br><span class="line">13.4.4 用input元素生成一组固定选项 273</span><br><span class="line">13.4.5 用input元素获取有规定格式的字符串 275</span><br><span class="line">13.4.6 用input元素获取时间和日期 277</span><br><span class="line">13.4.7 用input元素获取颜色值 279</span><br><span class="line">13.5 用input元素获取搜索用词 281</span><br><span class="line">13.6 用input元素生成隐藏的数据项 282</span><br><span class="line">13.7 用input元素生成图像按钮和分区响应图 284</span><br><span class="line">13.8 用input元素上传文件 286</span><br><span class="line">13.9 小结 288</span><br><span class="line">第14章 其他表单元素及输入验证 289</span><br><span class="line">14.1 使用其他表单元素 289</span><br><span class="line">14.1.1 生成选项列表 289</span><br><span class="line">14.1.2 输入多行文字 294</span><br><span class="line">14.1.3 表示计算结果 296</span><br><span class="line">14.1.4 生成公开&#x2F;私有密钥对 297</span><br><span class="line">14.2 使用输入验证 298</span><br><span class="line">14.2.1 确保用户提供了一个值 299</span><br><span class="line">14.2.2 确保输入值位于某个范围内 300</span><br><span class="line">14.2.3 确保输入值与指定模式匹配 301</span><br><span class="line">14.2.4 确保输入值是电子邮箱地址或URL 303</span><br><span class="line">14.3 禁用输入验证 304</span><br><span class="line">14.4 小结 305</span><br><span class="line">第15章 嵌入内容 306</span><br><span class="line">15.1 嵌入图像 306</span><br><span class="line">15.1.1 在超链接里嵌入图像 308</span><br><span class="line">15.1.2 创建客户端分区响应图 310</span><br><span class="line">15.2 嵌入另一张HTML文档 313</span><br><span class="line">15.3 通过插件嵌入内容 315</span><br><span class="line">15.3.1 使用embed元素 315</span><br><span class="line">15.3.2 使用object和param元素 317</span><br><span class="line">15.4 object元素的其他用途 319</span><br><span class="line">15.4.1 使用object元素嵌入图像 319</span><br><span class="line">15.4.2 使用object元素创建分区响应图 320</span><br><span class="line">15.4.3 将object元素作为浏览上下文环境 320</span><br><span class="line">15.5 嵌入数字表现形式 321</span><br><span class="line">15.5.1 显示进度 321</span><br><span class="line">15.5.2 显示范围里的值 322</span><br><span class="line">15.6 其他嵌入元素 324</span><br><span class="line">15.6.1 嵌入音频和视频 324</span><br><span class="line">15.6.2 嵌入图形 324</span><br><span class="line">15.7 小结 324</span><br><span class="line">第三部分 CSS</span><br><span class="line">第16章 理解CSS 326</span><br><span class="line">16.1 CSS标准化 326</span><br><span class="line">16.2 盒模型 327</span><br><span class="line">16.3 选择器简明参考 328</span><br><span class="line">16.4 属性简明参考 329</span><br><span class="line">16.4.1 边框和背景属性 329</span><br><span class="line">16.4.2 盒模型属性 331</span><br><span class="line">16.4.3 布局属性 332</span><br><span class="line">16.4.4 文本属性 332</span><br><span class="line">16.4.5 过渡、动画和变换属性 333</span><br><span class="line">16.4.6 其他属性 334</span><br><span class="line">16.5 小结 334</span><br><span class="line">第17章 使用CSS选择器（第Ⅰ部分） 335</span><br><span class="line">17.1 使用CSS基本选择器 335</span><br><span class="line">17.1.1 选择所有元素 336</span><br><span class="line">17.1.2 根据类型选择元素 337</span><br><span class="line">17.1.3 根据类选择元素 338</span><br><span class="line">17.1.4 根据ID选择元素 340</span><br><span class="line">17.1.5 根据属性选择元素 341</span><br><span class="line">17.2 复合选择器 344</span><br><span class="line">17.2.1 并集选择器 344</span><br><span class="line">17.2.2 后代选择器 345</span><br><span class="line">17.2.3 选择子元素 347</span><br><span class="line">17.2.4 选择兄弟元素 349</span><br><span class="line">17.3 使用伪元素选择器 351</span><br><span class="line">17.3.1 使用：：first—line选择器 351</span><br><span class="line">17.3.2 使用：：first—letter选择器 352</span><br><span class="line">17.3.3 使用：before和：after选择器 353</span><br><span class="line">17.3.4 使用CSS计数器 354</span><br><span class="line">17.4 小结 356</span><br><span class="line">第18章 使用CSS选择器（第Ⅱ部分） 357</span><br><span class="line">18.1 使用结构性伪类选择器 357</span><br><span class="line">18.1.1 使用根元素选择器 358</span><br><span class="line">18.1.2 使用子元素选择器 359</span><br><span class="line">18.1.3 使用：nth—child选择器 363</span><br><span class="line">18.2 使用UI伪类选择器 364</span><br><span class="line">18.2.1 选择启用或禁用元素 364</span><br><span class="line">18.2.2 选择已勾选的元素 365</span><br><span class="line">18.2.3 选择默认元素 366</span><br><span class="line">18.2.4 选择有效和无效的input元素 367</span><br><span class="line">18.2.5 选择限定范围的input元素 369</span><br><span class="line">18.2.6 选择必需和可选的input元素 370</span><br><span class="line">18.3 使用动态伪类选择器 371</span><br><span class="line">18.3.1 使用：link和：visited选择器 371</span><br><span class="line">18.3.2 使用：hover选择器 372</span><br><span class="line">18.3.3 使用：active选择器 373</span><br><span class="line">18.3.4 使用：focus选择器 374</span><br><span class="line">18.4 其他伪类选择器 375</span><br><span class="line">18.4.1 使用否定选择器 376</span><br><span class="line">18.4.2 使用：empty选择器 376</span><br><span class="line">18.4.3 使用：lang选择器 377</span><br><span class="line">18.4.4 使用：target选择器 377</span><br><span class="line">18.5 小结 379</span><br><span class="line">第19章 使用边框和背景 380</span><br><span class="line">19.1 应用边框样式 380</span><br><span class="line">19.1.1 定义边框宽度 381</span><br><span class="line">19.1.2 定义边框样式 382</span><br><span class="line">19.1.3 为一条边应用边框样式 383</span><br><span class="line">19.1.4 使用border简写属性 384</span><br><span class="line">19.1.5 创建圆角边框 385</span><br><span class="line">19.1.6 将图像用做边框 388</span><br><span class="line">19.2 设置元素的背景 392</span><br><span class="line">19.2.1 设置背景颜色和图像 392</span><br><span class="line">19.2.2 设置背景图像的尺寸 394</span><br><span class="line">19.2.3 设置背景图像位置 395</span><br><span class="line">19.2.4 设置元素的背景附着方式 396</span><br><span class="line">19.2.5 设置背景图像的开始位置和裁剪样式 397</span><br><span class="line">19.2.6 使用background简写属性 399</span><br><span class="line">19.3 创建盒子阴影 400</span><br><span class="line">19.4 应用轮廓 403</span><br><span class="line">19.5 小结 405</span><br><span class="line">第20章 使用盒模型 406</span><br><span class="line">20.1 为元素应用内边距 407</span><br><span class="line">20.2 为元素应用外边距 409</span><br><span class="line">20.3 控制元素的尺寸 410</span><br><span class="line">20.3.1 设置一定尺寸的盒子 412</span><br><span class="line">20.3.2 设置最小和最大尺寸 413</span><br><span class="line">20.4 处理溢出内容 414</span><br><span class="line">20.5 控制元素的可见性 417</span><br><span class="line">20.6 设置元素的盒类型 419</span><br><span class="line">20.6.1 认识块级元素 420</span><br><span class="line">20.6.2 认识行内元素 421</span><br><span class="line">20.6.3 认识行内？块级元素 422</span><br><span class="line">20.6.4 认识插入元素 423</span><br><span class="line">20.6.5 隐藏元素 426</span><br><span class="line">20.7 创建浮动盒 427</span><br><span class="line">20.8 小结 433</span><br><span class="line">第21章 创建布局 434</span><br><span class="line">21.1 定位内容 434</span><br><span class="line">21.1.1 设置定位类型 435</span><br><span class="line">21.1.2 设置元素的层叠顺序 437</span><br><span class="line">21.2 创建多列布局 439</span><br><span class="line">21.3 创建弹性盒布局 442</span><br><span class="line">21.3.1 创建简单的弹性盒 444</span><br><span class="line">21.3.2 伸缩多个元素 446</span><br><span class="line">21.3.3 处理垂直空间 447</span><br><span class="line">21.3.4 处理最大尺寸 448</span><br><span class="line">21.4 创建表格布局 450</span><br><span class="line">21.5 小结 453</span><br><span class="line">第22章 设置文本样式 454</span><br><span class="line">22.1 应用基本文本样式 454</span><br><span class="line">22.1.1 对齐文本 455</span><br><span class="line">22.1.2 处理空白 457</span><br><span class="line">22.1.3 指定文本方向 460</span><br><span class="line">22.1.4 指定单词、字母、行之间的间距 461</span><br><span class="line">22.1.5 控制断词 462</span><br><span class="line">22.1.6 首行缩进 464</span><br><span class="line">22.2 文本装饰与大小写转换 465</span><br><span class="line">22.3 创建文本阴影 467</span><br><span class="line">22.4 使用字体 468</span><br><span class="line">22.4.1 选择字体 469</span><br><span class="line">22.4.2 设置字体大小 470</span><br><span class="line">22.4.3 设置字体样式和粗细 472</span><br><span class="line">22.5 使用Web字体 473</span><br><span class="line">22.6 小结 475</span><br><span class="line">第23章 过渡、动画和变换 476</span><br><span class="line">23.1 使用过渡 477</span><br><span class="line">23.1.1 创建反向过渡 480</span><br><span class="line">23.1.2 选择中间值的计算方式 481</span><br><span class="line">23.2 使用动画 483</span><br><span class="line">23.2.1 使用关键帧 486</span><br><span class="line">23.2.2 设置重复方向 488</span><br><span class="line">23.2.3 理解结束状态 490</span><br><span class="line">23.2.4 初始布局时应用动画 491</span><br><span class="line">23.2.5 重用关键帧 492</span><br><span class="line">23.2.6 为多个元素应用多个动画 493</span><br><span class="line">23.2.7 停止和启动动画 495</span><br><span class="line">23.3 使用变换 497</span><br><span class="line">23.3.1 应用变换 497</span><br><span class="line">23.3.2 指定元素变换的起点 498</span><br><span class="line">23.3.3 将变换作为动画和过渡处理 500</span><br><span class="line">23.4 小结 501</span><br><span class="line">第24章 其他CSS属性和特性 502</span><br><span class="line">24.1 设置元素的颜色和透明度 502</span><br><span class="line">24.1.1 设置前景色 502</span><br><span class="line">24.1.2 设置元素的透明度 504</span><br><span class="line">24.2 设置表格样式 505</span><br><span class="line">24.2.1 合并表格边框 505</span><br><span class="line">24.2.2 配置独立边框 507</span><br><span class="line">24.2.3 处理空单元格 508</span><br><span class="line">24.2.4 设置标题的位置 509</span><br><span class="line">24.2.5 指定表格布局 511</span><br><span class="line">24.3 设置列表样式 512</span><br><span class="line">24.3.1 设置列表标记类型 513</span><br><span class="line">24.3.2 使用图像作为列表标记 514</span><br><span class="line">24.3.3 设置列表标记的位置 515</span><br><span class="line">24.4 设置光标样式 517</span><br><span class="line">24.5 小结 518</span><br><span class="line">第四部分 使用DOM</span><br><span class="line">第25章 理解DOM 520</span><br><span class="line">25.1 理解文档对象模型 520</span><br><span class="line">25.2 理解DOMLevel和兼容性 522</span><br><span class="line">25.3 DOM快速查询 524</span><br><span class="line">25.3.1 Document的成员 524</span><br><span class="line">25.3.2 Window的成员 525</span><br><span class="line">25.3.3 HTMLElement的成员 527</span><br><span class="line">25.3.4 DOM里的CSS属性 529</span><br><span class="line">25.3.5 DOM中的事件 531</span><br><span class="line">25.4 小结 532</span><br><span class="line">第26章 使用Document对象 533</span><br><span class="line">26.1 使用Document元数据 536</span><br><span class="line">26.1.1 获取文档信息 536</span><br><span class="line">26.1.2 使用Location对象 537</span><br><span class="line">26.1.3 读取和写入cookie 541</span><br><span class="line">26.1.4 理解就绪状态 542</span><br><span class="line">26.1.5 获取DOM的实现情况 543</span><br><span class="line">26.2 获取HTML元素对象 544</span><br><span class="line">26.2.1 使用属性获取元素对象 545</span><br><span class="line">26.2.2 使用数组标记获取已命名元素 546</span><br><span class="line">26.2.3 搜索元素 548</span><br><span class="line">26.2.4 合并进行链式搜索 550</span><br><span class="line">26.3 在DOM树里导航 552</span><br><span class="line">26.4 小结 554</span><br><span class="line">第27章 使用Window对象 555</span><br><span class="line">27.1 获取Window对象 555</span><br><span class="line">27.2 获取窗口信息 556</span><br><span class="line">27.3 与窗口进行交互 558</span><br><span class="line">27.4 对用户进行提示 559</span><br><span class="line">27.5 获取基本信息 561</span><br><span class="line">27.6 使用浏览器历史 561</span><br><span class="line">27.6.1 在浏览历史中导航 562</span><br><span class="line">27.6.2 在浏览历史里插入条目 564</span><br><span class="line">27.6.3 为不同的文档添加条目 566</span><br><span class="line">27.6.4 在浏览历史中保存复杂状态 567</span><br><span class="line">27.6.5 替换浏览历史中的条目 570</span><br><span class="line">27.7 使用跨文档消息传递 570</span><br><span class="line">27.8 使用计时器 574</span><br><span class="line">27.9 小结 576</span><br><span class="line">第28章 使用DOM元素 577</span><br><span class="line">28.1 使用元素对象 577</span><br><span class="line">28.1.1 使用类 579</span><br><span class="line">28.1.2 使用元素属性 582</span><br><span class="line">28.2 使用Text对象 586</span><br><span class="line">28.3 修改模型 588</span><br><span class="line">28.3.1 创建和删除元素 589</span><br><span class="line">28.3.2 复制元素 591</span><br><span class="line">28.3.3 移动元素 592</span><br><span class="line">28.3.4 比较元素对象 593</span><br><span class="line">28.3.5 使用HTML片段 595</span><br><span class="line">28.3.6 向文本块插入元素 600</span><br><span class="line">28.4 小结 601</span><br><span class="line">第29章 为DOM元素设置样式 602</span><br><span class="line">29.1 使用样式表 602</span><br><span class="line">29.1.1 获得样式表的基本信息 603</span><br><span class="line">29.1.2 使用媒介限制 605</span><br><span class="line">29.1.3 禁用样式表 607</span><br><span class="line">29.1.4 CSSRuleList对象的成员 608</span><br><span class="line">29.2 使用元素样式 611</span><br><span class="line">29.3 使用CSSStyleDeclaration对象 613</span><br><span class="line">29.3.1 使用便捷属性 613</span><br><span class="line">29.3.2 使用常规属性 616</span><br><span class="line">29.3.3 使用细粒度的CSSDOM对象 620</span><br><span class="line">29.4 使用计算样式 623</span><br><span class="line">29.5 小结 625</span><br><span class="line">第30章 使用事件 626</span><br><span class="line">30.1 使用简单事件处理器 627</span><br><span class="line">30.1.1 实现简单的内联事件处理器 627</span><br><span class="line">30.1.2 实现一个简单的事件处理函数 629</span><br><span class="line">30.2 使用DOM和事件对象 630</span><br><span class="line">30.2.1 按类型区分事件 633</span><br><span class="line">30.2.2 理解事件流 634</span><br><span class="line">30.2.3 使用可撤销事件 641</span><br><span class="line">30.3 使用HTML事件 642</span><br><span class="line">30.3.1 文档和窗口事件 642</span><br><span class="line">30.3.2 使用鼠标事件 643</span><br><span class="line">30.3.3 使用键盘焦点事件 645</span><br><span class="line">30.3.4 使用键盘事件 647</span><br><span class="line">30.3.5 使用表单事件 649</span><br><span class="line">30.4 小结 649</span><br><span class="line">第31章 使用元素专属对象 650</span><br><span class="line">31.1 文档和元数据对象 650</span><br><span class="line">31.1.1 base元素 650</span><br><span class="line">31.1.2 body元素 650</span><br><span class="line">31.1.3 link元素 651</span><br><span class="line">31.1.4 meta元素 651</span><br><span class="line">31.1.5 script元素 651</span><br><span class="line">31.1.6 style元素 652</span><br><span class="line">31.1.7 title元素 652</span><br><span class="line">31.1.8 其他文档和元数据元素 652</span><br><span class="line">31.2 文本元素 652</span><br><span class="line">31.2.1 a元素 652</span><br><span class="line">31.2.2 del和ins元素 653</span><br><span class="line">31.2.3 q元素 653</span><br><span class="line">31.2.4 time元素 653</span><br><span class="line">31.2.5 其他文本元素 654</span><br><span class="line">31.3 分组元素 654</span><br><span class="line">31.3.1 blockquote元素 654</span><br><span class="line">31.3.2 li元素 654</span><br><span class="line">31.3.3 ol元素 654</span><br><span class="line">31.3.4 其他分组元素 655</span><br><span class="line">31.4 区块元素 655</span><br><span class="line">31.4.1 details元素 655</span><br><span class="line">31.4.2 其他区块元素 655</span><br><span class="line">31.5 表格元素 655</span><br><span class="line">31.5.1 col和colgroup元素 655</span><br><span class="line">31.5.2 table元素 656</span><br><span class="line">31.5.3 thead、tbody和tfoot元素 656</span><br><span class="line">31.5.4 th元素 657</span><br><span class="line">31.5.5 tr元素 657</span><br><span class="line">31.5.6 其他表格元素 657</span><br><span class="line">31.6 表单元素 657</span><br><span class="line">31.6.1 button元素 657</span><br><span class="line">31.6.2 datalist元素 658</span><br><span class="line">31.6.3 fieldset元素 658</span><br><span class="line">31.6.4 form元素 658</span><br><span class="line">31.6.5 input元素 659</span><br><span class="line">31.6.6 label元素 660</span><br><span class="line">31.6.7 legend元素 661</span><br><span class="line">31.6.8 optgroup元素 661</span><br><span class="line">31.6.9 option元素 661</span><br><span class="line">31.6.10 output元素 661</span><br><span class="line">31.6.11 select元素 662</span><br><span class="line">31.6.12 textarea元素 663</span><br><span class="line">31.7 内容元素 663</span><br><span class="line">31.7.1 area元素 664</span><br><span class="line">31.7.2 embed元素 664</span><br><span class="line">31.7.3 iframe元素 664</span><br><span class="line">31.7.4 img元素 665</span><br><span class="line">31.7.5 map元素 665</span><br><span class="line">31.7.6 meter元素 665</span><br><span class="line">31.7.7 object元素 666</span><br><span class="line">31.7.8 param元素 666</span><br><span class="line">31.7.9 progress元素 667</span><br><span class="line">31.8 小结 667</span><br><span class="line">第五部分 高级功能</span><br><span class="line">第32章 使用Ajax（第Ⅰ部分） 670</span><br><span class="line">32.1 Ajax起步 671</span><br><span class="line">32.1.1 处理响应 674</span><br><span class="line">32.1.2 主流中的异类：应对Opera 675</span><br><span class="line">32.2 使用Ajax事件 677</span><br><span class="line">32.3 处理错误 679</span><br><span class="line">32.3.1 处理设置错误 681</span><br><span class="line">32.3.2 处理请求错误 682</span><br><span class="line">32.3.3 处理应用程序错误 682</span><br><span class="line">32.4 获取和设置标头 683</span><br><span class="line">32.4.1 覆盖请求的HTTP方法 683</span><br><span class="line">32.4.2 禁用内容缓存 685</span><br><span class="line">32.4.3 读取响应标头 685</span><br><span class="line">32.5 生成跨源Ajax请求 687</span><br><span class="line">32.5.1 使用Origin请求标头 690</span><br><span class="line">32.5.2 高级CORS功能 691</span><br><span class="line">32.6 中止请求 691</span><br><span class="line">32.7 小结 693</span><br><span class="line">第33章 使用Ajax（第Ⅱ部分） 694</span><br><span class="line">33.1 准备向服务器发送数据 694</span><br><span class="line">33.1.1 定义服务器 695</span><br><span class="line">33.1.2 理解问题所在 697</span><br><span class="line">33.2 发送表单数据 698</span><br><span class="line">33.3 使用FormData对象发送表单数据 701</span><br><span class="line">33.3.1 创建FormData对象 701</span><br><span class="line">33.3.2 修改FormData对象 702</span><br><span class="line">33.4 发送JSON数据 703</span><br><span class="line">33.5 发送文件 705</span><br><span class="line">33.6 追踪上传进度 707</span><br><span class="line">33.7 请求并处理不同内容类型 709</span><br><span class="line">33.7.1 接收HTML片段 709</span><br><span class="line">33.7.2 接收XML数据 712</span><br><span class="line">33.7.3 接收JSON数据 714</span><br><span class="line">33.8 小结 715</span><br><span class="line">第34章 使用多媒体 716</span><br><span class="line">34.1 使用video元素 717</span><br><span class="line">34.1.1 预先加载视频 718</span><br><span class="line">34.1.2 显示占位图像 720</span><br><span class="line">34.1.3 设置视频尺寸 720</span><br><span class="line">34.1.4 指定视频来源（和格式） 721</span><br><span class="line">34.1.5 track元素 724</span><br><span class="line">34.2 使用audio元素 724</span><br><span class="line">34.3 通过DOM操作嵌入式媒体 726</span><br><span class="line">34.3.1 获得媒体信息 726</span><br><span class="line">34.3.2 评估回放能力 728</span><br><span class="line">34.3.3 控制媒体回放 730</span><br><span class="line">34.4 小结 733</span><br><span class="line">第35章 使用canvas元素（第Ⅰ部分） 734</span><br><span class="line">35.1 开始使用canvas元素 735</span><br><span class="line">35.2 获取画布的上下文 736</span><br><span class="line">35.3 绘制矩形 737</span><br><span class="line">35.4 设置画布绘制状态 739</span><br><span class="line">35.4.1 设置线条连接样式 741</span><br><span class="line">35.4.2 设置填充和笔触样式 742</span><br><span class="line">35.4.3 使用渐变 743</span><br><span class="line">35.4.4 使用径向渐变 748</span><br><span class="line">35.4.5 使用图案 751</span><br><span class="line">35.5 保存和恢复绘制状态 753</span><br><span class="line">35.6 绘制图像 755</span><br><span class="line">35.6.1 使用视频图像 756</span><br><span class="line">35.6.2 使用画布图像 759</span><br><span class="line">35.7 小结 761</span><br><span class="line">第36章 使用canvas元素（第Ⅱ部分） 762</span><br><span class="line">36.1 用路径绘图 762</span><br><span class="line">36.1.1 用线条绘制路径 763</span><br><span class="line">36.1.2 绘制矩形 766</span><br><span class="line">36.2 绘制圆弧 768</span><br><span class="line">36.2.1 使用arcTo方法 768</span><br><span class="line">36.2.2 使用arc方法 772</span><br><span class="line">36.3 绘制贝塞尔曲线 773</span><br><span class="line">36.3.1 绘制三次贝塞尔曲线 773</span><br><span class="line">36.3.2 绘制二次贝塞尔曲线 775</span><br><span class="line">36.4 创建剪辑区域 777</span><br><span class="line">36.5 绘制文本 778</span><br><span class="line">36.6 使用特效和变换 780</span><br><span class="line">36.6.1 使用阴影 780</span><br><span class="line">36.6.2 使用透明度 781</span><br><span class="line">36.6.3 使用合成 782</span><br><span class="line">36.6.4 使用变换 784</span><br><span class="line">36.7 小结 786</span><br><span class="line">第37章 使用拖放 787</span><br><span class="line">37.1 创建来源项目 787</span><br><span class="line">37.2 创建释放区 791</span><br><span class="line">37.3 使用DataTransfer对象 794</span><br><span class="line">37.3.1 根据数据过滤被拖动项目 796</span><br><span class="line">37.3.2 拖放文件 797</span><br><span class="line">37.4 小结 801</span><br><span class="line">第38章 使用地理定位 802</span><br><span class="line">38.1 使用地理定位 802</span><br><span class="line">38.2 处理地理定位错误 805</span><br><span class="line">38.3 指定地理定位选项 807</span><br><span class="line">38.4 监控位置 809</span><br><span class="line">38.5 小结 810</span><br><span class="line">第39章 使用Web存储 811</span><br><span class="line">39.1 使用本地存储 811</span><br><span class="line">39.2 使用会话存储 815</span><br><span class="line">39.3 小结 819</span><br><span class="line">第40章 创建离线Web应用程序 820</span><br><span class="line">40.1 定义问题 820</span><br><span class="line">40.2 定义清单 822</span><br><span class="line">40.3 检测浏览器状态 827</span><br><span class="line">40.4 使用离线缓存 828</span><br><span class="line">40.4.1 制作更新 832</span><br><span class="line">40.4.2 获取更新 832</span><br><span class="line">40.4.3 应用更新 833</span><br><span class="line">40.5 小结 834</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00H706BIG/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00H706BIG&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51Qu7zBmUKL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>实现领域驱动设计</title>
    <url>/2020/04/19/B00IYTVWA6/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 实现领域驱动设计<br>作者信息： 作者: 沃恩•弗农 (Vaughn Vernon) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>著译俱佳 ThoughtWorks资深咨询师倾力译、校完整涵盖DDD各方面知识 提供大量示例代码案例贯穿全书 理论与实践紧密衔接之典范架构师、程序员境界提升不可或缺之必选书目</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">序…………… xix</span><br><span class="line">前言…………. xxi</span><br><span class="line">致谢………… xxxi</span><br><span class="line">关于作者………………. xxxv</span><br><span class="line">如何使用本书………xxxvii</span><br><span class="line">第1章 DDD入门……………1</span><br><span class="line">我能DDD吗？………………2</span><br><span class="line">为什么我们需要DDD………….5</span><br><span class="line">如何DDD…………………. 17</span><br><span class="line">使用DDD的业务价值…………..22</span><br><span class="line">1.你获得了一个非常有用的领域模型…………….22</span><br><span class="line">2.你的业务得到了更准确的定义和理解…………23</span><br><span class="line">3.领域专家可以为软件设计做出贡献………..23</span><br><span class="line">4.更好的用户体验………………..23</span><br><span class="line">5.清晰的模型边界…………………24</span><br><span class="line">6.更好的企业架构…………..24</span><br><span class="line">7.敏捷、迭代式和持续建模………………..24</span><br><span class="line">8.使用战略和战术新工具……………………24</span><br><span class="line">实施DDD所面临的挑战…………………25</span><br><span class="line">虚构的案例，真实的实践………………. 33</span><br><span class="line">本章小结…………………….36</span><br><span class="line">第2章 领域、子域和限界上下文…………………37</span><br><span class="line">总览………………….. 37</span><br><span class="line">工作中的子域和限界上下文……………………….. 38</span><br><span class="line">将关注点放在核心域上……………………….. 42</span><br><span class="line">战略设计为什么重要……………….. 45</span><br><span class="line">现实世界中领域和子域……………….48</span><br><span class="line">理解限界上下文………………… 53</span><br><span class="line">限界上下文不仅仅只包含模型………………… 57</span><br><span class="line">限界上下文的大小…………………. 59</span><br><span class="line">与技术组件保持一致………………. 61</span><br><span class="line">示例上下文…………………… 62</span><br><span class="line">协作上下文………………63</span><br><span class="line">身份与访问上下文………………69</span><br><span class="line">敏捷项目管理上下文…………….. 71</span><br><span class="line">本章小结………………………………73</span><br><span class="line">第3章 上下文映射图……………………….75</span><br><span class="line">上下文映射图为什么重要…………………… 75</span><br><span class="line">绘制上下文映射图………………….77</span><br><span class="line">产品和组织关系……………………79</span><br><span class="line">映射3个示例限界上下文……………………82</span><br><span class="line">本章小结……………………….97</span><br><span class="line">第4章 架构…………………..99</span><br><span class="line">采访一个成功的CIO……………….. 100</span><br><span class="line">分层…………………………… 104</span><br><span class="line">依赖倒置原则……………….. 107</span><br><span class="line">六边形架构（端口与适配器）………………… 110</span><br><span class="line">面向服务架构…………………..114</span><br><span class="line">REST…………………………..117</span><br><span class="line">REST作为一种架构风格………………………117</span><br><span class="line">RESTful HTTP服务器的关键方面 …………………………………. 118</span><br><span class="line">RESTful HTTP客户端的关键方面 …………………………………. 119</span><br><span class="line">REST和DDD………………… 120</span><br><span class="line">为什么是REST？……………………. 121</span><br><span class="line">命令和查询职责分离——CQRS…………….. 121</span><br><span class="line">CQRS的各个方面…………………… 123</span><br><span class="line">处理具有最终一致性的查询模型……………… 128</span><br><span class="line">事件驱动架构………………. 129</span><br><span class="line">管道和过滤器………………… 131</span><br><span class="line">长时处理过程（也叫Saga）………………. 134</span><br><span class="line">事件源…………………. 140</span><br><span class="line">数据网织和基于网格的分布式计算………………….. 143</span><br><span class="line">数据复制………………… 144</span><br><span class="line">事件驱动网织和领域事件……………… 145</span><br><span class="line">持续查询………………. 145</span><br><span class="line">分布式处理…………………. 146</span><br><span class="line">本章小结………………………. 148</span><br><span class="line">第5章 实体……………………. 149</span><br><span class="line">为什么使用实体……………………. 149</span><br><span class="line">唯一标识………………………. 151</span><br><span class="line">用户提供唯一标识……………………. 152</span><br><span class="line">应用程序生成唯一标识……………………… 153</span><br><span class="line">持久化机制生成唯一标识………………………. 156</span><br><span class="line">另一个限界上下文提供唯一标识………………… 160</span><br><span class="line">标识生成时间………………… 161</span><br><span class="line">委派标识……………………. 163</span><br><span class="line">标识稳定性…………………….. 165</span><br><span class="line">发现实体及其本质特征……………………….. 167</span><br><span class="line">揭开实体及其本质特征的神秘面纱…………….. 168</span><br><span class="line">挖掘实体的关键行为…………………….. 172</span><br><span class="line">角色和职责……………………. 176</span><br><span class="line">创建实体……………………. 181</span><br><span class="line">验证…………………………….. 183</span><br><span class="line">跟踪变化………………………. 192</span><br><span class="line">本章小结………………………….. 192</span><br><span class="line">第6章 值对象………………… 193</span><br><span class="line">值对象的特征…………………….. 194</span><br><span class="line">度量或描述…………………….. 195</span><br><span class="line">不变性……………………… 195</span><br><span class="line">概念整体………………………….. 196</span><br><span class="line">可替换性…………………….. 199</span><br><span class="line">值对象相等性……………………..200</span><br><span class="line">无副作用行为……………………….. 201</span><br><span class="line">最小化集成………………204</span><br><span class="line">用值对象表示标准类型……………………206</span><br><span class="line">测试值对象…………………… 210</span><br><span class="line">实现………………………… 214</span><br><span class="line">持久化值对象…………….. 219</span><br><span class="line">拒绝由数据建模泄漏带来的不利影响………………220</span><br><span class="line">ORM与单个值对象………………………….. 221</span><br><span class="line">多个值对象序列化到单个列中…………………224</span><br><span class="line">使用数据库实体保存多个值对象………………..225</span><br><span class="line">使用联合表保存多个值对象……………………..229</span><br><span class="line">ORM与枚举状态对象………………………………….230</span><br><span class="line">本章小结………………….. 233</span><br><span class="line">第7章 领域服务……………………………235</span><br><span class="line">什么是领域服务（首先，什么不是领域服务）……………… 237</span><br><span class="line">请确定你是否需要一个领域服务………………………….. 238</span><br><span class="line">建模领域服务……………… 241</span><br><span class="line">独立接口有必要吗………………………..244</span><br><span class="line">一个计算过程……………………..246</span><br><span class="line">转换服务……………………249</span><br><span class="line">为领域服务创建一个迷你层…………………….250</span><br><span class="line">测试领域服务……………………….250</span><br><span class="line">本章小结……………… 253</span><br><span class="line">第8章 领域事件………………………….255</span><br><span class="line">何时&#x2F;为什么使用领域事件…………………….. 255</span><br><span class="line">建模领域事件……………….. 258</span><br><span class="line">创建具有聚合特征的领域事件………………. 263</span><br><span class="line">身份标识……………………….264</span><br><span class="line">从领域模型中发布领域事件………………………… 265</span><br><span class="line">发送方………………. 265</span><br><span class="line">订阅方…………………269</span><br><span class="line">向远程限界上下文发布领域事件……………………….. 271</span><br><span class="line">消息设施的一致性……………………… 271</span><br><span class="line">自治服务和系统……………………….. 272</span><br><span class="line">容许时延……………… 273</span><br><span class="line">事件存储……………… 274</span><br><span class="line">转发存储事件的架构风格……………………… 279</span><br><span class="line">以REST资源的方式发布事件通知………………….. 279</span><br><span class="line">通过消息中间件发布事件通知……………… 283</span><br><span class="line">实现……………………….284</span><br><span class="line">发布NotificationLog…………… 285</span><br><span class="line">发布基于消息的事件通知…………………………290</span><br><span class="line">本章小结……………………297</span><br><span class="line">第9章 模块…………………………..299</span><br><span class="line">通过模块完成设计…………………………….299</span><br><span class="line">模块的基本命名规范……………………..302</span><br><span class="line">领域模型的命名规范………………………302</span><br><span class="line">敏捷项目管理上下文中的模块…………………………305</span><br><span class="line">其他层中的模块………………308</span><br><span class="line">先考虑模块，再是限界上下文………………………….309</span><br><span class="line">本章小结……………………. 310</span><br><span class="line">第10章 聚合…………………. 311</span><br><span class="line">在Scrum核心领域中使用聚合…………………… 312</span><br><span class="line">第一次尝试：臃肿的聚合………………….. 313</span><br><span class="line">第二次尝试：多个聚合……………………… 314</span><br><span class="line">原则：在一致性边界之内建模真正的不变条件…………….317</span><br><span class="line">原则：设计小聚合……………………….. 319</span><br><span class="line">不要相信每一个用例………………………. 321</span><br><span class="line">原则：通过唯一标识引用其他聚合……………………. 322</span><br><span class="line">通过标识引用使多个聚合协同工作 ……………………………….. 324</span><br><span class="line">建模对象导航性………………………. 325</span><br><span class="line">可伸缩性和分布式……………………….. 326</span><br><span class="line">原则：在边界之外使用最终一致性……………………….. 327</span><br><span class="line">谁的任务？………………………. 328</span><br><span class="line">打破原则的理由……………………. 329</span><br><span class="line">理由之一：方便用户界面…………………………… 329</span><br><span class="line">理由之二：缺乏技术机制……………………….. 330</span><br><span class="line">理由之三：全局事务…………………………………… 331</span><br><span class="line">理由之四：查询性能……………………………. 331</span><br><span class="line">遵循原则……………….. 332</span><br><span class="line">通过发现，深入理解…………………………. 332</span><br><span class="line">重新思考设计…………………………. 332</span><br><span class="line">估算聚合成本……………………….. 334</span><br><span class="line">常见用例场景…………………… 335</span><br><span class="line">内存消耗………………………. 336</span><br><span class="line">探索另外的设计…………………………….. 337</span><br><span class="line">实现最终一致性………………………… 338</span><br><span class="line">这是Scrum团队成员的任务吗？……………………. 339</span><br><span class="line">决定的时候到了………………………… 341</span><br><span class="line">实现…………………………………. 341</span><br><span class="line">创建具有唯一标识的根实体…………………… 342</span><br><span class="line">优先使用值对象…………………. 343</span><br><span class="line">使用迪米特法则和“告诉而非询问”原则 ……………344</span><br><span class="line">乐观并发……………346</span><br><span class="line">避免依赖注入…………….348</span><br><span class="line">本章小结………………………….. 349</span><br><span class="line">第11章 工厂…………….. 351</span><br><span class="line">领域模型中的工厂…………….. 351</span><br><span class="line">聚合根中的工厂方法……………………….. 352</span><br><span class="line">创建CalendarEntry实例………………. 353</span><br><span class="line">创建Discussion实例………………………. 357</span><br><span class="line">领域服务中的工厂…………………….. 358</span><br><span class="line">本章小结…………………….. 361</span><br><span class="line">第12章 资源库………………………363</span><br><span class="line">面向集合资源库………………………364</span><br><span class="line">Hibernate实现…………………. 369</span><br><span class="line">TopLink实现……………….. 377</span><br><span class="line">面向持久化资源库…………………… 379</span><br><span class="line">Coherence实现………………………. 381</span><br><span class="line">MongoDB实现……………………. 386</span><br><span class="line">额外的行为……………………………….. 391</span><br><span class="line">管理事务…………………………… 393</span><br><span class="line">警告…………………………… 397</span><br><span class="line">类型层级…………………………. 397</span><br><span class="line">资源库 vs 数据访问对象（DAO）…………………………400</span><br><span class="line">测试资源库…………………………………… 401</span><br><span class="line">以内存实现进行测试……………….404</span><br><span class="line">本章小结…………………………..407</span><br><span class="line">第13章 集成限界上下文………………………….409</span><br><span class="line">集成基础知识………………………………409</span><br><span class="line">分布式系统之间存在根本性区别…………………..411</span><br><span class="line">跨系统边界交换信息………………………….411</span><br><span class="line">通过REST资源集成限界上下文……………………. 417</span><br><span class="line">实现REST资源…………………….. 418</span><br><span class="line">使用防腐层实现REST客户端……….. 421</span><br><span class="line">通过消息集成限界上下文……………. 428</span><br><span class="line">从Scrum的产品负责人和团队成员处得到持续通知 ……………….. 428</span><br><span class="line">你能处理这样的职责吗？………………… 434</span><br><span class="line">长时处理过程，以及避免职责…………. 439</span><br><span class="line">长时处理过程的状态机和超时跟踪器 ……………………………. 450</span><br><span class="line">设计一个更复杂的长时处理过程 ……………………………………460</span><br><span class="line">当消息机制或你的系统不可用时 …………………………………….464</span><br><span class="line">本章小结……………………………465</span><br><span class="line">第14章 应用程序………………467</span><br><span class="line">用户界面……………………………..469</span><br><span class="line">渲染领域对象…………. 470</span><br><span class="line">渲染数据传输对象………………. 471</span><br><span class="line">使用调停者发布聚合的内部状态 …………………………………… 471</span><br><span class="line">通过领域负载对象渲染聚合实例 …………………………………… 472</span><br><span class="line">聚合实例的状态展现……………………….. 473</span><br><span class="line">用例优化资源库查询…………………. 474</span><br><span class="line">处理不同类型的客户端………………. 474</span><br><span class="line">渲染适配器以及处理用户编辑…………. 475</span><br><span class="line">应用服务 …………………………………….. 478</span><br><span class="line">示例应用服务 ………………………….. 478</span><br><span class="line">解耦服务输出 …………………485</span><br><span class="line">组合多个限界上下文 …………………487</span><br><span class="line">基础设施 ………………………….489</span><br><span class="line">企业组件容器 ………………..490</span><br><span class="line">本章小结 ………………..494</span><br><span class="line">附录A 聚合与事件源：A+ES ……………………..495</span><br><span class="line">应用服务内部 ………………….. 496</span><br><span class="line">命令处理器 …………………505</span><br><span class="line">Lambda语法……………….508</span><br><span class="line">并发控制 ………………….. 510</span><br><span class="line">A+ES所带来的结构自由性 ………….. 513</span><br><span class="line">性能 ………………………. 513</span><br><span class="line">实现事件存储 ………………… 516</span><br><span class="line">关系型持久化 ……………… 520</span><br><span class="line">BLOB持久化 …………………. 522</span><br><span class="line">专注的聚合 ………………………. 523</span><br><span class="line">读模型投射 ……………………… 524</span><br><span class="line">与聚合设计一道使用 ……………. 527</span><br><span class="line">增强事件 ……………………… 527</span><br><span class="line">工具和模式 ………………. 529</span><br><span class="line">事件序列器 ………. 530</span><br><span class="line">事件不变性 ……………. 531</span><br><span class="line">值对象 ………………… 531</span><br><span class="line">协议生成 ……………….. 534</span><br><span class="line">单元测试和需求规范 ………….. 535</span><br><span class="line">事件源和函数式语言 ………. 536</span><br><span class="line">参考文献 ………………539</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00IYTVWA6/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00IYTVWA6&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51hS5z5LKdL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>dsl</tag>
      </tags>
  </entry>
  <entry>
    <title>C标准库(英文版)</title>
    <url>/2020/04/19/B00IZW4DK8/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C标准库(英文版)<br>作者信息： 作者: 普劳戈 (Plauger P.J.) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>C标准库圣经<br>提供完整源代码，全面深入阐述库函数的实现与运用<br>C程序员必备参考书</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Chapter 0： Introduction</span><br><span class="line">Background</span><br><span class="line">What the C Standard Says</span><br><span class="line">Using the Library</span><br><span class="line">Implementing the Library</span><br><span class="line">Testing he Library</span><br><span class="line">References</span><br><span class="line">Exercises</span><br><span class="line">Chapter 1：</span><br><span class="line">Background</span><br><span class="line">What the C Standard Says</span><br><span class="line">Using</span><br><span class="line">Implementing</span><br><span class="line">Testing</span><br><span class="line">References</span><br><span class="line">Exercises</span><br><span class="line">Chapter 2：</span><br><span class="line">Background</span><br><span class="line">What the C Standard Says</span><br><span class="line">Using</span><br><span class="line">Implementìng</span><br><span class="line">Testing</span><br><span class="line">References</span><br><span class="line">Exercises</span><br><span class="line">Chapter 3：</span><br><span class="line">Background</span><br><span class="line">What the C Stcndard Says</span><br><span class="line">Usìng</span><br><span class="line">Implementing</span><br><span class="line">Testìng</span><br><span class="line">References</span><br><span class="line">Exercises</span><br><span class="line">Chapter 4：</span><br><span class="line">Background</span><br><span class="line">What the C Standard Says</span><br><span class="line">Using</span><br><span class="line">Implementing</span><br><span class="line">Testing</span><br><span class="line">References</span><br><span class="line">Exercises</span><br><span class="line">Chapter 5：</span><br><span class="line">Background</span><br><span class="line">What the C Standard Says</span><br><span class="line">Using</span><br><span class="line">Implementing</span><br><span class="line">Testing</span><br><span class="line">References</span><br><span class="line">Exercises</span><br><span class="line">Chapter 6：</span><br><span class="line">Background</span><br><span class="line">What the C Standard Says</span><br><span class="line">Using</span><br><span class="line">Implementing</span><br><span class="line">Testing</span><br><span class="line">References</span><br><span class="line">Exercises</span><br><span class="line">Chapter 7：</span><br><span class="line">Background</span><br><span class="line">What the C Standard Says</span><br><span class="line">Using</span><br><span class="line">Implementing</span><br><span class="line">Testing</span><br><span class="line">References</span><br><span class="line">Exercises</span><br><span class="line">Chapter 8：</span><br><span class="line">Background</span><br><span class="line">What the C Standard Says</span><br><span class="line">Using</span><br><span class="line">Implementing</span><br><span class="line">Testing</span><br><span class="line">References</span><br><span class="line">Exercises</span><br><span class="line">Chapter9：</span><br><span class="line">Background</span><br><span class="line">What the C Standard Says</span><br><span class="line">Using</span><br><span class="line">Implementing</span><br><span class="line">Testing</span><br><span class="line">References</span><br><span class="line">Exercises</span><br><span class="line">Chapter 10：</span><br><span class="line">Background</span><br><span class="line">What the C Standard Says</span><br><span class="line">Using</span><br><span class="line">Implementing</span><br><span class="line">Testing</span><br><span class="line">References</span><br><span class="line">Exerclses</span><br><span class="line">Chapter 11：</span><br><span class="line">Background</span><br><span class="line">What the C Standard Says</span><br><span class="line">Using</span><br><span class="line">Implementing</span><br><span class="line">Testing</span><br><span class="line">References</span><br><span class="line">Exercises</span><br><span class="line">Chapter 12：</span><br><span class="line">Background</span><br><span class="line">What the C Standard Says</span><br><span class="line">Using</span><br><span class="line">Implementing</span><br><span class="line">Testing</span><br><span class="line">References</span><br><span class="line">Exercises</span><br><span class="line">Chapter 13：</span><br><span class="line">Background</span><br><span class="line">What the C Standard Says</span><br><span class="line">Using</span><br><span class="line">Imple lenting</span><br><span class="line">Testing</span><br><span class="line">References</span><br><span class="line">Exercises</span><br><span class="line">Chapter 14：</span><br><span class="line">Background</span><br><span class="line">What the C Standard Says</span><br><span class="line">Using</span><br><span class="line">Implementing</span><br><span class="line">Testing</span><br><span class="line">References</span><br><span class="line">Exercises</span><br><span class="line">Chapter 15：</span><br><span class="line">Background</span><br><span class="line">What the C Standard Says</span><br><span class="line">Using</span><br><span class="line">Implementlng</span><br><span class="line">Testing</span><br><span class="line">References</span><br><span class="line">Exercises</span><br><span class="line">Appendix A： Inferfaces</span><br><span class="line">Appendix B： Names</span><br><span class="line">Appendix C： Terms</span><br><span class="line">Index</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00IZW4DK8/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00IZW4DK8&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51nzgU5rolL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C和C++安全编码</title>
    <url>/2020/04/19/B00HI6UH8Y/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C和C++安全编码<br>作者信息： 作者: 塞克德 (Robert C.Seacord) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《华章程序员书库:C和C++安全编码(原书第2版)》介绍了Windows和Linux上数以百计的例子，包括安全的代码、不安全的代码和利用方法。如果你负责创建安全的C或C++软件，或者需要保证它们的安全，《华章程序员书库:C和C++安全编码(原书第2版)》将为你提供详尽的专家级援助。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">译者序</span><br><span class="line">序</span><br><span class="line">前言</span><br><span class="line">致谢</span><br><span class="line">第1章 夹缝求生</span><br><span class="line">1.1 衡量危险</span><br><span class="line">1.1.1 损失的现状</span><br><span class="line">1.1.2 威胁的来源</span><br><span class="line">1.1.3 软件安全</span><br><span class="line">1.2 安全概念</span><br><span class="line">1.2.1 安全策略</span><br><span class="line">1.2.2 安全缺陷</span><br><span class="line">1.2.3 漏洞</span><br><span class="line">1.2.4 漏洞利用</span><br><span class="line">1.2.5 缓解措施</span><br><span class="line">1.3 C和C++</span><br><span class="line">1.3.1 C和C++简史</span><br><span class="line">1.3.2 C存在的问题</span><br><span class="line">1.3.3 遗留代码</span><br><span class="line">1.3.4 其他语言</span><br><span class="line">1.4 开发平台</span><br><span class="line">1.4.1 操作系统</span><br><span class="line">1.4.2 编译器</span><br><span class="line">1.5 小结</span><br><span class="line">1.6 阅读材料</span><br><span class="line">第2章 字符串</span><br><span class="line">2.1 字符串</span><br><span class="line">2.1.1 字符串数据类型</span><br><span class="line">2.1.2 UTF—8</span><br><span class="line">2.1.3 宽字符串</span><br><span class="line">2.1.4 字符串字面值</span><br><span class="line">2.1.5 C++中的字符串</span><br><span class="line">2.1.6 字符类型</span><br><span class="line">2.1.7 计算字符串大小</span><br><span class="line">2.2 常见的字符串操作错误</span><br><span class="line">2.2.1 无界字符串复制</span><br><span class="line">2.2.2 差一错误</span><br><span class="line">2.2.3 空字符结尾错误</span><br><span class="line">2.2.4 字符串截断</span><br><span class="line">2.2.5 与函数无关的字符串错误</span><br><span class="line">2.3 字符串漏洞及其利用</span><br><span class="line">2.3.1 被污染的数据</span><br><span class="line">2.3.2 IsPasswordOK的安全缺陷</span><br><span class="line">2.3.3 缓冲区溢出</span><br><span class="line">2.3.4 进程内存组织</span><br><span class="line">2.3.5 栈管理</span><br><span class="line">2.3.6 栈溢出</span><br><span class="line">2.3.7 代码注入</span><br><span class="line">2.3.8 弧注入</span><br><span class="line">2.3.9 返回导向编程</span><br><span class="line">2.4 字符串漏洞缓解策略</span><br><span class="line">2.4.1 字符串处理</span><br><span class="line">2.4.2 C11附录K边界检查接口</span><br><span class="line">2.4.3 动态分配函数</span><br><span class="line">2.4.4 C++ std：：basic_string</span><br><span class="line">2.4.5 使字符串对象的引用失效</span><br><span class="line">2.4.6 使用basic_string的其他常见错误</span><br><span class="line">2.5 字符串处理函数</span><br><span class="line">2.5.1 gets</span><br><span class="line">2.5.2 C99</span><br><span class="line">2.5.3 C11附录K边界检查接口：gets—s</span><br><span class="line">2.5.4 动态分配函数</span><br><span class="line">2.5.5 strcpy和strcat</span><br><span class="line">2.5.6 C99</span><br><span class="line">2.5.7 strncpy和strncat</span><br><span class="line">2.5.8 memcpy和memmove</span><br><span class="line">2.5.9 strlen</span><br><span class="line">2.6 运行时保护策略</span><br><span class="line">2.6.1 检测和恢复</span><br><span class="line">2.6.2 输入验证</span><br><span class="line">2.6.3 对象大小检查</span><br><span class="line">2.6.4 Visual Studio中编译器生成的运行时检查</span><br><span class="line">2.6.5 栈探测仪</span><br><span class="line">2.6.6 栈溢出保护器</span><br><span class="line">2.6.7 操作系统策略</span><br><span class="line">2.6.8 检测和恢复</span><br><span class="line">2.6.9 不可执行栈</span><br><span class="line">2.6.10 WX</span><br><span class="line">2.6.11 PaX</span><br><span class="line">2.6.12 未来发展方向</span><br><span class="line">2.7 著名的漏洞</span><br><span class="line">2.7.1 远程登录</span><br><span class="line">2.7.2 Kerberos</span><br><span class="line">2.8 小结</span><br><span class="line">2.9 阅读材料</span><br><span class="line">第3章 指针诡计</span><br><span class="line">3.1 数据位置</span><br><span class="line">3.2 函数指针</span><br><span class="line">3.3 对象指针</span><br><span class="line">3.4 修改指令指针</span><br><span class="line">3.5 全局偏移表</span><br><span class="line">3.6 dtors区</span><br><span class="line">3.7 虚指针</span><br><span class="line">3.8 atexit和on—exit函数</span><br><span class="line">3.9 longjmp函数</span><br><span class="line">3.10 异常处理</span><br><span class="line">3.10.1 结构化异常处理</span><br><span class="line">3.10.2 系统默认异常处理</span><br><span class="line">3.11 缓解策略</span><br><span class="line">3.11.1 栈探测仪</span><br><span class="line">3.11.2 W—X</span><br><span class="line">3.11.3 对函数指针编码和解码</span><br><span class="line">3.12 小结</span><br><span class="line">3.13 阅读材料</span><br><span class="line">第4章 动态内存管理</span><br><span class="line">4.1 C内存管理</span><br><span class="line">4.1.1 C标准内存管理函数</span><br><span class="line">4.1.2 对齐</span><br><span class="line">4.1.3 alloca和变长数组</span><br><span class="line">4.2 常见的C内存管理错误</span><br><span class="line">4.2.1 初始化错误</span><br><span class="line">4.2.2 未检查返回值</span><br><span class="line">4.2.3 Null或无效指针解引用</span><br><span class="line">4.2.4 引用已释放内存</span><br><span class="line">4.2.5 多次释放内存</span><br><span class="line">4.2.6 内存泄漏</span><br><span class="line">4.2.7 零长度分配</span><br><span class="line">4.2.8 DR # 400</span><br><span class="line">4.3 C++的动态内存管理</span><br><span class="line">4.3.1 分配函数</span><br><span class="line">4.3.2 释放函数</span><br><span class="line">4.3.3 垃圾回收</span><br><span class="line">4.4 常见的C++内存管理错误</span><br><span class="line">4.4.1 未能正确检查分配失败</span><br><span class="line">4.4.2 不正确配对的内存管理函数</span><br><span class="line">4.4.3 多次释放内存</span><br><span class="line">4.4.4 释放函数抛出一个异常</span><br><span class="line">4.5 内存管理器</span><br><span class="line">4.6 Doug Lea的内存分配器</span><br><span class="line">4.7 双重释放漏洞</span><br><span class="line">4.7.1 写入已释放的内存</span><br><span class="line">4.7.2 RtlHeap</span><br><span class="line">4.7.3 缓冲区溢出（终极版）</span><br><span class="line">4.8 缓解策略</span><br><span class="line">4.8.1 空指针</span><br><span class="line">4.8.2 一致的内存管理约定</span><br><span class="line">4.8.3 phkmalloc</span><br><span class="line">4.8.4 随机化</span><br><span class="line">4.8.5 OpenBSD</span><br><span class="line">4.8.6 jemalloc内存管理器</span><br><span class="line">4.8.7 静态分析</span><br><span class="line">4.8.8 运行时分析工具</span><br><span class="line">4.9 值得注意的漏洞</span><br><span class="line">4.9.1 CVS缓冲区溢出漏洞</span><br><span class="line">4.9.2 Microsoft数据访问组件</span><br><span class="line">4.9.3 CVS服务器双重释放漏洞</span><br><span class="line">4.9.4 MIT Kerberos 5中的漏洞</span><br><span class="line">4.10 小结</span><br><span class="line">第5章 整数安全</span><br><span class="line">5.1 整数安全导论</span><br><span class="line">5.2 整数数据类型</span><br><span class="line">5.2.1 无符号整数类型</span><br><span class="line">5.2.2 回绕</span><br><span class="line">5.2.3 有符号整数类型</span><br><span class="line">5.2.4 有符号整数的取值范围</span><br><span class="line">5.2.5 整数溢出</span><br><span class="line">5.2.6 字符类型</span><br><span class="line">5.2.7 数据模型</span><br><span class="line">5.2.8 其他整数类型</span><br><span class="line">5.3 整数转换</span><br><span class="line">5.3.1 转换整数</span><br><span class="line">5.3.2 整数转换级别</span><br><span class="line">5.3.3 整数类型提升</span><br><span class="line">5.3.4 普通算术转换</span><br><span class="line">5.3.5 由无符号整数类型转换</span><br><span class="line">5.3.6 由有符号整数类型转换</span><br><span class="line">5.3.7 转换的影响</span><br><span class="line">5.4 整数操作</span><br><span class="line">5.4.1 赋值</span><br><span class="line">5.4.2 加法</span><br><span class="line">5.4.3 减法</span><br><span class="line">5.4.4 乘法</span><br><span class="line">5.4.5 除法和求余</span><br><span class="line">5.4.6 移位</span><br><span class="line">5.5 整数漏洞</span><br><span class="line">5.5.1 漏洞</span><br><span class="line">5.5.2 回绕</span><br><span class="line">5.5.3 转换和截断错误</span><br><span class="line">5.5.4 非异常的整数逻辑错误</span><br><span class="line">5.6 缓解策略</span><br><span class="line">5.6.1 整数类型的选择</span><br><span class="line">5.6.2 抽象数据类型</span><br><span class="line">5.6.3 任意精度算术</span><br><span class="line">5.6.4 范围检查</span><br><span class="line">5.6.5 前提条件和后验条件测试</span><br><span class="line">5.6.6 安全整数库</span><br><span class="line">5.6.7 溢出检测</span><br><span class="line">5.6.8 编译器生成的运行时检查</span><br><span class="line">5.6.9 可验证范围操作</span><br><span class="line">5.6.10 仿佛无限范围整数模型</span><br><span class="line">5.6.11 测试与分析</span><br><span class="line">5.7 小结</span><br><span class="line">第6章 格式化输出</span><br><span class="line">6.1 变参函数</span><br><span class="line">6.2 格式化输出函数</span><br><span class="line">6.2.1 格式字符串</span><br><span class="line">6.2.2 GCC</span><br><span class="line">6.2.3 Visual C++</span><br><span class="line">6.3 对格式化输出函数的漏洞利用</span><br><span class="line">6.3.1 缓冲区溢出</span><br><span class="line">6.3.2 输出流</span><br><span class="line">6.3.3 使程序崩溃</span><br><span class="line">6.3.4 查看栈内容</span><br><span class="line">6.3.5 查看内存内容</span><br><span class="line">6.3.6 覆写内存</span><br><span class="line">6.3.7 国际化</span><br><span class="line">6.3.8 宽字符格式字符串漏洞</span><br><span class="line">6.4 栈随机化</span><br><span class="line">6.4.1 阻碍栈随机化</span><br><span class="line">6.4.2 以双字的格式写地址</span><br><span class="line">6.4.3 直接参数访问</span><br><span class="line">6.5 缓解策略</span><br><span class="line">6.5.1 排除用户输入的格式字符串</span><br><span class="line">6.5.2 静态内容的动态使用</span><br><span class="line">6.5.3 限制字节写入</span><br><span class="line">6.5.4 C11附录K边界检查接口</span><br><span class="line">6.5.5 iostream与stdio</span><br><span class="line">6.5.6 测试</span><br><span class="line">6.5.7 编译器检查</span><br><span class="line">6.5.8 静态污点分析</span><br><span class="line">6.5.9 调整变参函数的实现</span><br><span class="line">6.5.10 Exec Shield</span><br><span class="line">6.5.11 FormatGuard</span><br><span class="line">6.5.12 静态二进制分析</span><br><span class="line">6.6 著名的漏洞</span><br><span class="line">6.6.1 华盛顿大学FTP Daemon</span><br><span class="line">6.6.2 CDE ToolTalk</span><br><span class="line">6.6.3 Ettercap NG—0.7.2版</span><br><span class="line">6.7 小结</span><br><span class="line">6.8 阅读材料</span><br><span class="line">……</span><br><span class="line">第7章 并发</span><br><span class="line">第8章 文件I／O</span><br><span class="line">第9章 推荐的实践</span><br><span class="line">参考文献</span><br><span class="line">缩略语</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00HI6UH8Y/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00HI6UH8Y&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41sAPjgYk5L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Beyond the C++ Standard Library</title>
    <url>/2020/04/19/beyond-the-cpp-standard-library/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Beyond the C++ Standard Library<br>作者信息： 作者: Bjorn Karlsson [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Introducing the Boost libraries: the next breakthrough in C++ programming Boost takes you far beyond the C++ Standard Library, making C++ programming more elegant, robust, and productive. Now, for the first time, a leading Boost expert systematically introduces the broad set of Boost libraries and teaches best practices for their use. Writing for intermediate-to-advanced C++ developers, Bjorn Karlsson briefly outlines all 58 Boost libraries, and then presents comprehensive coverage of 12 libraries you’re likely to find especially useful. Karlsson’s topics range from smart pointers and conversions to containers and data structures, explaining exactly how using each library can improve your code.</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Back Cover Table of Contents Author Reviews Foreword.</span><br><span class="line"></span><br><span class="line"> Preface.</span><br><span class="line"></span><br><span class="line"> Acknowledgments.</span><br><span class="line"></span><br><span class="line"> About the Author.</span><br><span class="line"></span><br><span class="line"> Organization of This Book.</span><br><span class="line"></span><br><span class="line"> Introduction to Boost.</span><br><span class="line"></span><br><span class="line"> String and Text Processing</span><br><span class="line"></span><br><span class="line"> Data Structures, Containers, Iterators, and Algorithms</span><br><span class="line"></span><br><span class="line"> Function Objects and Higher-Order Programming</span><br><span class="line"></span><br><span class="line"> Generic Programming and Template Metaprogramming</span><br><span class="line"></span><br><span class="line"> Math and Numerics</span><br><span class="line"></span><br><span class="line"> Input&#x2F;Output</span><br><span class="line"></span><br><span class="line"> Miscellaneous</span><br><span class="line"></span><br><span class="line"> GENERAL LIBRARIES. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Library 1: Smart_ptr.</span><br><span class="line"></span><br><span class="line"> How Does the Smart_ptr Library Improve Your Programs?</span><br><span class="line"></span><br><span class="line"> When Do We Need Smart Pointers?</span><br><span class="line"></span><br><span class="line"> How Does Smart_ptr Fit with the Standard Library?</span><br><span class="line"></span><br><span class="line"> scoped_ptr</span><br><span class="line"></span><br><span class="line"> scoped_array</span><br><span class="line"></span><br><span class="line"> shared_ptr</span><br><span class="line"></span><br><span class="line"> shared_array</span><br><span class="line"></span><br><span class="line"> intrusive_ptr</span><br><span class="line"></span><br><span class="line"> weak_ptr</span><br><span class="line"></span><br><span class="line"> Smart_ptr Summary</span><br><span class="line"></span><br><span class="line"> Library 2: Conversion.</span><br><span class="line"></span><br><span class="line"> How Does the Conversion Library Improve Your Programs?</span><br><span class="line"></span><br><span class="line"> polymorphic_cast</span><br><span class="line"></span><br><span class="line"> polymorphic_downcast</span><br><span class="line"></span><br><span class="line"> numeric_cast</span><br><span class="line"></span><br><span class="line"> lexical_cast</span><br><span class="line"></span><br><span class="line"> Conversion Summary</span><br><span class="line"></span><br><span class="line"> Library 3: Utility.</span><br><span class="line"></span><br><span class="line"> How Does the Utility Library Improve Your Programs?</span><br><span class="line"></span><br><span class="line"> BOOST_STATIC_ASSERT</span><br><span class="line"></span><br><span class="line"> checked_delete</span><br><span class="line"></span><br><span class="line"> noncopyable</span><br><span class="line"></span><br><span class="line"> addressof</span><br><span class="line"></span><br><span class="line"> enable_if</span><br><span class="line"></span><br><span class="line"> Utility Summary</span><br><span class="line"></span><br><span class="line"> Library 4: Operators.</span><br><span class="line"></span><br><span class="line"> How Does the Operators Library Improve Your Programs?</span><br><span class="line"></span><br><span class="line"> Operators</span><br><span class="line"></span><br><span class="line"> Usage</span><br><span class="line"></span><br><span class="line"> Operators Summary</span><br><span class="line"></span><br><span class="line"> Library 5: Regex.</span><br><span class="line"></span><br><span class="line"> How Does the Regex Library Improve Your Programs?</span><br><span class="line"></span><br><span class="line"> How Does Regex Fit with the Standard Library?</span><br><span class="line"></span><br><span class="line"> Regex</span><br><span class="line"></span><br><span class="line"> Usage</span><br><span class="line"></span><br><span class="line"> Regex Summary</span><br><span class="line"></span><br><span class="line"> II. CONTAINERS AND DATA STRUCTURES.</span><br><span class="line"></span><br><span class="line"> Library 6: Any.</span><br><span class="line"></span><br><span class="line"> How Does the Any Library Improve Your Programs?</span><br><span class="line"></span><br><span class="line"> How Does Any Fit with the Standard Library?</span><br><span class="line"></span><br><span class="line"> Any</span><br><span class="line"></span><br><span class="line"> Usage</span><br><span class="line"></span><br><span class="line"> Any Summary</span><br><span class="line"></span><br><span class="line"> Library 7: Variant.</span><br><span class="line"></span><br><span class="line"> How Does the Variant Library Improve Your Programs?</span><br><span class="line"></span><br><span class="line"> How Does Variant Fit with the Standard Library?</span><br><span class="line"></span><br><span class="line"> Variant</span><br><span class="line"></span><br><span class="line"> Usage</span><br><span class="line"></span><br><span class="line"> Variant Summary</span><br><span class="line"></span><br><span class="line"> Library 8: Tuple.</span><br><span class="line"></span><br><span class="line"> How Does the Tuple Library Improve Your Programs?</span><br><span class="line"></span><br><span class="line"> How Does the Tuple Library Fit with the Standard Library?</span><br><span class="line"></span><br><span class="line"> Tuple</span><br><span class="line"></span><br><span class="line"> Usage</span><br><span class="line"></span><br><span class="line"> Tuple Summary</span><br><span class="line"></span><br><span class="line"> III. FUNCTION OBJECTS AND HIGHER-ORDER PROGRAMMING.</span><br><span class="line"></span><br><span class="line"> Library 9: Bind.</span><br><span class="line"></span><br><span class="line"> How Does the Bind Library Improve Your Programs?</span><br><span class="line"></span><br><span class="line"> How Does Bind Fit with the Standard Library?</span><br><span class="line"></span><br><span class="line"> Bind</span><br><span class="line"></span><br><span class="line"> Usage</span><br><span class="line"></span><br><span class="line"> Bind Summary</span><br><span class="line"></span><br><span class="line"> Library 10: Lambda.</span><br><span class="line"></span><br><span class="line"> How Does the Lambda Library Improve Your Programs?</span><br><span class="line"></span><br><span class="line"> How Does Lambda Fit with the Standard Library?</span><br><span class="line"></span><br><span class="line"> Lambda</span><br><span class="line"></span><br><span class="line"> Usage</span><br><span class="line"></span><br><span class="line"> Lambda Summary</span><br><span class="line"></span><br><span class="line"> Library 11: Function.</span><br><span class="line"></span><br><span class="line"> How Does the Function Library Improve Your Programs?</span><br><span class="line"></span><br><span class="line"> How Does Function Fit with the Standard Library?</span><br><span class="line"></span><br><span class="line"> Function</span><br><span class="line"></span><br><span class="line"> Usage</span><br><span class="line"></span><br><span class="line"> Function Summary</span><br><span class="line"></span><br><span class="line"> Library 12: Signals.</span><br><span class="line"></span><br><span class="line"> How Does the Signals Library Improve Your Programs?</span><br><span class="line"></span><br><span class="line"> How Does Signals Fit with the Standard Library?</span><br><span class="line"></span><br><span class="line"> Signals</span><br><span class="line"></span><br><span class="line"> Usage</span><br><span class="line"></span><br><span class="line"> Signals Summary</span><br><span class="line"></span><br><span class="line"> Bibliography.</span><br><span class="line"></span><br><span class="line"> Index.</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/0321133544/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=0321133544&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/4174N3PAX6L._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>超越C++标准库:Boost库导论</title>
    <url>/2020/04/19/beyond-the-cpp-standard-library-zh/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 超越C++标准库:Boost库导论<br>作者信息： 作者: 卡尔森 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《超越C++标准库Boost库导论》不仅介绍了Boost库的功能、使用方法及注意事项，而且还深入讨论了Boost库的设计理念、解决问题的思想和技巧以及待处理的问题。因此，本书是一本了解Boost库并探索其机理的实用手册。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第ⅰ部分 通用库</span><br><span class="line">　第1章 smart_ptr库</span><br><span class="line">　　1.1 smart_ptr库如何改进程序</span><br><span class="line">　　1.2 何时需要智能指针</span><br><span class="line">　　1.3 smart_ptr库如何适用于标准库</span><br><span class="line">　　1.4 智能指针scoped_ptr</span><br><span class="line">　　1.5 智能指针scoped_array</span><br><span class="line">　　1.6 智能指针shared_ptr</span><br><span class="line">　 1.7 智能指针shared_array</span><br><span class="line">　 1.8 智能指针intrusive_ptr</span><br><span class="line">　 1.9 智能指针weak_ptr</span><br><span class="line">　 1.10 smart_ptr库小结</span><br><span class="line">第2章 conversion库</span><br><span class="line">　 2.1 conversion库如何改进程序</span><br><span class="line">　 2.2 polymorphic_cast转型函数</span><br><span class="line">　2.3 polymorphic_downcast转型函数</span><br><span class="line">　 2.4 numeric_cast转型函数</span><br><span class="line">　2.5 lexical_cast转型函数</span><br><span class="line">　2.6 conversion库小结</span><br><span class="line">第3章 utility库</span><br><span class="line">. 　 3.1 utility库如何改进程序</span><br><span class="line">　3.2 boost_static_assert断言</span><br><span class="line">　 3.3 checked_delete函数</span><br><span class="line">　 3.4 noncopyable类</span><br><span class="line">　3.5 addressof函数</span><br><span class="line">　 3.6 enable_if函数</span><br><span class="line">　 3.7 utility库小结</span><br><span class="line">第4章 operators库</span><br><span class="line">　 4.1 operators库如何改进程序</span><br><span class="line">　 4.2 operators库如何适用于标准库</span><br><span class="line">　 4.3 operators库</span><br><span class="line">　 4.4 使用方法</span><br><span class="line">　 4.5 operators库小结</span><br><span class="line">第5章 regex库</span><br><span class="line">　 5.1 regex库如何改进程序</span><br><span class="line">　 5.2 regex库如何适用于标准库</span><br><span class="line">　 5.3 regex库</span><br><span class="line">　 5.4 使用方法</span><br><span class="line">　 5.5 regex库小结</span><br><span class="line">第ⅱ部分 容器和数据结构</span><br><span class="line">第6章 any库</span><br><span class="line">　 6.1 any库如何改进程序</span><br><span class="line">　6.2 any库如何适用于标准库</span><br><span class="line">　6.3 any库</span><br><span class="line">　 6.4 使用方法</span><br><span class="line">　 6.5 any库小结</span><br><span class="line">第7章 variant库</span><br><span class="line">　 7.1 variant库如何改进程序</span><br><span class="line">　 7.2 variant库如何适用于标准库</span><br><span class="line">　 7.3 variant库</span><br><span class="line">　7.4 使用方法</span><br><span class="line">　7.5 variant库小结</span><br><span class="line">第8章 tuple库</span><br><span class="line">　 8.1 tuple库如何改进程序</span><br><span class="line">　8.2 tuple库如何适用于标准库</span><br><span class="line">　 8.3 tuple库</span><br><span class="line">　 8.4 使用方法</span><br><span class="line">　 8.5 tuple库小结</span><br><span class="line">第ⅲ部分 函数对象和高阶编程</span><br><span class="line">第9章 bind库</span><br><span class="line">　 9.1 bind库如何改进程序</span><br><span class="line">　 9.2 bind库如何适用于标准库</span><br><span class="line">　 9.3 bind库</span><br><span class="line">　9.4 使用方法</span><br><span class="line">　 9.5 bind库小结</span><br><span class="line">第10章 lambda库</span><br><span class="line">　 10.1 lambda库如何改进程序</span><br><span class="line">　 10.2 lambda库如何适用于标准库</span><br><span class="line">　 10.3 lambda库</span><br><span class="line">　 10.4 使用方法</span><br><span class="line">　 10.5 lambda库小结</span><br><span class="line">第11章 function库</span><br><span class="line">　 11.1 function库如何改进程序</span><br><span class="line">　 11.2 function库如何适用于标准库</span><br><span class="line">　11.3 function库</span><br><span class="line">　 11.4 使用方法</span><br><span class="line">　 11.5 function库小结</span><br><span class="line">第12章 signals库</span><br><span class="line">　 12.1 signals库如何改进程序</span><br><span class="line">　12.2 signals库如何适用于标准库</span><br><span class="line">　12.3 signals库</span><br><span class="line">　 12.4 使用方法</span><br><span class="line">　 12.5 signals库小结</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0011F3VLI/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0011F3VLI&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51Es-qMZAuL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++编码规范</title>
    <url>/2020/04/19/cpp-coding-standards/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C++编码规范<br>作者信息： 作者: Herb Sutter [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《C++编程规范:101条规则、准则与最佳实践》中，两位知名的c++专家将全球c++界20年的集体智慧和经验凝结成一套编程规范。这些规范可以作为每一个开发团队制定实际开发规范的基础，更是每一位c++程序员应该遵循的行事准则。书中对每一条规范都给出了精确的描述，并辅以实例说明；从类型定义到错误处理，都给出了最佳的c++实践，即使使用c++多年的程序员也会从《C++编程规范:101条规则、准则与最佳实践》中受益匪浅。<br>《C++编程规范:101条规则、准则与最佳实践》适合于各层次c++程序员使用，也可作为高等院校c++课程的教学参考书。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第0条 不要拘泥于小节（又名：了解哪些东西不应该标准化） 2</span><br><span class="line">第1条 在高警告级别干净利落地进行编译 4</span><br><span class="line">第2条 使用自动构建系统 7</span><br><span class="line">第3条 使用版本控制系统 8</span><br><span class="line">第4条 做代码审查 9设计风格 11</span><br><span class="line">第5条 一个实体应该只有一个紧凑的职责 12</span><br><span class="line">第6条 正确、简单和清晰第一 13</span><br><span class="line">第7条 编程中应知道何时和如何考虑可伸缩性 14</span><br><span class="line">第8条 不要进行不成熟的优化 16</span><br><span class="line">第9条 不要进行不成熟的劣化 18</span><br><span class="line">第10条 尽量减少全局和共享数据 19</span><br><span class="line">第11条 隐藏信息 20</span><br><span class="line">第12条 懂得何时和如何进行并发性编程 21</span><br><span class="line">第13条 确保资源为对象所拥有。使用显式的raii和智能指针 24</span><br><span class="line">编程风格 27</span><br><span class="line">第14条 宁要编译时和连接时错误，也不要运行时错误 28</span><br><span class="line">第15条 积极使用const 30</span><br><span class="line">第16条 避免使用宏 32</span><br><span class="line">第17条 避免使用“魔数” 34</span><br><span class="line">第18条 尽可能局部地声明变量 35</span><br><span class="line">第19条 总是初始化变量 36</span><br><span class="line">第20条 避免函数过长，避免嵌套过深 38</span><br><span class="line">第21条 避免跨编译单元的初始化依赖 39</span><br><span class="line">第22条 尽量减少定义性依赖。避免循环依赖 40</span><br><span class="line">第23条 头文件应该自给自足 42</span><br><span class="line">第24条 总是编写内部#include保护符，决不要编写外部#include保护符 43</span><br><span class="line">函数与操作符 45</span><br><span class="line">第25条 正确地选择通过值、（智能）指针或者引用传递参数 46</span><br><span class="line">第26条 保持重载操作符的自然语义 47</span><br><span class="line">第27条 优先使用算术操作符和赋值操作符的标准形式 48</span><br><span class="line">第28条 优先使用++和——的标准形式。优先调用前缀形式 50</span><br><span class="line">第29条 考虑重载以避免隐含类型转换 51</span><br><span class="line">第30条 避免重载&amp;&amp;、</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B004CF9QXG/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B004CF9QXG&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51OYBV-LCAL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Concurrency in Action</title>
    <url>/2020/04/19/cpp-concurrency-in-action/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C++ Concurrency in Action<br>作者信息： 作者: Anthony Williams [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>HIGHLIGHT C++ Concurrency in Action is the first book to market to show how to take advantage of the new C++ Standard and how to write robust multi-threaded applications in C++. DESCRIPTION With the new C++ Standard and Technical Report 2 (TR2), multi-threading is coming to C++ in a big way. TR2 will provide higher-level synchronization facilities that allow for a much greater level of abstraction, and make programming multi-threaded applications simpler and safer. As a guide and reference to the new concurrency features in the upcoming C++ Standard and TR2, this book is invaluable for existing programmers familiar with writing multi-threaded code in C++ using platform-specific APIs, or in other languages, as well as C++ programmers who have never written multithreaded code before. KEY POINTS * When and when not to use concurrency * Concurrency and multi-threading in C++ * Concurrency support in the New Standard * How to improve performance with concurrency * How to manage concurrency * Problems and solutions in sharing data * Synchronization and why we need it * Memory model details</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/1933988770/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=1933988770&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51nuLYxU2iL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 第四版</title>
    <url>/2020/04/19/cpp-primer-4/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C++ Primer 第四版<br>作者信息： 作者: Stanley B.Lippman [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《C++ Primer中文版(第4版)》对C++基本概念和技术全面而且权威的阐述，对现代C++编程风格的强调，使本书成为C++初学者的最佳指南；对于中高级程序员，本书也是不可或缺的参考书。第4版不再强调低层编程技术，而把中心转向标准库的使用。书中很早就开始介绍标准库，示例也已经重新改写，充分利用了标准库设施。我们也对语言主题叙述的先后次序进行了重新编排，使讲解更加流畅。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章　快速入门. 1</span><br><span class="line">1.1编写简单的C++程序 2</span><br><span class="line">1.2初窥输入&#x2F;输出 5</span><br><span class="line">1.2.1标准输入与输出对象 5</span><br><span class="line">1.2.2一个使用IO库的程序 5</span><br><span class="line">1.3关于注释 8</span><br><span class="line">1.4控制结构 10</span><br><span class="line">1.4.1　while语句 10</span><br><span class="line">1.4.2for语句 12</span><br><span class="line">1.4.3if语句 14</span><br><span class="line">1.4.4读入未知数目的输入 15</span><br><span class="line">1.5类的简介 17</span><br><span class="line">1.5.1Sales_item类 17</span><br><span class="line">1.5.2初窥成员函数 19</span><br><span class="line">1.6C++程序 21</span><br><span class="line">小结 22</span><br><span class="line">术语 22</span><br><span class="line">第一部分基本语言</span><br><span class="line">第2章　变量和基本类型 29</span><br><span class="line">2.1基本内置类型 30</span><br><span class="line">2.1.1整型 30</span><br><span class="line">2.1.2浮点型 32</span><br><span class="line">2.2字面值常量 34</span><br><span class="line">2.3变量 38</span><br><span class="line">2.3.1什么是变量 39</span><br><span class="line">2.3.2变量名 40</span><br><span class="line">2.3.3定义对象 42</span><br><span class="line">2.3.4变量初始化规则 44</span><br><span class="line">2.3.5声明和定义 45</span><br><span class="line">2.3.6名字的作用域 46</span><br><span class="line">2.3.7在变量使用处定义变量 48</span><br><span class="line">2.4const限定符 49</span><br><span class="line">2.5引用 50</span><br><span class="line">2.6typedef名字 53</span><br><span class="line">2.7枚举 53</span><br><span class="line">2.8类类型 54</span><br><span class="line">2.9编写自己的头文件 57</span><br><span class="line">2.9.1设计自己的头文件 58</span><br><span class="line">2.9.2预处理器的简单介绍 60</span><br><span class="line">小结 62</span><br><span class="line">术语 62</span><br><span class="line">第3章　标准库类型 67</span><br><span class="line">3.1命名空间的using声明 68</span><br><span class="line">3.2标准库string类型 70</span><br><span class="line">3.2.1string对象的定义和初始化 70</span><br><span class="line">3.2.2String对象的读写 71</span><br><span class="line">3.2.3string对象的操作 72</span><br><span class="line">3.2.4string对象中字符的处理 76</span><br><span class="line">3.3标准库vector类型 78</span><br><span class="line">3.3.1vector对象的定义和初始化 79</span><br><span class="line">3.3.2vector对象的操作 81</span><br><span class="line">3.4迭代器简介 83</span><br><span class="line">3.5标准库bitset类型 88</span><br><span class="line">3.5.1bitset对象的定义和初始化 88</span><br><span class="line">3.5.2bitset对象上的操作 90</span><br><span class="line">小结 92</span><br><span class="line">术语 92</span><br><span class="line">第4章　数组和指针 95</span><br><span class="line">4.1数组 96</span><br><span class="line">4.1.1数组的定义和初始化 96</span><br><span class="line">4.1.2数组操作 99</span><br><span class="line">4.2指针的引入 100</span><br><span class="line">4.2.1什么是指针 100</span><br><span class="line">4.2.2指针的定义和初始化 101</span><br><span class="line">4.2.3指针操作 104</span><br><span class="line">4.2.4使用指针访问数组元素 106</span><br><span class="line">4.2.5指针和const限定符 110</span><br><span class="line">4.3C风格字符串 113</span><br><span class="line">4.3.1创建动态数组 117</span><br><span class="line">4.3.2新旧代码的兼容 120</span><br><span class="line">4.4多维数组 122</span><br><span class="line">小结 124</span><br><span class="line">术语 125</span><br><span class="line">第5章　表达式 127</span><br><span class="line">5.1算术操作符 129</span><br><span class="line">5.2关系操作符和逻辑操作符 131</span><br><span class="line">5.3位操作符 134</span><br><span class="line">5.3.1bitset对象或整型值的使用 135</span><br><span class="line">5.3.2将移位操作符用于IO 137</span><br><span class="line">5.4赋值操作符 137</span><br><span class="line">5.4.1赋值操作的右结合性 138</span><br><span class="line">5.4.2赋值操作具有低优先级 138</span><br><span class="line">5.4.3复合赋值操作符 139</span><br><span class="line">5.5自增和自减操作符 140</span><br><span class="line">5.6箭头操作符 142</span><br><span class="line">5.7条件操作符 143</span><br><span class="line">5.8sizeof操作符 144</span><br><span class="line">5.9逗号操作符 145</span><br><span class="line">5.10复合表达式的求值 145</span><br><span class="line">5.10.1优先级 145</span><br><span class="line">5.10.2结合性 146</span><br><span class="line">5.10.3求值顺序 148</span><br><span class="line">5.11new和delete表达式 150</span><br><span class="line">5.12类型转换 154</span><br><span class="line">5.12.1何时发生隐式类型转换 154</span><br><span class="line">5.12.2算术转换 155</span><br><span class="line">5.12.3其他隐式转换 156</span><br><span class="line">5.12.4显式转换 158</span><br><span class="line">5.12.5何时需要强制类型转换 158</span><br><span class="line">5.12.6命名的强制类型转换 158</span><br><span class="line">5.12.7旧式强制类型转换 160</span><br><span class="line">小结 161</span><br><span class="line">术语 162</span><br><span class="line">第6章　语句 165</span><br><span class="line">6.1简单语句 166</span><br><span class="line">6.2声明语句 167</span><br><span class="line">6.3复合语句（块） 167</span><br><span class="line">6.4语句作用域 168</span><br><span class="line">6.5if语句 169</span><br><span class="line">6.6switch语句 172</span><br><span class="line">6.6.1使用switch 173</span><br><span class="line">6.6.2switch中的控制流 173</span><br><span class="line">6.6.3default标号 175</span><br><span class="line">6.6.4switch表达式与case标号 176</span><br><span class="line">6.6.5switch内部的变量定义 176</span><br><span class="line">6.7while语句 177</span><br><span class="line">6.8for循环语句 179</span><br><span class="line">6.8.1省略for语句头的某些部分 180</span><br><span class="line">6.8.2for语句头中的多个定义 181</span><br><span class="line">6.9dowhile语句 182</span><br><span class="line">6.10break语句 183</span><br><span class="line">6.11continue语句 184</span><br><span class="line">6.12goto语句 185</span><br><span class="line">6.13try块和异常处理 186</span><br><span class="line">6.13.1throw表达式 186</span><br><span class="line">6.13.2try块 187</span><br><span class="line">6.13.3标准异常 189</span><br><span class="line">6.14使用预处理器进行调试 190</span><br><span class="line">小结 192</span><br><span class="line">术语 192</span><br><span class="line">第7章　函数 195</span><br><span class="line">7.1函数的定义 196</span><br><span class="line">7.1.1函数返回类型 197</span><br><span class="line">7.1.2函数形参表 198</span><br><span class="line">7.2参数传递 199</span><br><span class="line">7.2.1非引用形参 199</span><br><span class="line">7.2.2引用形参 201</span><br><span class="line">7.2.3vector和其他容器类型的形参 206</span><br><span class="line">7.2.4数组形参 206</span><br><span class="line">7.2.5传递给函数的数组的处理 209</span><br><span class="line">7.2.6main：处理命令行选项 210</span><br><span class="line">7.2.7含有可变形参的函数 211</span><br><span class="line">7.3return语句 211</span><br><span class="line">7.3.1没有返回值的函数 212</span><br><span class="line">7.3.2具有返回值的函数 212</span><br><span class="line">7.3.3递归 216</span><br><span class="line">7.4函数声明 217</span><br><span class="line">7.5局部对象 220</span><br><span class="line">7.5.1自动对象 220</span><br><span class="line">7.5.2静态局部对象 220</span><br><span class="line">7.6内联函数 221</span><br><span class="line">7.7类的成员函数 222</span><br><span class="line">7.7.1定义成员函数的函数体 223</span><br><span class="line">7.7.2在类外定义成员函数 225</span><br><span class="line">7.7.3编写Sales_item类的构造</span><br><span class="line">函数 225</span><br><span class="line">7.7.4类代码文件的组织 227</span><br><span class="line">7.8重载函数 228</span><br><span class="line">7.8.1重载与作用域 230</span><br><span class="line">7.8.2函数匹配与实参转换 231</span><br><span class="line">7.8.3重载确定的三个步骤 232</span><br><span class="line">7.8.4实参类型转换 234</span><br><span class="line">7.9指向函数的指针 237</span><br><span class="line">小结 239</span><br><span class="line">术语 240</span><br><span class="line">第8章　标准IO库 243</span><br><span class="line">8.1面向对象的标准库 244</span><br><span class="line">8.2条件状态 247</span><br><span class="line">8.3输出缓冲区的管理 249</span><br><span class="line">8.4文件的输入和输出 251</span><br><span class="line">8.4.1文件流对象的使用 251</span><br><span class="line">8.4.2文件模式 254</span><br><span class="line">8.4.3一个打开并检查输入文件的</span><br><span class="line">程序 256</span><br><span class="line">8.5字符串流 257</span><br><span class="line">小结 259</span><br><span class="line">术语 259</span><br><span class="line">第二部分容器和算法</span><br><span class="line">第9章　顺序容器 263</span><br><span class="line">9.1顺序容器的定义 264</span><br><span class="line">9.1.1容器元素的初始化 265</span><br><span class="line">9.1.2容器内元素的类型约束 267</span><br><span class="line">9.2迭代器和迭代器范围 268</span><br><span class="line">9.2.1迭代器范围 270</span><br><span class="line">9.2.2使迭代器失效的容器操作 271</span><br><span class="line">9.3顺序容器的操作 272</span><br><span class="line">9.3.1容器定义的类型别名 272</span><br><span class="line">9.3.2begin和end成员 273</span><br><span class="line">9.3.3在顺序容器中添加元素 273</span><br><span class="line">9.3.4关系操作符 277</span><br><span class="line">9.3.5容器大小的操作 278</span><br><span class="line">9.3.6访问元素 279</span><br><span class="line">9.3.7删除元素 280</span><br><span class="line">9.3.8赋值与swap 282</span><br><span class="line">9.4vector容器的自增长 284</span><br><span class="line">9.5容器的选用 287</span><br><span class="line">9.6再谈string类型 289</span><br><span class="line">9.6.1构造string对象的其他方法 290</span><br><span class="line">9.6.2修改string对象的其他方法 292</span><br><span class="line">9.6.3只适用于string类型的操作 293</span><br><span class="line">9.6.4string类型的查找操作 295</span><br><span class="line">9.6.5string对象的比较 298</span><br><span class="line">9.7容器适配器 300</span><br><span class="line">9.7.1栈适配器 301</span><br><span class="line">9.7.2队列和优先级队列 302</span><br><span class="line">小结 303</span><br><span class="line">术语 303</span><br><span class="line">第10章　关联容器 305</span><br><span class="line">10.1引言：pair类型 306</span><br><span class="line">10.2关联容器 308</span><br><span class="line">10.3map类型 309</span><br><span class="line">10.3.1map对象的定义 309</span><br><span class="line">10.3.2map定义的类型 310</span><br><span class="line">10.3.3给map添加元素 311</span><br><span class="line">10.3.4使用下标访问map对象 311</span><br><span class="line">10.3.5map::insert的使用 313</span><br><span class="line">10.3.6查找并读取map中的元素 315</span><br><span class="line">10.3.7从map对象中删除元素 316</span><br><span class="line">10.3.8map对象的迭代遍历 316</span><br><span class="line">10.3.9“单词转换”map对象 317</span><br><span class="line">10.4set类型 319</span><br><span class="line">10.4.1set容器的定义和使用 319</span><br><span class="line">10.4.2创建“单词排除”集 321</span><br><span class="line">10.5multimap和multiset类型 322</span><br><span class="line">10.5.1元素的添加和删除 322</span><br><span class="line">10.5.2在multimap和multiset</span><br><span class="line">中查找元素 323</span><br><span class="line">10.6容器的综合应用：文本查询程序 325</span><br><span class="line">10.6.1查询程序的设计 326</span><br><span class="line">10.6.2TextQuery类 327</span><br><span class="line">10.6.3TextQuery类的使用 328</span><br><span class="line">10.6.4编写成员函数 330</span><br><span class="line">小结 332</span><br><span class="line">术语 332</span><br><span class="line">第11章　泛型算法 335</span><br><span class="line">11.1概述 336</span><br><span class="line">11.2初窥算法 339</span><br><span class="line">11.2.1只读算法 339</span><br><span class="line">11.2.2写容器元素的算法 341</span><br><span class="line">11.2.3对容器元素重新排序的算法 343</span><br><span class="line">11.3再谈迭代器 347</span><br><span class="line">11.3.1插入迭代器 348</span><br><span class="line">11.3.2iostream迭代器 349</span><br><span class="line">11.3.3反向迭代器 353</span><br><span class="line">11.3.4const迭代器 355</span><br><span class="line">11.3.5五种迭代器 356</span><br><span class="line">11.4泛型算法的结构 358</span><br><span class="line">11.4.1算法的形参模式 359</span><br><span class="line">11.4.2算法的命名规范 359</span><br><span class="line">11.5容器特有的算法 361</span><br><span class="line">小结 362</span><br><span class="line">术语 363</span><br><span class="line">第三部分类和数据抽象</span><br><span class="line">第12章　类 367</span><br><span class="line">12.1类的定义和声明 368</span><br><span class="line">12.1.1类定义：扼要重述 368</span><br><span class="line">12.1.2数据抽象和封装 369</span><br><span class="line">12.1.3关于类定义的更多内容 372</span><br><span class="line">12.1.4类声明与类定义 374</span><br><span class="line">12.1.5类对象 375</span><br><span class="line">12.2隐含的this指针 376</span><br><span class="line">12.3类作用域 380</span><br><span class="line">类作用域中的名字查找 382</span><br><span class="line">12.4构造函数 385</span><br><span class="line">12.4.1构造函数初始化式 387</span><br><span class="line">12.4.2默认实参与构造函数 391</span><br><span class="line">12.4.3默认构造函数 392</span><br><span class="line">12.4.4隐式类类型转换 393</span><br><span class="line">12.4.5类成员的显式初始化 396</span><br><span class="line">12.5友元 396</span><br><span class="line">12.6static类成员 398</span><br><span class="line">12.6.1static成员函数 400</span><br><span class="line">12.6.2static数据成员 400</span><br><span class="line">小结 403</span><br><span class="line">术语 403</span><br><span class="line">第13章　复制控制 405</span><br><span class="line">13.1复制构造函数 406</span><br><span class="line">13.1.1合成的复制构造函数 409</span><br><span class="line">13.1.2定义自己的复制构造函数 409</span><br><span class="line">13.1.3禁止复制 410</span><br><span class="line">13.2赋值操作符 411</span><br><span class="line">13.3析构函数 412</span><br><span class="line">13.4消息处理示例 415</span><br><span class="line">13.5管理指针成员 419</span><br><span class="line">13.5.1定义智能指针类 421</span><br><span class="line">13.5.2定义值型类 425</span><br><span class="line">小结 427</span><br><span class="line">术语 427</span><br><span class="line">第14章　重载操作符与转换 429</span><br><span class="line">14.1重载操作符的定义 430</span><br><span class="line">14.2输入和输出操作符 435</span><br><span class="line">14.2.1输出操作符&lt;&lt;的重载 435</span><br><span class="line">14.2.2输入操作符&gt;&gt;的重载 437</span><br><span class="line">14.3算术操作符和关系操作符 439</span><br><span class="line">14.3.1相等操作符 440</span><br><span class="line">14.3.2关系操作符 441</span><br><span class="line">14.4赋值操作符 441</span><br><span class="line">14.5下标操作符 442</span><br><span class="line">14.6成员访问操作符 443</span><br><span class="line">14.7自增操作符和自减操作符 446</span><br><span class="line">14.8调用操作符和函数对象 449</span><br><span class="line">14.8.1将函数对象用于标准库算法 450</span><br><span class="line">14.8.2标准库定义的函数对象 451</span><br><span class="line">14.8.3函数对象的函数适配器 453</span><br><span class="line">14.9转换与类类型 454</span><br><span class="line">14.9.1转换为什么有用 454</span><br><span class="line">14.9.2转换操作符 455</span><br><span class="line">14.9.3实参匹配和转换 458</span><br><span class="line">14.9.4重载确定和类的实参 461</span><br><span class="line">14.9.5重载.转换和操作符 464</span><br><span class="line">小结 466</span><br><span class="line">术语 467</span><br><span class="line">第四部分面向对象编程与泛型编程</span><br><span class="line">第15章　面向对象编程 471</span><br><span class="line">15.1面向对象编程：概述 472</span><br><span class="line">15.2定义基类和派生类 473</span><br><span class="line">15.2.1定义基类 474</span><br><span class="line">15.2.2protected成员 475</span><br><span class="line">15.2.3派生类 476</span><br><span class="line">15.2.4virtual与其他成员函数 479</span><br><span class="line">15.2.5公用.私有和受保护的继承 482</span><br><span class="line">15.2.6友元关系与继承 486</span><br><span class="line">15.2.7继承与静态成员 486</span><br><span class="line">15.3转换与继承 487</span><br><span class="line">15.3.1派生类到基类的转换 487</span><br><span class="line">15.3.2基类到派生类的转换 489</span><br><span class="line">15.4构造函数和复制控制 490</span><br><span class="line">15.4.1基类构造函数和复制控制 490</span><br><span class="line">15.4.2派生类构造函数 490</span><br><span class="line">15.4.3复制控制和继承 494</span><br><span class="line">15.4.4虚析构函数 495</span><br><span class="line">15.4.5构造函数和析构函数中的虚函数 497</span><br><span class="line">15.5继承情况下的类作用域 497</span><br><span class="line">15.5.1名字查找在编译时发生 498</span><br><span class="line">15.5.2名字冲突与继承 498</span><br><span class="line">15.5.3作用域与成员函数 499</span><br><span class="line">15.5.4虚函数与作用域 500</span><br><span class="line">15.6纯虚函数 502</span><br><span class="line">15.7容器与继承 503</span><br><span class="line">15.8句柄类与继承 504</span><br><span class="line">15.8.1指针型句柄 505</span><br><span class="line">15.8.2复制未知类型 507</span><br><span class="line">15.8.3句柄的使用 508</span><br><span class="line">15.9再谈文本查询示例 511</span><br><span class="line">15.9.1面向对象的解决方案 513</span><br><span class="line">15.9.2值型句柄 514</span><br><span class="line">15.9.3Query_base类 515</span><br><span class="line">15.9.4Query句柄类 516</span><br><span class="line">15.9.5派生类 518</span><br><span class="line">15.9.6eval函数 520</span><br><span class="line">小结 522</span><br><span class="line">术语 523</span><br><span class="line">第16章　模板与泛型编程 525</span><br><span class="line">16.1模板定义 526</span><br><span class="line">16.1.1定义函数模板 526</span><br><span class="line">16.1.2定义类模板 528</span><br><span class="line">16.1.3模板形参 529</span><br><span class="line">16.1.4模板类型形参 531</span><br><span class="line">16.1.5非类型模板形参 533</span><br><span class="line">16.1.6编写泛型程序 534</span><br><span class="line">16.2实例化 535</span><br><span class="line">16.2.1模板实参推断 537</span><br><span class="line">16.2.2函数模板的显式实参 540</span><br><span class="line">16.3模板编译模型 542</span><br><span class="line">16.4类模板成员 545</span><br><span class="line">16.4.1类模板成员函数 548</span><br><span class="line">16.4.2非类型形参的模板实参 551</span><br><span class="line">16.4.3类模板中的友元声明 552</span><br><span class="line">16.4.4Queue和QueueItem的友元</span><br><span class="line">声明 554</span><br><span class="line">16.4.5成员模板 556</span><br><span class="line">16.4.6完整的Queue类 558</span><br><span class="line">16.4.7类模板的static成员 559</span><br><span class="line">16.5一个泛型句柄类 560</span><br><span class="line">16.5.1定义句柄类 561</span><br><span class="line">16.5.2使用句柄 562</span><br><span class="line">16.6模板特化 564</span><br><span class="line">16.6.1函数模板的特化 565</span><br><span class="line">16.6.2类模板的特化 567</span><br><span class="line">16.6.3特化成员而不特化类 569</span><br><span class="line">16.6.4类模板的部分特化 570</span><br><span class="line">16.7重载与函数模板 570</span><br><span class="line">小结 573</span><br><span class="line">术语 574</span><br><span class="line">第五部分高级主题</span><br><span class="line">第17章　用于大型程序的工具 579</span><br><span class="line">17.1异常处理 580</span><br><span class="line">17.1.1抛出类类型的异常 581</span><br><span class="line">17.1.2栈展开 582</span><br><span class="line">17.1.3捕获异常 583</span><br><span class="line">17.1.4重新抛出 585</span><br><span class="line">17.1.5捕获所有异常的处理代码 586</span><br><span class="line">17.1.6函数测试块与构造函数 586</span><br><span class="line">17.1.7异常类层次 587</span><br><span class="line">17.1.8自动资源释放 589</span><br><span class="line">17.1.9auto_ptr类 591</span><br><span class="line">17.1.10异常说明 595</span><br><span class="line">17.1.11函数指针的异常说明 598</span><br><span class="line">17.2命名空间 599</span><br><span class="line">17.2.1命名空间的定义 599</span><br><span class="line">17.2.2嵌套命名空间 603</span><br><span class="line">17.2.3未命名的命名空间 604</span><br><span class="line">17.2.4命名空间成员的使用 606</span><br><span class="line">17.2.5类.命名空间和作用域 609</span><br><span class="line">17.2.6重载与命名空间 612</span><br><span class="line">17.2.7命名空间与模板 614</span><br><span class="line">17.3多重继承与虚继承 614</span><br><span class="line">17.3.1多重继承 615</span><br><span class="line">17.3.2转换与多个基类 617</span><br><span class="line">17.3.3多重继承派生类的复制控制 619</span><br><span class="line">17.3.4多重继承下的类作用域 620</span><br><span class="line">17.3.5虚继承 622</span><br><span class="line">17.3.6虚基类的声明 624</span><br><span class="line">17.3.7特殊的初始化语义 625</span><br><span class="line">小结 628</span><br><span class="line">术语 628</span><br><span class="line">第18章　特殊工具与技术 631</span><br><span class="line">18.1优化内存分配 632</span><br><span class="line">18.1.1C++中的内存分配 632</span><br><span class="line">18.1.2allocator类 633</span><br><span class="line">18.1.3operatornew函数和</span><br><span class="line">operatordelete函数 636</span><br><span class="line">18.1.4定位new表达式 638</span><br><span class="line">18.1.5显式析构函数的调用 639</span><br><span class="line">18.1.6类特定的new和delete 639</span><br><span class="line">18.1.7一个内存分配器基类 641</span><br><span class="line">18.2运行时类型识别 646</span><br><span class="line">18.2.1dynamic_cast操作符 647</span><br><span class="line">18.2.2typeid操作符 649</span><br><span class="line">18.2.3RTTI的使用 650</span><br><span class="line">18.2.4type_info类.. 652</span><br><span class="line">18.3类成员的指针 653</span><br><span class="line">18.3.1声明成员指针 653</span><br><span class="line">18.3.2使用类成员的指针 655</span><br><span class="line">18.4嵌套类 658</span><br><span class="line">18.4.1嵌套类的实现 658</span><br><span class="line">18.4.2嵌套类作用域中的名字查找 661</span><br><span class="line">18.5联合：节省空间的类 662</span><br><span class="line">18.6局部类 665</span><br><span class="line">18.7固有的不可移植的特征 666</span><br><span class="line">18.7.1位域 666</span><br><span class="line">18.7.2volatile限定符 668</span><br><span class="line">18.7.3链接指示：extern&quot;C&quot; 669</span><br><span class="line">小结 672</span><br><span class="line">术语 673</span><br><span class="line">附录　标准库 675</span><br><span class="line">索引… 703</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00114DX08/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00114DX08&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/519LZVVm-aL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Templates</title>
    <url>/2020/04/19/cpp-templates/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C++ Templates<br>作者信息： 作者: Nicolai M.Josuttis [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《C++ Templates中文版》全书共22章。第1章全面介绍了《C++ Templates中文版》的内容结构和相关情况。第1部分(第2～7章)以教程的风格介绍了模板的基本概念，第2部分(第8～13章)阐述了模板的语言细节，第3部分(第14～18章)介绍了C++模板所支持的基本设计技术，第4部分(第19～22章)深入探讨了各种使用模板的普通应用程序。附录A和附录B分别为一处定义原则和重载解析的相关资料。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 关于本章 1</span><br><span class="line">1.1 阅读本书所需具备的知识 2</span><br><span class="line">1.2 本书的整体结构 2</span><br><span class="line">1.3 如何阅读本书 2</span><br><span class="line">1.4 关于编程风格的一些说明 3</span><br><span class="line">1.5 标准和现实 5</span><br><span class="line">1.6 代码例子和更多信息 5</span><br><span class="line">1.7 反馈 5</span><br><span class="line">第1部分 基础 7</span><br><span class="line">第2章 函数模板 9</span><br><span class="line">2.1 初探函数模板 9</span><br><span class="line">2.1.1 定义模板 9</span><br><span class="line">2.1.2 使用模板 10</span><br><span class="line">2.2 实参的演绎（deduction） 12</span><br><span class="line">2.3 模板参数 13</span><br><span class="line">2.4 重载函数模板 15</span><br><span class="line">2.5 小结 19</span><br><span class="line">第3章 类模板 21</span><br><span class="line">3.1 类模板Stack的实现 21</span><br><span class="line">3.1.1 类模板的声明 22</span><br><span class="line">3.1.2 成员函数的实现 23</span><br><span class="line">3.2 类模板Stack的使用 25</span><br><span class="line">3.3 类模板的特化 27</span><br><span class="line">3.4 局部特化 29</span><br><span class="line">3.5 缺省模板实参 30</span><br><span class="line">3.6 小结 32</span><br><span class="line">第4章 非类型模板参数 33</span><br><span class="line">4.1 非类型的类模板参数 33</span><br><span class="line">4.2 非类型的函数模板参数 36</span><br><span class="line">4.3 非类型模板参数的限制 37</span><br><span class="line">4.4 小结 38</span><br><span class="line">第5章 技巧性基础知识 39</span><br><span class="line">5.1 关键字typename 39</span><br><span class="line">5.2 使用this—&gt; 41</span><br><span class="line">5.3 成员模板 42</span><br><span class="line">5.4 模板的模板参数 45</span><br><span class="line">5.5 零初始化 51</span><br><span class="line">5.6 使用字符串作为函数模板的实参 52</span><br><span class="line">5.7 小结 55</span><br><span class="line">第6章 模板实战 57</span><br><span class="line">6.1 包含模型 57</span><br><span class="line">6.1.1 链接器错误 57</span><br><span class="line">6.1.2 头文件中的模板 59</span><br><span class="line">6.2 显式实例化 60</span><br><span class="line">6.2.1 显式实例化的例子 61</span><br><span class="line">6.2.2 整合包含模型和显式实例化 62</span><br><span class="line">6.3 分离模型 63</span><br><span class="line">6.3.1 关键字export 63</span><br><span class="line">6.3.2 分离模型的限制 65</span><br><span class="line">6.3.3 为分离模型做好准备 66</span><br><span class="line">6.4 模板和内联 67</span><br><span class="line">6.5 预编译头文件 68</span><br><span class="line">6.6 调试模板 70</span><br><span class="line">6.6.1 理解长段的错误信息 71</span><br><span class="line">6.6.2 浅式实例化 72</span><br><span class="line">6.6.3 长符号串 75</span><br><span class="line">6.6.4 跟踪程序 75</span><br><span class="line">6.6.5 oracles 79</span><br><span class="line">6.6.6 archetypes 80</span><br><span class="line">6.7 本章后记 80</span><br><span class="line">6.8 小结 81</span><br><span class="line">第7章 模板术语 83</span><br><span class="line">7.1 “类模板”还是“模板类” 83</span><br><span class="line">7.2 实例化和特化 84</span><br><span class="line">7.3 声明和定义 85</span><br><span class="line">7.4 一处定义原则 86</span><br><span class="line">7.5 模板实参和模板参数 86</span><br><span class="line">第2部分 深入模板 89</span><br><span class="line">第8章 深入模板基础 91</span><br><span class="line">8.1 参数化声明 91</span><br><span class="line">8.1.1 虚成员函数 94</span><br><span class="line">8.1.2 模板的链接 95</span><br><span class="line">8.1.3 基本模板 96</span><br><span class="line">8.2 模板参数 96</span><br><span class="line">8.2.1 类型参数 97</span><br><span class="line">8.2.2 非类型参数 97</span><br><span class="line">8.2.3 模板的模板参数 98</span><br><span class="line">8.2.4 缺省模板实参 99</span><br><span class="line">8.3 模板实参 100</span><br><span class="line">8.3.1 函数模板实参 101</span><br><span class="line">8.3.2 类型实参 103</span><br><span class="line">8.3.3 非类型实参 105</span><br><span class="line">8.3.4 模板的模板实参 107</span><br><span class="line">8.3.5 实参的等价性 109</span><br><span class="line">8.4 友元 109</span><br><span class="line">8.4.1 友元函数 110</span><br><span class="line">8.4.2 友元模板 113</span><br><span class="line">8.5 本章后记 113</span><br><span class="line">第9章 模板中的名称 115</span><br><span class="line">9.1 名称的分类 115</span><br><span class="line">9.2 名称查找 117</span><br><span class="line">9.2.1 Argument—DependentLookup（ADL） 119</span><br><span class="line">9.2.2 友元名称插入 121</span><br><span class="line">9.2.3 插入式类名称 121</span><br><span class="line">9.3 解析模板 123</span><br><span class="line">9.3.1 非模板中的上下文相关性 123</span><br><span class="line">9.3.2 依赖型类型名称 125</span><br><span class="line">9.3.3 依赖型模板名称 127</span><br><span class="line">9.3.4 using—declaration中的依赖型名称 129</span><br><span class="line">9.3.5 ADL和显式模板实参 130</span><br><span class="line">9.4 派生和类模板 131</span><br><span class="line">9.4.1 非依赖型基类 131</span><br><span class="line">9.4.2 依赖型基类 132</span><br><span class="line">9.5 本章后记 134</span><br><span class="line">第10章 实例化 137</span><br><span class="line">10.1 On—Demand实例化 137</span><br><span class="line">10.2 延迟实例化 139</span><br><span class="line">10.3 C++的实例化模型 142</span><br><span class="line">10.3.1 两阶段查找 142</span><br><span class="line">10.3.2 POI 142</span><br><span class="line">10.3.3 包含模型与分离模型 145</span><br><span class="line">10.3.4 跨翻译单元查找 146</span><br><span class="line">10.3.5 例子 147</span><br><span class="line">10.4 几种实现方案 149</span><br><span class="line">10.4.1 贪婪实例化 151</span><br><span class="line">10.4.2 询问实例化 152</span><br><span class="line">10.4.3 迭代实例化 153</span><br><span class="line">10.5 显式实例化 155</span><br><span class="line">10.6 本章后记 159</span><br><span class="line">第11章 模板实参演译 163</span><br><span class="line">11.1 演绎的过程 163</span><br><span class="line">11.2 演绎的上下文 165</span><br><span class="line">11.3 特殊的演绎情况 167</span><br><span class="line">11.4 可接受的实参转型 168</span><br><span class="line">11.5 类模板参数 169</span><br><span class="line">11.6 缺省调用实参 169</span><br><span class="line">11.7 Barton—Nackman方法 170</span><br><span class="line">11.8 本章后记 172</span><br><span class="line">第12章 特化与重载 175</span><br><span class="line">12.1 当泛型代码不再适用的时候 175</span><br><span class="line">12.1.1 透明自定义 176</span><br><span class="line">12.1.2 语义的透明性 177</span><br><span class="line">12.2 重载函数模板 178</span><br><span class="line">12.2.1 签名 179</span><br><span class="line">12.2.2 重载的函数模板的局部排序 182</span><br><span class="line">12.2.3 正式的排序原则 183</span><br><span class="line">12.2.4 模板和非模板 185</span><br><span class="line">12.3 显式特化 185</span><br><span class="line">12.3.1 全局的类模板特化 186</span><br><span class="line">12.3.2 全局的函数模板特化 189</span><br><span class="line">12.3.3 全局成员特化 191</span><br><span class="line">12.4 局部的类模板特化 194</span><br><span class="line">12.5 本章后记 197</span><br><span class="line">第13章 未来的方向 199</span><br><span class="line">13.1 尖括号Hack 199</span><br><span class="line">13.2 放松typename的原则 200</span><br><span class="line">13.3 缺省函数模板实参 201</span><br><span class="line">13.4 字符串文字和浮点型模板实参 202</span><br><span class="line">13.5 放松模板的模板参数的匹配 204</span><br><span class="line">13.6 typedef模板 206</span><br><span class="line">13.7 函数模板的局部特化 207</span><br><span class="line">13.8 typeof运算符 208</span><br><span class="line">13.9 命名模板实参 210</span><br><span class="line">13.10 静态属性 211</span><br><span class="line">13.11 客户端的实例化诊断信息 212</span><br><span class="line">13.12 重载类模板 214</span><br><span class="line">13.13 List参数 215</span><br><span class="line">13.14 布局控制 217</span><br><span class="line">13.15 初始化器的演绎 218</span><br><span class="line">13.16 函数表达式 219</span><br><span class="line">13.17 本章后记 221</span><br><span class="line">第3部分 模板与设计 223</span><br><span class="line">第14章 模板的多态威力 225</span><br><span class="line">14.1 动多态 225</span><br><span class="line">14.2 静多态 228</span><br><span class="line">14.3 动多态和静多态 231</span><br><span class="line">14.3.1 术语 231</span><br><span class="line">14.3.2 优点和缺点 232</span><br><span class="line">14.3.3 组合这两种多态 232</span><br><span class="line">14.4 新形式的设计模板 233</span><br><span class="line">14.5 泛型程序设计 234</span><br><span class="line">14.6 本章后记 236</span><br><span class="line">第15章 trait与policy类 239</span><br><span class="line">15.1 一个实例：累加一个序列 239</span><br><span class="line">15.1.1 fixedtraits 240</span><br><span class="line">15.1.2 valuetrait 243</span><br><span class="line">15.1.3 参数化trait 247</span><br><span class="line">15.1.4 policy和policy类 249</span><br><span class="line">15.1.5 trait和policy：区别在何处 251</span><br><span class="line">15.1.6 成员模板和模板的模板参数 252</span><br><span class="line">15.1.7 组合多个policie和／或trait 254</span><br><span class="line">15.1.8 运用普通的迭代器进行累积 255</span><br><span class="line">15.2 类型函数 256</span><br><span class="line">15.2.1 确定元素的类型 257</span><br><span class="line">15.2.2 确定class类型 259</span><br><span class="line">15.2.3 引用和限定符 261</span><br><span class="line">15.2.4 promotiontrait 264</span><br><span class="line">15.3 policytrait 267</span><br><span class="line">15.3.1 只读的参数类型 268</span><br><span class="line">15.3.2 拷贝、交换和移动 271</span><br><span class="line">15.4 本章后记 275</span><br><span class="line">第16章 模板与继承 277</span><br><span class="line">16.1 命名模板参数 277</span><br><span class="line">16.2 空基类优化 281</span><br><span class="line">16.2.1 布局原则 281</span><br><span class="line">16.2.2 成员作基类 284</span><br><span class="line">16.3 奇特的递归模板模式 286</span><br><span class="line">16.4 参数化虚拟性 289</span><br><span class="line">16.5 本章后记 290</span><br><span class="line">第17章 metaprogram 293</span><br><span class="line">17.1 metaprogram的第一个实例 293</span><br><span class="line">17.2 枚举值和静态常量 295</span><br><span class="line">17.3 第2个例子：计算平方根 297</span><br><span class="line">17.4 使用归纳变量 301</span><br><span class="line">17.5 计算完整性 304</span><br><span class="line">17.6 递归实例化和递归模板实参 304</span><br><span class="line">17.7 使用metaprogram来展开循环 306</span><br><span class="line">17.8 本章后记 309</span><br><span class="line">第18章 表示式模板 313</span><br><span class="line">18.1 临时变量和分割循环 314</span><br><span class="line">18.2 在模板实参中编码表达式 319</span><br><span class="line">18.2.1 表达式模板的操作数 320</span><br><span class="line">18.2.2 Array类型 323</span><br><span class="line">18.2.3 运算符 325</span><br><span class="line">18.2.4 回顾 327</span><br><span class="line">18.2.5 表达式模板赋值 329</span><br><span class="line">18.3 表达式模板的性能与约束 330</span><br><span class="line">18.4 本章后记 331</span><br><span class="line">第4部分 高级应用程序 335</span><br><span class="line">第19章 类型区分 337</span><br><span class="line">19.1 辨别基本类型 337</span><br><span class="line">19.2 辨别组合类型 340</span><br><span class="line">19.3 辨别函数类型 342</span><br><span class="line">19.4 运用重载解析辨别枚举类型 346</span><br><span class="line">19.5 辨别class类型 348</span><br><span class="line">19.6 辨别所有类型的函数模板 349</span><br><span class="line">19.7 本章后记 352</span><br><span class="line">第20章 智能指针 355</span><br><span class="line">20.1 holder和trule 355</span><br><span class="line">20.1.1 安全处理异常 356</span><br><span class="line">20.1.2 holder 358</span><br><span class="line">20.1.3 作为成员的holder 360</span><br><span class="line">20.1.4 资源获取于初始化 362</span><br><span class="line">20.1.5 holder的局限 363</span><br><span class="line">20.1.6 复制holder 364</span><br><span class="line">20.1.7 跨函数调用来复制holder 365</span><br><span class="line">20.1.8 trule 366</span><br><span class="line">20.2 引用记数 368</span><br><span class="line">20.2.1 计数器在什么地方 370</span><br><span class="line">20.2.2 并发访问计数器 370</span><br><span class="line">20.2.3 析构和释放 371</span><br><span class="line">20.2.4 CountingPtr模板 372</span><br><span class="line">20.2.5 一个简单的非侵入式计数器 375</span><br><span class="line">20.2.6 一个简单的侵入式计数器模板 377</span><br><span class="line">20.2.7 常数性 378</span><br><span class="line">20.2.8 隐式转型 379</span><br><span class="line">20.2.9 比较 381</span><br><span class="line">20.3 本章后记 383</span><br><span class="line">第21章 tuple 385</span><br><span class="line">21.1 duo 385</span><br><span class="line">21.2 可递归duo 390</span><br><span class="line">21.2.1 域的个数 390</span><br><span class="line">21.2.2 域的类型 392</span><br><span class="line">21.2.3 域的值 393</span><br><span class="line">21.3 tuple构造 398</span><br><span class="line">21.4 本章后记 403</span><br><span class="line">第22章 函数对象和回调 405</span><br><span class="line">22.1 直接调用、间接调用与内联调用 406</span><br><span class="line">22.2 函数指针与函数引用 409</span><br><span class="line">22.3 成员函数指针 411</span><br><span class="line">22.4 class类型的仿函数 414</span><br><span class="line">22.4.1 class类型仿函数的第1个实例 414</span><br><span class="line">22.4.2 class类型仿函数的类型 416</span><br><span class="line">22.5 指定仿函数 417</span><br><span class="line">22.5.1 作为模板类型实参的仿函数 417</span><br><span class="line">22.5.2 作为函数调用实参的仿函数 418</span><br><span class="line">22.5.3 结合函数调用参数和模板类型参数 419</span><br><span class="line">22.5.4 作为非类型模板实参的仿函数 420</span><br><span class="line">22.5.5 函数指针的封装 421</span><br><span class="line">22.6 内省 423</span><br><span class="line">22.6.1 分析一个仿函数的类型 424</span><br><span class="line">22.6.2 访问参数的类型 425</span><br><span class="line">22.6.3 封装函数指针 426</span><br><span class="line">22.7 函数对象组合 431</span><br><span class="line">22.7.1 简单的组合 432</span><br><span class="line">22.7.2 混合类型的组合 436</span><br><span class="line">22.7.3 减少参数的个数 440</span><br><span class="line">22.8 值绑定 443</span><br><span class="line">22.8.1 选择绑定的目标 444</span><br><span class="line">22.8.2 绑定签名 446</span><br><span class="line">22.8.3 实参选择 447</span><br><span class="line">22.8.4 辅助函数 453</span><br><span class="line">22.9 仿函数操作：一个完整的实现 455</span><br><span class="line">22.10 本章后记 457</span><br><span class="line">附录A 一处定义原则 459</span><br><span class="line">A.1 翻译单元 459</span><br><span class="line">A.2 声明和定义 460</span><br><span class="line">A.3 一处定义原则的细节 461</span><br><span class="line">A.3.1 程序的一处定义约束 461</span><br><span class="line">A.3.2 翻译单元的一处定义约束 463</span><br><span class="line">A.3.3 跨翻译单元的等价性约束 465</span><br><span class="line">附录B 重载解析 471</span><br><span class="line">B.1 何时应用重载解析 472</span><br><span class="line">B.2 简化过的重载解析 472</span><br><span class="line">B.2.1 成员函数的隐含实参 474</span><br><span class="line">B.2.2 细化完美匹配 476</span><br><span class="line">B.3 重载的细节 477</span><br><span class="line">B.3.1 非模板优先 477</span><br><span class="line">B.3.2 转型序列 477</span><br><span class="line">B.3.3 指针的转型 478</span><br><span class="line">B.3.4 仿函数和代理函数 480</span><br><span class="line">B.3.5 其他的重载情况 481</span><br><span class="line">参考资料 483</span><br><span class="line">术语表 487</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00C8UTZOM/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00C8UTZOM&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51pi2fESjiL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective STL</title>
    <url>/2020/04/19/efeffective-stl/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Effective STL<br>作者信息： 作者: Scott Meyers [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>C++标准模板库(STL)是革命性的，但是要想学会并用好却并不容易。 Scott Meyers(EffectiveC++与More effectivec++的作者)揭示了专家总结的一些关键规则，既有专家们总是采用的做法，也有专家们总是避免的做法。通过这些规则，STL程序员可以最大限度地使用STL。在讲述50条指导原则时，本书提供了透彻的分析和深刻的实例，以让读者学到要做什么，什么时候该这样做，以及为什么要这样做。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">引言</span><br><span class="line">１ 容器</span><br><span class="line">第1 条：慎重选择容器类型。</span><br><span class="line">第2 条：不要试图编写独立于容器类型的代码。</span><br><span class="line">第3 条：确保容器中的对象拷贝正确而高效。</span><br><span class="line">第4 条：调用empty 而不是检查size()是否为0。</span><br><span class="line">第5 条：区间成员函数优先于与之对应的单元素成员函数。</span><br><span class="line">第6 条：当心C++编译器最烦人的分析机制。</span><br><span class="line">第7 条：如果容器中包含了通过new 操作创建的指针，切记在容器对象析构前将</span><br><span class="line">指针delete 掉。</span><br><span class="line">第8 条：切勿创建包含auto_ptr 的容器对象。</span><br><span class="line">第9 条：慎重选择删除元素的方法。</span><br><span class="line">第10 条：了解分配子（allocator）的约定和限制。</span><br><span class="line">第11 条：理解自定义分配子的合理用法。</span><br><span class="line">第12 条：切勿对STL 容器的线程安全性有不切实际的依赖。</span><br><span class="line">２ vector 和string</span><br><span class="line">第13 条：vector 和string 优先于动态分配的数组。</span><br><span class="line">第14 条：使用reserve 来避免不必要的重新分配。</span><br><span class="line">第15 条：注意string 实现的多样性。</span><br><span class="line">第16 条：了解如何把vector 和string 数据传给旧的API。</span><br><span class="line">第17 条：使用“swap 技巧”除去多余的容量。</span><br><span class="line">第18 条：避免使用vector。</span><br><span class="line">３ 关联容器</span><br><span class="line">第19 条：理解相等（equality）和等价（equivalence）的区别。</span><br><span class="line">第20 条：为包含指针的关联容器指定比较类型。</span><br><span class="line">第21 条：总是让比较函数在等值情况下返回false。</span><br><span class="line">第22 条：切勿直接修改set 或multiset 中的键。</span><br><span class="line">第23 条：考虑用排序的vector 替代关联容器。</span><br><span class="line">第24 条：当效率至关重要时，请在map::operator[ ]与map::insert 之间谨慎做出选择。</span><br><span class="line">第25 条：熟悉非标准的散列容器。</span><br><span class="line">４ 迭代器</span><br><span class="line">第26 条：iterator 优先于const_iterator、reverse_iterator及const_reverse_iterator。</span><br><span class="line">第27 条：使用distance 和advance 将容器的const_iterator 转换成iterator。</span><br><span class="line">第28 条：正确理解由reverse_iterator 的base()成员函数所产生的iterator的用法。</span><br><span class="line">第29 条：对于逐个字符的输入请考虑使用istreambuf_iterator。</span><br><span class="line">５ 算法</span><br><span class="line">第30 条：确保目标区间足够大。</span><br><span class="line">第31 条：了解各种与排序有关的选择。</span><br><span class="line">第32 条：如果确实需要删除元素，则需要在remove 这一类算法之后调用erase。</span><br><span class="line">第33 条：对包含指针的容器使用remove 这一类算法时要特别小心。</span><br><span class="line">第34 条：了解哪些算法要求使用排序的区间作为参数。</span><br><span class="line">第35 条：通过mismatch 或lexicographical_compare 实现简单的忽略大小写的字符</span><br><span class="line">串比较。</span><br><span class="line">第36 条：理解copy_if 算法的正确实现。</span><br><span class="line">第37 条：使用accumulate 或者for_each 进行区间统计。</span><br><span class="line">６ 函数子、函数子类、函数及其他</span><br><span class="line">第38 条：遵循按值传递的原则来设计函数子类。</span><br><span class="line">第39 条：确保判别式是“纯函数”。</span><br><span class="line">第40 条：若一个类是函数子，则应使它可配接。</span><br><span class="line">第41 条：理解ptr_fun、mem_fun 和mem_fun_ref 的来由。</span><br><span class="line">第42 条：确保less与operator&lt;具有相同的语义。</span><br><span class="line">７ 在程序中使用STL</span><br><span class="line">第43 条：算法调用优先于手写的循环。</span><br><span class="line">第44 条：容器的成员函数优先于同名的算法。</span><br><span class="line">第45 条：正确区分count、find、binary_search、lower_bound、upper_bound 和</span><br><span class="line">equal_range。</span><br><span class="line">第46 条：考虑使用函数对象而不是函数作为STL 算法的参数。</span><br><span class="line">第47 条：避免产生“直写型”（write-only）的代码。</span><br><span class="line">第48 条：总是包含（#include）正确的头文件。</span><br><span class="line">第49 条：学会分析与STL 相关的编译器诊断信息。</span><br><span class="line">第50 条：熟悉与STL 相关的Web 站点。</span><br><span class="line">参考书目</span><br><span class="line">附录A 地域性与忽略大小写的字符串比较</span><br><span class="line">附录B 对Microsoft 的STL 平台的说明</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00CSWIJUQ/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00CSWIJUQ&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51iIOtqOHhL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer 第五版 （英文）</title>
    <url>/2020/04/19/cpp-primer-5th/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C++ Primer 第五版 （英文）<br>作者信息： 作者: Stanley B.Lippman [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《C++ Primer英文版(第5版)》编辑推荐：最新标准C++11发布，距上一版本已10年；《C++ Primer英文版(第5版)》是唯一持续更新的全球顶级C++读本。多位深孚众望的大师组合堪称绝无仅有；经过前四个版本积累，第5版的体例堪称完美。这一版本作者历时3年完成，极力避免在原版上升级，而是将C++11的新特性真正融入各章节；更将所有代码示例用C++ 11的简化写法完成，而不是仅单独增加内容。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Preface xxiii</span><br><span class="line">Chapter 1 Getting Started</span><br><span class="line">1.1 Writing a Simple C++Program</span><br><span class="line">1.1.1 Compiling and Executing Our Program</span><br><span class="line">1.2 AFirstLookat Input&#x2F;Output</span><br><span class="line">1.3 AWordaboutComments</span><br><span class="line">1.4 FlowofControl</span><br><span class="line">1.4.1 The whileStatement</span><br><span class="line">1.4.2 The forStatement</span><br><span class="line">1.4.3 ReadinganUnknownNumberof Inputs</span><br><span class="line">1.4.4 The ifStatement</span><br><span class="line">1.5 IntroducingClasses</span><br><span class="line">1.5.1 The Sales_itemClass</span><br><span class="line">1.5.2 AFirstLookatMemberFunctions</span><br><span class="line">1.6 TheBookstoreProgram</span><br><span class="line">ChapterSummary</span><br><span class="line">DefinedTerms</span><br><span class="line">Part I The Basics</span><br><span class="line">Chapter 2 Variables and Basic Types</span><br><span class="line">2.1 PrimitiveBuilt-inTypes</span><br><span class="line">2.1.1 ArithmeticTypes</span><br><span class="line">2.1.2 TypeConversions</span><br><span class="line">2.1.3 Literals</span><br><span class="line">2.2 Variables</span><br><span class="line">2.2.1 VariableDefinitions</span><br><span class="line">2.2.2 VariableDeclarations andDefinitions</span><br><span class="line">2.2.3 Identifiers</span><br><span class="line">2.2.4 Scopeof aName</span><br><span class="line">2.3 CompoundTypes</span><br><span class="line">2.3.1 References</span><br><span class="line">2.3.2 Pointers</span><br><span class="line">vii</span><br><span class="line">viii Contents</span><br><span class="line">2.3.3 UnderstandingCompoundTypeDeclarations</span><br><span class="line">2.4 constQualifier</span><br><span class="line">2.4.1 References to const</span><br><span class="line">2.4.2 Pointers and const</span><br><span class="line">2.4.3 Top-Level const</span><br><span class="line">2.4.4 constexprandConstantExpressions</span><br><span class="line">2.5 DealingwithTypes</span><br><span class="line">2.5.1 TypeAliases</span><br><span class="line">2.5.2 The autoTypeSpecifier</span><br><span class="line">2.5.3 The decltypeTypeSpecifier</span><br><span class="line">2.6 DefiningOurOwnDataStructures</span><br><span class="line">2.6.1 Defining the Sales_dataType</span><br><span class="line">2.6.2 Using the Sales_dataClass</span><br><span class="line">2.6.3 Writing Our Own Header Files</span><br><span class="line">ChapterSummary</span><br><span class="line">DefinedTerms</span><br><span class="line">Chapter 3 Strings， Vectors， and Arrays</span><br><span class="line">3.1 Namespace usingDeclarations</span><br><span class="line">3.2 Library stringType</span><br><span class="line">3.2.1 Defining and Initializing strings</span><br><span class="line">3.2.2 Operations on strings</span><br><span class="line">3.2.3 Dealing with the Characters in a string</span><br><span class="line">3.3 Library vectorType</span><br><span class="line">3.3.1 Defining and Initializing vectors</span><br><span class="line">3.3.2 Adding Elements to a vector</span><br><span class="line">3.3.3 Other vectorOperations</span><br><span class="line">3.4 IntroducingIterators</span><br><span class="line">3.4.1 UsingIterators</span><br><span class="line">3.4.2 IteratorArithmetic</span><br><span class="line">3.5 Arrays</span><br><span class="line">3.5.1 DefiningandInitializingBuilt-inArrays</span><br><span class="line">3.5.2 AccessingtheElementsof anArray</span><br><span class="line">3.5.3 Pointers andArrays</span><br><span class="line">3.5.4 C-StyleCharacterStrings</span><br><span class="line">3.5.5 InterfacingtoOlderCode</span><br><span class="line">3.6 MultidimensionalArrays</span><br><span class="line">ChapterSummary</span><br><span class="line">DefinedTerms</span><br><span class="line">Chapter 4 Expressions</span><br><span class="line">4.1 Fundamentals</span><br><span class="line">4.1.1 BasicConcepts</span><br><span class="line">4.1.2 PrecedenceandAssociativity</span><br><span class="line">4.1.3 OrderofEvaluation</span><br><span class="line">4.2 ArithmeticOperators</span><br><span class="line">4.3 Logical andRelationalOperators</span><br><span class="line">Contents ix</span><br><span class="line">4.4 AssignmentOperators</span><br><span class="line">4.5 Increment andDecrementOperators</span><br><span class="line">4.6 TheMemberAccessOperators</span><br><span class="line">4.7 TheConditionalOperator</span><br><span class="line">4.8 TheBitwiseOperators</span><br><span class="line">4.9 The sizeofOperator</span><br><span class="line">4.10 CommaOperator</span><br><span class="line">4.11 TypeConversions</span><br><span class="line">4.11.1 TheArithmeticConversions</span><br><span class="line">4.11.2 Other ImplicitConversions</span><br><span class="line">4.11.3 ExplicitConversions</span><br><span class="line">4.12 OperatorPrecedenceTable</span><br><span class="line">ChapterSummary</span><br><span class="line">DefinedTerms</span><br><span class="line">Chapter 5 Statements</span><br><span class="line">5.1 Simple Statements</span><br><span class="line">5.2 StatementScope</span><br><span class="line">5.3 Conditional Statements</span><br><span class="line">5.3.1 The ifStatement</span><br><span class="line">5.3.2 The switchStatement</span><br><span class="line">5.4 IterativeStatements</span><br><span class="line">5.4.1 The whileStatement</span><br><span class="line">5.4.2 Traditional forStatement</span><br><span class="line">5.4.3 Range forStatement</span><br><span class="line">5.4.4 The do whileStatement</span><br><span class="line">5.5 JumpStatements</span><br><span class="line">5.5.1 The breakStatement</span><br><span class="line">5.5.2 The continueStatement</span><br><span class="line">5.5.3 The gotoStatement</span><br><span class="line">5.6 tryBlocks andExceptionHandling</span><br><span class="line">5.6.1 A throwExpression</span><br><span class="line">5.6.2 The tryBlock</span><br><span class="line">5.6.3 StandardExceptions</span><br><span class="line">ChapterSummary</span><br><span class="line">DefinedTerms</span><br><span class="line">Chapter 6 Functions</span><br><span class="line">6.1 FunctionBasics</span><br><span class="line">6.1.1 LocalObjects</span><br><span class="line">6.1.2 FunctionDeclarations</span><br><span class="line">6.1.3 SeparateCompilation</span><br><span class="line">6.2 ArgumentPassing</span><br><span class="line">6.2.1 PassingArgumentsbyValue</span><br><span class="line">6.2.2 PassingArgumentsbyReference</span><br><span class="line">6.2.3 constParametersandArguments</span><br><span class="line">6.2.4 ArrayParameters</span><br><span class="line">x Contents</span><br><span class="line">6.2.5 main：HandlingCommand-LineOptions</span><br><span class="line">6.2.6 FunctionswithVaryingParameters</span><br><span class="line">6.3 Return Types and the returnStatement</span><br><span class="line">6.3.1 FunctionswithNoReturnValue</span><br><span class="line">6.3.2 FunctionsThatReturnaValue</span><br><span class="line">6.3.3 ReturningaPointer toanArray</span><br><span class="line">6.4 OverloadedFunctions</span><br><span class="line">6.4.1 OverloadingandScope</span><br><span class="line">6.5 Features forSpecializedUses</span><br><span class="line">6.5.1 DefaultArguments</span><br><span class="line">6.5.2 Inline and constexprFunctions</span><br><span class="line">6.5.3 Aids for Debugging</span><br><span class="line">6.6 FunctionMatching</span><br><span class="line">6.6.1 ArgumentTypeConversions</span><br><span class="line">6.7 Pointers toFunctions</span><br><span class="line">ChapterSummary</span><br><span class="line">DefinedTerms</span><br><span class="line">Chapter 7 Classes</span><br><span class="line">7.1 DefiningAbstractDataTypes</span><br><span class="line">7.1.1 Designing the Sales_dataClass</span><br><span class="line">7.1.2 Defining the Revised Sales_dataClass</span><br><span class="line">7.1.3 DefiningNonmemberClass-RelatedFunctions</span><br><span class="line">7.1.4 Constructors</span><br><span class="line">7.1.5 Copy，Assignment， andDestruction</span><br><span class="line">7.2 AccessControl andEncapsulation</span><br><span class="line">7.2.1 Friends</span><br><span class="line">7.3 AdditionalClassFeatures</span><br><span class="line">7.3.1 ClassMembersRevisited</span><br><span class="line">7.3.2 Functions That Return *this</span><br><span class="line">7.3.3 ClassTypes</span><br><span class="line">7.3.4 FriendshipRevisited</span><br><span class="line">7.4 ClassScope</span><br><span class="line">7.4.1 NameLookupandClassScope</span><br><span class="line">7.5 ConstructorsRevisited</span><br><span class="line">7.5.1 Constructor InitializerList</span><br><span class="line">7.5.2 DelegatingConstructors</span><br><span class="line">7.5.3 TheRoleof theDefaultConstructor</span><br><span class="line">7.5.4 ImplicitClass-TypeConversions</span><br><span class="line">7.5.5 AggregateClasses</span><br><span class="line">7.5.6 LiteralClasses</span><br><span class="line">7.6 staticClassMembers</span><br><span class="line">ChapterSummary</span><br><span class="line">DefinedTerms</span><br><span class="line">Contents xi</span><br><span class="line">Part II The C++ Library</span><br><span class="line">Chapter 8 The IO Library</span><br><span class="line">8.1 The IOClasses</span><br><span class="line">8.1.1 NoCopyorAssignfor IOObjects</span><br><span class="line">8.1.2 ConditionStates</span><br><span class="line">8.1.3 ManagingtheOutputBuffer</span><br><span class="line">8.2 File Input and Output</span><br><span class="line">8.2.1 Using File Stream Objects</span><br><span class="line">8.2.2 File Modes</span><br><span class="line">8.3 stringStreams</span><br><span class="line">8.3.1 Using an istringstream</span><br><span class="line">8.3.2 Using ostringstreams</span><br><span class="line">ChapterSummary</span><br><span class="line">DefinedTerms</span><br><span class="line">Chapter 9 Sequential Containers</span><br><span class="line">9.1 Overviewof the SequentialContainers</span><br><span class="line">9.2 ContainerLibraryOverview</span><br><span class="line">9.2.1 Iterators</span><br><span class="line">9.2.2 ContainerTypeMembers</span><br><span class="line">9.2.3 begin and endMembers</span><br><span class="line">9.2.4 DefiningandInitializingaContainer</span><br><span class="line">9.2.5 Assignment and swap</span><br><span class="line">9.2.6 ContainerSizeOperations</span><br><span class="line">9.2.7 RelationalOperators</span><br><span class="line">9.3 SequentialContainerOperations</span><br><span class="line">9.3.1 AddingElements toaSequentialContainer</span><br><span class="line">9.3.2 AccessingElements</span><br><span class="line">9.3.3 ErasingElements</span><br><span class="line">9.3.4 Specialized forward_listOperations</span><br><span class="line">9.3.5 ResizingaContainer</span><br><span class="line">9.3.6 ContainerOperationsMayInvalidateIterators</span><br><span class="line">9.4 How a vectorGrows</span><br><span class="line">9.5 Additional stringOperations</span><br><span class="line">9.5.1 Other Ways to Construct strings</span><br><span class="line">9.5.2 Other Ways to Change a string</span><br><span class="line">9.5.3 stringSearchOperations</span><br><span class="line">9.5.4 The compareFunctions</span><br><span class="line">9.5.5 NumericConversions</span><br><span class="line">9.6 ContainerAdaptors</span><br><span class="line">ChapterSummary</span><br><span class="line">DefinedTerms</span><br><span class="line">xii Contents</span><br><span class="line">Chapter 10 Generic Algorithms</span><br><span class="line">10.1 Overview</span><br><span class="line">10.2 AFirstLookat theAlgorithms</span><br><span class="line">10.2.1 Read-OnlyAlgorithms</span><br><span class="line">10.2.2 AlgorithmsThatWriteContainerElements</span><br><span class="line">10.2.3 AlgorithmsThatReorderContainerElements</span><br><span class="line">10.3 CustomizingOperations</span><br><span class="line">10.3.1 PassingaFunctiontoanAlgorithm</span><br><span class="line">10.3.2 LambdaExpressions</span><br><span class="line">10.3.3 LambdaCapturesandReturns</span><br><span class="line">10.3.4 BindingArguments</span><br><span class="line">10.4 Revisiting Iterators</span><br><span class="line">10.4.1 Insert Iterators</span><br><span class="line">10.4.2 iostream Iterators</span><br><span class="line">10.4.3 Reverse Iterators</span><br><span class="line">10.5 StructureofGenericAlgorithms</span><br><span class="line">10.5.1 TheFive IteratorCategories</span><br><span class="line">10.5.2 AlgorithmParameterPatterns</span><br><span class="line">10.5.3 AlgorithmNamingConventions</span><br><span class="line">10.6 Container-SpecificAlgorithms</span><br><span class="line">ChapterSummary</span><br><span class="line">DefinedTerms</span><br><span class="line">Chapter 11 Associative Containers</span><br><span class="line">11.1 UsinganAssociativeContainer</span><br><span class="line">11.2 Overviewof theAssociativeContainers</span><br><span class="line">11.2.1 DefininganAssociativeContainer</span><br><span class="line">11.2.2 Requirements onKeyType</span><br><span class="line">11.2.3 The pairType</span><br><span class="line">11.3 Operations onAssociativeContainers</span><br><span class="line">11.3.1 AssociativeContainer Iterators</span><br><span class="line">11.3.2 AddingElements</span><br><span class="line">11.3.3 ErasingElements</span><br><span class="line">11.3.4 Subscripting a map</span><br><span class="line">11.3.5 AccessingElements</span><br><span class="line">11.3.6 AWordTransformationMap</span><br><span class="line">11.4 TheUnorderedContainers</span><br><span class="line">ChapterSummary</span><br><span class="line">DefinedTerms</span><br><span class="line">Chapter 12 DynamicMemory</span><br><span class="line">12.1 DynamicMemoryandSmartPointers</span><br><span class="line">12.1.1 The shared_ptrClass</span><br><span class="line">12.1.2 ManagingMemoryDirectly</span><br><span class="line">12.1.3 Using shared_ptrs with new</span><br><span class="line">12.1.4 SmartPointers andExceptions</span><br><span class="line">12.1.5 unique_ptr</span><br><span class="line">Contents xiii</span><br><span class="line">12.1.6 weak_ptr</span><br><span class="line">12.2 DynamicArrays</span><br><span class="line">12.2.1 newandArrays</span><br><span class="line">12.2.2 The allocatorClass</span><br><span class="line">12.3 UsingtheLibrary：AText-QueryProgram</span><br><span class="line">12.3.1 Designof theQueryProgram</span><br><span class="line">12.3.2 DefiningtheQueryProgramClasses</span><br><span class="line">ChapterSummary</span><br><span class="line">DefinedTerms</span><br><span class="line">Part III Tools for Class Authors</span><br><span class="line">Chapter 13 Copy Control</span><br><span class="line">13.1 Copy，Assign， andDestroy</span><br><span class="line">13.1.1 TheCopyConstructor</span><br><span class="line">13.1.2 TheCopy-AssignmentOperator</span><br><span class="line">13.1.3 TheDestructor</span><br><span class="line">13.1.4 TheRuleofThree&#x2F;Five</span><br><span class="line">13.1.5 Using &#x3D; default</span><br><span class="line">13.1.6 PreventingCopies</span><br><span class="line">13.2 CopyControl andResourceManagement</span><br><span class="line">13.2.1 ClassesThatActLikeValues</span><br><span class="line">13.2.2 DefiningClassesThatActLikePointers</span><br><span class="line">13.3 Swap</span><br><span class="line">13.4 ACopy-ControlExample</span><br><span class="line">13.5 ClassesThatManageDynamicMemory</span><br><span class="line">13.6 MovingObjects</span><br><span class="line">13.6.1 RvalueReferences</span><br><span class="line">13.6.2 MoveConstructor andMoveAssignment</span><br><span class="line">13.6.3 RvalueReferencesandMemberFunctions</span><br><span class="line">ChapterSummary</span><br><span class="line">DefinedTerms</span><br><span class="line">Chapter 14 Overloaded Operations and Conversions</span><br><span class="line">14.1 BasicConcepts</span><br><span class="line">14.2 Input andOutputOperators</span><br><span class="line">14.2.1 Overloading the Output Operator &lt;&lt;</span><br><span class="line">14.2.2 Overloading the Input Operator &gt;&gt;</span><br><span class="line">14.3 Arithmetic andRelationalOperators</span><br><span class="line">14.3.1 EqualityOperators</span><br><span class="line">14.3.2 RelationalOperators</span><br><span class="line">14.4 AssignmentOperators</span><br><span class="line">14.5 SubscriptOperator</span><br><span class="line">14.6 Increment andDecrementOperators</span><br><span class="line">14.7 MemberAccessOperators</span><br><span class="line">14.8 Function-CallOperator</span><br><span class="line">xiv Contents</span><br><span class="line">14.8.1 LambdasAreFunctionObjects</span><br><span class="line">14.8.2 Library-DefinedFunctionObjects</span><br><span class="line">14.8.3 Callable Objects and function</span><br><span class="line">14.9 Overloading，Conversions， andOperators</span><br><span class="line">14.9.1 ConversionOperators</span><br><span class="line">14.9.2 AvoidingAmbiguousConversions</span><br><span class="line">14.9.3 FunctionMatchingandOverloadedOperators</span><br><span class="line">ChapterSummary</span><br><span class="line">DefinedTerms</span><br><span class="line">Chapter 15 Object-Oriented Programming</span><br><span class="line">15.1 OOP：AnOverview</span><br><span class="line">15.2 DefiningBaseandDerivedClasses</span><br><span class="line">15.2.1 DefiningaBaseClass</span><br><span class="line">15.2.2 DefiningaDerivedClass</span><br><span class="line">15.2.3 Conversions andInheritance</span><br><span class="line">15.3 VirtualFunctions</span><br><span class="line">15.4 AbstractBaseClasses</span><br><span class="line">15.5 AccessControl andInheritance</span><br><span class="line">15.6 ClassScopeunder Inheritance</span><br><span class="line">15.7 Constructors andCopyControl</span><br><span class="line">15.7.1 VirtualDestructors</span><br><span class="line">15.7.2 SynthesizedCopyControl andInheritance</span><br><span class="line">15.7.3 Derived-ClassCopy-ControlMembers</span><br><span class="line">15.7.4 InheritedConstructors</span><br><span class="line">15.8 Containers andInheritance</span><br><span class="line">15.8.1 Writing a BasketClass</span><br><span class="line">15.9 TextQueriesRevisited</span><br><span class="line">15.9.1 AnObject-OrientedSolution</span><br><span class="line">15.9.2 The Query_base and QueryClasses</span><br><span class="line">15.9.3 TheDerivedClasses</span><br><span class="line">15.9.4 The evalFunctions</span><br><span class="line">ChapterSummary</span><br><span class="line">DefinedTerms</span><br><span class="line">Chapter 16 Templates and Generic Programming</span><br><span class="line">16.1 DefiningaTemplate</span><br><span class="line">16.1.1 FunctionTemplates</span><br><span class="line">16.1.2 ClassTemplates</span><br><span class="line">16.1.3 TemplateParameters</span><br><span class="line">16.1.4 MemberTemplates</span><br><span class="line">16.1.5 Controlling Instantiations</span><br><span class="line">16.1.6 Efficiency and Flexibility</span><br><span class="line">16.2 TemplateArgumentDeduction</span><br><span class="line">16.2.1 Conversions andTemplateTypeParameters</span><br><span class="line">16.2.2 Function-TemplateExplicitArguments</span><br><span class="line">16.2.3 Trailing Return Types and Type Transformation</span><br><span class="line">Contents xv</span><br><span class="line">16.2.4 FunctionPointers andArgumentDeduction</span><br><span class="line">16.2.5 TemplateArgumentDeductionandReferences</span><br><span class="line">16.2.6 Understanding std：：move</span><br><span class="line">16.2.7 Forwarding</span><br><span class="line">16.3 OverloadingandTemplates</span><br><span class="line">16.4 VariadicTemplates</span><br><span class="line">16.4.1 WritingaVariadicFunctionTemplate</span><br><span class="line">16.4.2 PackExpansion</span><br><span class="line">16.4.3 ForwardingParameterPacks</span><br><span class="line">16.5 Template Specializations</span><br><span class="line">ChapterSummary</span><br><span class="line">DefinedTerms</span><br><span class="line">Part IV Advanced Topics</span><br><span class="line">Chapter 17 Specialized Library Facilities</span><br><span class="line">17.1 The tupleType</span><br><span class="line">17.1.1 Defining and Initializing tuples</span><br><span class="line">17.1.2 Using a tuple toReturnMultipleValues</span><br><span class="line">17.2 The bitsetType</span><br><span class="line">17.2.1 Defining and Initializing bitsets</span><br><span class="line">17.2.2 Operations on bitsets</span><br><span class="line">17.3 RegularExpressions</span><br><span class="line">17.3.1 UsingtheRegularExpressionLibrary</span><br><span class="line">17.3.2 TheMatchandRegex IteratorTypes</span><br><span class="line">17.3.3 UsingSubexpressions</span><br><span class="line">17.3.4 Using regex_replace</span><br><span class="line">17.4 RandomNumbers</span><br><span class="line">17.4.1 Random-NumberEngines andDistribution</span><br><span class="line">17.4.2 OtherKinds ofDistributions</span><br><span class="line">17.5 The IOLibraryRevisited</span><br><span class="line">17.5.1 FormattedInput andOutput</span><br><span class="line">17.5.2 UnformattedInput&#x2F;OutputOperations</span><br><span class="line">17.5.3 RandomAccess toaStream</span><br><span class="line">ChapterSummary</span><br><span class="line">DefinedTerms</span><br><span class="line">Chapter 18 Tools for Large Programs</span><br><span class="line">18.1 ExceptionHandling</span><br><span class="line">18.1.1 ThrowinganException</span><br><span class="line">18.1.2 CatchinganException</span><br><span class="line">18.1.3 Function tryBlocks andConstructors</span><br><span class="line">18.1.4 The noexceptExceptionSpecification</span><br><span class="line">18.1.5 ExceptionClassHierarchies</span><br><span class="line">18.2 Namespaces</span><br><span class="line">18.2.1 NamespaceDefinitions</span><br><span class="line">xvi Contents</span><br><span class="line">18.2.2 UsingNamespaceMembers</span><br><span class="line">18.2.3 Classes，Namespaces，andScope</span><br><span class="line">18.2.4 OverloadingandNamespaces</span><br><span class="line">18.3 Multiple andVirtual Inheritance</span><br><span class="line">18.3.1 Multiple Inheritance</span><br><span class="line">18.3.2 Conversions andMultipleBaseClasses</span><br><span class="line">18.3.3 ClassScopeunderMultiple Inheritance</span><br><span class="line">18.3.4 Virtual Inheritance</span><br><span class="line">18.3.5 Constructors andVirtual Inheritance</span><br><span class="line">ChapterSummary</span><br><span class="line">DefinedTerms</span><br><span class="line">Chapter 19 Specialized Tools and Techniques</span><br><span class="line">19.1 Controlling Memory Allocation</span><br><span class="line">19.1.1 Overloading new and delete</span><br><span class="line">19.1.2 Placement newExpressions</span><br><span class="line">19.2 Run-TimeTypeIdentification</span><br><span class="line">19.2.1 The dynamic_castOperator</span><br><span class="line">19.2.2 The typeidOperator</span><br><span class="line">19.2.3 UsingRTTI</span><br><span class="line">19.2.4 The type_infoClass</span><br><span class="line">19.3 Enumerations</span><br><span class="line">19.4 Pointer toClassMember</span><br><span class="line">19.4.1 Pointers toDataMembers</span><br><span class="line">19.4.2 Pointers toMemberFunctions</span><br><span class="line">19.4.3 UsingMemberFunctions asCallableObjects</span><br><span class="line">19.5 NestedClasses</span><br><span class="line">19.6 union：ASpace-SavingClass</span><br><span class="line">19.7 LocalClasses</span><br><span class="line">19.8 InherentlyNonportableFeatures</span><br><span class="line">19.8.1 Bit-fields</span><br><span class="line">19.8.2 volatileQualifier</span><br><span class="line">19.8.3 Linkage Directives： extern “C”</span><br><span class="line">ChapterSummary</span><br><span class="line">DefinedTerms</span><br><span class="line">Appendix A The Library</span><br><span class="line">A.1 LibraryNames andHeaders</span><br><span class="line">A.2 ABriefTourof theAlgorithms</span><br><span class="line">A.2.1 Algorithms toFindanObject</span><br><span class="line">A.2.2 OtherRead-OnlyAlgorithms</span><br><span class="line">A.2.3 BinarySearchAlgorithms</span><br><span class="line">A.2.4 AlgorithmsThatWriteContainerElements</span><br><span class="line">A.2.5 PartitioningandSortingAlgorithms</span><br><span class="line">A.2.6 GeneralReorderingOperations</span><br><span class="line">A.2.7 PermutationAlgorithms</span><br><span class="line">A.2.8 SetAlgorithms forSortedSequences</span><br><span class="line">Contents xvii</span><br><span class="line">A.2.9 MinimumandMaximumValues</span><br><span class="line">A.2.10 NumericAlgorithms</span><br><span class="line">A.3 RandomNumbers</span><br><span class="line">A.3.1 RandomNumberDistributions</span><br><span class="line">A.3.2 RandomNumberEngines</span><br><span class="line">Index </span><br><span class="line"></span><br><span class="line"> New Features in C++ 2.1.1 long longType 2.2.1 List Initialization 2.3.2 nullptrLiteral 2.4.4 constexprVariables 2.5.1 TypeAliasDeclarations 2.5.2 The autoTypeSpecifier 2.5.3 The decltypeTypeSpecifier 2.6.1 In-Class Initializers 3.2.2 Using auto or decltype forTypeAbbreviation 3.2.3 Range forStatement 3.3 Defining a vector of vectors 3.3.1 List Initialization for vectors 3.4.1 Container cbegin and cendFunctions 3.5.3 Library begin and endFunctions 3.6 Using auto or decltype to SimplifyDeclarations 4.2 RoundingRules forDivision 4.4 Assignment fromaBracedListofValues 4.9 sizeofAppliedtoaClassMember 5.4.3 Range forStatement 6.2.6 Library initializer_listClass 6.3.2 List InitializingaReturnValue 6.3.3 Declaring a Trailing Return Type 6.3.3 Using decltype to Simplify Return Type Declarations 6.5.2 constexprFunctions 7.1.4 Using &#x3D; default toGenerateaDefaultConstructor 7.3.1 In-class Initializers forMembersofClassType 7.5.2 DelegatingConstructors 7.5.6 constexprConstructors 8.2.1 Using strings for File Names 9.1 The array and forward_listContainers 9.2.3 Container cbegin and cendFunctions 9.2.4 List InitializationforContainers 9.2.5 Container Nonmember swapFunctions 9.3.1 Return Type for Container insertMembers 9.3.1 Container emplaceMembers xix xx New Features in C++ 9.4 shrink_to_fit 9.5.5 Numeric Conversion Functions for strings 10.3.2 LambdaExpressions 10.3.3 Trailing Return Type in Lambda Expressions 10.3.4 The Library bindFunction 11.2.1 List Initializationof anAssociativeContainer 11.2.3 List Initializing pairReturnType 11.3.2 List Initialization of a pair 11.4 TheUnorderedContainers 12.1 SmartPointers 12.1.1 The shared_ptrClass 12.1.2 List InitializationofDynamicallyAllocatedObjects 12.1.2 autoandDynamicAllocation 12.1.5 The unique_ptrClass 12.1.6 The weak_ptrClass 12.2.1 Range for Doesn‘t Apply to Dynamically AllocatedArrays 12.2.1 List InitializationofDynamicallyAllocatedArrays 12.2.1 autoCan’tBeUsedtoAllocateanArray 12.2.2 allocator：：constructCanUseanyConstructor 13.1.5 Using &#x3D; default forCopy-ControlMembers 13.1.6 Using &#x3D; delete toPreventCopyingClassObjects 13.5 MovingInsteadofCopyingClassObjects 13.6.1 RvalueReferences 13.6.1 The Library moveFunction 13.6.2 MoveConstructor andMoveAssignment 13.6.2 Move Constructors Usually Should Be noexcept 13.6.2 MoveIterators 13.6.3 ReferenceQualifiedMemberFunctions 14.8.3 The functionClassTemplate 14.9.1 explicitConversionOperators 15.2.2 overrideSpecifier forVirtualFunctions 15.2.2 Preventing Inheritance by Defining a Class as final 15.3 override and final Specifiers for Virtual Functions 15.7.2 DeletedCopyControl andInheritance 15.7.4 InheritedConstructors 16.1.2 DeclaringaTemplateTypeParameteras aFriend 16.1.2 TemplateTypeAliases 16.1.3 DefaultTemplateArguments forTemplateFunctions 16.1.5 ExplicitControlof Instantiation 16.2.3 Template Functions and Trailing Return Types 16.2.5 ReferenceCollapsingRules 16.2.6 static_cast fromanLvaluetoanRvalue 16.2.7 The Library forwardFunction 16.4 VariadicTemplates 16.4 The sizeof…Operator 16.4.3 VariadicTemplates andForwarding New Features in C++11 xxi 17.1 The Library TupleClassTemplate 17.2.2 New bitsetOperations 17.3 TheRegularExpressionLibrary 17.4 TheRandomNumberLibrary 17.5.1 Floating-Point FormatControl 18.1.4 The noexceptExceptionSpecifier 18.1.4 The noexceptOperator 18.2.1 InlineNamespaces 18.3.1 InheritedConstructors andMultiple Inheritance 19.3 Scoped enums 19.3 Specifying the Type Used to Hold an enum 19.3 Forward Declarations for enums 19.4.3 The Library mem_fnClassTemplate 19.6 UnionMembersofClassTypes</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00CE43I04/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00CE43I04&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41YyoY5A7pL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>领域专用语言实战(英文版)</title>
    <url>/2020/04/19/dsls-in-action/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 领域专用语言实战(英文版)<br>作者信息： 作者: Debasish Ghosh [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>DSLs in Action introduces the concepts and definitions a developer needs to build high-quality domain specific languages. It provides a solid foundation to the usage as well as implementation aspects of a DSL, focusing on the necessity of applications speaking the language of the domain. After reading this book, a programmer will be able to design APIs that make better domain models. For experienced developers, the book addresses the intricacies of domain language design without the pain of writing parsers by hand.<br>The gap in understanding between the development team and the business domain specialists can lead to errors during user acceptance tests. This book teaches developers to build DSLs that bridge this gap by offering API development techniques that closely model the domain vocabulary. Even non-programmer domain experts can benefit from this book by learning how DSLs can make them a more integral part of the team during the program development phase.<br>The book discusses DSL usage and implementations in the real world based on a suite of JVM languages like Java, Ruby, Scala, and Groovy. It contains code snippets that implement real world DSL designs and discusses the pros and cons of each implementation.</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/1935182455/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=1935182455&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51KkyQcrsVL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>dsl</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 第三版（英文)</title>
    <url>/2020/04/19/effective-cpp-3-en/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Effective C++ 第三版（英文)<br>作者信息： 作者: Scott Meyers [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>“Every C++ professional needs a copy of Effective C++. It is an absolute must-read for anyone thinking of doing serious C++ development. If you’ve never read Effective C++ and you think you know everything about C++, think again.”<br>— Steve Schirripa, Software Engineer, Google<br>“C++ and the C++ community have grown up in the last fifteen years, and the third edition of Effective C++ reflects this. The clear and precise style of the book is evidence of Scott’s deep insight and distinctive ability to impart knowledge.”<br>— Gerhard Kreuzer, Research and Development Engineer, Siemens AG</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Effective C++ Third Edition 55 Specific Ways to Improve Your Programs and Designs</span><br><span class="line">Table of Contents</span><br><span class="line">Copyright</span><br><span class="line">Praise for Effective C++, Third Edition</span><br><span class="line">Addison-Wesley Professional Computing Series</span><br><span class="line">Preface</span><br><span class="line">Acknowledgments</span><br><span class="line">Introduction</span><br><span class="line">Chapter 1. Accustoming Yourself to C++</span><br><span class="line">Chapter 2. Constructors, Destructors, and Assignment Operators</span><br><span class="line">Chapter 3. Resource Management</span><br><span class="line">Chapter 4. Designs and Declarations</span><br><span class="line">Chapter 5. Implementations</span><br><span class="line">Chapter 6. Inheritance and Object-Oriented Design</span><br><span class="line">Chapter 7. Templates and Generic Programming</span><br><span class="line">Chapter 8. Customizing new and delete</span><br><span class="line">Chapter 9. Miscellany</span><br><span class="line">Appendix A. Beyond Effective C++</span><br><span class="line">Appendix B. Item Mappings Between Second and Third Editions</span><br><span class="line">Index</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/0321334876/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=0321334876&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51jZoCCiyWL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ 第三版</title>
    <url>/2020/04/19/effective-cpp-3/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Effective C++ 第三版<br>作者信息： 作者: Scott Meyers [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Effective C++:改善程序与设计的55个具体做法(第3版)(中文版)(双色)》前两个版本抓住了全世界无数程序员的目光。原因十分明显：Scott Meyers极富实践意义的C++研讨方式，描述出专家用以产出干净、正确、高效代码的经验法则和行事法则——也就是他们几乎总是做或不做的某些事。<br>《Effective C++:改善程序与设计的55个具体做法(第3版)(中文版)(双色)》一共组织55个准则，每一条准则描述一个编写出更好的C++的方式、每一个条款的背后都有具体范例支撑。第三版有一半以上的篇幅是崭新内容，包括讨沦资源管理和模块（templates）运用的两个新章。为反映出现代设计考虑，对第二版论题做了广泛的修订，包括异常（exceptions）、没汁模式（design patterns）和多线程（multithreading）。<br>高效的Classes、functions、templates和inheritance hierarchies（继承体系）方面的专家级指导。<br>崭新的“TR1”标准程序库功能应用，以及与既有标准程序库组件的比较。<br>洞察C++和其他语言（例如Java、C＃、C）之间的不同。此举有助于那些来自其他语言阵营的开发人员消化吸收C++式的各种解法。 译序<br>中英简繁术语对照<br>目录<br>序言<br>致谢<br>导读</p>
<ol>
<li>让自己习惯c++</li>
<li>构造/析构/赋值运算</li>
<li>资源管理</li>
<li>设计与声明</li>
<li>实现</li>
<li>继承与面向对象设计</li>
<li>模板与泛型编程</li>
<li>定制new和delete</li>
<li>杂项讨论<br>a 本书之外<br>b 新旧版条款对照<br>索引</li>
</ol>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B004G72P24/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B004G72P24&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51-0vwhQxVL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective STL(英文)</title>
    <url>/2020/04/19/effective-stl-en/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Effective STL(英文)<br>作者信息： 作者: Scott Meyers [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Each of the book’s 50 guidelines is backedby Meyers’ legendary analysis and incisive examples, so you’lllearn not only what to do, but also when to do it – and why.Highlights of Effective STL include: * Advice on choosing amongstandard STL containers (like vector and list), nonstandard STLcontainers (like hash_set and hash_map), and non-STL containers(like bitset). * Techniques to maximize the efficiency of the STLand the programs that use it. * Insights into the behavior ofiterators, function objects, and allocators, including things youshould not do. * Guidance for the proper use of algorithms andmember functions whose names are the same (e.g., find), but whoseactions differ in subtle (but important) ways. * Discussions ofpotential portability problems, including straightforward ways toavoid them. Like Meyers’ previous books, Effective STL is filledwith proven wisdom that comes only from experience. Its clear,concise, penetrating style makes it an essential resource for everySTL programmer. Copyright<br>Addison-Wesley Professional Computing Series<br>Preface<br>Acknowledgments<br>Introduction<br>Ch. 1. Containers<br>Ch. 2. vector and string<br>Ch. 3. Associative Containers<br>Ch. 4. Iterators<br>Ch. 5. Algorithms<br>Ch. 6. Functors, Functor Classes, Functions, etc<br>Ch. 7. Programming with the STL<br>Bibliography<br>Appx. A. Locales and Case-Insensitive String Comparisons<br>How to Do Case-Insensitive String Comparison by Matt Austern</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/0201749629/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=0201749629&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41BdKV2m2nL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Exceptional C++ Style</title>
    <url>/2020/04/19/exceptional-cpp-style/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Exceptional C++ Style<br>作者信息： 作者: Herb sutter [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>本书中，C++大师Herb Sutter通过40个编程问题，不仅使读者“知其然”，更要“知其所以然”，帮助程序设计人员在软件中寻找恰到好处的折衷，即讨论如何在开销和功能性之间、优雅跟可维护性之间、灵活性与过分灵活之间寻找完美的平衡点。本书是围绕实际问题及其解决方案展开论述的，对一些至关重要的C++细节和相互关系提出了新的见解，为当今关键的C++编程技术（如泛型编程、STL、异常安全等）提供了新的策略。本书的目标是让读者在设计、架构和编码过程中保持良好的风格，从而使编写的C++软件更健壮、更高效。本书适合各个层次的C++程序员阅读</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">泛型编程与C++标准库 1</span><br><span class="line">第1条 vector的使用 2</span><br><span class="line">第2条 字符串格式化的“动物庄园”之一：sprintf 9</span><br><span class="line">第3条 字符串格式化的“动物庄园”之二：标准的（或极度优雅的）替代方案 14</span><br><span class="line">第4条 标准库成员函数 23</span><br><span class="line">第5条 泛型性的风味之一：基础 26</span><br><span class="line">第6条 泛型性的风味之二：够“泛”了吗 30</span><br><span class="line">第7条 为什么不特化函数模板 36</span><br><span class="line">第8条 友元模板 42</span><br><span class="line">第9条 导出限制之一：基础 51</span><br><span class="line">第10条 导出限制之二：相互影响，可用性问题以及准则 58</span><br><span class="line">异常安全问题及相关技术 67</span><br><span class="line">第11条 Try和Catch 68</span><br><span class="line">第12条 异常安全性：值得吗？ 72</span><br><span class="line">第13条 对异常规格的实际考虑 75</span><br><span class="line">类的设计、继承和多态 83</span><br><span class="line">第14条 顺序，顺序！ 84</span><br><span class="line">第15条 访问权限的使用 88</span><br><span class="line">第16条 （几乎）私有 93</span><br><span class="line">第17条 封 装 101</span><br><span class="line">第18条 虚 拟 110</span><br><span class="line">第19条 对派生类施加规则 118</span><br><span class="line">内存和资源管理 129</span><br><span class="line">第20条 内存中的容器之一：内存管理的层次 130</span><br><span class="line">第21条 内存中的容器之二：它到底有多大？ 133</span><br><span class="line">第22条 进行new操作，也许会抛出异常之一：new的方方面面 140</span><br><span class="line">第23条 进行new操作，也许会抛出异常之二：内存管理中的实际问题 148</span><br><span class="line">优化和效率 155</span><br><span class="line">第24条 常量优化 156</span><br><span class="line">第25条 再论内联 161</span><br><span class="line">第26条 数据格式和效率之一：什么时候压缩是真正重要的 168</span><br><span class="line">第27条 数据格式和效率之二：（甚至更少的）位操纵 172</span><br><span class="line">陷阱、缺陷和谜题 179</span><br><span class="line">第28条 不是关键字的关键字（或者：另一种注释） 180</span><br><span class="line">第29条 这是初始化么？ 186</span><br><span class="line">第30条 要么double要么彻底完蛋 191</span><br><span class="line">第31条 狂乱的代码 194</span><br><span class="line">第32条 小小的拼写错误？鬼画符似的语言以及其他奇形怪状的东西 199</span><br><span class="line">第33条 操作符，无处不在的操作符 202</span><br><span class="line">风格案例研究 207</span><br><span class="line">第34条 索 引 表 208</span><br><span class="line">第35条 泛型回调 218</span><br><span class="line">第36条 构造式union 226</span><br><span class="line">第37条 分解std::string之一：概观std::string 242</span><br><span class="line">第38条 分解std::string之二：重构std::string 247</span><br><span class="line">第39条 分解std::string之三：给std::string瘦身 255</span><br><span class="line">第40条 分解std::string之四：再论std::string 259</span><br><span class="line">参考文献 267</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001146QI4/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001146QI4&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/513Unuy3JiL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Exceptional C++</title>
    <url>/2020/04/19/exceptional-cpp-zh/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Exceptional C++<br>作者信息： 作者: Herb Sutter [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《exceptionalc++：47个c++工程难题、编程问题和解决方案(中文版)》讲述如何用标准c++进行企业级的软件开发，通过“问题/解答”的方式，启发读者思考，帮助了解隐藏在问题背后的设计思想，以及各种编程指导原则适用的场合。本书列出的条款涵盖了许多方面的主题，尤其对异常安全性、类和模块的合理设计，正确的代码优化，以及编写符合c++标准的可移植代码进行了深入的讨论。<br>《exceptional c++：47个c++工程难题、编程问题和解决方案(中文版)》适于有一定c++编程基础的读者阅读。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 泛型程序设计与c++标准库</span><br><span class="line">条款1：迭代器难度系数</span><br><span class="line">条款2：大小写不敏感的字符串——之一</span><br><span class="line">条款3：大小写不敏感的字符串——之二</span><br><span class="line">条款4：可重用性最高的泛型容器——之一</span><br><span class="line">条款5：可重用性最高的泛型容器——之二</span><br><span class="line">条款6：临时对象</span><br><span class="line">条款7：标准库的使用（或者，再论临时对象）</span><br><span class="line">2 异常安全性相关的问题与技术</span><br><span class="line">条款8：编写异常安全的代码——之一</span><br><span class="line">条款9：编写异常安全的代码——之二</span><br><span class="line">条款10：编写异常安全的代码——之三</span><br><span class="line">条款11：编写异常安全的代码——之四</span><br><span class="line">条款12：编写异常安全的代码——之五</span><br><span class="line">条款13：编写异常安全的代码——之六</span><br><span class="line">条款14：编写异常安全的代码——之七</span><br><span class="line">条款15：编写异常安全的代码——之八</span><br><span class="line">条款16：编写异常安全的代码——之九</span><br><span class="line">条款17：编写异常安全的代码——之十</span><br><span class="line">条款18：代码的复杂性——之一</span><br><span class="line">条款19：代码的复杂性——之二</span><br><span class="line">3 类的设计与继承</span><br><span class="line">条款20：类的编写技巧</span><br><span class="line">条款21：虚函数的重载</span><br><span class="line">条款22：类之间的关系——之一</span><br><span class="line">条款23：类之间的关系——之二</span><br><span class="line">条款24：继承的使用和滥用</span><br><span class="line">条款25：面向对象程序设计</span><br><span class="line">4 编译器防火墙和pimpl惯用法</span><br><span class="line">条款26：将编译期依赖性降到最低——之一</span><br><span class="line">条款27：将编译期依赖性降到最低——之二</span><br><span class="line">条款28：将编译期依赖性降到最低——之三</span><br><span class="line">条款29：编译防火墙</span><br><span class="line">条款30：fast pimpl惯用法</span><br><span class="line">5 名字查找、名字空间和接口规则</span><br><span class="line">条款31：名字查找与接口规则——之一</span><br><span class="line">条款32：名字查找与接口规则——之二</span><br><span class="line">条款33：名字查找和接口规则——之三</span><br><span class="line">条款34：名字查找与接口规则——之四</span><br><span class="line">6 内存管理</span><br><span class="line">条款35：内存管理——之一</span><br><span class="line">条款36：内存管理——之二</span><br><span class="line">条款37：auto_ptr</span><br><span class="line">7 误区、陷阱以及错误的惯用法</span><br><span class="line">条款38：对象标识</span><br><span class="line">条款39：自动转换</span><br><span class="line">条款40：对象的生存期——之一</span><br><span class="line">条款41：对象的生存期——之二</span><br><span class="line">8 其他主题</span><br><span class="line">条款42：变量的初始化</span><br><span class="line">条款43：正确使用const</span><br><span class="line">条款44：类型转换</span><br><span class="line">条款45：bool</span><br><span class="line">条款46：转调函数</span><br><span class="line">条款47：控制流程</span><br><span class="line">后记</span><br><span class="line">参考书目</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B008CGKUBS/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B008CGKUBS&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51YQWkwhlgL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言编程</title>
    <url>/2020/04/19/goyu-yan-bian-cheng/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Go语言编程<br>作者信息： 作者: 许式伟 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>国内第一本Go语言编程书<br>原盛大创新院研究员执笔<br>Go语言领域技术大牛作品<br>作者Go语言开发实战项目<br>帮助您快速入手全新语言</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章　初识Go语言　1</span><br><span class="line">1.1　语言简史　1</span><br><span class="line">1.2　语言特性　2</span><br><span class="line">1.2.1　自动垃圾回收　3</span><br><span class="line">1.2.2　更丰富的内置类型　4</span><br><span class="line">1.2.3　函数多返回值　5</span><br><span class="line">1.2.4　错误处理　6</span><br><span class="line">1.2.5　匿名函数和闭包　6</span><br><span class="line">1.2.6　类型和接口　7</span><br><span class="line">1.2.7　并发编程　8</span><br><span class="line">1.2.8　反射　9</span><br><span class="line">1.2.9　语言交互性　10</span><br><span class="line">1.3　第一个Go程序　11</span><br><span class="line">1.3.1　代码解读　11</span><br><span class="line">1.3.2　编译环境准备　12</span><br><span class="line">1.3.3　编译程序　12</span><br><span class="line">1.4　开发工具选择　13</span><br><span class="line">1.5　工程管理　13</span><br><span class="line">1.6　问题追踪和调试　18</span><br><span class="line">1.6.1　打印日志　18</span><br><span class="line">1.6.2　GDB调试　18</span><br><span class="line">1.7　如何寻求帮助　18</span><br><span class="line">1.7.1　邮件列表　19</span><br><span class="line">1.7.2　网站资源　19</span><br><span class="line">1.8　小结　19 </span><br><span class="line"></span><br><span class="line"> 第2章　顺序编程　20 2.1　变量　20 2.1.1　变量声明　20 2.1.2　变量初始化　21 2.1.3　变量赋值　21 2.1.4　匿名变量　22 2.2　常量　22 2.2.1　字面常量　22 2.2.2　常量定义　23 2.2.3　预定义常量　23 2.2.4　枚举　24 2.3　类型　24 2.3.1　布尔类型　25 2.3.2　整型　25 2.3.3　浮点型　27 2.3.4　复数类型　28 2.3.5　字符串　28 2.3.6　字符类型　30 2.3.7　数组　31 2.3.8　数组切片　32 2.3.9　map　36 2.4　流程控制　38 2.4.1　条件语句　38 2.4.2　选择语句　39 2.4.3　循环语句　40 2.4.4　跳转语句　41 2.5　函数　41 2.5.1　函数定义　42 2.5.2　函数调用　42 2.5.3　不定参数　43 2.5.4　多返回值　45 2.5.5　匿名函数与闭包　45 2.6　错误处理　47 2.6.1　error接口　47 2.6.2　defer　48 2.6.3　panic()和recover()　49 2.7　完整示例　50 2.7.1　程序结构　51 2.7.2　主程序　51 2.7.3　算法实现　54 2.7.4　主程序　57 2.7.5　构建与执行　59 2.8　小结　61</span><br><span class="line"></span><br><span class="line"> 第3章　面向对象编程　62 3.1　类型系统　62 3.1.1　为类型添加方法　63 3.1.2　值语义和引用语义　66 3.1.3　结构体　67 3.2　初始化　68 3.3　匿名组合　68 3.4　可见性　71 3.5　接口　71 3.5.1　其他语言的接口　71 3.5.2　非侵入式接口　73 3.5.3　接口赋值　74 3.5.4　接口查询　76 3.5.5　类型查询　78 3.5.6　接口组合　78 3.5.7　Any类型　79 3.6　完整示例　79 3.6.1　音乐库　80 3.6.2　音乐播放　82 3.6.3　主程序　84 3.6.4　构建运行　86 3.6.5　遗留问题　86 3.7　小结　87 第4章　并发编程　88 4.1　并发基础　88 4.2　协程　90 4.3　goroutine　90 4.4　并发通信　91 4.5　channel　94 4.5.1　基本语法　95 4.5.2　select　95 4.5.3　缓冲机制　96 4.5.4　超时机制　97 4.5.5　channel的传递　98 4.5.6　单向channel　98 4.5.7　关闭channel　99 4.6　多核并行化　100 4.7　出让时间片　101 4.8　同步　101 4.8.1　同步锁　101 4.8.2　全局唯一性操作　102 4.9　完整示例　103 4.9.1　简单IPC框架　105 4.9.2　中央服务器　108 4.9.3　主程序　113 4.9.4　运行程序　116 4.10　小结　117</span><br><span class="line"></span><br><span class="line"> 第5章　网络编程　118 5.1　Socket编程　118 5.1.1　Dial()函数　118 5.1.2　ICMP示例程序　119 5.1.3　TCP示例程序　121 5.1.4　更丰富的网络通信　122 5.2　HTTP编程　124 5.2.1　HTTP客户端　124 5.2.2　HTTP服务端　130 5.3　RPC编程　132 5.3.1　Go语言中的RPC支持与处理　132 5.3.2　Gob简介　134 5.3.3　设计优雅的RPC接口　134 5.4　JSON处理　135 5.4.1　编码为JSON格式　136 5.4.2　解码JSON数据　137 5.4.3　解码未知结构的JSON数据　138 5.4.4　JSON的流式读写　140 5.5　网站开发　140 5.5.1　最简单的网站程序　141 5.5.2　net&#x2F;http包简介　141 5.5.3　开发一个简单的相册网站　142 5.6　小结　157</span><br><span class="line"></span><br><span class="line"> 第6章　安全编程　158 6.1　数据加密　158 6.2　数字签名　158 6.3　数字证书　159 6.4　PKI体系　159 6.5　Go语言的哈希函数　159 6.6　加密通信　160 6.6.1　加密通信流程　161 6.6.2　支持HTTPS的Web服务器　162 6.6.3　支持HTTPS的文件服务器　165 6.6.4　基于SSL&#x2F;TLS的ECHO程序　166 6.7　小结　169</span><br><span class="line"></span><br><span class="line"> 第7章　工程管理　170 7.1　Go命令行工具　170 7.2　代码风格　172 7.2.1　强制性编码规范　172 7.2.2　非强制性编码风格建议　173 7.3　远程import支持　175 7.4　工程组织　175 7.4.1　GOPATH　176 7.4.2　目录结构　176 7.5　文档管理　177 7.6　工程构建　180 7.7　跨平台开发　180 7.7.1　交叉编译　181 7.7.2　Android支持　182 7.8　单元测试　183 7.9　打包分发　184 7.10　小结　184</span><br><span class="line"></span><br><span class="line"> 第8章　开发工具　186 8.1　选择开发工具　186 8.2　gedit　187 8.2.1　语法高亮　187 8.2.2　编译环境　187 8.3　Vim　188 8.4　Eclipse　189 8.5　Notepad++　192 8.5.1　语法高亮　192 8.5.2　编译环境　192 8.6　LiteIDE　193 8.7　小结　195</span><br><span class="line"></span><br><span class="line"> 第9章　进阶话题　196 9.1　反射　196 9.1.1　基本概念　196 9.1.2　基本用法　197 9.1.3　对结构的反射操作　199 9.2　语言交互性　199 9.2.1　类型映射　200 9.2.2　字符串映射　201 9.2.3　C程序　201 9.2.4　函数调用　202 9.2.5　编译Cgo　203 9.3　链接符号　203 9.4　goroutine机理　204 9.4.1　协程　204 9.4.2　协程的C语言实现　205 9.4.3　协程库概述　205 9.4.4　任务　208 9.4.5　任务调度　210 9.4.6　上下文切换　211 9.4.7　通信机制　215 9.5　接口机理　216 9.5.1　类型赋值给接口　217 9.5.2　接口查询　223 9.5.3　接口赋值　224</span><br><span class="line"></span><br><span class="line"> 附录A　225</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00932YRPA/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00932YRPA&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/61lrDCGobzL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Exceptional C++(英文)</title>
    <url>/2020/04/19/exceptional-cpp/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Exceptional C++(英文)<br>作者信息： 作者: Herb Sutter [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Exceptional C++ shows by example how to go about soundsoftware engineering in standard C++. Do you enjoy solving thornyC++ problems and puzzles? Do you relish writing robust andextensible code? Then take a few minutes and challenge yourselfwith some tough C++ design and programming problems. The puzzlesand problems in Exceptional C++ not only entertain, they will helpyou hone your skills to become the sharpest C++ programmer you canbe.</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Item 1: Iterators. </span><br><span class="line"></span><br><span class="line"> Item 2: Case-Insensitive Strings-Part 1.</span><br><span class="line"></span><br><span class="line"> Item 3: Case-Insensitive Strings-Part 2.</span><br><span class="line"></span><br><span class="line"> Item 4: Maximally Reusable Generic Containers-Part 1.</span><br><span class="line"></span><br><span class="line"> Item 5: Maximally Reusable Generic Containers-Part 2.</span><br><span class="line"></span><br><span class="line"> Item 6: Temporary Objects.</span><br><span class="line"></span><br><span class="line"> Item 7: Using the Standard Library (or, Temporaries Revisited).</span><br><span class="line"></span><br><span class="line"> EXCEPTION-SAFETY ISSUES AND TECHNIQUES.</span><br><span class="line"></span><br><span class="line"> Item 8: Writing Exception-Safe Code-Part 1.</span><br><span class="line"></span><br><span class="line"> Item 9: Writing Exception-Safe Code-Part 2.</span><br><span class="line"></span><br><span class="line"> Item 10: Writing Exception-Safe Code-Part 3.</span><br><span class="line"></span><br><span class="line"> Item 11: Writing Exception-Safe Code-Part 4.</span><br><span class="line"></span><br><span class="line"> Item 12: Writing Exception-Safe Code-Part 5.</span><br><span class="line"></span><br><span class="line"> Item 13: Writing Exception-Safe Code-Part 6.</span><br><span class="line"></span><br><span class="line"> Item 14: Writing Exception-Safe Code-Part 7.</span><br><span class="line"></span><br><span class="line"> Item 15: Writing Exception-Safe Code-Part 8.</span><br><span class="line"></span><br><span class="line"> Item 16: Writing Exception-Safe Code-Part 9.</span><br><span class="line"></span><br><span class="line"> Item 17: Writing Exception-Safe Code-Part 10.</span><br><span class="line"></span><br><span class="line"> Item 18: Code Complexity-Part 1.</span><br><span class="line"></span><br><span class="line"> Item 19: Code Complexity-Part 2.</span><br><span class="line"></span><br><span class="line"> CLASS DESIGN AND INHERITANCE.</span><br><span class="line"></span><br><span class="line"> Item 20: Class Mechanics.</span><br><span class="line"></span><br><span class="line"> Item 21: Overriding Virtual Functions.</span><br><span class="line"></span><br><span class="line"> Item 22: Class Relationships-Part 1.</span><br><span class="line"></span><br><span class="line"> Item 23: Class Relationships-Part 2.</span><br><span class="line"></span><br><span class="line"> Item 24: Uses and Abuses of Inheritance.</span><br><span class="line"></span><br><span class="line"> Item 25: Object-Oriented Programming.</span><br><span class="line"></span><br><span class="line"> COMPILER FIREWALLS AND THE PIMPL IDIOM.</span><br><span class="line"></span><br><span class="line"> Item 26: Minimizing Compile-time Dependencies-Part 1.</span><br><span class="line"></span><br><span class="line"> Item 27: Minimizing Compile-time Dependencies-Part 2.</span><br><span class="line"></span><br><span class="line"> Item 28: Minimizing Compile-time Dependencies-Part 3.</span><br><span class="line"></span><br><span class="line"> Item 29: Compilation Firewalls.</span><br><span class="line"></span><br><span class="line"> Item 30: The “Fast Pimpl” Idiom.</span><br><span class="line"></span><br><span class="line"> NAME LOOKUP, NAMESPACES, AND THE INTERFACE PRINCIPLE.</span><br><span class="line"></span><br><span class="line"> Item 31: Name Lookup and the Interface Principle-Part 1.</span><br><span class="line"></span><br><span class="line"> Item 32: Name Lookup and the Interface Principle-Part 2.</span><br><span class="line"></span><br><span class="line"> Item 33: Name Lookup and the Interface Principle-Part 3.</span><br><span class="line"></span><br><span class="line"> Item 34: Name Lookup and the Interface Principle-Part 4.</span><br><span class="line"></span><br><span class="line"> MEMORY MANAGEMENT.</span><br><span class="line"></span><br><span class="line"> Item 35: Memory Management-Part 1.</span><br><span class="line"></span><br><span class="line"> Item 36: Memory Management-Part 2.</span><br><span class="line"></span><br><span class="line"> Item 37: auto_ptr.</span><br><span class="line"></span><br><span class="line"> TRAPS, PITFALLS, AND ANIT-IDIOMS.</span><br><span class="line"></span><br><span class="line"> Item 38: Object Identity.</span><br><span class="line"></span><br><span class="line"> Item 39: Automatic Conversions.</span><br><span class="line"></span><br><span class="line"> Item 40: Object Lifetimes-Part 1.</span><br><span class="line"></span><br><span class="line"> Item 41: Object Lifetimes-Part 2.</span><br><span class="line"></span><br><span class="line"> MISCELLANEOUS TOPICS.</span><br><span class="line"></span><br><span class="line"> Item 42: Variable Initialization—Or Is It?</span><br><span class="line"></span><br><span class="line"> Item 43: Const-Correctness.</span><br><span class="line"></span><br><span class="line"> Item 44: Casts.</span><br><span class="line"></span><br><span class="line"> Item 45: bool.</span><br><span class="line"></span><br><span class="line"> Item 46: Forwarding Functions.</span><br><span class="line"></span><br><span class="line"> Item 47: Control Flow.</span><br><span class="line"></span><br><span class="line"> Afterword.</span><br><span class="line"></span><br><span class="line"> Bibliography.</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/0201615622/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=0201615622&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/5108GGG3S1L._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>深度探索C++对象模型</title>
    <url>/2020/04/19/inside-the-cpp-object-model-zh/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 深度探索C++对象模型<br>作者信息： 作者: Lippman [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《深度探索C++对象模型》重点探索了“面向对象程序所支持的C++对象模型”下的程序行为，对于“面向对象性质的基础实现技术”以及“各种性质背后的隐含利益交换”提供了一个清楚的认识，检验了由程序变形所带来的效率冲击，提供了丰富的程序范例、图片，以及面向对象观念和底层对象模型之间的效率测量。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本立道生（侯捷 译序）</span><br><span class="line">目录</span><br><span class="line">前言（Stanley B.Lippman） </span><br><span class="line"></span><br><span class="line"> 第0章 导读（译者的话）</span><br><span class="line"></span><br><span class="line"> 第1章 关于对象（Object Lessons）</span><br><span class="line"></span><br><span class="line"> 加上封装后的布局成本（Layout Costs for Adding Encapsulation） 1.1 C++模式模式（The C++ Object Model） 简单对象模型（A Simple Object Model） 表格驱动对象模型（A Table-driven Object Model） C++对象模型（The C++ Object Model） 对象模型如何影响程序（How the Object Model Effects Programs） 1.2 关键词所带来的差异（A Keyword Distinction） 关键词的困扰 策略性正确的struct（The Politically Correct Struct） 1.3 对象的差异（An Object Distinction） 指针的类型（The Type of a Pointer） 加上多态之后（Adding Polymorphism）</span><br><span class="line"></span><br><span class="line"> 第2章 构造函数语意学（The Semantics of constructors）</span><br><span class="line"></span><br><span class="line"> 2.1 Default Constructor的建构操作 “带有Default Constructor”的Member Class Object “带有Default Constructor”的Base Class “带有一个Virual Function”的Class “带有一个virual Base class”的Class 总结 2.2 Copy Constructor的建构操作 Default Memberwise Initialization Bitwise Copy Semantics（位逐次拷贝） 不要Bitwise Copy Semantics！ 重新设定的指针Virtual Table 处理Virtual Base Class Subobject 2.3程序转换语意学（Program Transformation Semantics） 明确的初始化操作（Explicit Initialization） 参数的初始化（Argument Initialization） 返回值的初始化（Return Value Initialization） 在使用者层面做优化（Optimization at the user Level） 在编译器层面做优化（Optimization at the Compiler Level） Copy Constructor：要还是不要？ 摘要 2.4 成员们的初始化队伍（Member Initialization List）</span><br><span class="line"></span><br><span class="line"> 第3章 Data语意学（The Semantics of Data）</span><br><span class="line"></span><br><span class="line"> 3.1 Data Member的绑定（The Binding of a Data Member） 3.2 Data Member的布局（Data Member Layout） 3.3 Data Member的存取 Static Data Members Nonstatic Data Member 3.4 “继承”与Data Member 只要继承不要多态（Inheritance without Polymorphism） 加上多态（Adding Polymorphism） 多重继承（Multiple Inheritance） 虚拟继承（Virtual Inheritance） 3.5 对象成员的效率（Object Member Efficiency） 3.6 指向Data Members的指针（Pointer to Data Members） “指向Members的指针”的效率问题</span><br><span class="line"></span><br><span class="line"> 第4章 Function语意学（The Semantics of Function）</span><br><span class="line"></span><br><span class="line"> 4.1 Member的各种调用方式 Nonstatic Member Functions（非静态成员函数） Virtual Member Functions（虚拟成员函数） Static Member Functions（静态成员函数） 4.2 Virtual Member Functions（虚拟成员函数） 多重继承下的Virtual Functions 虚拟继承下的Virtual Functions 4.3 函数的效能 4.4 指向Member Functions的指针（Pointer-to-Member Functions） 支持“指向Virtual Member Functions”之指针 在多重继承之下，指向Member Functions的指针 “指向Member Functions之指针”的效率 4.5 Inline Functions 形式对数（Formal Arguments） 局部变量（Local Variables）</span><br><span class="line"></span><br><span class="line"> 第5章 构造、解构、拷贝 语意学（Semantics of Construction，Destruction，and Copy）</span><br><span class="line"></span><br><span class="line"> 纯虚拟函数的存在（Presence of a Pure Virtual Function） 虚拟规格的存在（Presence of a Virtual Specification） 虚拟规格中const的存在 重新考虑class的声明 5.1 无继承情况下的对象构造 抽象数据类型（Abstract Data Type） 为继承做准备 5.2 继承体系下的对象构造 虚拟继承（Virtual Inheritance） 初始化语意学（The Semantics of the vptr Initialization） 5.3 对象复制语意学（Object Copy Semantics） 5.4 对象的功能（Object Efficiency） 5.5 解构语意学（Semantics of Destruction）</span><br><span class="line"></span><br><span class="line"> 第6章 执行期语意学（Runting Semantics）</span><br><span class="line"></span><br><span class="line"> 6.1 对象的构造和解构（Object Construction and Destruction） 全局对象（Global Objects） 局部静态对象（Local Static Objects） 对象数组（Array of Objects） Default Constructors和数组 6.2 new和delete运算符 针对数组的new语意 Placement Operator new的语意 6.3 临时性对象（Temporary Objects） 临时性对象的迷思（神话、传说）</span><br><span class="line"></span><br><span class="line"> 第7章 站在对象模型的类端（On the Cusp of the Object Model）</span><br><span class="line"></span><br><span class="line"> 7.1 Template Template的“具现”行为（Template Instantiation） Template的错误报告（Error Reporting within a Template） Template中的名称决议方式（Name Resolution within a Template） Member Function的具现行为（Member Function Instantiation） 7.2 异常处理（Exception Handling） Exception Handling快速检阅 对Exception Handling的支持 7.3 执行期类型识别（Runtime Type Identification，RTTI） Type-Safe Downcast（保证安全的向下转型操作） Type-Safe Dynamic Cast（保证安全的动态转型） References并不是Pointers Typeid运算符 7.4 效率有了，弹性呢？ 动态共享函数库（Dynamic Shared Libraries） 共享内存（Shared Memory）</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B006QXQXTM/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B006QXQXTM&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51WYQOMNn8L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>inside the c++ object model</title>
    <url>/2020/04/19/inside-the-cpp-object-model/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： inside the c++ object model<br>作者信息： 作者: Stanley B. Lippman [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Inside the C++ Object Model focuses on the underlying mechanisms that support object-oriented programming within C++: constructor semantics, temporary generation, support for encapsulation, inheritance, and “the virtuals”–virtual functions and virtual inheritance. This book shows how your understanding the underlying implementation models can help you code more efficiently and with greater confidence. Lippman dispells the misinformation and myths about the overhead and complexity associated with C++, while pointing out areas in which costs and trade offs, sometimes hidden, do exist. He then explains how the various implementation models arose, points out areas in which they are likely to evolve, and why they are what they are. He covers the semantic implications of the C++ object model and how that model affects your programs. Highlights <em>Explores the program behavior implicit in the C++ Object Model’s support of object-oriented programming. *Explains the basic implementation of the object-oriented features and the trade offs implicit in those features. *Examines the impact on performance in terms of program transformation.</em> Provides abundant program examples, diagrams, and performance measurements to relate object-oriented concepts to the underlying object model.</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Chapter 1. Object Lessons</span><br><span class="line">Layout Costs for Adding Encapsulation</span><br><span class="line">Section 1.1. The C++ Object Model</span><br><span class="line">Section 1.2. A Keyword Distinction</span><br><span class="line">Section 1.3. An Object Distinction</span><br><span class="line">Chapter 2. The Semantics of Constructors</span><br><span class="line">Section 2.1. Default Constructor Construction</span><br><span class="line">Section 2.2. Copy Constructor Construction</span><br><span class="line">Section 2.3. Program Transformation Semantics</span><br><span class="line">Section 2.4. Member Initialization List</span><br><span class="line">Chapter 3. The Semantics of Data</span><br><span class="line">Section 3.1. The Binding of a Data Member</span><br><span class="line">Section 3.2. Data Member Layout</span><br><span class="line">Section 3.3. Access of a Data Member</span><br><span class="line">Section 3.4. Inheritance and the Data Member</span><br><span class="line">Section 3.5. Object Member Efficiency</span><br><span class="line">Section 3.6. Pointer to Data Members</span><br><span class="line">Chapter 4. The Semantics of Function</span><br><span class="line">Section 4.1. Varieties of Member Invocation</span><br><span class="line">Section 4.2. Virtual Member Functions</span><br><span class="line">Section 4.3. Function Efficiency</span><br><span class="line">Section 4.4. Pointer-to-Member Functions</span><br><span class="line">Section 4.5. Inline Functions</span><br><span class="line">Chapter 5. Semantics of Construction, Destruction, and Copy</span><br><span class="line">Presence of a Pure Virtual Destructor</span><br><span class="line">Presence of a Virtual Specification</span><br><span class="line">Presence of const within a Virtual Specification</span><br><span class="line">A Reconsidered Class Declaration</span><br><span class="line">Section 5.1. Object Construction without Inheritance</span><br><span class="line">Section 5.2. Object Construction under Inheritance</span><br><span class="line">Section 5.3. Object Copy Semantics</span><br><span class="line">Section 5.4. Object Efficiency</span><br><span class="line">Section 5.5. Semantics of Destruction</span><br><span class="line">Chapter 6. Runtime Semantics</span><br><span class="line">Section 6.1. Object Construction and Destruction</span><br><span class="line">Section 6.2. Operators new and delete</span><br><span class="line">Section 6.3. Temporary Objects</span><br><span class="line">Chapter 7. On the Cusp of the Object Model</span><br><span class="line">Section 7.1. Templates</span><br><span class="line">Section 7.2. Exception Handling</span><br><span class="line">Section 7.3. Runtime Type Identification</span><br><span class="line">Section 7.4. Efficient, but Inflexible?</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/0201834545/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=0201834545&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51M0RWZW29L._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++设计新思维</title>
    <url>/2020/04/19/modern-cpp-design/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C++设计新思维<br>作者信息： 作者: Alexandrescu [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>本书从根本上展示了generic patterns(泛型模式)或pattern templates（模式模板），并将它们视之为“在C 中创造可扩充设计”的一种功能强大的新方法。这种方法结合了template和patterns，你可能未曾想过，但的确存在。为C 打开了全新视野，而且不仅仅在编程方面，还在于软件设计本身；对软件分析和软件体系结构来说，它也具有丰富的内涵。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">译序by 侯捷 i</span><br><span class="line">译序by 於春景  iii</span><br><span class="line">目录   v</span><br><span class="line">序言by scott meyers    xi</span><br><span class="line">序言by john vlissides  xv</span><br><span class="line">前言   xvii</span><br><span class="line">致谢   xxi</span><br><span class="line">第一篇 技术（techniques）    1</span><br><span class="line">第1章 基于policy的class设计（policy-based class design）   3</span><br><span class="line">1.1 软件设计的多样性（multiplicity）   3</span><br><span class="line">1.2 全功能型（do-it-all）接口的失败   4</span><br><span class="line">1.3 多重继承（multiple inheritance）是救世主？   5</span><br><span class="line">1.4 templates带来曙光    6</span><br><span class="line">1.5 policies和policy classes    7</span><br><span class="line">1.6 更丰富的policies     12</span><br><span class="line">1.7 policy classes的析构函数（destructors）   12</span><br><span class="line">1.8 通过不完全具现化（incomplete instantiation）而获得的选择性机能（optional functionality）    13</span><br><span class="line">1.9 结合policy classes    14</span><br><span class="line">.   1.10    以policy classes定制结构   16</span><br><span class="line">1.11    policies的兼容性     17</span><br><span class="line">1.12    将一个class分解为一堆policies    19</span><br><span class="line">1.13    摘要   20</span><br><span class="line">第2章 技术（techniques）   23</span><br><span class="line">2.1 编译期（compile-time）assertions   23</span><br><span class="line">2.2 partial template specialization（模板偏特化）    26</span><br><span class="line">2.3 局部类（local classes）     28</span><br><span class="line">2.4 常整数映射为型别（mapping integral constants to types）   29</span><br><span class="line">2.5 型别对型别的映射（type-to-type mapping）  31</span><br><span class="line">2.6 型别选择（type selection）     33</span><br><span class="line">2.7 编译期间侦测可转换性（convertibility）和继承性（inheritance） 34</span><br><span class="line">2.8 type_info的一个外覆类（wrapper）    37</span><br><span class="line">2.9 nulltype和emptytype     39</span><br><span class="line">2.10    type traits  40</span><br><span class="line">2.11    摘要   46</span><br><span class="line">第3章 typelists    49</span><br><span class="line">3.1 typelists的必要性 49</span><br><span class="line">3.2 定义typelists  51</span><br><span class="line">3.3 将typelist的生成线性化（linearizing）  52</span><br><span class="line">3.4 计算长度     53</span><br><span class="line">3.5 间奏曲    54</span><br><span class="line">3.6 索引式访问（indexed access） 55</span><br><span class="line">3.7 查找typelists  56</span><br><span class="line">3.8 附加元素至typelists     57</span><br><span class="line">3.9 移除typelist中的某个元素    58</span><br><span class="line">3.10    移除重复元素（erasing duplicates）59</span><br><span class="line">3.11    取代typelist中的某个元素    60</span><br><span class="line">3.12    为typelists局部更换次序（partially ordering）  61</span><br><span class="line">3.13    运用typelists自动产生classes   64</span><br><span class="line">3.14    摘要   74</span><br><span class="line">3.15    typelist要点概览     75</span><br><span class="line">第4章 小型对象分配技术（small-object allocation）    77</span><br><span class="line">4.1 缺省的free store分配器     78</span><br><span class="line">4.2 内存分配器的工作方式   78</span><br><span class="line">4.3 小型对象分配器（small-object allocator）   80</span><br><span class="line">4.4 chunks（大块内存）     81</span><br><span class="line">4.5 大小一致（fixed-size）的分配器    84</span><br><span class="line">4.6 smallobjallocator class  87</span><br><span class="line">4.7 帽子下的戏法   89</span><br><span class="line">4.8 简单，复杂，终究还是简单    92</span><br><span class="line">4.9 使用细节     93</span><br><span class="line">4.10    摘要   94</span><br><span class="line">4.11    小型对象分配器（small-object allocator）要点概览   94</span><br><span class="line">第二篇   组件（components）   97</span><br><span class="line">第5章 泛化仿函数（generalized functors）   99</span><br><span class="line">5.1 command设计模式  100</span><br><span class="line">5.2 真实世界中的command    102</span><br><span class="line">5.3 c++ 中的可呼叫体（callable entities）    103</span><br><span class="line">5.4 functor class template骨干    104</span><br><span class="line">5.5 实现“转发式”（forwarding）functor::operator()     108</span><br><span class="line">5.6 处理仿函数  110</span><br><span class="line">5.7 做一个，送一个    112</span><br><span class="line">5.8 引数（argument）和返回型别（return type）的转换    114</span><br><span class="line">5.9 处理pointer to member function（成员函数指针）     115</span><br><span class="line">5.10    绑定（binding）  119</span><br><span class="line">5.11    将请求串接起来（chaining requests）    122</span><br><span class="line">5.12    现实世界中的问题之1：转发式函数的成本 122</span><br><span class="line">5.13    现实世界中的问题之2：heap分配    124</span><br><span class="line">5.14    通过functor实现undo和redo   125</span><br><span class="line">5.15    摘要   126</span><br><span class="line">5.16    functor要点概览  126</span><br><span class="line">第6章 singletons（单件）实现技术   129</span><br><span class="line">6.1 静态数据 + 静态函数 !&#x3D; singleton    130</span><br><span class="line">6.2 用以支持singleton的一些c++ 基本手法  131</span><br><span class="line">6.3 实施“singleton的唯一性”    132</span><br><span class="line">6.4 摧毁singleton  133</span><br><span class="line">6.5 dead（失效的）reference问题   135</span><br><span class="line">6.6 解决dead reference问题（i）：phoenix singleton    137</span><br><span class="line">6.7 解决dead reference问题（ii）：带寿命的singletons 139</span><br><span class="line">6.8 实现“带寿命的singletons”   142</span><br><span class="line">6.9 生活在多线程世界     145</span><br><span class="line">6.10    将一切组装起来    148</span><br><span class="line">6.11    使用singletonholder    153</span><br><span class="line">6.12    摘要   155</span><br><span class="line">6.13    singletonholder class template要点概览  155</span><br><span class="line">第7章 smart pointers（智能指针）    157</span><br><span class="line">7.1 smart pointers基础    157</span><br><span class="line">7.2 交易   158</span><br><span class="line">7.3 smart pointers的存储 160</span><br><span class="line">7.4 smart pointer的成员函数    161</span><br><span class="line">7.5 拥有权（ownership）管理策略     163</span><br><span class="line">7.6 address-of（取址）操作符  170</span><br><span class="line">7.7 隐式转换（implicit conversion）至原始指针型别   171</span><br><span class="line">7.8 相等性（equality）和不等性（inequality）  173</span><br><span class="line">7.9 次序比较（ordering comparisons）  178</span><br><span class="line">7.10    检测及错误报告（checking and error reporting）  181</span><br><span class="line">7.11    smart pointers to const和const smart pointers   182</span><br><span class="line">7.12    arrays   183</span><br><span class="line">7.13    smart pointers和多线程（multithreading）  184</span><br><span class="line">7.14    将一切组装起来   187</span><br><span class="line">7.15    摘要   194</span><br><span class="line">7.16    smartptr要点概览194</span><br><span class="line">第8章 object factories（对象工厂）  197</span><br><span class="line">8.1 为什么需要object factories 198</span><br><span class="line">8.2 object factories in c++：classes和objects 200</span><br><span class="line">8.3 实现一个object factory   201</span><br><span class="line">8.4 型别标识符（type identifiers）   206</span><br><span class="line">8.5 泛化（generalization）   207</span><br><span class="line">8.6 细节琐务    210</span><br><span class="line">8.7 clone factories（克隆工厂、翻制工厂、复制工厂） 211</span><br><span class="line">8.8 通过其他泛型组件来使用object factories    215</span><br><span class="line">8.9 摘要   216</span><br><span class="line">8.10    factory class template要点概览   216</span><br><span class="line">8.11    clonefactory class template要点概览 217</span><br><span class="line">第9章 abstract factory（抽象工厂）  219</span><br><span class="line">9.1 abstract factory扮演的体系结构角色（architectural role） 219</span><br><span class="line">9.2 一个泛化的abstract factory接口    223</span><br><span class="line">9.3 实作出abstractfactory     226</span><br><span class="line">9.4 一个prototype-based abstract factory实作品 228</span><br><span class="line">9.5 摘要  233</span><br><span class="line">9.6 abstractfactory和concretefactory要点概览   233</span><br><span class="line">第10章    visitor（访问者、视察者）  235</span><br><span class="line">10.1    visitor 基本原理    235</span><br><span class="line">10.2    重载（overloading）：catch-all函数    242</span><br><span class="line">10.3    一份更加精炼的实作品：acyclic visitor     243</span><br><span class="line">10.4    visitor之泛型实作  248</span><br><span class="line">10.5    再论 “cyclic” visitor 255</span><br><span class="line">10.6    变化手段     258</span><br><span class="line">10.7    摘要   260</span><br><span class="line">10.8    visitor泛型组件要点概览  261</span><br><span class="line">第11章    multimethods     263</span><br><span class="line">11.1    什么是multimethods?  264</span><br><span class="line">11.2    何时需要multimethods？ 264</span><br><span class="line">11.3    double switch-on-type：暴力法   265</span><br><span class="line">11.4    将暴力法自动化    268</span><br><span class="line">11.5    暴力式dispatcher 的对称性    273</span><br><span class="line">11.6    对数型（logarithmic）double dispatcher 276</span><br><span class="line">11.7    fndispatcher 和对称性    282</span><br><span class="line">11.8    double dispatch（双重分派）至仿函数（functors） 282</span><br><span class="line">11.9    引数的转型：static_cast或dynamic_cast？  285</span><br><span class="line">11.10   常数时间的multimethods：原始速度（raw speed）   290</span><br><span class="line">11.11   将basicdispatcher 和basicfastdispatcher当做policies 293</span><br><span class="line">11.12   展望  294</span><br><span class="line">11.13   摘要  296</span><br><span class="line">11.14   double dispatcher要点概览   297</span><br><span class="line">附录  一个超迷你的多线程程序库（a minimalist multithreading library）   301</span><br><span class="line">a.1 多线程的反思  302</span><br><span class="line">a.2 loki的作法   303</span><br><span class="line">a.3 整数型别上的原子操作（atomic operations）   303</span><br><span class="line">a.4 mutexes（互斥器）  305</span><br><span class="line">a.5 面向对象编程中的锁定语意（locking semantics） 306</span><br><span class="line">a.6 可有可无的（optional）volatile标识符  308</span><br><span class="line">a.7 semaphores, events和其他好东西     309</span><br><span class="line">a.8 摘要  309</span><br><span class="line">参考书目（bibliography）  311</span><br><span class="line">索引（index）    313</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00CLQBZ28/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00CLQBZ28&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41BQPo8oQIL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>More Effective C++</title>
    <url>/2020/04/19/more-effective-cpp/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： More Effective C++<br>作者信息： 作者: Scott Meyers [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《More Effective C++:35个改善编程与设计的有效方法(中文版)》内容简介：继Effective C++之后，Scott Meyers于1996推出这本《More Effective C++(35个改善编程与设计的有效方法)》“续集”。条款变得比较少，页数倒是多了一些，原因是这次选材比“第一集”更高阶，尤其是第5章。Meyers将此章命名为技术（techniques），并明白告诉你，其中都是一些patterns，例如virtual constructors，smart pointers，reference counting，proxy classes，double dispatching……这一章的每个条款篇幅都达15-30 页之多，实在让人有“山重水复疑无路，柳暗花明又一村”之叹。<br>虽然出版年代稍嫌久远，但《More Effective C++》并没有第2版，原因是当其出版之时（1996），C++ Standard已经几乎定案，《More Effective C++:35个改善编程与设计的有效方法(中文版)》即依当时的标准草案而写，其与现今的C++ 标准规范几乎相同。而且可能变化的几个弹性之处，Meyers也都有所说明与提示。读者可以登录作者提供的网址，看看上下两集的勘误与讨论（数量之多，令人惊恐。幸好多是技术讨论或文字斟酌，并没有什么重大误失）。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">译序（侯捷）</span><br><span class="line">导读（Introduction）</span><br><span class="line">基础议题（Basics）</span><br><span class="line">　条款1：仔细区别 pointers 和 references</span><br><span class="line">　Distinguish between pointers and references.</span><br><span class="line">　条款2：最好使用 C++ 转型操作符</span><br><span class="line">　Prefer C++-style casts.</span><br><span class="line">　条款3：绝对不要以多态（polymorphically）方式处理数组</span><br><span class="line">　Never treat arrays polymorphically.</span><br><span class="line">　条款4：非必要不提供 default constructor</span><br><span class="line">　Avoid gratuitous default constructors.</span><br><span class="line">操作符（Operators）</span><br><span class="line">　条款5：对定制的“类型转换函数”保持警觉</span><br><span class="line">　Be wary of user-defined conversion functions.</span><br><span class="line">　条款6：区别 increment&#x2F;decrement 操作符的</span><br><span class="line">　前置（prefix）和后置（postfix）形式</span><br><span class="line">　Distinguish between prefix and postfix forms of increment</span><br><span class="line">　and decrement operators.</span><br><span class="line">　条款7：千万不要重载＆＆，||和, 操作符</span><br><span class="line">　Never overload ＆＆, ||, or ,.</span><br><span class="line">　条款8：了解各种不同意义的 new 和 delete</span><br><span class="line">　Understand the different meanings of new and delete</span><br><span class="line">异常（Exceptions）</span><br><span class="line">　条款9：利用 destructors 避免泄漏资源</span><br><span class="line">　Use destructors to prevent resource leaks.</span><br><span class="line">　条款10：在 constructors 内阻止资源泄漏（resource leak）</span><br><span class="line">　Prevent resource leaks in constructors.</span><br><span class="line">　条款11：禁止异常（exceptions）流出 destructors 之外</span><br><span class="line">　Prevent exceptions from leaving destructors.</span><br><span class="line">　条款12：了解“抛出一个 exception”与“传递一个参数”</span><br><span class="line">　或“调用一个虚函数”之间的差异61</span><br><span class="line">　Understand how throwing an exception differs from</span><br><span class="line">　passing a parameter or calling a virtual function.</span><br><span class="line">　条款13：以 by reference 方式捕捉 exceptions</span><br><span class="line">　Catch exceptions by reference.</span><br><span class="line">　条款14：明智运用 exception specifications</span><br><span class="line">　Use exception specifications judiciously.</span><br><span class="line">　条款15：了解异常处理（exception handling）的成本</span><br><span class="line">　Understand the costs of exception handling.</span><br><span class="line">效率（Efficiency）</span><br><span class="line">　条款16：谨记 80-20 法则</span><br><span class="line">　Remember the 80-20 rule.</span><br><span class="line">　条款17：考虑使用 lazy evaluation（缓式评估）</span><br><span class="line">　Consider using lazy evaluation.</span><br><span class="line">　条款18：分期摊还预期的计算成本</span><br><span class="line">　Amortize the cost of expected computations.</span><br><span class="line">　条款19：了解临时对象的来源</span><br><span class="line">　Understand the origin of temporary objects.</span><br><span class="line">　条款20：协助完成“返回值优化（RVO）”</span><br><span class="line">　Facilitate the return value optimization.</span><br><span class="line">　条款21：利用重载技术（overload）避免隐式类型转换（implict type conversions）</span><br><span class="line">　Overload to avoid implicit type conversions.</span><br><span class="line">　条款22：考虑以操作符复合形式（op&#x3D;）取代其独身形式（op）</span><br><span class="line">　Consider using op&#x3D; instead of stand-alone op.</span><br><span class="line">　条款23：考虑使用其他程序库</span><br><span class="line">　Consider alternative libraries.</span><br><span class="line">　条款24：了解 virtual functions、multiple inheritance、virtual baseclasses、</span><br><span class="line">　runtime type identification 的成本</span><br><span class="line">　Understand the costs of virtual functions, multipleinheritance,</span><br><span class="line">　virtual base classes, and RTTI.</span><br><span class="line">技术（Techniques, Idioms, Patterns）</span><br><span class="line">杂项讨论（Miscellany）</span><br><span class="line">索引（一）（General Index）</span><br><span class="line">索引（二）（Index of Example Classes，Functions，and Templtes）</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B004IP8BD6/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B004IP8BD6&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51ACMXRYbpL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>More Exceptional C++(英文)</title>
    <url>/2020/04/19/more-exceptional-cpp-en/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： More Exceptional C++(英文)<br>作者信息： 作者: Herb Sutter [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Generic Programming and the C++ Standard Library.</span><br><span class="line">Item 1: Switching Streams (2 &#x2F; 10).</span><br><span class="line">Item 2: Predicates,</span><br><span class="line">Part 1: What remove() Removes (4 &#x2F; 10).</span><br><span class="line">Item 3: Predicates, Part 2: Matters of State (7 &#x2F; 10).</span><br><span class="line">Item 4: Extensible Templates: Via Inheritance or Traits? (7 &#x2F; 10).</span><br><span class="line">Item 5: Typename (7 &#x2F; 10).</span><br><span class="line">Item 6: Containers, Pointers, and Containers That Aren’t (5 &#x2F; 10).</span><br><span class="line">Item 7: Using Vector and Deque (3 &#x2F; 10).</span><br><span class="line">Item 8: Using Set and Map (5 &#x2F; 10).</span><br><span class="line">Item 9: Equivalent Code? (5 &#x2F; 10).</span><br><span class="line">Item 10: Template Specialization and Overloading (6 &#x2F; 10).</span><br><span class="line">Item 11: Mastermind (8 &#x2F; 10). </span><br><span class="line"></span><br><span class="line"> Optimization and Performance. Item 12: Inline (4 &#x2F; 10). Item 13: Lazy Optimization, Part 1: A Plain Old String (2 &#x2F; 10). Item 14: Lazy Optimization, Part 2: Introducing Laziness (3 &#x2F; 10). Item 15: Lazy Optimization, Part 3: Iterators and References (6 &#x2F; 10). Item 16: Lazy Optimization, Part 4: Multi-Threaded Environments (8 &#x2F; 10).</span><br><span class="line"></span><br><span class="line"> Exception Safety Issues and Techniques. Item 17: Constructor Failures, Part 1: Object Lifetimes (4 &#x2F; 10). Item 18: Constructor Failures, Part 2: Absorption? (7 &#x2F; 10). Item 19: Uncaught Exceptions (6 &#x2F; 10). Item 20: An Unmanaged Pointer Problem, Part 1: Parameter Evaluation (6 &#x2F; 10). Item 21: An Unmanaged Pointer Problem, Part 2: What About auto_ptr? (8 &#x2F; 10). Item 22: Exception-Safe Class Design, Part 1: Copy Assignment (7 &#x2F; 10). Item 23: Exception-Safe Class Design, Part 2: Inheritance (6 &#x2F; 10).</span><br><span class="line"></span><br><span class="line"> Inheritance and Polymorphism. Item 24: Why Multiple Inheritance? (6 &#x2F; 10). Item 25: Emulating Multiple Inheritance (5 &#x2F; 10). Item 26: Multiple Inheritance and the Siamese Twin Problem (4 &#x2F; 10).Item 27: (Im)pure Virtual Functions (7 &#x2F; 10). Item 28: Controlled Polymorphism (3 &#x2F; 10).</span><br><span class="line"></span><br><span class="line"> Memory and Resource Management. Item 29: Using auto_ptr (5 &#x2F; 10). Item 30: Smart Pointer Members, Part 1: A Problem with auto_ptr (5 &#x2F; 10). Item 31: Smart Pointer Members, Part 2: Toward a ValuePtr (6 &#x2F; 10).</span><br><span class="line"></span><br><span class="line"> Free Functions and Macros. Item 32: Recursive Declarations (6 &#x2F; 10). Item 33: Simulating Nested Functions (5 &#x2F; 10). Item 34: Preprocessor Macros (4 &#x2F; 10). Item 35: #Definition (4 &#x2F; 10).</span><br><span class="line"></span><br><span class="line"> Miscellaneous Topics. Item 36: Initialization (3 &#x2F; 10). Item 37: Forward Declarations (3 &#x2F; 10). Item 38: Typedef (3 &#x2F; 10). Item 39: Namespaces, Part 1: Using-Declarations and Using-Directives (2 &#x2F; 10). Item 40: Namespaces, Part 2: Migrating to Namespaces (4 &#x2F; 10).</span><br><span class="line"></span><br><span class="line"> Afterword.</span><br><span class="line"></span><br><span class="line"> Appendixes,</span><br><span class="line"></span><br><span class="line"> Appendix A. Optimizations That Aren’t (In a Multithreaded World).</span><br><span class="line"></span><br><span class="line"> Appendix B. Test Results for Single- versus Multi-Thread-Safe String Implementations.</span><br><span class="line"></span><br><span class="line"> Bibliography.</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/020170434X/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=020170434X&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51BG1Y2XDML._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++程序设计原理与实践</title>
    <url>/2020/04/19/principles-and-practice-using-cpp/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C++程序设计原理与实践<br>作者信息： 作者: Bjarne Stroustrup [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>本书是经典程序设计思想与C++开发实践的完美结合，是C++之父回归校园后对C++编程原理和技巧的全新阐述。书中全面地介绍了程序设计基本原理，包括基本概念、设计和编程技术、语言特性以及标准库等，教你学会如何编写具有输入、输出、计算以及简单图形显示等功能的程序。此外，本书通过对C++思想和历史的讨论、对经典实例（如矩阵运算、文本处理、测试以及嵌入式系统程序设计）的展示，以及对C语言的简单描述，为你呈现了一幅程序设计的全景图。<br>·C++初学者的权威指南。无论你是从事软件开发还是其他领域的工作，本书将为你打开程序开发之门。<br>·中高级程序员的必备参考。通过观察程序设计大师如何处理编程中的各种问题，使你获得新的领悟和指引。<br>·全面阐释C++基本概念和技术。与传统的C++教材相比，本书对基本概念和技术的介绍更为深入，为你编写实用、正确、易维护和有效的代码打下坚实的基础。<br>·强调现代C++编程风格。本书从开篇就介绍现代C++程序设计技术，并揭示了大量关于如何使用C++标准库来简化程序设计的原理，使你快速掌握实用编成技巧。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">出版者的话</span><br><span class="line">译者序</span><br><span class="line">前言</span><br><span class="line">第0章 致读者</span><br><span class="line">0.1 本书结构</span><br><span class="line">0.2 讲授和学习本书的方法</span><br><span class="line">0.3 程序设计和计算机科学</span><br><span class="line">0.4 创造性和问题求解</span><br><span class="line">0.5 反馈方法</span><br><span class="line">0.6 参考文献</span><br><span class="line">0.7 作者简介</span><br><span class="line">第1章 计算机、人与程序设计</span><br><span class="line">1.1 介绍</span><br><span class="line">1.2 软件</span><br><span class="line">1.3 人</span><br><span class="line">1.4 计算机科学</span><br><span class="line">1.5 计算机已无处不在</span><br><span class="line">1.6 程序员的理想</span><br><span class="line">第一部分 基本知识</span><br><span class="line">第2章 Hello，World!</span><br><span class="line">2.1 程序</span><br><span class="line">2.2 经典的第一个程序</span><br><span class="line">2.3 编译</span><br><span class="line">2.4 链接</span><br><span class="line">2.5 编程环境</span><br><span class="line">第3章 对象、类型和值</span><br><span class="line">3.1 输入</span><br><span class="line">3.2 变量</span><br><span class="line">3.3 输入和类型</span><br><span class="line">3.4 运算和运算符</span><br><span class="line">3.5 赋值和初始化</span><br><span class="line">3.6 组合赋值运算符</span><br><span class="line">3.7 命名</span><br><span class="line">3.8 类型和对象</span><br><span class="line">3.9 类型安全</span><br><span class="line">第4章 计算</span><br><span class="line">4.1 计算</span><br><span class="line">4.2 目标和工具</span><br><span class="line">4.3 表达式</span><br><span class="line">4.4 语句</span><br><span class="line">4.5 函数</span><br><span class="line">4.6 向量</span><br><span class="line">4.7 语言特性</span><br><span class="line">第5章 错误</span><br><span class="line">5.1 介绍</span><br><span class="line">5.2 错误的来源</span><br><span class="line">5.3 编译时错误</span><br><span class="line">5.4 连接时错误</span><br><span class="line">5.5 运行时错误</span><br><span class="line">5.6 异常</span><br><span class="line">5.7 逻辑错误</span><br><span class="line">5.8 估计</span><br><span class="line">5.9 调试</span><br><span class="line">5.10 前置条件和后置条件</span><br><span class="line">5.11 测试</span><br><span class="line">第6章 编写一个程序</span><br><span class="line">6.1 一个问题</span><br><span class="line">6.2 对问题的思考</span><br><span class="line">6.3 回到计算器问题</span><br><span class="line">6.4 文法</span><br><span class="line">6.5 将文法转换为程序</span><br><span class="line">6.6 试验第一个版本</span><br><span class="line">6.7 试验第二个版本</span><br><span class="line">6.8 单词流</span><br><span class="line">6.9 程序结构</span><br><span class="line">第7章 完成一个程序</span><br><span class="line">7.1 介绍</span><br><span class="line">7.2 输入和输出</span><br><span class="line">7.3 错误处理</span><br><span class="line">7.4 处理负数</span><br><span class="line">7.5 模运算：%</span><br><span class="line">7.6 清理代码</span><br><span class="line">7.7 错误恢复</span><br><span class="line">7.8 变量</span><br><span class="line">第8章 函数相关的技术细节</span><br><span class="line">8.1 技术细节</span><br><span class="line">8.2 声明和定义</span><br><span class="line">8.3 头文件</span><br><span class="line">8.4 作用域</span><br><span class="line">8.5 函数调用和返回</span><br><span class="line">8.6 求值顺序</span><br><span class="line">8.7 名字空间</span><br><span class="line">第9章 类相关的技术细节</span><br><span class="line">9.1 用户自定义类型</span><br><span class="line">9.2 类和成员</span><br><span class="line">9.3 接口和实现</span><br><span class="line">9.4 演化一个类</span><br><span class="line">9.5 枚举类型</span><br><span class="line">9.6 运算符重载</span><br><span class="line">9.7 类接口</span><br><span class="line">9.8 Date类</span><br><span class="line">第二部分 输入和输出</span><br><span class="line">第10章 输入&#x2F;输出流</span><br><span class="line">第11章 定制输入&#x2F;输出</span><br><span class="line">第12章 一个显示模型</span><br><span class="line">第13章 图形类</span><br><span class="line">第14章 设计图形类</span><br><span class="line">第15章 绘制函数图和数据图</span><br><span class="line">第16章 图形用户界面</span><br><span class="line">第三部分 数据结构和算法</span><br><span class="line">第17章 向量和自由空间</span><br><span class="line">第18章 向量和数组</span><br><span class="line">第19章 向量、模板和异常</span><br><span class="line">第20章 容器和迭代器</span><br><span class="line">第21章 算法和映射</span><br><span class="line">第四部分 拓宽视野</span><br><span class="line">第22章 理念和历史</span><br><span class="line">第23章 文本处理</span><br><span class="line">第24章 数值计算</span><br><span class="line">第25章 嵌入式系统程序设计</span><br><span class="line">第26章 测试</span><br><span class="line">第27章 C语言</span><br><span class="line">术语表</span><br><span class="line">参考书目</span><br><span class="line">第五部分 附录?</span><br><span class="line">附录A C++语言概要</span><br><span class="line">附录B 标准库概要</span><br><span class="line">附录C Visual Studio简要入门教程</span><br><span class="line">附录D 安装FLTK</span><br><span class="line">附录E GUI实现</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B003VPX6YS/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B003VPX6YS&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/513QJk5dqkL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Clojure程序设计(英文)</title>
    <url>/2020/04/19/programming-clojure-2nd/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Clojure程序设计(英文)<br>作者信息： 作者: 哈罗威 [ 英文 epub ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Clojure程序设计》是介绍Clojure的经典之作。它完全覆盖了Clojure 1.3版本提供的新特性，而且为了体现Clojure新生概念的重要意义，作者重新组织和编写了一些章节。两位作者通过《Clojure程序设计》展示了如何从头构建一个应用，帮助读者充分了解Clojure程序的完整开发流程，还帮助读者运用Clojure思想为问题的各个部分找出解决方案。<br>通过阅读《Clojure程序设计》，你能够学会运用Clojure的方式进行思考，充分利用这门语言的优势，快速构建强大的程序。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章启航1</span><br><span class="line">1.1为什么是Clojure2</span><br><span class="line">1.1.1Clojure非常优雅2</span><br><span class="line">1.1.2Clojure是Lisp的再度崛起5</span><br><span class="line">1.1.3为什么是Lisp5</span><br><span class="line">1.1.4它是Lisp，但括号少了6</span><br><span class="line">1.1.5Clojure是函数式语言8</span><br><span class="line">1.1.6Clojure简化了并发编程9</span><br><span class="line">1.1.7Clojure与Java虚拟机彼此亲密无间10</span><br><span class="line">1.2Clojure编程快速入门11</span><br><span class="line">1.2.1使用REPL12</span><br><span class="line">1.2.2特殊变量13</span><br><span class="line">1.2.3添加共享状态14</span><br><span class="line">1.3探索Clojure的程序库16</span><br><span class="line">1.3.1require和use17</span><br><span class="line">1.3.2查找文档18</span><br><span class="line">1.4小结20</span><br><span class="line">第2章探索Clojure21</span><br><span class="line">2.1形式21</span><br><span class="line">2.1.1使用数值类型22</span><br><span class="line">2.1.2符号24</span><br><span class="line">2.1.3字符串与字符25</span><br><span class="line">2.1.4布尔值与nil27</span><br><span class="line">2.1.5映射表、关键字和记录28</span><br><span class="line">2.2读取器宏30</span><br><span class="line">2.3函数32</span><br><span class="line">2.3.1匿名函数34</span><br><span class="line">2.3.2何时使用匿名函数36</span><br><span class="line">2.4变量、绑定和命名空间36</span><br><span class="line">2.4.1绑定37</span><br><span class="line">2.4.2解构38</span><br><span class="line">2.4.3命名空间40</span><br><span class="line">2.5调用Java43</span><br><span class="line">2.5.1访问构造函数、方法和字段43</span><br><span class="line">2.5.2Javadoc45</span><br><span class="line">2.6流程控制45</span><br><span class="line">2.6.1分支结构与if45</span><br><span class="line">2.6.2用do引入副作用46</span><br><span class="line">2.6.3循环与loop&#x2F;recur47</span><br><span class="line">2.7我的for循环哪儿去了48</span><br><span class="line">2.8元数据52</span><br><span class="line">2.9小结53</span><br><span class="line">第3章一切皆序列55</span><br><span class="line">3.1一切皆序列56</span><br><span class="line">3.2使用序列库61</span><br><span class="line">3.2.1创建序列61</span><br><span class="line">3.2.2过滤序列64</span><br><span class="line">3.2.3序列谓词65</span><br><span class="line">3.2.4序列转换66</span><br><span class="line">3.3惰性和无限序列69</span><br><span class="line">3.4Java亦可序化71</span><br><span class="line">3.4.1序化Java容器71</span><br><span class="line">3.4.2序化正则表达式73</span><br><span class="line">3.4.3序化文件系统74</span><br><span class="line">3.4.4序化流75</span><br><span class="line">3.4.5序化XML76</span><br><span class="line">3.5调用特定于结构的函数77</span><br><span class="line">3.5.1列表函数77</span><br><span class="line">3.5.2向量函数78</span><br><span class="line">3.5.3映射表函数79</span><br><span class="line">3.5.4集合函数82</span><br><span class="line">3.6小结85</span><br><span class="line">第4章函数式编程86</span><br><span class="line">4.1函数式编程理念86</span><br><span class="line">4.1.1纯函数87</span><br><span class="line">4.1.2持久性数据结构87</span><br><span class="line">4.1.3惰性和递归88</span><br><span class="line">4.1.4引用透明性89</span><br><span class="line">4.1.5FP的优势89</span><br><span class="line">4.1.66条规则90</span><br><span class="line">4.2怎样偷个懒91</span><br><span class="line">4.2.1尾递归92</span><br><span class="line">4.2.2自递归与recur94</span><br><span class="line">4.2.3惰性序列95</span><br><span class="line">4.2.4聊聊变现97</span><br><span class="line">4.2.5丢弃头元素98</span><br><span class="line">4.3懒上加懒99</span><br><span class="line">4.4再议递归105</span><br><span class="line">4.4.1转换为自递归106</span><br><span class="line">4.4.2采用Trampolining技术107</span><br><span class="line">4.4.3用惰性化替代递归109</span><br><span class="line">4.4.4用快存为递归抄条近路112</span><br><span class="line">4.5小结114</span><br><span class="line">第5章状态115</span><br><span class="line">5.1并发、并行和锁定116</span><br><span class="line">5.2引用与软事务内存117</span><br><span class="line">5.2.1ref—set118</span><br><span class="line">5.2.2事务的属性118</span><br><span class="line">5.2.3alter119</span><br><span class="line">5.2.4STM的工作原理：MVCC120</span><br><span class="line">5.2.5commute121</span><br><span class="line">5.2.6alter优先122</span><br><span class="line">5.2.7为引用添加验证123</span><br><span class="line">5.3使用原子进行非协同、同步的更新124</span><br><span class="line">5.4使用代理进行异步更新125</span><br><span class="line">5.4.1代理的验证与错误处理126</span><br><span class="line">5.4.2在事务中包含代理127</span><br><span class="line">5.4.3统一的更新模型129</span><br><span class="line">5.5用变量管理线程内状态129</span><br><span class="line">5.5.1远距离作用131</span><br><span class="line">5.5.2用于Java回调API132</span><br><span class="line">5.6Clojure贪吃蛇134</span><br><span class="line">5.6.1函数式模型135</span><br><span class="line">5.6.2使用STM建立可变模型139</span><br><span class="line">5.6.3贪吃蛇的GUI140</span><br><span class="line">5.6.4没有引用的贪吃蛇143</span><br><span class="line">5.7小结144</span><br><span class="line">第6章协议和数据类型145</span><br><span class="line">6.1针对抽象编程145</span><br><span class="line">6.2接口148</span><br><span class="line">6.3协议149</span><br><span class="line">6.4数据类型153</span><br><span class="line">6.5记录158</span><br><span class="line">6.6具体化164</span><br><span class="line">6.7小结165</span><br><span class="line">第7章宏166</span><br><span class="line">7.1何时使用宏166</span><br><span class="line">7.2编写流程控制宏167</span><br><span class="line">7.2.1特殊形式、设计模式和宏169</span><br><span class="line">7.2.2宏展开170</span><br><span class="line">7.2.3when与when—not172</span><br><span class="line">7.3让宏更加简单173</span><br><span class="line">7.3.1语法引述、解引述和解引述拼接175</span><br><span class="line">7.3.2在宏内部创建名称176</span><br><span class="line">7.4宏的分类178</span><br><span class="line">7.4.1有条件的求值180</span><br><span class="line">7.4.2创建变量181</span><br><span class="line">7.4.3Java互操作183</span><br><span class="line">7.4.4延迟求值184</span><br><span class="line">7.4.5对求值进行包装184</span><br><span class="line">7.4.6避免Lambda表达式186</span><br><span class="line">7.5小结187</span><br><span class="line">第8章多重方法188</span><br><span class="line">8.1没有多重方法的日子188</span><br><span class="line">8.2定义多重方法190</span><br><span class="line">8.2.1调度是继承感知的192</span><br><span class="line">8.2.2多重方法的默认值192</span><br><span class="line">8.3调度不简单193</span><br><span class="line">8.4创建特设分类法195</span><br><span class="line">8.5何时应该使用多重方法199</span><br><span class="line">8.5.1Inspector200</span><br><span class="line">8.5.2clojure.test201</span><br><span class="line">8.5.3反例202</span><br><span class="line">8.6小结203</span><br><span class="line">第9章极尽Java之所能204</span><br><span class="line">9.1异常处理205</span><br><span class="line">9.1.1保持简单的异常处理205</span><br><span class="line">9.1.2清理资源206</span><br><span class="line">9.1.3响应异常207</span><br><span class="line">9.2与整数搏斗209</span><br><span class="line">9.3性能优化210</span><br><span class="line">9.3.1使用基本类型提升性能210</span><br><span class="line">9.3.2添加类型提示213</span><br><span class="line">9.4在Clojure中创建Java类215</span><br><span class="line">9.4.1创建Java代理215</span><br><span class="line">9.4.2使用Java容器217</span><br><span class="line">9.5真实世界的例子220</span><br><span class="line">9.5.1真正的持续循环222</span><br><span class="line">9.5.2日志224</span><br><span class="line">9.5.3配置226</span><br><span class="line">9.6小结227</span><br><span class="line">第10章搭建应用228</span><br><span class="line">10.1为电码译员游戏计分229</span><br><span class="line">10.2测试计分器232</span><br><span class="line">10.2.1手工构造输入233</span><br><span class="line">10.2.2运行测试234</span><br><span class="line">10.2.3验证输出235</span><br><span class="line">10.2.4回归测试236</span><br><span class="line">10.3test.generative237</span><br><span class="line">10.3.1生成数据237</span><br><span class="line">10.3.2程序化验证238</span><br><span class="line">10.3.3defspec240</span><br><span class="line">10.3.4运行测试241</span><br><span class="line">10.3.5规格执行失败时242</span><br><span class="line">10.3.6计分函数的产生式测试243</span><br><span class="line">10.4创建用户界面244</span><br><span class="line">10.4.1该是时候处理状态了245</span><br><span class="line">10.4.2玩家界面246</span><br><span class="line">10.5部署代码249</span><br><span class="line">10.5.1Procfile250</span><br><span class="line">10.5.2Heroku库250</span><br><span class="line">10.5.3Git251</span><br><span class="line">10.5.4安置你的应用251</span><br><span class="line">10.5.5部署252</span><br><span class="line">10.6小结252</span><br><span class="line">附录编辑器254</span><br><span class="line">参考书目255</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00BN5N7R4/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00BN5N7R4&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41waYrAXMeL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>clojure</tag>
      </tags>
  </entry>
  <entry>
    <title>Real-Time C++</title>
    <url>/2020/04/19/real-time-cpp/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Real-Time C++<br>作者信息： 作者: Michael Kormanyos [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>With this book, Chris Kormanyos delivers a highly practical guide to programming real-time embedded microcontroller systems in C++. It is divided into three parts plus several appendices. Part I provides a foundation for real-time C++ by covering language technologies, including object-oriented methods, template programming and optimization. Next, part II presents detailed descriptions of a variety of C++ components that are widely used in microcontroller programming. It details some of C++’s most powerful language elements, such as class types, templates and the STL, to develop components for microcontroller register access, low-level drivers, custom memory management, embedded containers, multitasking, etc.  Finally, part III describes mathematical methods and generic utilities that can be employed to solve recurring problems in real-time C++. The appendices include a brief C++ language tutorial, information on the real-time C++ development environment and instructions for building GNU GCC cross-compilers and a microcontroller circuit.</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href=""><img src="/images/posts/Real-Time-CPP.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++沉思录</title>
    <url>/2020/04/19/ruminations-on-cpp/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C++沉思录<br>作者信息： 作者: Andrew Koenig [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>C和C++经典著作•C++沉思录:Ruminations on C++》分为6篇32章，分别对C++语言的历史和特点、类和继承、STL与泛型编程、库的设计等几大技术话题进行了详细而深入的讨论，细微之处几乎涵盖了C++所有的设计思想和技术细节。全书通过精心挑选的实例，向读者传达先进的程序设计的方法和理念</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第0章　序幕</span><br><span class="line">第一篇　动机</span><br><span class="line">第1章　为什么我用C++</span><br><span class="line">第2章　为什么用C++工作</span><br><span class="line">第3章　生活在现实世界中 </span><br><span class="line"></span><br><span class="line"> 第二篇　类和继承 第4章　类设计者的核查表 第5章　代理类 第6章　句柄：第一部分 第7章　句柄：第二部分 第8章　一个面向对象程序范例 第9章　一个课堂练习的分析（上） 第10章　一个课堂练习的分析（下） 第11章　什么时候不应当使用虚函数</span><br><span class="line"></span><br><span class="line"> 第三篇　模板 第12章　设计容器类 第13章　访问容器中的元素 第14章　迭代器 第15章　序列 第16章　作为接口的模板 第17章　模板和泛型算法 第18章　泛型迭代器 第19章　使用泛型迭代器 第20章　迭代器配接器 第21章　函数对象 第22章　函数配接器</span><br><span class="line"></span><br><span class="line"> 第四篇　库 第23章　日常使用的库 第24章　一个库接口设计实例 第25章　库设计就是语言设计 第26章　语言设计就是库设计</span><br><span class="line"></span><br><span class="line"> 第五篇　技术 第27章　自己跟踪自己的类 第28章　在簇中分配对象 第29章　应用器、操纵器和函数对象 第30章　将应用程序库从输入输出中分离出来</span><br><span class="line"></span><br><span class="line"> 第六篇　总结 第31章　通过复杂性获取简单性 第32章　说了Hello world后再做什么 附录　Koenig和Moo夫妇访谈 索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0012NMEXU/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0012NMEXU&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51ucIrOlJlL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>More Exceptional C++</title>
    <url>/2020/04/19/more-exceptional-cpp/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： More Exceptional C++<br>作者信息： 作者: Herb Sutter [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>对C++程序员来说，ISO／ANSIC++标准的问世标志着一个新纪元的开始。C++标准为程序设计提供了很多新的便利和可能，但要想在如此众多的信息中挖掘到其中的精髓，现实世界中的程序员缺少足够的时间。本书针对一定的主题，为程序员提供了简明扼要的指导，从而将学习时间和疑惑减至最少。本书内容包括泛型程序设计与C++标准库、优化与性能、异常安全议题及技术、继承与多态、内存及资源管理、自由函数与宏等。<br>本书内容全面丰富，论述翔实清晰，作者权威且经验丰富，是C++程序员的必备读物。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">与大师面对面（译序）</span><br><span class="line">序</span><br><span class="line">前言</span><br><span class="line">泛型程序设计与C++标准库</span><br><span class="line">　条款1：流</span><br><span class="line">　条款2：Predicates，之一：remove()删除了什么?</span><br><span class="line">　条款3：Predicates，之二：状态带来的问题</span><br><span class="line">　条款4：可扩充的模板：使用继承还是traits?</span><br><span class="line">　条款5：typename</span><br><span class="line">　条款6：容器、指针和“不是容器的容器”</span><br><span class="line">　条款7：使用vector和deque</span><br><span class="line">　条款8：使用set和map</span><br><span class="line">　条款9：等同的代码吗?</span><br><span class="line">　条款10：模板特殊化与重载</span><br><span class="line">　条款11：Mastermind</span><br><span class="line">优化与性能</span><br><span class="line">　条款12：内联</span><br><span class="line">　条款13：缓式优化，之一：一个普通的旧式String</span><br><span class="line">　条款14：缓式优化，之二：引入缓式优化</span><br><span class="line">　条款15：缓式优化，之三：迭代器与引用</span><br><span class="line">　条款16：缓式优化，之四：多线程环境</span><br><span class="line">异常安全议题及技术</span><br><span class="line">　条款17：构造函数失败，之一：对象生命期</span><br><span class="line">　条款18：构造函数失败，之二：吸收异常?</span><br><span class="line">　条款19：未捕获的异常</span><br><span class="line">　条款20：未管理指针存在的问题，之一：参数求值</span><br><span class="line">　条款21：未管理指针存在的问题，之二：使用auto~tr7</span><br><span class="line">　条款22：异常安全与类的设计，之一：复制赋值</span><br><span class="line">　条款23：异常安全与类的设计，之二：继承</span><br><span class="line">继承与多态</span><br><span class="line">　条款24：为什么要使用多继承?</span><br><span class="line">　条款25：模拟多继承</span><br><span class="line">　条款26：多继承与连体双婴问题</span><br><span class="line">　条款27： (非)纯虚函数</span><br><span class="line">　条款28：受控的多态</span><br><span class="line">内存及资源管理</span><br><span class="line">　条款29：使用auto_ptr</span><br><span class="line">　条款30：智能指针成员，之一：auto_ptr存在的问题</span><br><span class="line">　条款31：智能指针成员，之二：设计Va1uePtr</span><br><span class="line">自由函数与宏</span><br><span class="line">　条款32：递归声明</span><br><span class="line">　条款33：模拟嵌套函数</span><br><span class="line">　条款34：预处理宏</span><br><span class="line">　条款35：宏定义</span><br><span class="line">杂项议题</span><br><span class="line">　条款36：初始化</span><br><span class="line">　条款37：前置声明</span><br><span class="line">　条款38：typedef</span><br><span class="line">　条款39：名字空间，之一：using声明和using指令</span><br><span class="line">　条款40：名字空间，之二：迁徙到名字空间</span><br><span class="line">后记</span><br><span class="line">参考文献</span><br><span class="line">索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B004IUISIO/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B004IUISIO&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/511xe8fGAlL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>The C++ Programming Language第四版</title>
    <url>/2020/04/19/the-cpp-programming-language-4th/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： The C++ Programming Language第四版<br>作者信息： 作者: Bjarne Stroustrup [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>C++11 has arrived: thoroughly master it, with the definitive new guide from C++ creator Bjarne Stroustrup, C++ Programming Language, Fourth Edition! The brand-new edition of the world’s most trusted and widely read guide to C++, it has been comprehensively updated for the long-awaited C++11 standard. Extensively rewritten to present the C++11 language, standard library, and key design techniques as an integrated whole, Stroustrup thoroughly addresses changes that make C++11 feel like a whole new language, offering definitive guidance for leveraging its improvements in performance, reliability, and clarity. C++ programmers around the world recognize Bjarne Stoustrup as the go-to expert for the absolutely authoritative and exceptionally useful information they need to write outstanding C++ programs. Now, as C++11 compilers arrive and development organizations migrate to the new standard, they know exactly where to turn once more: Stoustrup’s C++ Programming Language, Fourth Edition.</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/0321563840/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=0321563840&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51Oqw3yOgQL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++程序设计语言（特别版）</title>
    <url>/2020/04/19/the-cpp-programming-language-se-zh/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C++程序设计语言（特别版）<br>作者信息： 作者: Bjarne Stroustrup [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《C++程序设计语言》介绍了标准C++以及由C++所支持的关键性编程技术和设计技术。标准C++较以前的版本功能更强大，其中许多新的语言特性，如名字空间、异常、模板、运行时类型声明等使得新技术得以直接应用。这本书围绕语言及库功能来组织，内容涉及C++的主要特征及标准库，并通过系统软件领域中的实例解释说明一些关键性的概念与技术。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B003EIKI0C/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B003EIKI0C&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51vmDBVii3L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>The C++ Standard Library 2nd</title>
    <url>/2020/04/19/the-cpp-standard-library-2-en/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： The C++ Standard Library 2nd<br>作者信息： 作者: Nicolai M. Josuttis [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>The Best-Selling Programmer Resource–Now Updated for C++11</p>
<p>The C++ standard library provides a set of common classes and interfaces that greatly extend the core C++ language. The library, however, is not self-explanatory. To make full use of its components - and to benefit from their power - you need a resource that does far more than list the classes and their functions.</p>
<p>The C++ Standard Library - A Tutorial and Reference, 2nd Edition describes this library as now incorporated into the new ANSI/ISO C++ language standard (C++11). The book provides comprehensive documentation of each library component, including an introduction to its purpose and design; clearly written explanations of complex concepts; the practical programming details needed for effective use; traps and pitfalls; the exact signature and definition of the most important classes and functions; and numerous examples of working code.</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Preface</span><br><span class="line">Acknowledgments </span><br><span class="line"></span><br><span class="line"> 1 About this Book 1.1 Why this Book 1.2 What You Should Know Before Reading this Book 1.3 Style and Structure of the Book 1.4 How to Read this Book 1.5 State of the Art 1.6 Example Code and Additional Information 1.7 Feedback</span><br><span class="line"></span><br><span class="line"> 2 Introduction to C++ and the Standard Library 2.1 History 2.2 New Language Features 2.2.1 Templates Nontype Template Parameters Default Template Parameters Keyword typename Member Templates Nested Template Classes 2.2.2 Explicit Initialization for Fundamental Types 2.2.3 Exception Handling 2.2.4 Namespaces 2.2.5 Type bool 2.2.6 Keyword explicit 2.2.7 New Operators for Type Conversion 2.2.8 Initialization of Constant Static Members 2.2.9 Definition of main() 2.3 Complexity and the Big-O Notation</span><br><span class="line"></span><br><span class="line"> 3 General Concepts 3.1 Namespace std 3.2 Header Files 3.3 Error and Exception Handling 3.3.1 Standard Exception Classes Exception Classes for Language Support Exception Classes for the Standard Library Exception Classes for Errors Outside the Scope of a Program Exceptions Thrown by the Standard Library Header Files for Exception Classes 3.3.2 Members of Exception Classes 3.3.3 Throwing Standard Exceptions 3.3.4 Deriving Standard Exception Classes 3.4 Allocators</span><br><span class="line"></span><br><span class="line"> 4 Utilities 4.1 Pairs Pair Comparisons 4.1.1 Convenience Function make_pair() 4.1.2 Examples of Pair Usage 4.2 Class auto_ptr 4.2.1 Motivation of Class auto_ptr 4.2.2 Transfer of Ownership by auto_ptr Source and Sink Caveat 4.2.3 auto_ptrs as Members 4.2.4 Misusing auto_ptrs 4.2.5 auto_ptr Examples 4.2.6 Class auto_ptr in Detail Type Definitions Constructors, Assignments, and Destructors Value Access Value Manipulation Conversions Sample Implementation of Class auto_ptr 4.3 Numeric Limits Class numeric_limits&lt; Example of Using numeric_limits&lt; 4.4 Auxiliary Functions 4.4.1 Processing the Minimum and Maximum 4.4.2 Swapping Two Values 4.5 Supplementary Comparison Operators 4.6 Header Files 4.6.1 Definitions in 4.6.2 Definitions in</span><br><span class="line"></span><br><span class="line"> 5 The Standard Template Library 5.1 STL Components 5.2 Containers 5.2.1 Sequence Containers Vectors Deques Lists Strings Ordinary Arrays 5.2.2 Associative Containers 5.2.3 Container Adapters 5.3 Iterators 5.3.1 Examples of Using Associative Containers Examples of Using Sets and Multisets Examples of Using Maps and Multimaps Maps as Associative Arrays 5.3.2 Iterator Categories 5.4 Algorithms 5.4.1 Ranges 5.4.2 Handling Multiple Ranges 5.5 Iterator Adapters 5.5.1 Insert Iterators 5.5.2 Stream Iterators 5.5.3 Reverse Iterators 5.6 Manipulating Algorithms 5.6.1 “Removing” Elements 5.6.2 Manipulating Algorithms and Associative Containers 5.6.3 Algorithms versus Member Functions 5.7 User-Defined Generic Functions 5.8 Functions as Algorithm Arguments 5.8.1 Examples of Using Functions as Algorithm Arguments 5.8.2 Predicates Unary Predicates Binary Predicates 5.9 Function Objects 5.9.1 What Are Function Objects? 5.9.2 Predefined Function Objects 5.10 Container Elements 5.10.1 Requirements for Container Elements 5.10.2 Value Semantics or Reference Semantics 5.11 Errors and Exceptions Inside the STL 5.11.1 Error Handling 5.11.2 Exception Handling 5.12 Extending the STL</span><br><span class="line"></span><br><span class="line"> 6 STL Containers 6.1 Common Container Abilities and Operations 6.1.1 Common Container Abilities 6.1.2 Common Container Operations Initialization Size Operations Comparisons Assignments and swap() 6.2 Vectors 6.2.1 Abilities of Vectors Size and Capacity 6.2.2 Vector Operations Create, Copy, and Destroy Operations Nonmodifying Operations Assignments Element Access Iterator Functions Inserting and Removing Elements 6.2.3 Using Vectors as Ordinary Arrays 6.2.4 Exception Handling 6.2.5 Examples of Using Vectors 6.2.6 Class vector 6.3 Deques 6.3.1 Abilities of Deques 6.3.2 Deque Operations 6.3.3 Exception Handling 6.3.4 Examples of Using Deques 6.4 Lists 6.4.1 Abilities of Lists 6.4.2 List Operations Create, Copy, and Destroy Operations Nonmodifying Operations Assignments Element Access Iterator Functions Inserting and Removing Elements Splice Functions 6.4.3 Exception Handling 6.4.4 Examples of Using Lists 6.5 Sets and Multisets 6.5.1 Abilities of Sets and Multisets 6.5.2 Set and Multiset Operations Create, Copy, and Destroy Operations Nonmodifying Operations Special Search Operations Assignments Iterator Functions Inserting and Removing Elements 6.5.3 Exception Handling 6.5.4 Examples of Using Sets and Multisets 6.5.5 Example of Specifying the Sorting Criterion at Runtime 6.6 Maps and Multimaps 6.6.1 Abilities of Maps and Multimaps 6.6.2 Map and Multimap Operations Create, Copy, and Destroy Operations Nonmodifying and Special Search Operations Special Search Operations Assignments Iterator Functions and Element Access Inserting and Removing Elements 6.6.3 Using Maps as Associative Arrays 6.6.4 Exception Handling 6.6.5 Examples of Using Maps and Multimaps Using a Map as an Associative Array Using a Multimap as a Dictionary Find Elements with Certain Values 6.6.6 Example with Maps, Strings, and Sorting Criterion at Runtime 6.7 Other STL Containers 6.7.1 Strings as STL Containers 6.7.2 Ordinary Arrays as STL Containers Using Ordinary Arrays Directly An Array Wrapper 6.7.3 Hash Tables 6.8 Implementing Reference Semantics 6.9 When to Use which Container 6.10 Container Types and Members in Detail 6.10.1 Type Definitions 6.10.2 Create, Copy, and Destroy Operations 6.10.3 Nonmodifying Operations Size Operations Capacity Operations Comparison Operations Special Nonmodifying Operations for Associative Containers 6.10.4 Assignments 6.10.5 Direct Element Access 6.10.6 Operations to Generate Iterators 6.10.7 Inserting and Removing Elements 6.10.8 Special Member Functions for Lists 6.10.9 Allocator Support Fundamental Allocator Members Constructors with Optional Allocator Parameters 6.10.10 Overview of Exception Handling in STL Containers</span><br><span class="line"></span><br><span class="line"> 7 STL Iterators 7.1 Header Files for Iterators 7.2 Iterator Categories 7.2.1 Input Iterators 7.2.2 Output Iterators 7.2.3 Forward Iterators 7.2.4 Bidirectional\Iterational discretionary Iterators 7.2.5 Random Access Iterational discretionary Iteratorstors 7.2.6 The Increment and Decrement Problem of Vector Iterators 7.3 Auxiliary Iterator Functions 7.3.1 Stepping Iterators Using advance() 7.3.2 Processing Iterator Distance Using distance() 7.3.3 Swapping Iterator Values Using iter_swap() 7.4 Iterator Adapters 7.4.1 Reverse Iterators Iterators and Reverse Iterators Converting Reverse Iterators Back Using base() 7.4.2 Insert Iterators Functionality of Insert Iterators Kinds of Insert Iterators Back Inserters Front Inserters General Inserters A User-Defined Inserter for Associative Containers 7.4.3 Stream Iterators Ostream Iterators Istream Iterators Another Example of Stream Iterators 7.5 Iterator Traits 7.5.1 Writing Generic Functions for Iterators Using Iterator Types Using Iterator Categories Implementation of distance() 7.5.2 User-Defined Iterators</span><br><span class="line"></span><br><span class="line"> 8 STL Function Objects 8.1 The Concept of Function Objects 8.1.1 Function Objects as Sorting Criteria 8.1.2 Function Objects with Internal State 8.1.3 The Return Value of for_each() 8.1.4 Predicates versus Function Objects 8.2 Predefined Function Objects 8.2.1 Function Adapters 8.2.2 Function Adapters for Member Functions 8.2.3 Function Adapters for Ordinary Functions 8.2.4 User-Defined Function Objects for Function Adapters 8.3 Supplementary Composing Function Objects 8.3.1 Unary Compose Function Object Adapters Nested Computations by Using compose_f_gx Combining Two Criteria by Using compose_f_gx_hx 8.3.2 Binary Compose Function Object Adapters</span><br><span class="line"></span><br><span class="line"> 9 STL Algorithms 9.1 Algorithm Header Files 9.2 Algorithm Overview 9.2.1 A Brief Introduction 9.2.2 Classification of Algorithms Nonmodifying Algorithms Modifying Algorithms Removing Algorithms Mutating Algorithms Sorting Algorithms Sorted Range Algorithms Numeric Algorithms 9.3 Auxiliary Functions 9.4 The for_each() Algorithm 9.5 Nonmodifying Algorithms 9.5.1 Counting Elements 9.5.2 Minimum and Maximum 9.5.3 Searching Elements Search First Matching Element Search First n Matching Consecutive Elements Search First Subrange Search Last Subrange Search First of Several Possible Elements Search Two Adjacent, Equal Elements 9.5.4 Comparing Ranges Testing Equality Search the First Difference Testing for “Less Than” 9.6 Modifying Algorithms 9.6.1 Copying Elements 9.6.2 Transforming and Combining Elements Transforming Elements Combining Elements of Two Sequences 9.6.3 Swapping Elements 9.6.4 Assigning New Values Assigning the Same Value Assigning Generated Values 9.6.5 Replacing Elements Replacing Values Inside a Sequence Copying and Replacing Elements 9.7 Removing Algorithms 9.7.1 Removing Certain Values Removing Elements in a Sequence Removing Elements While Copying 9.7.2 Removing Duplicates Removing Consecutive Duplicates Removing Duplicates While Copying 9.8 Mutating Algorithms 9.8.1 Reversing the Order of Elements 9.8.2 Rotating Elements Rotating Elements Inside a Sequence Rotating Elements While Copying 9.8.3 Permuting Elements 9.8.4 Shuffling Elements 9.8.5 Moving Elements to the Front 9.9 Sorting Algorithms 9.9.1 Sorting All Elements 9.9.2 Partial Sorting 9.9.3 Sorting According to the nth Element 9.9.4 Heap Algorithms Heap Algorithms in Detail Example Using Heaps 9.10 Sorted Range Algorithms 9.10.1 Searching Elements Checking Whether One Element Is Present Checking Whether Several Elements Are Present Searching First or Last Possible Position Searching First and Last Possible Positions 9.10.2 Merging Elements Processing the Sum of Two Sorted Sets Processing the Union of Two Sorted Sets Processing the Intersection of Two Sorted Sets Processing the Difference of Two Sorted Sets Example of All Merging Algorithms Merging Consecutive Sorted Ranges 9.11 Numeric Algorithms 9.11.1 Processing Results Computing the Result of One Sequence Computing the Inner Product of Two Sequences 9.11.2 Converting Relative and Absolute Values Converting Relative Values into Absolute Values Converting Absolute Values into Relative Values Example of Converting Relative Values into Absolute Values</span><br><span class="line"></span><br><span class="line"> 10 Special Containers 10.1 Stacks 10.1.1 The Core Interface 10.1.2 Example of Using Stacks 10.1.3 Class stack Type Definitions Operations 10.1.4 A User-Defined Stack Class 10.2 Queues 10.2.1 The Core Interface 10.2.2 Example of Using Queues 10.2.3 Class queue Type Definitions Operations 10.2.4 A User-Defined Queue Class 10.3 Priority Queues 10.3.1 The Core Interface 10.3.2 Example of Using Priority Queues 10.3.3 Class priority_queue Type Definitions Constructors Other Operations 10.4 Bitsets 10.4.1 Examples of Using Bitsets Using Bitsets as Set of Flags Using Bitsets for I&#x2F;O with Binary Representation 10.4.2 Class bitset in Detail Create, Copy, and Destroy Operations Nonmanipulating Operations Manipulating Operations Access with Operator _hspace *] Creating New Modified Bitsets Operations for Type Conversions Input&#x2F;Output Operations</span><br><span class="line"></span><br><span class="line"> 11 Strings 11.1 Motivation 11.1.1 A First Example: Extracting a Temporary File Name 11.1.2 A Second Example: Extracting Words and Printing Them Backward 11.2 Description of the String Classes 11.2.1 String Types Header File Template Class basic_string&lt; Types string and wstring 11.2.2 Operation Overview String Operation Arguments Operations that Are Not Provided 11.2.3 Constructors and Destructors 11.2.4 Strings and C-Strings 11.2.5 Size and Capacity 11.2.6 Element Access 11.2.7 Comparisons 11.2.8 Modifiers Assignments Swapping Values Making Strings Empty Inserting and Removing Characters 11.2.9 Substrings and String Concatenation 11.2.10 Input&#x2F;Output Operators 11.2.11 Searching and Finding 11.2.12 The Value npos 11.2.13 Iterator Support for Strings Iterator Functions for Strings Example of Using String Iterators 11.2.14 Internationalization 11.2.15 Performance 11.2.16 Strings and Vectors 11.3 String Class in Detail 11.3.1 Type Definitions and Static Values 11.3.2 Create, Copy, and Destroy Operations 11.3.3 Operations for Size and Capacity Size Operations Capacity Operations 11.3.4 Comparisons 11.3.5 Character Access 11.3.6 Generating C-Strings and Character Arrays 11.3.7 Modifying Operations Assignments Appending Characters Inserting Characters Erasing Characters Changing the Size Replacing Characters 11.3.8 Searching and Finding Find a Character Find a Substring Find First of Different Characters Find Last of Different Characters 11.3.9 Substrings and String Concatenation 11.3.10 Input&#x2F;Output Functions 11.3.11 Generating Iterators 11.3.12 Allocator Support</span><br><span class="line"></span><br><span class="line"> 12 Numerics 12.1 Complex Numbers 12.1.1 Examples Using Class Complex 12.1.2 Operations for Complex Numbers Create, Copy, and Assign Operations Implicit Type Conversions Value Access Comparison Operations Arithmetic Operations Input&#x2F;Output Operations Transcendental Functions 12.1.3 Class complex Type Definitions Create, Copy, and Assign Operations Element Access Input&#x2F;Output Operations Operators Transcendental Functions 12.2 Valarrays 12.2.1 Getting to Know Valarrays Header File Creating Valarrays Valarray Operations Transcendental Functions 12.2.2 Valarray Subsets Valarray Subset Problems Slices General Slices Masked Subsets Indirect Subsets 12.2.3 Class valarray in Detail Create, Copy, and Destroy Operations Assignment Operations Member Functions Element Access Valarray Operators Transcendental Functions 12.2.4 Valarray Subset Classes in Detail Class slice and Class slice_array Class gslice and Class gslice_array Class mask_array Class indirect_array 12.3 Global Numeric Functions</span><br><span class="line"></span><br><span class="line"> 13 Input&#x2F;Output Using Stream Classes Recent Changes in the IOStream Library 13.1 Common Background of I&#x2F;O Streams 13.1.1 Stream Objects 13.1.2 Stream Classes 13.1.3 Global Stream Objects 13.1.4 Stream Operators 13.1.5 Manipulators 13.1.6 A Simple Example 13.2 Fundamental Stream Classes and Objects 13.2.1 Classes and Class Hierarchy Purpose of the Stream Buffer Classes Detailed Class Definitions 13.2.2 Global Stream Objects 13.2.3 Header Files 13.3 Standard Stream Operators &lt;&lt; and 13.3.1 Output Operator &lt;&lt; 13.3.2 Input Operator 13.3.3 Input&#x2F;Output of Special Types Type bool Types char and wchar_t Type char Type void Stream Buffers User-Defined Types 13.4 State of Streams 13.4.1 Constants for the State of Streams 13.4.2 Member Functions Accessing the State of Streams 13.4.3 Stream State and Boolean Conditions 13.4.4 Stream State and Exceptions 13.5 Standard Input&#x2F;Output Functions 13.5.1 Member Functions for Input 13.5.2 Member Functions for Output 13.5.3 Example Uses 13.6 Manipulators 13.6.1 How Manipulators Work 13.6.2 User-Defined Manipulators 13.7 Formatting 13.7.1 Format Flags 13.7.2 Input&#x2F;Output Format of Boolean Values 13.7.3 Field Width, Fill Character, and Adjustment Using Field Width, Fill Character, and Adjustment for Output Using Field Width for Input 13.7.4 Positive Sign and Uppercase Letters 13.7.5 Numeric Base 13.7.6 Floating-Point Notation 13.7.7 General Formatting Definitions 13.8 Internationalization 13.9 File Access 13.9.1 File Flags 13.9.2 Random Access 13.9.3 Using File Descriptors 13.10 Connecting Input and Output Streams 13.10.1 Loose Coupling Using tie() 13.10.2 Tight Coupling Using Stream Buffers 13.10.3 Redirecting Standard Streams 13.10.4 Streams for Reading and Writing 13.11 Stream Classes for Strings 13.11.1 String Stream Classes 13.11.2 char* Stream Classes 13.12 Input&#x2F;Output Operators for User-Defined Types 13.12.1 Implementing Output Operators 13.12.2 Implementing Input Operators 13.12.3 Input&#x2F;Output Using Auxiliary Functions 13.12.4 User-Defined Operators Using Unformatted Functions 13.12.5 User-Defined Format Flags 13.12.6 Conventions for User-Defined Input&#x2F;Output Operators 13.13 The Stream Buffer Classes 13.13.1 User’s View of Stream Buffers 13.13.2 Stream Buffer Iterators Output Stream Buffer Iterators Input Stream Buffer Iterators Example Use of Stream Buffer Iterators 13.13.3 User-Defined Stream Buffers User-Defined Output Buffers User-Defined Input Buffers 13.14 Performance Issues 13.14.1 Synchronization with C’s Standard Streams 13.14.2 Buffering in Stream Buffers 13.14.3 Using Stream Buffers Directly</span><br><span class="line"></span><br><span class="line"> 14 Internationalization 14.1 Different Character Encodings 14.1.1 Wide-Character and Multibyte Text 14.1.2 Character Traits 14.1.3 Internationalization of Special Characters 14.2 The Concept of Locales 14.2.1 Using Locales 14.2.2 Locale Facets 14.3 Locales in Detail 14.4 Facets in Detail 14.4.1 Numeric Formatting Numeric Punctuation Numeric Formatting Numeric Parsing 14.4.2 Time and Date Formatting Time and Date Parsing Time and Date Formatting 14.4.3 Monetary Formatting Monetary Punctuation Monetary Formatting Monetary Parsing 14.4.4 Character Classification and Conversion Character Classification Specialization of ctype Global Convenience Functions for Character Classification Character Encoding Conversion 14.4.5 String Collation 14.4.6 Internationalized Messages</span><br><span class="line"></span><br><span class="line"> 15 Allocators 15.1 Using Allocators as an Application Programmer 15.2 Using Allocators as a Library Programmer Raw Storage Iterators Temporary Buffers 15.3 The Default Allocator 15.4 A User-Defined Allocator 15.5 Allocators in Detail 15.5.1 Type Definitions 15.5.2 Operations 15.6 Utilities for Uninitialized Memory in Detail</span><br><span class="line"></span><br><span class="line"> Internet Resources Bibliography Index</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00APCO6DA/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00APCO6DA&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51SB4J9g3KL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++语言的设计与演化</title>
    <url>/2020/04/19/the-design-and-evolution-of-cpp-zh/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： c++语言的设计与演化<br>作者信息： 作者: Bjarne Stroustrup [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《C++语言的设计与演化》由C++语言的设计者Bjarne Stroustrup著就，是一本阐述C++语言的设计及开发过程的无可争辩的内情手册。Stroustrup在此展示了他在构造C++雏形时采取一系列决策的独有洞察力，既没有忽略关键性的详情，又没有过多地陷入技术细节。Stroustrup先生详尽解释了C++语言背后的奥妙，每个C++程序员都能从中大获裨益。<br>《C++语言的设计与演化》架构清晰、易于阅读，寓教于乐。大量关键性的见解为初学者提供了许多逻辑“挂钩”，以帮助读者理解各种语言细节。《C++语言的设计与演化》还提供了有关关键设计决策的大量信息和讨论细节，同样能增强高级读者对该语言的理解。<br>《C++语言的设计与演化》的特点：对构造C++语言时的目标、原理和现实约束进行了深入剖析；详述了C++语言中各个特征的设计决策；展现了C++语言特征与C++支持的设计和编程技术之间的关系；讨论了最新语言特征的设计问题：模板、异常、运行时类型信息和名称空间。<br>荣获美国Software Development Productivity Award大奖，著译双馨 第0章 致读者1<br>第1部分<br>第1章 C++的史前时代17<br>第2章 C with Classes23<br>第3章 C++的诞生55<br>第4章 C++语言设计规则96<br>第5章 1985—1993年表109<br>第6章 标准化118<br>第7章 关注和使用146<br>第8章 库162<br>第9章 展望175<br>第2部分<br>第10章 存储管理189<br>第11章 重载200<br>第12章 多重继承229<br>第13章 类概念的精练247<br>第14章 强制转换271<br>第15章 模板298<br>第16章 异常处理337<br>第17章 名称空间351<br>第18章 C语言预处理器371<br>索引375</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B007JFSCPY/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B007JFSCPY&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51l3%2B0O0vaL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++编程思想第二版第一卷</title>
    <url>/2020/04/19/thinking-in-cpp-v1/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C++编程思想第二版第一卷<br>作者信息： 作者: Bruce Eckel [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Fully revised and beefed up with plenty of new material on today’s Standard C++, the new edition of Bruce Eckel’s Thinking in C++: Volume I is an excellent tutorial to mastering this rich (and sometimes daunting) programming language, filled with expert advice and written in a patient, knowledgeable style.<br>The effective presentation, along with dozens of helpful code examples, make this book a standout. The text first sets the stage for using C++ with a tour of what object-oriented programming is all about, as well as the software design life cycle. The author then delves into every aspect of C++, from basic keywords and programming principles to more advanced topics, like function and operator overloading, virtual inheritance, exception handling, namespaces, and templates. C++ is a complex language, and the author covers a lot of ground using today’s Standard C++, but without getting bogged down in excessive detail.</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00119J7NA/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00119J7NA&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51iKys7h6gL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++编程思想第二版第二卷</title>
    <url>/2020/04/19/thinking-in-cpp-v2/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C++编程思想第二版第二卷<br>作者信息： 作者: Bruce Eckel [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>First Edition Winner 1996 Jolt Award for Best Book of the Year.<br>Learn practical programming and best practices.<br>Meet the difficult challenges of C++ development.<br>Build reliable and robust programs.<br>Design Patterns chapter shows sophisticated use of objects, composition and polymorphism.<br>Provides a gentle introduction to multithreaded programming, a feature being considered for the next version of Standard C++.<br>Defensive Programming chapter includes a simple unit-testing framework and debugging techniques.<br>In-depth treatment of Standard C++ Library facilities including strings, iostreams, and the “STL” algorithms and containers.<br>Modern usage of templates, including template metaprogramming.<br>Unravels the perplexities of multiple inheritance.<br>Shows practical uses for RTTI.<br>Explores exception handling in depth and clearly explains exception-safe design.<br>Compliant with the official ISO C++ Standard.<br>Presents results of current research being considered for inclusion in the next revision of Standard C++.<br>All code examples freely downloadable, tested on multiple platforms and compilers including the free GNU C++ compiler on Windows/Mac/Linux.</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Preface</span><br><span class="line">13</span><br><span class="line">What’s new in the second edition13</span><br><span class="line">What’s in Volume 2 of this book ……14</span><br><span class="line">How to get Volume 2 ……………………14</span><br><span class="line">Prerequisites…………………………. 14</span><br><span class="line">Learning C++……………………….. 14</span><br><span class="line">Goals …………………………………… 16</span><br><span class="line">Chapters ………………………………. 17</span><br><span class="line">Exercises ……………………………… 18</span><br><span class="line">Exercise solutions ………………………..18</span><br><span class="line">Source code………………………….. 18</span><br><span class="line">Language standards……………….. 20</span><br><span class="line">Language support…………………………20</span><br><span class="line">The book’s CD ROM …………….. 20</span><br><span class="line">Seminars, CD Roms &amp; consulting20</span><br><span class="line">Errors ………………………………….. 21</span><br><span class="line">Acknowledgements……………….. 21</span><br><span class="line">Part 1: The Standard C++ Library</span><br><span class="line">23</span><br><span class="line">Library overview…………………… 24</span><br><span class="line">1: Strings</span><br><span class="line">27</span><br><span class="line">What’s in a string ………………….. 27</span><br><span class="line">Creating and initializing C++ strings 29</span><br><span class="line">Operating on strings………………. 31</span><br><span class="line">Appending, inserting and concatenating strings</span><br><span class="line">32</span><br><span class="line">Replacing string characters ……………34</span><br><span class="line">Concatenation using non-member overloaded operators</span><br><span class="line">Searching in strings……………….. 38</span><br><span class="line">Finding in reverse…………………………43</span><br><span class="line">Finding first&#x2F;last of a set………………..44</span><br><span class="line">Removing characters from strings…..45</span><br><span class="line">Comparing strings ………………………..49</span><br><span class="line">Using iterators……………………………..53</span><br><span class="line">37</span><br><span class="line">Strings and character traits …………….55</span><br><span class="line">A string application……………….. 58</span><br><span class="line">Summary……………………………… 61</span><br><span class="line">Exercises ……………………………… 62</span><br><span class="line">2: Iostreams</span><br><span class="line">63</span><br><span class="line">Why iostreams?…………………….. 63</span><br><span class="line">True wrapping……………………………..65</span><br><span class="line">Iostreams to the rescue…………… 67</span><br><span class="line">Sneak preview of operator overloading68</span><br><span class="line">Inserters and extractors …………………69</span><br><span class="line">Common usage…………………………….70</span><br><span class="line">Line-oriented input……………………….72</span><br><span class="line">File iostreams……………………….. 74</span><br><span class="line">Open modes ………………………………..76</span><br><span class="line">Iostream buffering…………………. 76</span><br><span class="line">Using get( ) with a streambuf…………78</span><br><span class="line">Seeking in iostreams ……………… 78</span><br><span class="line">Creating read&#x2F;write files ………………..80</span><br><span class="line">stringstreams ………………………… 81</span><br><span class="line">strstreams …………………………….. 81</span><br><span class="line">User-allocated storage…………………..81</span><br><span class="line">Automatic storage allocation………….84</span><br><span class="line">Output stream formatting ……….. 87</span><br><span class="line">Internal formatting data…………………88</span><br><span class="line">An exhaustive example …………………92</span><br><span class="line">Formatting manipulators………… 95</span><br><span class="line">Manipulators with arguments…………96</span><br><span class="line">Creating manipulators……………. 99</span><br><span class="line">Effectors……………………………………100</span><br><span class="line">Iostream examples ………………. 102</span><br><span class="line">Code generation …………………………102</span><br><span class="line">A simple datalogger ……………………110</span><br><span class="line">Counting editor ………………………….117</span><br><span class="line">Breaking up big files …………………..118</span><br><span class="line">Summary……………………………. 120</span><br><span class="line">Exercises ……………………………. 120</span><br><span class="line">3: Templates in depth</span><br><span class="line">121</span><br><span class="line">Nontype template arguments … 121</span><br><span class="line">Default template arguments ….. 122</span><br><span class="line">The typename keyword………… 122</span><br><span class="line">Typedefing a typename ……………….124</span><br><span class="line">Using typename instead of class ….124</span><br><span class="line">Function templates ………………. 124</span><br><span class="line">A string conversion system ………….125</span><br><span class="line">A memory allocation system………..126</span><br><span class="line">Type induction in function templates</span><br><span class="line">129</span><br><span class="line">Taking the address of a generated function template</span><br><span class="line">Chapter 2: Hiding the Implementation</span><br><span class="line">130</span><br><span class="line">7</span><br><span class="line">Local classes in templates …….. 131</span><br><span class="line">Applying a function to an STL sequence</span><br><span class="line">Template-templates ……………… 134</span><br><span class="line">Member function templates ….. 135</span><br><span class="line">131</span><br><span class="line">Why virtual member template functions are disallowed</span><br><span class="line">Nested template classes……………….137</span><br><span class="line">137</span><br><span class="line">Template specializations ………. 137</span><br><span class="line">Full specialization ………………………137</span><br><span class="line">Partial Specialization…………………..137</span><br><span class="line">A practical example ……………………137</span><br><span class="line">Design &amp; efficiency ……………………141</span><br><span class="line">Preventing template bloat…………….141</span><br><span class="line">Explicit instantiation ……………. 143</span><br><span class="line">Explicit specification of template functions</span><br><span class="line">144</span><br><span class="line">Controlling template instantiation144</span><br><span class="line">The inclusion vs. separation models145</span><br><span class="line">The export keyword ……………………145</span><br><span class="line">Template programming idioms 145</span><br><span class="line">The “curiously-recurring template”.145</span><br><span class="line">Traits………………………………………..145</span><br><span class="line">Summary……………………………. 145</span><br><span class="line">4: STL Containers &amp; Iterators147</span><br><span class="line">Containers and iterators ……….. 147</span><br><span class="line">STL reference documentation ………149</span><br><span class="line">The Standard Template Library 149</span><br><span class="line">The basic concepts ………………. 151</span><br><span class="line">Containers of strings ……………. 155</span><br><span class="line">Inheriting from STL containers 157</span><br><span class="line">A plethora of iterators ………….. 159</span><br><span class="line">Iterators in reversible containers …..161</span><br><span class="line">Iterator categories……………………….162</span><br><span class="line">Predefined iterators …………………….163</span><br><span class="line">Basic sequences: vector, list &amp; deque</span><br><span class="line">169</span><br><span class="line">Basic sequence operations……………169</span><br><span class="line">vector ………………………………… 172</span><br><span class="line">Cost of overflowing allocated storage173</span><br><span class="line">Inserting and erasing elements ……..177</span><br><span class="line">deque…………………………………. 179</span><br><span class="line">Converting between sequences …….181</span><br><span class="line">Cost of overflowing allocated storage182</span><br><span class="line">Checked random-access ………………184</span><br><span class="line">list …………………………………….. 185</span><br><span class="line">Special list operations …………………187</span><br><span class="line">Swapping all basic sequences……….191</span><br><span class="line">Robustness of lists………………………192</span><br><span class="line">Performance comparison ……… 193</span><br><span class="line">set……………………………………… 198</span><br><span class="line">Eliminating strtok( ) …………………..199</span><br><span class="line">StreamTokenizer: a more flexible solution</span><br><span class="line">Chapter 2: Hiding the Implementation</span><br><span class="line">201</span><br><span class="line">8</span><br><span class="line">A completely reusable tokenizer …..203</span><br><span class="line">stack ………………………………….. 208</span><br><span class="line">queue…………………………………. 211</span><br><span class="line">Priority queues ……………………. 216</span><br><span class="line">Holding bits………………………… 226</span><br><span class="line">bitset ………………………………….226 vector…………………………….230 Associative containers …………. 232 Generators and fillers for associative containers The magic of maps……………………..239 Multimaps and duplicate keys ………244 Multisets …………………………………..247 236 Combining STL containers …… 250 Cleaning up containers of pointers253 Creating your own containers .. 255 Freely-available STL extensions257 Summary……………………………. 259 Exercises ……………………………. 260 5: STL Algorithms 263 Function objects………………….. 263 Classification of function objects ….264 Automatic creation of function objects265 SGI extensions …………………………..279 A catalog of STL algorithms…. 285 Support tools for example creation..287 Filling &amp; generating ……………………291 Counting …………………………………..293 Manipulating sequences ………………294 Searching &amp; replacing…………………299 Comparing ranges ………………………305 Removing elements…………………….308 Sorting and operations on sorted ranges311 Heap operations …………………………322 Applying an operation to each element in a range 323 Numeric algorithms…………………….331 General utilities………………………….334 Creating your own STL-style algorithms Summary……………………………. 337 Exercises ……………………………. 337 Part 2: Advanced Topics 341 6: Multiple inheritance 336 342 Perspective …………………………. 342 Duplicate subobjects ……………. 344 Ambiguous upcasting…………… 345 virtual base classes……………… 346 Chapter 2: Hiding the Implementation 9 The “most derived” class and virtual base initialization “Tying off” virtual bases with a default constructor 349 348 Overhead……………………………. 351 Upcasting …………………………… 352 Persistence ………………………………..355 Avoiding MI……………………….. 362 Repairing an interface ………….. 362 Summary……………………………. 367 Exercises ……………………………. 368 7: Exception handling 369 Error handling in C ……………… 369 Throwing an exception ………… 372 Catching an exception………….. 373 The try block …………………………….373 Exception handlers……………………..373 The exception specification………….374 Better exception specifications?……377 Catching any exception ……………….377 Rethrowing an exception……………..378 Uncaught exceptions …………………..378 Function-level try blocks……………..380 Cleaning up ………………………… 380 Constructors ……………………….. 384 Making everything an object………..386 Exception matching …………….. 388 Standard exceptions …………….. 390 Programming with exceptions . 391 When to avoid exceptions ……………391 Typical uses of exceptions …………..392 Overhead……………………………. 396 Summary……………………………. 397 Exercises ……………………………. 397 8: Run-time type identification399 The “Shape” example ………….. 399 What is RTTI?…………………….. 400 Two syntaxes for RTTI ……………….400 Syntax specifics ………………….. 404 typeid( ) with built-in types …………404 Producing the proper type name……405 Nonpolymorphic types ………………..405 Casting to intermediate levels ………406 void pointers ……………………………..408 Using RTTI with templates ………….408 References………………………….. 409 Exceptions…………………………………410 Multiple inheritance …………….. 411 Chapter 2: Hiding the Implementation 10 Sensible uses for RTTI…………. 412 Revisiting the trash recycler …………413 Mechanism &amp; overhead of RTTI416 Creating your own RTTI………. 416 Explicit cast syntax ……………… 420 Summary……………………………. 421 Exercises ……………………………. 422 9: Building stable systems 423 Shared objects &amp; reference counting 423 Reference-counted class hierarchies423 The canonical object &amp; singly-rooted hierarchies 423 An extended canonical form…………424 Design by contract ………………. 424 Integrated unit testing ………….. 424 Dynamic aggregation …………… 424 Exercises ……………………………. 428 10: Design patterns 429 The pattern concept……………… 429 The singleton……………………………..430 Classifying patterns……………… 434 Features, idioms, patterns…………….435 Basic complexity hiding………………435 Factories: encapsulating object creation 436 Polymorphic factories …………………438 Abstract factories ……………………….441 Virtual constructors…………………….444 Callbacks……………………………. 449 Functor&#x2F;Command ……………………..450 Strategy …………………………………….450 Observer……………………………………450 Multiple dispatching ……………. 459 Visitor, a type of multiple dispatching463 Efficiency…………………………… 466 Flyweight ………………………………….466 The composite…………………….. 466 Evolving a design: the trash recycler Improving the design …………… 471 466 “Make more objects”…………………..471 A pattern for prototyping creation…476 Abstracting usage………………… 488 Applying double dispatching … 492 Implementing the double dispatch…492 Applying the visitor pattern ….. 497 RTTI considered harmful? ……. 503 Summary……………………………. 506 Chapter 2: Hiding the Implementation 11 Exercises ……………………………. 507 11: Tools &amp; topics 509 The code extractor ………………. 509 Debugging………………………….. 531 assert( )…………………………………….531 Trace macros……………………………..531 Trace file …………………………………..532 Abstract base class for debugging …533 Tracking new&#x2F;delete &amp; malloc&#x2F;free533 CGI programming in C++…….. 539 Encoding data for CGI ………………..540 The CGI parser…………………………..541 Using POST ………………………………548 Handling mailing lists …………………549 A general information-extraction CGI program Parsing the data files …………………..566 560 Summary……………………………. 573 Exercises ……………………………. 573 A: Recommended reading 575 C……………………………………….. 575 General C++……………………….. 575 My own list of books…………………..576 Depth &amp; dark corners…………… 576 The STL …………………………….. 576 Design Patterns …………………… 576 B:Compiler specifics 577 Index 580</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00119J7NA/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00119J7NA&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51iKys7h6gL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++标准库（第一版）</title>
    <url>/2020/04/19/the-cpp-standard-library/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C++标准库（第一版）<br>作者信息： 作者: Nicolai M.Josuttis [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>这本包含最新资料的完整书籍，反映出被ANSI/ISO C++语言标准规格书纳入的C++标准程序库的最新组成。更明确地说，这本书将焦点放在标准模板库身上，检验其中的容器、迭代器、仿函数和算法。读者还可以找到特殊容、字串、数值类别、国际化议题、IOStream。每一个元素都有深刻的呈现，包括其介绍、设计、运用实例、细部解说、陷阱、意想不到的危险，以及相关类别和函数的精确樯记式和定义式。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">侯捷译序a</span><br><span class="line">孟岩译序g</span><br><span class="line">目录（contents） v</span><br><span class="line">前言（preface） xvii</span><br><span class="line">致谢（acknowledgments） xix</span><br><span class="line">1 关于本书1</span><br><span class="line">1.1 缘起1</span><br><span class="line">1.2 阅读前的必要基础2</span><br><span class="line">1.3 本书风格与结构2</span><br><span class="line">1.4 如何阅读本书4</span><br><span class="line">1.5 目前发展形式5</span><br><span class="line">1.6 范例程序代码及额外信息5</span><br><span class="line">1.7 回应5</span><br><span class="line">2 c++ 及其标准程序库简介7</span><br><span class="line">2.1 沿革7</span><br><span class="line">2.2 新的语言特性9</span><br><span class="line">2.2.1 templates（模板） 9</span><br><span class="line">2.2.2 基本型别的显式初始化（explicit initialization） 14</span><br><span class="line">2.2.3 异常处理（exception handling） 15</span><br><span class="line">.2.2.4 命名空间（namespaces） 16</span><br><span class="line">2.2.5 bool型别18</span><br><span class="line">2.2.6 关键词explicit 18</span><br><span class="line">2.2.7 新的型别转换操作符（type conversion operators） 19</span><br><span class="line">2.2.8 常数静态成员（constant static members）的初始化20</span><br><span class="line">2.2.9 main() 的定义21</span><br><span class="line">2.3 复杂度和big-o 表示法21</span><br><span class="line">3 一般概念（general concepts） 23</span><br><span class="line">3.1 命名空间（namespace）std 23</span><br><span class="line">3.2 头文件（header files） 24</span><br><span class="line">3.3 错误（error）处理和异常（exception）处理25</span><br><span class="line">3.3.1 标准异常类别（standard exception classes） 25</span><br><span class="line">3.3.2 异常类别（exception classes）的成员28</span><br><span class="line">3.3.3 抛出标准异常29</span><br><span class="line">3.3.4 从标准异常类别（exception classes）中派生新的类别30</span><br><span class="line">3.4 配置器（allocators） 31</span><br><span class="line">4 通用工具（utilities） 33</span><br><span class="line">4.1 pairs（对组） 33</span><br><span class="line">4.1.1 便捷函数make_pair() 36</span><br><span class="line">4.1.2 pair运用实例37</span><br><span class="line">4.2 class auto_ptr 38</span><br><span class="line">4.2.1 auto_ptr的发展动机38</span><br><span class="line">4.2.2 auto_ptr拥有权（ownership）的转移40</span><br><span class="line">4.2.3 auto_ptrs 做为成员之一44</span><br><span class="line">4.2.4 auto_ptrs 的错误运用46</span><br><span class="line">4.2.5 auto_ptr运用实例47</span><br><span class="line">4.2.6 auto_ptr实作细目51</span><br><span class="line">4.3 数值极限（numeric limits） 59</span><br><span class="line">4.4 辅助函数66</span><br><span class="line">4.4.1 挑选较小值和较大值66</span><br><span class="line">4.4.2 两值互换67</span><br><span class="line">4.5 辅助性的“比较操作符”（comparison operators） 69</span><br><span class="line">4.6 头文件[cstddef] 和[cstdlib] 71</span><br><span class="line">4.6.1 [cstddef] 内的各种定义71</span><br><span class="line">4.6.2 [cstdlib] 内的各种定义71</span><br><span class="line">5 standard template library（标准模板库） 73</span><br><span class="line">5.1 stl 组件（stl components） 73</span><br><span class="line">5.2 容器（containers） 75</span><br><span class="line">5.2.1 序列式容器（sequence containers） 76</span><br><span class="line">5.2.2 关联式容器（associative containers） 81</span><br><span class="line">5.2.3 容器配接器（container adapters） 82</span><br><span class="line">5.3 迭代器（iterators） 83</span><br><span class="line">5.3.1 关联式容器的运用实例86</span><br><span class="line">5.3.2 迭代器类型（iterator categories） 93</span><br><span class="line">5.4 算法（algorithms） 94</span><br><span class="line">5.4.1 区间（ranges） 97</span><br><span class="line">5.4.2 处理多个区间101</span><br><span class="line">5.5 迭代器之配接器（iterator adapters） 104</span><br><span class="line">5.5.1 insert iterators（安插型迭代器） 104</span><br><span class="line">5.5.2 stream iterators（串流迭代器） 107</span><br><span class="line">5.5.3 reverse iterators（逆向迭代器） 109</span><br><span class="line">5.6 更易型算法（manipulating algorithms） 111</span><br><span class="line">5.6.1 移除（removing）元素111</span><br><span class="line">5.6.2 更易型算法和关联式容器115</span><br><span class="line">5.6.3 算法v.s. 成员函数116</span><br><span class="line">5.7 使用者自定之泛型函数（user-defined generic functions） 117</span><br><span class="line">5.8 以函数做为算法的参数119</span><br><span class="line">5.8.1“以函数做为算法的参数”实例示范119</span><br><span class="line">5.8.2 判断式（predicates） 121</span><br><span class="line">5.9 仿函数（functors or function objects） 124</span><br><span class="line">5.9.1 什么是仿函数124</span><br><span class="line">5.9.2 预先定义的仿函数131</span><br><span class="line">5.10 容器内的元素（container elements） 134</span><br><span class="line">5.10.1 容器元素的条件134</span><br><span class="line">5.10.2 value 语意vs. reference 语意135</span><br><span class="line">5.11 stl内部的错误处理和异常处理136</span><br><span class="line">5.11.1 错误处理（error handling） 137</span><br><span class="line">5.11.2 异常处理（exception handling） 139</span><br><span class="line">5.12 扩展stl 141</span><br><span class="line">6 stl 容器（containers） 143</span><br><span class="line">6.1 容器的共通能力和共通操作144</span><br><span class="line">6.1.1 容器的共通能力144</span><br><span class="line">6.1.2 容器的共通操作144</span><br><span class="line">6.2 vectors 148</span><br><span class="line">6.2.1 vectors 的能力148</span><br><span class="line">6.2.2 vector 的操作函数150</span><br><span class="line">6.2.3 将vectors 当做一般arrays 使用155</span><br><span class="line">6.2.4 异常处理155</span><br><span class="line">6.2.5 vectors 运用实例156</span><br><span class="line">6.2.6 class vector[bool] 158</span><br><span class="line">6.3 deques 160</span><br><span class="line">6.3.1 deques 的能力161</span><br><span class="line">6.3.2 deque 的操作函数162</span><br><span class="line">6.3.3 异常处理（exception handling） 164</span><br><span class="line">6.3.4 deques 运用实例164</span><br><span class="line">6.4 lists 166</span><br><span class="line">6.4.1 lists 的能力166</span><br><span class="line">6.4.2 list 的操作函数167</span><br><span class="line">6.4.3 异常处理（exception handling） 172</span><br><span class="line">6.4.4 lists 运用实例172</span><br><span class="line">6.5 sets和multisets</span><br><span class="line">175</span><br><span class="line">6.5.1 sets 和multisets 的能力176</span><br><span class="line">6.5.2 set 和multiset 的操作177</span><br><span class="line">6.5.3 异常处理（exception handling） 185</span><br><span class="line">6.5.4 sets 和multisets 运用实例186</span><br><span class="line">6.5.5 执行期指定排序准则（sorting criterion） 191</span><br><span class="line">6.6 maps 和multimaps 194</span><br><span class="line">6.6.1 maps 和multimaps 的能力195</span><br><span class="line">6.6.2 map 和multimap 的操作函数196</span><br><span class="line">6.6.3 将maps 视为关联式数组（associated arrays） 205</span><br><span class="line">6.6.4 异常处理（exception handling） 207</span><br><span class="line">6.6.5 maps 和multimaps 运用实例207</span><br><span class="line">6.6.6 综合实例：运用maps, strings 并于执行期指定排序准则213</span><br><span class="line">6.7 其它的stl容器217</span><br><span class="line">6.7.1 strings 可被视为一种stl容器217</span><br><span class="line">6.7.2 arrays 可被视为一种stl容器218</span><br><span class="line">6.7.3 hash tables 221</span><br><span class="line">6.8 动手实现reference 语意222</span><br><span class="line">6.9 各种容器的运用时机226</span><br><span class="line">6.10 细说容器内的型别和成员230</span><br><span class="line">6.10.1 容器内的型别230</span><br><span class="line">6.10.2 生成（create）、复制（copy）、销毁（destroy） 231</span><br><span class="line">6.10.3“非变动性操作（nonmodifying operations） 233</span><br><span class="line">6.10.4 赋值（指派, assignments） 236</span><br><span class="line">6.10.5 直接元素存取237</span><br><span class="line">6.10.6 “会产出迭代器”的各项操作239</span><br><span class="line">6.10.7 元素的安插（inserting）和移除（removing） 240</span><br><span class="line">6.10.8 lists 的特殊成员函数244</span><br><span class="line">6.10.9 对配置器（allocator）的支持246</span><br><span class="line">6.10.10 综观stl容器的异常处理248</span><br><span class="line">7 stl 迭代器（iterators） 251</span><br><span class="line">7.1 迭代器头文件251</span><br><span class="line">7.2 迭代器类型（iterator categories） 251</span><br><span class="line">7.2.1 input（输入）迭代器252</span><br><span class="line">7.2.2 output（输出）迭代器253</span><br><span class="line">7.2.3 forward（前向）迭代器254</span><br><span class="line">7.2.4 bidirectional（双向）迭代器255</span><br><span class="line">7.2.5 random access（随机存取）迭代器255</span><br><span class="line">7.2.6 vector 迭代器的递增（increment）和递减（decrement） 258</span><br><span class="line">7.3 迭代器相关辅助函数259</span><br><span class="line">7.3.1 advance() 可令迭代器前进259</span><br><span class="line">7.3.2 distance() 可处理迭代器之间的距离261</span><br><span class="line">7.3.3 iter_swap() 可交换两个迭代器所指内容263</span><br><span class="line">7.4 迭代器配接器（iterator adapters） 264</span><br><span class="line">7.4.1 reverse（逆向）迭代器264</span><br><span class="line">7.4.2 insert（安插型）迭代器271</span><br><span class="line">7.4.3 stream（串流）迭代器277</span><br><span class="line">7.5 迭代器特性（iterator traits） 283</span><br><span class="line">7.5.1 为迭代器编写泛型函数（generic functions） 285</span><br><span class="line">7.5.2 使用者自定（user-defined）的迭代器288</span><br><span class="line">8 stl 仿函数（functors or function objects） 293</span><br><span class="line">8.1 仿函数的概念293</span><br><span class="line">8.1.1 仿函数可当做排序准则（sort criteria） 294</span><br><span class="line">8.1.2 仿函数可拥有自己的内部状态（internal state） 296</span><br><span class="line">8.1.3 for_each() 的回返值300</span><br><span class="line">8.1.4 判断式（predicates）和仿函数（functors） 302</span><br><span class="line">8.2 预定义的仿函数305</span><br><span class="line">8.2.1 函数配接器（function adapters） 306</span><br><span class="line">8.2.2 针对成员函数而设计的函数配接器307</span><br><span class="line">8.2.3 针对一般函数（非成员函数）而设计的函数配接器309</span><br><span class="line">8.2.4 让自定仿函数也可以使用函数配接器310</span><br><span class="line">8.3 辅助用（组合型）仿函数313</span><br><span class="line">8.3.1 一元组合函数配接器（unary compose function object adapters） 314</span><br><span class="line">8.3.2 二元组合函数配接器（binary compose function object adapters） 318</span><br><span class="line">9 stl 算法（algorithms） 321</span><br><span class="line">9.1 算法头文件（header files） 321</span><br><span class="line">9.2 算法概观322</span><br><span class="line">9.2.1 简介322</span><br><span class="line">9.2.2 算法分门别类323</span><br><span class="line">9.3 辅助函数332</span><br><span class="line">9.4 for_each() 算法334</span><br><span class="line">9.5 非变动性算法（nonmodifying algorithms） 338</span><br><span class="line">9.5.1 计算元素个数338</span><br><span class="line">9.5.2 求最大值和最小值339</span><br><span class="line">9.5.3 搜寻元素341</span><br><span class="line">9.5.4 区间的比较356</span><br><span class="line">9.6 变动性算法（modifying algorithms） 363</span><br><span class="line">9.6.1 复制（copying）元素363</span><br><span class="line">9.6.2 转换（transforming）和结合（combining）元素366</span><br><span class="line">9.6.3 互换（swapping）元素内容370</span><br><span class="line">9.6.4 赋予（assigning）新值372</span><br><span class="line">9.6.5 替换（replacing）元素375</span><br><span class="line">9.7 移除性算法（removing algorithms） 378</span><br><span class="line">9.7.1 移除某些特定元素378</span><br><span class="line">9.7.2 移除重复元素381</span><br><span class="line">9.8 变序性算法（mutating algorithms） 386</span><br><span class="line">9.8.1 逆转（reversing）元素次序386</span><br><span class="line">9.8.2 旋转（rotating）元素次序388</span><br><span class="line">9.8.3 排列（permuting）元素391</span><br><span class="line">9.8.4 重排元素（shuffling, 搅乱次序） 393</span><br><span class="line">9.8.5 将元素向前搬移395</span><br><span class="line">9.9 排序算法（sorting algorithms） 397</span><br><span class="line">9.9.1 对所有元素排序397</span><br><span class="line">9.9.2 局部排序（partial sorting） 400</span><br><span class="line">9.9.3 根据第n 个元素排序404</span><br><span class="line">9.9.4 heap 算法406</span><br><span class="line">9.10 已序区间算法（sorted range algorithms） 409</span><br><span class="line">9.10.1 搜寻元素（searching） 410</span><br><span class="line">9.10.2 合并元素（merging） 416</span><br><span class="line">9.11 数值算法（numeric algorithms） 425</span><br><span class="line">9.11.1 加工运算后产生结果425</span><br><span class="line">9.11.2 相对值和绝对值之间的转换429</span><br><span class="line">10 特殊容器（special containers） 435</span><br><span class="line">10.1 stacks（堆栈） 435</span><br><span class="line">10.1.1 核心界面436</span><br><span class="line">10.1.2 stacks 运用实例437</span><br><span class="line">10.1.3 class stack[] 细部讨论438</span><br><span class="line">10.1.4 一个使用者自定的stack class 441</span><br><span class="line">10.2 queues（队列） 444</span><br><span class="line">10.2.1 核心界面445</span><br><span class="line">10.2.2 queues 运用实例446</span><br><span class="line">10.2.3 class queue[] 细部讨论447</span><br><span class="line">10.2.4 一个使用者自定的queue class 450</span><br><span class="line">10.3 priority queues（优先队列） 453</span><br><span class="line">10.3.1 核心界面455</span><br><span class="line">10.3.2 priority queues 运用实例455</span><br><span class="line">10.3.3 class priority_queue[] 细部讨论456</span><br><span class="line">10.4 bitsets 460</span><br><span class="line">10.4.1 bitsets 运用实例460</span><br><span class="line">10.4.2 class bitset 细部讨论463</span><br><span class="line">11 strings（字符串） 471</span><br><span class="line">11.1 动机471</span><br><span class="line">11.1.1 例一：引出一个临时文件名</span><br><span class="line">472</span><br><span class="line">11.1.2 例二：引出一段文字并逆向打印476</span><br><span class="line">11.2 string classes 细部描述479</span><br><span class="line">11.2.1 string 的各种相关型别479</span><br><span class="line">11.2.2 操作函数（operations）综览481</span><br><span class="line">11.2.3 建构式和解构式（constructors and destructors） 483</span><br><span class="line">11.2.4 strings 和c-strings 484</span><br><span class="line">11.2.5 大小（size）和容量（capacity） 485</span><br><span class="line">11.2.6 元素存取（element access） 487</span><br><span class="line">11.2.7 比较（comparisons） 488</span><br><span class="line">11.2.8 更改内容（modifiers） 489</span><br><span class="line">11.2.9 子字符串及字符串接合492</span><br><span class="line">11.2.10 i&#x2F;o 操作符492</span><br><span class="line">11.2.11 搜寻和查找（searching and finding） 493</span><br><span class="line">11.2.12 数值npos 的意义495</span><br><span class="line">11.2.13 strings 对迭代器的支援497</span><br><span class="line">11.2.14 国际化（internationalization） 503</span><br><span class="line">11.2.15 效率（performance） 506</span><br><span class="line">11.2.16 strings 和vectors 506</span><br><span class="line">11.3 细说string class 507</span><br><span class="line">11.3.1 内部的型别定义和静态值507</span><br><span class="line">11.3.2 生成（create）、拷贝（copy）、销毁（destroy） 508</span><br><span class="line">11.3.3 大小（size）和容量（capacity） 510</span><br><span class="line">11.3.4 比较（comparisons） 511</span><br><span class="line">11.3.5 字符存取（character access） 512</span><br><span class="line">11.3.6 产生c-strings 和字符数组（character arrays） 513</span><br><span class="line">11.3.7 更改内容514</span><br><span class="line">11.3.8 搜寻（searching and finding） 520</span><br><span class="line">11.3.9 子字符串及字符串接合524</span><br><span class="line">11.3.10 i&#x2F;o 函数524</span><br><span class="line">11.3.11 产生迭代器525</span><br><span class="line">11.3.12 对配置器（allocator）的支持526</span><br><span class="line">12 数值（numerics） 529</span><br><span class="line">12.1 复数（complex numbers） 529</span><br><span class="line">12.1.1 class complex运用实例530</span><br><span class="line">12.1.2 复数的各种操作533</span><br><span class="line">12.1.3 class complex[] 细部讨论541</span><br><span class="line">12.2 valarrays 547</span><br><span class="line">12.2.1 认识valarrays 547</span><br><span class="line">12.2.2 valarray 的子集（subsets） 553</span><br><span class="line">12.2.3 class valarray 细部讨论569</span><br><span class="line">12.2.4 valarray子集类别（subset classes）细部讨论575</span><br><span class="line">12.3 全域性的数值函数581</span><br><span class="line">13 以stream classes完成输入和输出583</span><br><span class="line">13.1 i&#x2F;o streams 基本概念584</span><br><span class="line">13.1.1 stream物件584</span><br><span class="line">13.1.2 stream类别584</span><br><span class="line">13.1.3 全域性的stream物件585</span><br><span class="line">13.1.4 stream操作符586</span><br><span class="line">13.1.5 操控器（manipulators） 586</span><br><span class="line">13.1.6 一个简单的例子587</span><br><span class="line">13.2 基本的stream类别和stream对象588</span><br><span class="line">13.2.1 相关类别及其阶层体系588</span><br><span class="line">13.2.2 全域性的stream物件591</span><br><span class="line">13.2.3 头文件（headers） 592</span><br><span class="line">13.3 标准的stream操作符[[ 和]] 593</span><br><span class="line">13.3.1 output操作符[[ 593</span><br><span class="line">13.3.2 input操作符]] 594</span><br><span class="line">13.3.3 特殊型别的i&#x2F;o 595</span><br><span class="line">13.4 streams 的状态（state） 597</span><br><span class="line">13.4.1 用来表示streams 状态的一些常数597</span><br><span class="line">13.4.2 用来处理streams 状态的一些成员函数598</span><br><span class="line">13.4.3 stream状态与布尔条件测试600</span><br><span class="line">13.4.4 stream的状态和异常602</span><br><span class="line">13.5 标准i&#x2F;o 函数607</span><br><span class="line">13.5.1 输入用的成员函数607</span><br><span class="line">13.5.2 输出用的成员函数610</span><br><span class="line">13.5.3 运用实例611</span><br><span class="line">13.6 操控器（manipulators） 612</span><br><span class="line">13.6.1 操控器如何运作612</span><br><span class="line">13.6.2 使用者自定操控器614</span><br><span class="line">13.7 格式化（formatting） 615</span><br><span class="line">13.7.1 格式标志（format flags） 615</span><br><span class="line">13.7.2 布尔值（boolean values）的i&#x2F;o 格式617</span><br><span class="line">13.7.3 字段宽度、填充字符、位置调整618</span><br><span class="line">13.7.4 正记号与大写字620</span><br><span class="line">13.7.5 数值进制（numeric base） 621</span><br><span class="line">13.7.6 浮点数（floating-point）表示法623</span><br><span class="line">13.7.7 一般性的格式定义625</span><br><span class="line">13.8 国际化（internationalization） 625</span><br><span class="line">13.9 文件存取（file access） 627</span><br><span class="line">13.9.1 文件标志（file flags） 631</span><br><span class="line">13.9.2 随机存取634</span><br><span class="line">13.9.3 使用文件描述器（file descriptors） 637</span><br><span class="line">13.10 连接input streams 和output streams 637</span><br><span class="line">13.10.1 以tie()完成“松耦合”（loose coupling） 637</span><br><span class="line">13.10.2 以stream缓冲区完成“紧耦合”（tight coupling） 638</span><br><span class="line">13.10.3 将标准streams 重新导向（redirecting） 641</span><br><span class="line">13.10.4 用于读写的streams 643</span><br><span class="line">13.11 string stream classes 645</span><br><span class="line">13.11.1 string stream classes 645</span><br><span class="line">13.11.2 char* stream classes 649</span><br><span class="line">13.12 “使用者自定型别”之i&#x2F;o操作符652</span><br><span class="line">13.12.1 实作一个output 操作符652</span><br><span class="line">13.12.2 实作一个input 操作符654</span><br><span class="line">13.12.3 以辅助函数完成i&#x2F;o 656</span><br><span class="line">13.12.4 以非格式化函数完成使用者自定的操作符658</span><br><span class="line">13.12.5 使用者自定的格式标志（format flags） 659</span><br><span class="line">13.12.6 使用者自定之i&#x2F;o 操作符的数个依循惯例662</span><br><span class="line">13.13 stream buffer classes 663</span><br><span class="line">13.13.1 从使用者的角度看stream缓冲区663</span><br><span class="line">13.13.2 stream缓冲区迭代器（buffer iterators） 665</span><br><span class="line">13.13.3 使用者自定的stream 缓冲区668</span><br><span class="line">13.14 关于效能（performance） 681</span><br><span class="line">13.14.1 与c 标准输入输出流（standard streams）同步682</span><br><span class="line">13.14.2 stream缓冲区内的缓冲机制682</span><br><span class="line">13.14.3 直接使用stream缓冲区683</span><br><span class="line">14 国际化（internationalization, i18n） 685</span><br><span class="line">14.1 不同的字符编码（character encoding） 686</span><br><span class="line">14.1.1 宽字符（wide-character）和多字节文本（multibyte text） 686</span><br><span class="line">14.1.2 字符特性（character traits） 687</span><br><span class="line">14.1.3 特殊字符国际化691</span><br><span class="line">14.2 locales 的概念692</span><br><span class="line">14.2.1 运用locales 693</span><br><span class="line">14.2.2 locale facets 698</span><br><span class="line">14.3 locales 细部讨论700</span><br><span class="line">14.4 facets 细部讨论704</span><br><span class="line">14.4.1 数值格式化705</span><br><span class="line">14.4.2 时间和日期格式化708</span><br><span class="line">14.4.3 货币符号格式化711</span><br><span class="line">14.4.4 字符的分类和转换715</span><br><span class="line">14.4.5 字符串校勘（string collation） 724</span><br><span class="line">14.4.6 信息国际化725</span><br><span class="line">15 空间配置器（allocators） 727</span><br><span class="line">15.1 应用程序开发者如何使用配置器727</span><br><span class="line">15.2 程序库开发者如何使用配置器728</span><br><span class="line">15.3 c++ 标准程序库的预设配置器732</span><br><span class="line">15.4 使用者自行定义的配置器735</span><br><span class="line">15.5 配置器细部讨论737</span><br><span class="line">15.5.1 内部定义的型别737</span><br><span class="line">15.5.2 各项操作739</span><br><span class="line">15.6“未初始化内存”之处理工具细部讨论740</span><br><span class="line">网络上的资源（internet resources） 743</span><br><span class="line">参考书目（bibliography） 745</span><br><span class="line">索引（index） 747</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0011BDOM8/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0011BDOM8&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41yUUBjIihL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++编程思想第二卷</title>
    <url>/2020/04/19/thinking-in-cpp-volume-2-zh/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C++编程思想第二卷<br>作者信息： 作者: bruce eckel [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>介绍实用的编程技术和最佳的实践方法，解决c++开发中最困难的课题<br>深入研究标准c++库的功能，包括：字符串、输入输出流、stl算法和容器<br>讲述模板的现代用法，包括模板元编程<br>解开对多重继承的困惑，展示rtti的实际使用<br>深入探究异常处理方法，清晰解释异常安全设计<br>介绍被认为是标准c++下一版特征之一的多线程处理编程技术，并提供最新研究成果<br>对书中包含的所有示例代码都提供免费下载，这些代码段经过多个软件平台和编译器(包括基于windows/mac/linux的gnu c++编译器) 的测试，稳定可靠。 目录<br>第一部分 建立稳定的系统<br>第1章 异常处理 2<br>第2章 防御性编程 32<br>第二部分 标准c++库<br>第3章 深入理解字符串 58<br>第4章 输入输出流 88<br>第5章 深入理解模板 134<br>第6章 通用算法 196<br>第7章 通用容器 260<br>第三部分 专 题<br>第8章 运行时类型识别 340<br>第9章 多重继承 355<br>第10章 设计模式 380<br>第11章 并发 430<br>附 录<br>附录a 推荐读物 484<br>附录b 其他 488<br>索引 493</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00116CZ82/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00116CZ82&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51Nx5JbvwkL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++编程思想第一卷</title>
    <url>/2020/04/19/thinking-in-cpp-volume-1-zh/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C++编程思想第一卷<br>作者信息： 作者: bruce eckel [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>本书的内容、讲授方法，选用例子和跟随的练习，别具特色。作者Bruce Eckel不是按传统的方法讲解C++的概念和编程方法，而是根据他自己过去学习C++的亲身体会，根据他在多年教学实践中发现的问题，用一些非常简单的例子和简练的叙述，阐明了在学习C++中特别容易混淆的概念。特别是，他经常通过例子引导读者从C++编译实现的汇编代码的角度反向审视C++的语法和语义，常常使读者有‘心有灵犀一点通’的奇特效果。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">《c++编程思想(两卷合订本)》</span><br><span class="line">出版者的话</span><br><span class="line">出版说明</span><br><span class="line">第1卷 标准c++导引</span><br><span class="line">译者序 3</span><br><span class="line">前言 5</span><br><span class="line">第1章 对象导言 11</span><br><span class="line">1.1 抽象的过程 11</span><br><span class="line">1.2 对象有一个接口 12</span><br><span class="line">1.3 实现的隐藏 14</span><br><span class="line">1.4 实现的重用 15</span><br><span class="line">1.5 继承：重用接口 15</span><br><span class="line">1.5.1 is-a 关系和is-like-a 关系 18</span><br><span class="line">1.6 具有多态性的可互换对象 18</span><br><span class="line">1.7 创建和销毁对象 21</span><br><span class="line">1.8 异常处理：应对错误 22</span><br><span class="line">1.9 分析和设计 22</span><br><span class="line">1.9.1 第0阶段：制定计划 24</span><br><span class="line">1.9.2 第1阶段：我们在做什么 24</span><br><span class="line">1.9.3 第2阶段：我们将如何建立对象 26 </span><br><span class="line"></span><br><span class="line"> .1.9.4 第3阶段：创建核心 28 1.9.5 第4阶段：迭代用例 29 1.9.6 第5阶段：进化 29 1.9.7 计划的回报 30 1.10 极限编程 30 1.10.1 先写测试 31 1.10.2 结对编程 32 1.11 为什么c++会成功 32 1.11.1 一个较好的c 32 1.11.2 延续式的学习过程 33 1.11.3 效率 33 1.11.4 系统更容易表达和理解 33 1.11.5 尽量使用库 33 1.11.6 利用模板的源代码重用 34 1.11.7 错误处理 34 1.11.8 大型程序设计 34 1.12 为向oop转变而采取的策略 34 1.12.1 指导方针 35 1.12.2 管理的障碍 35 1.13 小结 37 第2章 对象的创建与使用 38 2.1 语言的翻译过程 38 2.1.1 解释器 38 2.1.2 编译器 39 2.1.3 编译过程 39 2.2 分段编译工具 40 2.2.1 声明与定义 40 2.2.2 连接 44 2.2.3 使用库文件 44 2.3 编写第一个c++程序 45 2.3.1 使用iostream类 45 2.3.2 名字空间 46 2.3.3 程序的基本结构 47 2.3.4 “hello, world!” 47 2.3.5 运行编译器 48 2.4 关于输入输出流 48 2.4.1 字符数组的拼接 49 2.4.2 读取输入数据 49 2.4.3 调用其他程序 50 2.5 字符串简介 50 2.6 文件的读写 51 2.7 vector简介 52 2.8 小结 55 2.9 练习 56 第3章 c++中的c 57 3.1 创建函数 57 3.1.1 函数的返回值 58 3.1.2 使用c的函数库 59 3.1.3 通过库管理器创建自己的库 59 3.2 执行控制语句 60 3.2.1 真和假 60 3.2.2 if-else语句 60 3.2.3 while语句 61 3.2.4 do-while语句 61 3.2.5 for语句 62 3.2.6 关键字break 和 continue 63 3.2.7 switch语句 64 3.2.8 使用和滥用goto 65 3.2.9 递归 65 3.3 运算符简介 66 3.3.1 优先级 66 3.3.2 自增和自减 67 3.4 数据类型简介 67 3.4.1 基本内建类型 67 3.4.2 bool类型与true和false 68 3.4.3 说明符 69 3.4.4 指针简介 70 3.4.5 修改外部对象 72 3.4.6 c++引用简介 74 3.4.7 用指针和引用作为修饰符 75 3.5 作用域 76 3.5.1 实时定义变量 77 3.6 指定存储空间分配 78 3.6.1 全局变量 78 3.6.2 局部变量 79 3.6.3 静态变量 80 3.6.4 外部变量 81 3.6.5 常量 82 3.6.6 volatile变量 83 3.7 运算符及其使用 83 3.7.1 赋值 83 3.7.2 数学运算符 83 3.7.3 关系运算符 85 3.7.4 逻辑运算符 85 3.7.5 位运算符 85 3.7.6 移位运算符 86 3.7.7 一元运算符 88 3.7.8 三元运算符 88 3.7.9 逗号运算符 89 3.7.10 使用运算符时的常见问题 89 3.7.11 转换运算符 90 3.7.12 c++的显式转换 90 3.7.13 sizeof—独立运算符 93 3.7.14 asm 关键字 94 3.7.15 显式运算符 94 3.8 创建复合类型 94 3.8.1 用typedef命名别名 95 3.8.2 用struct把变量结合在一起 95 3.8.3 用enum提高程度清晰度 97 3.8.4 用union节省内存 98 3.8.5 数组 99 3.9 调试技巧 106 3.9.1 调试标记 106 3.9.2 把变量和表达式转换成字符串 108 3.9.3 c语言assert( )宏 108 3.10 函数地址 109 3.10.1 定义函数指针 109 3.10.2 复杂的声明和定义 109 3.10.3 使用函数指针 110 3.10.4 指向函数的指针数组 111 3.11 make：管理分段编译 111 3.11.1 make的行为 112 3.11.2 本书中的makefile 114 3.11.3 makefile的一个例子 114 3.12 小结 116 3.13 练习 116 第4章 数据抽象 119 4.1 一个袖珍c库 119 4.1.1 动态存储分配 122 4.1.2 有害的猜测 124 4.2 哪儿出问题 125 4.3 基本对象 126 4.4 什么是对象 130 4.5 抽象数据类型 131 4.6 对象细节 131 4.7 头文件形式 132 4.7.1 头文件的重要性 132 4.7.2 多次声明问题 133 4.7.3 预处理器指示#define、#ifdef 和#endif 134 4.7.4 头文件的标准 134 4.7.5 头文件中的名字空间 135 4.7.6 在项目中使用头文件 135 4.8 嵌套结构 136 4.8.1 全局作用域解析 138 4.9 小结 139 4.10 练习 139 第5章 隐藏实现 142 5.1 设置限制 142 5.2 c++的访问控制 142 5.2.1 protected说明符 144 5.3 友元 144 5.3.1 嵌套友元 146 5.3.2 它是纯面向对象的吗 148 5.4 对象布局 148 5.5 类 149 5.5.1 用访问控制来修改stash 151 5.5.2 用访问控制来修改stack 151 5.6 句柄类 152 5.6.1 隐藏实现 152 5.6.2 减少重复编译 152 5.7 小结 154 5.8 练习 154 第6章 初始化与清除 156 6.1 用构造函数确保初始化 156 6.2 用析构函数确保清除 157 6.3 清除定义块 159 6.3.1 for循环 160 6.3.2 内存分配 161 6.4 带有构造函数和析构函数的stash 162 6.5 带有构造函数和析构函数的stack 164 6.6 聚合初始化 166 6.7 默认构造函数 168 6.8 小结 169 6.9 练习 169 第7章 函数重载与默认参数 171 7.1 名字修饰 172 7.1.1 用返回值重载 172 7.1.2 类型安全连接 172 7.2 重载的例子 173 7.3 联合 176 7.4 默认参数 178 7.4.1 占位符参数 179 7.5 选择重载还是默认参数 180 7.6 小结 183 7.7 练习 183 第8章 常量 185 8.1 值替代 185 8.1.1 头文件里的const 186 8.1.2 const的安全性 186 8.1.3 聚合 187 8.1.4 与c语言的区别 187 8.2 指针 188 8.2.1 指向const的指针 189 8.2.2 const指针 189 8.2.3 赋值和类型检查 190 8.3 函数参数和返回值 191 8.3.1 传递const值 191 8.3.2 返回const值 191 8.3.3 传递和返回地址 193 8.4 类 195 8.4.1 类里的const 196 8.4.2 编译期间类里的常量 198 8.4.3 const对象和成员函数 200 8.5 volatile 204 8.6 小结 205 8.7 练习 205 第9章 内联函数 207 9.1 预处理器的缺陷 207 9.1.1 宏和访问 209 9.2 内联函数 210 9.2.1 类内部的内联函数 210 9.2.2 访问函数 211 9.3 带内联函数的stash和stack 215 9.4 内联函数和编译器 218 9.4.1 限制 219 9.4.2 向前引用 219 9.4.3 在构造函数和析构函数里隐藏行为 220 9.5 减少混乱 220 9.6 预处理器的更多特征 221 9.6.1 标志粘贴 222 9.7 改进的错误检查 222 9.8 小结 225 9.9 练习 225 第10章 名字控制 227 10.1 来自c语言中的静态元素 227 10.1.1 函数内部的静态变量 227 10.1.2 控制连接 230 10.1.3 其他存储类型说明符 232 10.2 名字空间 232 10.2.1 创建一个名字空间 232 10.2.2 使用名字空间 234 10.2.3 名字空间的使用 237 10.3 c++中的静态成员 238 10.3.1 定义静态数据成员的存储 238 10.3.2 嵌套类和局部类 241 10.3.3 静态成员函数 242 10.4 静态初始化的相依性 244 10.4.1 怎么办 245 10.5 替代连接说明 250 10.6 小结 250 10.7 练习 251 第11章 引用和拷贝构造函数 254 11.1 c++中的指针 254 11.2 c++中的引用 254 11.2.1 函数中的引用 255 11.2.2 参数传递准则 257 11.3 拷贝构造函数 257 11.3.1 按值传递和返回 257 11.3.2 拷贝构造函数 261 11.3.3 默认拷贝构造函数 265 11.3.4 替代拷贝构造函数的方法 266 11.4 指向成员的指针 267 11.4.1 函数 269 11.5 小结 271 11.6 练习 271 第12章 运算符重载 274 12.1 两个极端 274 12.2 语法 274 12.3 可重载的运算符 275 12.3.1 一元运算符 276 12.3.2 二元运算符 279 12.3.3 参数和返回值 288 12.3.4 不常用的运算符 290 12.3.5 不能重载的运算符 295 12.4 非成员运算符 296 12.4.1 基本方针 297 12.5 重载赋值符 297 12.5.1 operator&#x3D;的行为 298 12.6 自动类型转换 306 12.6.1 构造函数转换 306 12.6.2 运算符转换 307 12.6.3 类型转换例子 309 12.6.4 自动类型转换的缺陷 310 12.7 小结 312 12.8 练习 312 第13章 动态对象创建 315 13.1 对象创建 315 13.1.1 c从堆中获取存储单元的方法 316 13.1.2 operator new 317 13.1.3 operator delete 317 13.1.4 一个简单的例子 318 13.1.5 内存管理的开销 318 13.2 重新设计前面的例子 319 13.2.1 使用delete void*可能会出错 319 13.2.2 对指针的清除责任 320 13.2.3 指针的stash 320 13.3 用于数组的new和delete 324 13.3.1 使指针更像数组 325 13.4 耗尽内存 325 13.5 重载new和delete 326 13.5.1 重载全局new和delete 327 13.5.2 对于一个类重载new和delete 328 13.5.3 为数组重载new和delete 330 13.5.4 构造函数调用 332 13.5.5 定位new和delete 333 13.6 小结 334 13.7 练习 334 第14章 继承和组合 336 14.1 组合语法 336 14.2 继承语法 337 14.3 构造函数的初始化表达式表 339 14.3.1 成员对象初始化 339 14.3.2 在初始化表达式表中的内建类型 339 14.4 组合和继承的联合 340 14.4.1 构造函数和析构函数调用的次序 341 14.5 名字隐藏 343 14.6 非自动继承的函数 346 14.6.1 继承和静态成员函数 349 14.7 组合与继承的选择 349 14.7.1 子类型设置 350 14.7.2 私有继承 352 14.8 protected 353 14.8.1 protected继承 353 14.9 运算符的重载与继承 353 14.10 多重继承 355 14.11 渐增式开发 355 14.12 向上类型转换 356 14.12.1 为什么要“向上类型转换” 357 14.12.2 向上类型转换和拷贝构造函数 357 14.12.3 组合与继承（再论） 359 14.12.4 指针和引用的向上类型转换 360 14.12.5 危机 360 14.13 小结 361 14.14 练习 361 第15章 多态性和虚函数 364 15.1 c++程序员的演变 364 15.2 向上类型转换 365 15.3 问题 366 15.3.1 函数调用捆绑 366 15.4 虚函数 366 15.4.1 扩展性 367 15.5 c++如何实现晚捆绑 369 15.5.1 存放类型信息 370 15.5.2 虚函数功能图示 371 15.5.3 撩开面纱 372 15.5.4 安装vpointer 373 15.5.5 对象是不同的 373 15.6 为什么需要虚函数 374 15.7 抽象基类和纯虚函数 375 15.7.1 纯虚定义 378 15.8 继承和vtable 378 15.8.1 对象切片 380 15.9 重载和重新定义 382 15.9.1 变量返回类型 383 15.10 虚函数和构造函数 385 15.10.1 构造函数调用次序 385 15.10.2 虚函数在构造函数中的行为 386 15.11 析构函数和虚拟析构函数 386 15.11.1 纯虚析构函数 388 15.11.2 析构函数中的虚机制 389 15.11.3 创建基于对象的继承 390 15.12 运算符重载 392 15.13 向下类型转换 394 15.14 小结 396 15.15 练习 397 第16章 模板介绍 400 16.1 容器 400 16.1.1 容器的需求 401 16.2 模板综述 402 16.2.1 模板方法 403 16.3 模板语法 404 16.3.1 非内联函数定义 405 16.3.2 作为模板的intstack 406 16.3.3 模板中的常量 408 16.4 作为模板的stash和stack 409 16.4.1 模板化的指针stash 411 16.5 打开和关闭所有权 415 16.6 以值存放对象 417 16.7 迭代器简介 418 16.7.1 带有迭代器的栈 425 16.7.2 带有迭代器的pstash 427 16.8 为什么使用迭代器 432 16.8.1 函数模板 434 16.9 小结 435 16.10 练习 435 附录a 编码风格 附录b 编程准则 附录c 推荐读物 第2卷 实用编程技术 译者序 441 前言 442 第一部分 建立稳定的系统 第1章 异常处理 448 1.1 传统的错误处理 448 1.2 抛出异常 450 1.3 捕获异常 451 1.3.1 try块 451 1.3.2 异常处理器 451 1.3.3 终止和恢复 452 1.4 异常匹配 453 1.4.1 捕获所有异常 454 1.4.2 重新抛出异常 454 1.4.3 不捕获异常 455 1.5 清理 456 1.5.1 资源管理 457 1.5.2 使所有事物都成为对象 458 1.5.3 auto_ptr 460 1.5.4 函数级的try块 461 1.6 标准异常 462 1.7 异常规格说明 464 1.7.1 更好的异常规格说明 467 1.7.2 异常规格说明和继承 467 1.7.3 什么时候不使用异常规格说明 468 1.8 异常安全 468 1.9 在编程中使用异常 471 1.9.1 什么时候避免异常 471 1.9.2 异常的典型应用 472 1.10 使用异常造成的开销 474 1.11 小结 476 1.12 练习 476 第2章 防御性编程 478 2.1 断言 480 2.2 一个简单的单元测试框架 482 2.2.1 自动测试 483 2.2.2 testsuite框架 485 2.2.3 测试套件 488 2.2.4 测试框架的源代码 489 2.3 调试技术 493 2.3.1 用于代码跟踪的宏 494 2.3.2 跟踪文件 494 2.3.3 发现内存泄漏 495 2.4 小结 499 2.5 练习 500 第二部分 标准c++库 第3章 深入理解字符串 504 3.1 字符串的内部是什么 504 3.2 创建并初始化c++字符串 505 3.3 对字符串进行操作 508 3.3.1 追加、插入和连接字符串 508 3.3.2 替换字符串中的字符 509 3.3.3 使用非成员重载运算符连接 512 3.4 字符串的查找 513 3.4.1 反向查找 516 3.4.2 查找一组字符第1次或最后一次出现的位置 517 3.4.3 从字符串中删除字符 519 3.4.4 字符串的比较 520 3.4.5 字符串和字符的特性 523 3.5 字符串的应用 527 3.6 小结 531 3.7 练习 531 第4章 输入输出流 534 4.1 为什么引入输入输出流 534 4.2 救助输入输出流 537 4.2.1 插入符和提取符 537 4.2.2 通常用法 540 4.2.3 按行输入 541 4.3 处理流错误 542 4.4 文件输入输出流 544 4.4.1 一个文件处理的例子 544 4.4.2 打开模式 546 4.5 输入输出流缓冲 546 4.6 在输入输出流中定位 548 4.7 字符串输入输出流 550 4.7.1 输入字符串流 551 4.7.2 输出字符串流 552 4.8 输出流的格式化 555 4.8.1 格式化标志 555 4.8.2 格式化域 556 4.8.3 宽度、填充和精度设置 557 4.8.4 一个完整的例子 557 4.9 操纵算子 560 4.9.1 带参数的操纵算子 560 4.9.2 创建操纵算子 562 4.9.3 效用算子 563 4.10 输入输出流程序举例 565 4.10.1 维护类库的源代码 565 4.10.2 检测编译器错误 568 4.10.3 一个简单的数据记录器 570 4.11 国际化 573 4.11.1 宽字符流 574 4.11.2 区域性字符流 575 4.12 小结 577 4.13 练习 577 第5章 深入理解模板 580 5.1 模板参数 580 5.1.1 无类型模板参数 580 5.1.2 默认模板参数 582 5.1.3 模板类型的模板参数 583 5.1.4 typename关键字 587 5.1.5 以template关键字作为提示 588 5.1.6 成员模板 589 5.2 有关函数模板的几个问题 591 5.2.1 函数模板参数的类型推断 591 5.2.2 函数模板重载 594 5.2.3 以一个已生成的函数模板地址作为参数 595 5.2.4 将函数应用到stl序列容器中 598 5.2.5 函数模板的半有序 600 5.3 模板特化 601 5.3.1 显式特化 601 5.3.2 半特化 602 5.3.3 一个实例 604 5.3.4 防止模板代码膨胀 606 5.4 名称查找问题 609 5.4.1 模板中的名称 609 5.4.2 模板和友元 613 5.5 模板编程中的习语 617 5.5.1 特征 617 5.5.2 策略 621 5.5.3 奇特的递归模板模式 623 5.6 模板元编程 624 5.6.1 编译时编程 625 5.6.2 表达式模板 631 5.7 模板编译模型 636 5.7.1 包含模型 636 5.7.2 显式实例化 637 5.7.3 分离模型 638 5.8 小结 639 5.9 练习 640 第6章 通用算法 642 6.1 概述 642 6.1.1 判定函数 644 6.1.2 流迭代器 646 6.1.3 算法复杂性 647 6.2 函数对象 648 6.2.1 函数对象的分类 649 6.2.2 自动创建函数对象 649 6.2.3 可调整的函数对象 652 6.2.4 更多的函数对象例子 653 6.2.5 函数指针适配器 658 6.2.6 编写自己的函数对象适配器 662 6.3 stl算法目录 665 6.3.1 实例创建的支持工具 666 6.3.2 填充和生成 669 6.3.3 计数 670 6.3.4 操作序列 671 6.3.5 查找和替换 674 6.3.6 比较范围 679 6.3.7 删除元素 681 6.3.8 对已排序的序列进行排序和运算 684 6.3.9 堆运算 691 6.3.10 对某一范围内的所有元素进行运算 691 6.3.11 数值算法 697 6.3.12 通用实用程序 699 6.4 创建自己的stl风格算法 700 6.5 小结 701 6.6 练习 702 第7章 通用容器 706 7.1 容器和迭代器 706 7.2 概述 707 7.2.1 字符串容器 711 7.2.2 从stl容器继承 712 7.3 更多迭代器 714 7.3.1 可逆容器中的迭代器 715 7.3.2 迭代器的种类 716 7.3.3 预定义迭代器 717 7.4 基本序列容器：vector、list和deque 721 7.4.1 基本序列容器的操作 721 7.4.2 向量 723 7.4.3 双端队列 728 7.4.4 序列容器间的转换 730 7.4.5 被检查的随机访问 731 7.4.6 链表 732 7.4.7 交换序列 736 7.5 集合 737 7.6 堆栈 743 7.7 队列 745 7.8 优先队列 748 7.9 持有二进制位 755 7.9.1 bitset[n] 756 7.9.2 vector[bool] 758 7.10 关联式容器 760 7.10.1 用于关联式容器的发生器和填充器 763 7.10.2 不可思议的映像 765 7.10.3 多重映像和重复的关键字 766 7.10.4 多重集合 768 7.11 将stl容器联合使用 771 7.12 清除容器的指针 773 7.13 创建自己的容器 774 7.14 对stl的扩充 776 7.15 非stl容器 777 7.16 小结 781 7.17 练习 781 第三部分 专 题 第8章 运行时类型识别 785 8.1 运行时类型转换 785 8.2 typeid 操作符 789 8.2.1 类型转换到中间层次类型 790 8.2.2 void型指针 791 8.2.3 运用带模板的rtti 792 8.3 多重继承 793 8.4 合理使用rtti 793 8.5 rtti的机制和开销 797 8.6 小结 797 8.7 练习 798 第9章 多重继承 800 9.1 概论 800 9.2 接口继承 801 9.3 实现继承 803 9.4 重复子对象 807 9.5 虚基类 810 9.6 名字查找问题 817 9.7 避免使用多重继承 819 9.8 扩充一个接口 820 9.9 小结 823 9.10 练习 823 第10章 设计模式 825 10.1 模式的概念 825 10.2 模式分类 826 10.3 简化习语 827 10.3.1 信使 827 10.3.2 收集参数 828 10.4 单件 829 10.5 命令：选择操作 833 10.6 消除对象耦合 836 10.6.1 代理模式：作为其他对象的前端 837 10.6.2 状态模式：改变对象的行为 838 10.7 适配器模式 840 10.8 模板方法模式 841 10.9 策略模式：运行时选择算法 842 10.10 职责链模式：尝试采用一系列 策略模式 843 10.11 工厂模式：封装对象的创建 845 10.11.1 多态工厂 847 10.11.2 抽象工厂 849 10.11.3 虚构造函数 851 10.12 构建器模式：创建复杂对象 855 10.13 观察者模式 860 10.13.1 “内部类”方法 862 10.13.2 观察者模式举例 864 10.14 多重派遣 867 10.15 小结 873 10.16 练习 873 第11章 并发 875 11.1 动机 875 11.2 c++中的并发 876 11.3 定义任务 878 11.4 使用线程 879 11.4.1 创建有响应的用户界面 880 11.4.2 使用执行器简化工作 882 11.4.3 让步 884 11.4.4 休眠 885 11.4.5 优先权 886 11.5 共享有限资源 887 11.5.1 保证对象的存在 887 11.5.2 不恰当地访问资源 890 11.5.3 访问控制 892 11.5.4 使用保护简化编码 893 11.5.5 线程本地存储 896 11.6 终止任务 897 11.6.1 防止输入&#x2F;输出流冲突 897 11.6.2 举例观赏植物园 898 11.6.3 阻塞时终止 901 11.6.4 中断 902 11.7 线程间协作 906 11.7.1 等待和信号 906 11.7.2 生产者-消费者关系 909 11.7.3 用队列解决线程处理的问题 912 11.7.4 广播 916 11.8 死锁 921 11.9 小结 925 11.10 练习 926 附 录 附录a 推荐读物 附录b 其他</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00119J7N0/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00119J7N0&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/517TcaLgATL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出MFC</title>
    <url>/2020/04/19/shen-ru-qian-chu-mfc/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 深入浅出MFC<br>作者信息： 作者: 侯捷 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《深入浅出MFC》分为四大篇。第一篇提出学习MFC程序设计之前的必要基础，包括Widnows程序的基本观念以及C++的高阶议题。“学前基础”是相当主观的认定，不过，甚于我个人的学习经验以及教学经验，我的挑选应该颇具说服力。第二篇介绍Visual C++整合环境开发工具。本篇只不过是提纲挈领而已，并不企图取代 Visual C++使用手册。然而对于软件使用的老手，此篇或已足以让您掌握Visual C++整合环境。工具的使用虽然谈不上学问，但在视觉化软件开发过程中扮演极重角色，切莫小觑它。 第三篇介绍application framework的观念，以及MFC骨干程序，所谓骨干程序，是指Visual C++的工具ppWizard所产生出来的程序码。当然，AppWizard会根据你的选项做出不同的程序码，我所据以解说的，是大众化选项下的产品。 第四篇以微软公司附于Visual C++光碟片上的一个范例程序Scribble为主轴，一步一步加上新的功能。并在其间深入介绍Runtime Type Information（RTTI）、Dynamic Creation、Persistence（Serialization）、Message Mapping、Command Routing等核心技术。这些技术正是其他书籍最缺乏的部分。此篇之最后数章则脱离Scribble程序，另成一格。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第0章 你一定要知道（导读）</span><br><span class="line">这本书适合谁</span><br><span class="line">你需要什么技术基础</span><br><span class="line">你需要什么软硬件环境</span><br><span class="line">让我们使用同一种语言</span><br><span class="line">本书符号习惯</span><br><span class="line">本书例程的取得</span><br><span class="line">范例程序说明</span><br><span class="line">与前版本之差异</span><br><span class="line">如何联络作者</span><br><span class="line">第一篇 勿在浮砂筑高台</span><br><span class="line">第1章 Win32程序基本概念</span><br><span class="line">Win32程序开发流程</span><br><span class="line">需要什么函数库（.LIB）</span><br><span class="line">需要什么头文件（.H）</span><br><span class="line">以消息为基础，以事件驱动之（message based，event driven）</span><br><span class="line">一个具体而微的Win32程序</span><br><span class="line">程序进入点WinMain</span><br><span class="line">窗口类之注册与窗口之诞生</span><br><span class="line">消息循环</span><br><span class="line">窗口的生命中枢：窗口函数</span><br><span class="line">消息映射（Message Map）的雏形</span><br><span class="line">对话框的运行</span><br><span class="line">模块定义文件（.DEF）</span><br><span class="line">资源描述档（.RC）</span><br><span class="line">Widnows程序的生与死</span><br><span class="line">空闲时间的处理：OnIdle</span><br><span class="line">Console程序</span><br><span class="line">Console程序与DOS程序的差别</span><br><span class="line">Console程序的编译链接</span><br><span class="line">JBACKUP：Win32 Console程序设计</span><br><span class="line">MFCCON：MFC Console程序设计</span><br><span class="line">行程与线程（Process and Thread）</span><br><span class="line">核心对象</span><br><span class="line">一个行程的诞生与死亡</span><br><span class="line">产生子行程</span><br><span class="line">一个线程的诞生与死亡</span><br><span class="line">以_beginthreadex取代CreateThread</span><br><span class="line">线程优先级（Priority）</span><br><span class="line">多线程程序设计实例</span><br><span class="line">第2章 C++的重要性质</span><br><span class="line">类及其成员——谈封装（encapsulation）</span><br><span class="line">基类与派生类：谈继承（Inheritance）</span><br><span class="line">this指针</span><br><span class="line">虚拟函数与多态（Polymorphism）</span><br><span class="line">类与对象大解剖</span><br><span class="line">Object slicing与虚拟函数</span><br><span class="line">静态成员（变量与函数）</span><br><span class="line">C++程序的生与死：兼谈构造函数与解构函数</span><br><span class="line">四种不同的对象生存方式（in stack、in heap、global、local static）</span><br><span class="line">执行期类型信息（RTTI）</span><br><span class="line">动态生成（Dynamic Creation）</span><br><span class="line">异常处理（Exception Handling）</span><br><span class="line">Template</span><br><span class="line">Template Functions</span><br><span class="line">Template Classes</span><br><span class="line">Template的编译与链接</span><br><span class="line">第3章 MFC六大关键技术之仿真</span><br><span class="line">MFC类层次结构</span><br><span class="line">Frame 1范例程序</span><br><span class="line">MFC程序的初始化过程</span><br><span class="line">Frame 2范例程序</span><br><span class="line">RTTI（执行期类型识别）</span><br><span class="line">类别型录网与CRuntimeClass</span><br><span class="line">DECLARE_DYNAMIC&#x2F;IMPLEMENT_DYNAMIC宏</span><br><span class="line">Frame 3范例程序</span><br><span class="line">IsKindOf（类型识别）</span><br><span class="line">Frame 4范例程序</span><br><span class="line">Dynamic Creation（动态生成）</span><br><span class="line">DECLARE_DYNCREATE&#x2F;IMPLEMENT_DYNCREATE宏</span><br><span class="line">Frame 6范例程序</span><br><span class="line">Persistence（永久保存）机制</span><br><span class="line">Serialize（数据读写）</span><br><span class="line">DECLARE_SERIAL&#x2F;IMPLEMENT_SERIAL宏</span><br><span class="line">没有范例程序</span><br><span class="line">Message Mapping（消息映射）</span><br><span class="line">Frame 7范例程序</span><br><span class="line">Command Routing（命令传递）</span><br><span class="line">Frame 8范例程序</span><br><span class="line">本章回顾</span><br><span class="line">第二篇 欲善工事先利其器</span><br><span class="line">第4章 Visual C++集成开发环境</span><br><span class="line">安装与组成</span><br><span class="line">四个重要的工具</span><br><span class="line">内务府总管：Visual C++集成开发环境</span><br><span class="line">关于project</span><br><span class="line">关于工具设定</span><br><span class="line">Source Browser</span><br><span class="line">Online Help</span><br><span class="line">调试工具</span><br><span class="line">VC++调试器</span><br><span class="line">Exception Handling</span><br><span class="line">程序代码产生器：AppWizard</span><br><span class="line">东圈西点完成MFC程序骨干</span><br><span class="line">威力强大的资源编辑器</span><br><span class="line">Icon编辑器</span><br><span class="line">Cursor编辑器</span><br><span class="line">Bitmap编辑器</span><br><span class="line">工具栏（Toolbar）编辑器</span><br><span class="line">VERSIONINFO资源编辑器</span><br><span class="line">字符串表格（Accelerator）编辑器</span><br><span class="line">菜单（Menu）编辑器</span><br><span class="line">加速键（Accelerator）编辑器</span><br><span class="line">对话框（Dialog）编辑器</span><br><span class="line">Console程序的项目管理</span><br><span class="line">第三篇 浅出MFC程序设计</span><br><span class="line">第5章 总观Application Framework</span><br><span class="line">什么是Application Framework？</span><br><span class="line">侯捷怎么说</span><br><span class="line">我怎么说</span><br><span class="line">别人怎么说</span><br><span class="line">为什么使用Application Framework</span><br><span class="line">Microsoft Foundation Classes（MFC）</span><br><span class="line">白头宫女话天宝：Visual C++与MFC</span><br><span class="line">纵览MFC</span><br><span class="line">General Purpose classes</span><br><span class="line">CObject</span><br><span class="line">数据处理类（collection classes）</span><br><span class="line">杂项类</span><br><span class="line">异常处理类（exception handling classes）</span><br><span class="line">Windows API classes</span><br><span class="line">Application framework classes</span><br><span class="line">High level Abstractions</span><br><span class="line">Afx全局函数</span><br><span class="line">MFC宏（macros）</span><br><span class="line">MFC数据类型（data types）</span><br><span class="line">第6章 MFC程序的生死因果</span><br><span class="line">不二法门：熟记MFC类的层次结构</span><br><span class="line">需要什么函数库？</span><br><span class="line">需要什么头文件？</span><br><span class="line">简化的MFC程序结构——以Hello MFC为例</span><br><span class="line">Hello程序程序代码</span><br><span class="line">MFC程序的来龙去脉（causal relations）</span><br><span class="line">我只借用两个类：CWinApp和CFrameWnd</span><br><span class="line">CWinApp——取代WinMain的地位</span><br><span class="line">CFrameWnd——取代WndProc的地位</span><br><span class="line">引爆器——Application object</span><br><span class="line">隐晦不明的WinMain</span><br><span class="line">AfxWinInit——AFX内部初始化操作</span><br><span class="line">CWinApp：：InitApplication</span><br><span class="line">CMyWinApp：：InitInstance</span><br><span class="line">CFrameWnd：：Create产生主窗口（并先注册窗口类）</span><br><span class="line">奇怪的窗口类名称Afx：b：14ae：6：3e8f</span><br><span class="line">窗口显示与更新</span><br><span class="line">CWinApp：：Run——程序生命的活水源头</span><br><span class="line">把消息与处理函数连接在一起：Message Map机制</span><br><span class="line">来龙去脉总整理</span><br><span class="line">Callback函数</span><br><span class="line">空闲时间（idle time）的处理：OnIdle</span><br><span class="line">Dialog与Control</span><br><span class="line">通用对话框（Common Dialogs）</span><br><span class="line">本章回顾</span><br><span class="line">第7章 简单而完整：MFC骨干程序</span><br><span class="line">不二法门：熟记MFC类层次结构</span><br><span class="line">MFC程序的UI新风貌</span><br><span class="line">Document&#x2F;View支撑你的应用程序</span><br><span class="line">利用Visual C++工具完成Scribble step0</span><br><span class="line">骨干程序使用哪些MFC类？</span><br><span class="line">Document Template的意义</span><br><span class="line">Scribble的Document&#x2F;View设计</span><br><span class="line">主窗口的诞生</span><br><span class="line">工具栏和状态栏的诞生（Toolbar&amp;Status bar）</span><br><span class="line">鼠标拖放（Drag and Drop）</span><br><span class="line">消息映射（Message Map）</span><br><span class="line">标准菜单File&#x2F;Edit&#x2F;View&#x2F;Window&#x2F;Help</span><br><span class="line">对话框</span><br><span class="line">改用CEditView</span><br><span class="line">第四篇 深入MFC程序设计</span><br><span class="line">第8章 Document-View深入探讨</span><br><span class="line">为什么需要Document-View（形而上）</span><br><span class="line">Document</span><br><span class="line">View</span><br><span class="line">Document Frame（View Frame）</span><br><span class="line">Document Template</span><br><span class="line">CDocTemplate管理CDocument&#x2F;CView&#x2F;CFrameWnd</span><br><span class="line">Scribble Step1的Document——数据结构设计</span><br><span class="line">MFC Collection Classes的选用</span><br><span class="line">CScribbleDoc的修改</span><br><span class="line">文件：一连串的线条</span><br><span class="line">线条与坐标点</span><br><span class="line">Scribble Step 1的View：数据重绘与编辑</span><br><span class="line">CScribbleView的修改</span><br><span class="line">View的重绘操作：GetDocument和OnDraw</span><br><span class="line">ClassWizard的辅佐</span><br><span class="line">WizardBar的辅佐</span><br><span class="line">Serialize：对象的档案读写</span><br><span class="line">Serialization以外的档案读写操作</span><br><span class="line">台面上的Serialize操作</span><br><span class="line">台面下的Serialize写档奥秘</span><br><span class="line">台面下的Serialize读档奥秘</span><br><span class="line">DYNAMIC&#x2F;DYNCREATE&#x2F;SERIAL三宏</span><br><span class="line">Serializable的必要条件</span><br><span class="line">CObject类</span><br><span class="line">IsKindOf</span><br><span class="line">IsSerializable</span><br><span class="line">CObject：：Serialize</span><br><span class="line">CArchive类</span><br><span class="line">operator《和operator》</span><br><span class="line">效率考虑</span><br><span class="line">自定SERIAL宏给抽象类使用</span><br><span class="line">在CObList中加入CStroke以外的类</span><br><span class="line">Document与View交流——为Step4做准备</span><br><span class="line">第9章 消息映射与命令传递</span><br><span class="line">到底要解决什么</span><br><span class="line">消息分类</span><br><span class="line">万流归宗Command Target（CCmdTarget）</span><br><span class="line">三个奇怪的宏，一张巨大的网</span><br><span class="line">DECLARE_MESSAGE_MAP宏</span><br><span class="line">消息映射网的形成：BEGIN…&#x2F;ON…&#x2F;END…宏</span><br><span class="line">米诺托斯（Minotauros）与西修斯（Theseus）</span><br><span class="line">二万五千里长征——消息的传递</span><br><span class="line">直线上溯（一般Windows消息）</span><br><span class="line">拐弯上溯（WM_COMMAND命令消息）</span><br><span class="line">罗塞达碑石：AfxSig_xx的奥秘</span><br><span class="line">Scribble Step2：UI对象的变化</span><br><span class="line">改变菜单</span><br><span class="line">改变工具栏</span><br><span class="line">利用ClassWizard连接命令项识别码与命令处理函数</span><br><span class="line">维护UI对象状态（UPDATE_COMMAND_UI）</span><br><span class="line">本章回顾</span><br><span class="line">第10章 MFC与对话盒</span><br><span class="line">对话框编辑器</span><br><span class="line">利用ClassWizard连接对话框与其专用类</span><br><span class="line">对话框的消息处理函数</span><br><span class="line">对话框数据交换与校验（DDX&amp;DDV）</span><br><span class="line">如何唤起对话框</span><br><span class="line">本章回顾</span><br><span class="line">第11章 View功能的加强与重绘效率的提高</span><br><span class="line">同时修改多个Views：UpdateAllViews和OnUpdate</span><br><span class="line">在View中定义一个hint</span><br><span class="line">把hint传给OnUpdate</span><br><span class="line">利用hint增加重绘效率</span><br><span class="line">可卷动的窗口：CScrollView</span><br><span class="line">大窗口中的小窗口：Splitter</span><br><span class="line">切分窗口的功能</span><br><span class="line">切分窗口的程序概念</span><br><span class="line">切分窗口的实现</span><br><span class="line">本章回顾</span><br><span class="line">第12章 打印与预览</span><br><span class="line">概述</span><br><span class="line">打印操作的后台原理</span><br><span class="line">MFC默认的打印机制</span><br><span class="line">Scribble打印机制的增强</span><br><span class="line">打印机的页和文件的页</span><br><span class="line">配置GDI绘图工具</span><br><span class="line">尺寸与方向：关于映射方式（坐标系统）</span><br><span class="line">分页</span><br><span class="line">页眉与页脚</span><br><span class="line">动态计算页码</span><br><span class="line">打印预览（Print Preview）</span><br><span class="line">本章回顾</span><br><span class="line">第13章 多重文件与多重显示</span><br><span class="line">MDI和SDI</span><br><span class="line">多重显示（Multiple Views）</span><br><span class="line">窗口的动态切分</span><br><span class="line">窗口的静态切分</span><br><span class="line">CreateStatic和CreateView</span><br><span class="line">窗口的静态三叉切分</span><br><span class="line">Graph范例程序</span><br><span class="line">静态切分窗口之观念整理</span><br><span class="line">同源子窗口</span><br><span class="line">CMDIFrameWnd：：OnWindowNew</span><br><span class="line">Text范例程序</span><br><span class="line">非标准做法的缺点</span><br><span class="line">多重文件</span><br><span class="line">新的Cocument类</span><br><span class="line">新的Document Template</span><br><span class="line">新的UI系统</span><br><span class="line">新文件的档案读写操作</span><br><span class="line">第14章 MFC多线程程序设计</span><br><span class="line">从操作系统层面看线程</span><br><span class="line">三个观念：模块、行程和线程</span><br><span class="line">线程优先级（Priority）</span><br><span class="line">线程调度（Scheduling）</span><br><span class="line">Thread Context</span><br><span class="line">从程序设计层面看线程</span><br><span class="line">Worker Threads和UI Threads</span><br><span class="line">错误观念</span><br><span class="line">正确态度</span><br><span class="line">MFC多线程程序设计</span><br><span class="line">探索CWinThread</span><br><span class="line">产生一个Worker Thread</span><br><span class="line">产生一个UI Thread</span><br><span class="line">线程的结束</span><br><span class="line">线程与同步控制</span><br><span class="line">MFC多线程程序例程 </span><br><span class="line"></span><br><span class="line"> 第15章 定制一个AppWizard 到底Wizard是什么？ Custom AppWizard的基本操作 剖析AppWizard Components Dialog Templates和Dialog classes Macros Directives 动手修改Top Studio AppWizard 利用资源编辑器修改IDD_CUSTOM1对话框画面 利用ClassWizard修改IDD_CUSTOM1对话框的对应类CCustomlDlg 改写OnDismiss虚拟函数，在其中定义macros 修改text template Top Studio AppWizard执行结果 更多的信息 第16章 站上众人的肩膀——使用Components&amp;activeX Controls 什么是Component Gallery 使用Components Splash screen system Info for About Dlg Tip of the Day Components实际运用：ComTest程序 修改ComTest程序内容 使用ActiveX Controls ActiveX Control基础观念：Properties、Methods、Events ActiveX Controls的五大使用步骤 使用ActiveX Control：OcxTest程序 第五篇 附录 附录A 无责任书评：从摇篮到坟墓Windows的完全学习 无责任书评：MFC四大天王 附录B Scribble Step 5完整原始码 附录C Visual C++5.0MFC范例程序一览 附录D 以MFC重建DBWIN</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001175K4M/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001175K4M&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/513kK4gwD2L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数据结构和算法(第2版)</title>
    <url>/2020/04/19/B0011AN2VW/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Java数据结构和算法(第2版)<br>作者信息： 作者: 平均4.2 星  [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Java数据结构和算法》(第2版)以一种易懂的方式教授如何安排和操纵数据的问题，其中不乏一些难题：了解这些知识以期使计算机的应用获得最好的表现。不管使用何种语言或平台，掌握了数据结构和算法将改进程序的质量和性能。 《Java数据结构和算法》(第2版)提供了一套独创的可视讨论专题用以阐明主要的论题：它使用Java语言说明重要的概念，而避免了C/C++语言的复杂性，以便集中精力论述数据结构和算法。经验丰富的作者RorbertLafore先生提供了许多简单明了的例子，避免了对于这类例题常见的冗长、繁锁的数学证明。在第二版中，他利用Java语言最新特性，修改并扩充了他的例子。在每一章后都有问题和练习，使读者有机会测试自己的理解程度。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">出版说明 献词 简介 第1章 综述 数据结构和算法能起到什么作用? 数据结构的概述 算法的概述 一些定义 面向对象编程 软件工程 对于C++程序员的Java Java数据结构的类库 小结 问题 第2章 数组 Array专题Applet Java中数组的基础知识 将程序划分成类 类接口 Ordered专题applet 有序数组的Java代码 对数 存储对象 大O表示法 为什么不用数组表示一切? 小结 问题 实验 编程作业 第3章 简单排序 如何排序? 冒泡排序 选择排序 插入排序 对象排序 几种简单排序之间的比较 小结 问题 实验 编程作业 第4章 栈和队列 不同的结构类型 栈 队列 优先级队列 解析算术表达式 小结 问题 实验 编程作业 第5章 链表 链结点(Link) LinkList专题Applet 单链表 查找和删除指定链结点 双端链表 链表的效率 抽象数据类型 有序链表 双向链表 迭代器 小结 问题 实验 编程作业 第6章 递归 三角数字 阶乘 变位字 递归的二分查找 汉诺(Hanoi)塔问题 归并排序 消除递归 一些有趣的递归应用 小结 问题 实验 编程作业 第7章 高级排序 希尔排序 划分 快速排序 基数排序 小结 问题 实验 编程作业 第8章 二叉树 为什么使用二叉树? 树的术语 一个类比 二叉搜索树如何工作 查找节点 插入一个节点 遍历树 查找最大值和最小值 删除节点 二叉树的效率 用数组表示树 重复关键字 完整的tree.java程序 哈夫曼(Huffman)编码 小结 问题 实验 编程作业 第9章 红-黑树 第10章 2-3-4树和外部存储 第11章 哈希表 第12章 堆 第13章 图 第14章 带权图 第15章 应用场合 附录A 运行专题applet和示例程序 附录B 进一步学习 附录C 问题答案</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0011AN2VW/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0011AN2VW&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51FLhQFzEhL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Beginning iPad Application Development</title>
    <url>/2020/04/19/0470641657/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Beginning iPad Application Development<br>作者信息： 作者: 李伟萌 (Lee Wei Meng) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>“Beginning iPad Application Development” provides a comprehensive, hands-on approach to iPad development for aspiring iPad developers. The book is divided into three main parts: Part One walks the reader through developing their first iPad application while familiarizing the reader with Cocoa, Cocoa Touch, the iPhone and iPad SDK and the Xcode tools. Part Two will focus on the features and syntax of the Objective-C language which is essential for creating many iPad applications. Part Three will focus specifically on the features of the iPad and iPhone/iPad SDK and how the reader can best implement each of these features in their applications.</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Introduction.   Part I Getting Started. </span><br><span class="line"></span><br><span class="line"> Chapter 1 Getting Started with iPad Programming. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Chapter 2 Write Your First Hello World! Application. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Chapter 3 Views, Outlets, and Actions. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Chapter 4 View Controllers. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Chapter 5 Keyboard Inputs. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Chapter 6 Screen Rotations. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Part II Di splaying and Persisting Data? </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Chapter 7 Using the Table View. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Chapter 8 Application Preferences. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Chapter 9 File Handling. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Chapter 10 Database Storage Using SQLite3. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Part III advanced ip ad programming techniques. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Chapter 11 Simple Animations. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Chapter 12 Recognizing Gestures. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Chapter 13 Accessing the Accelerometer. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Part IV Network Programming. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Chapter 14 Web Services. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Chapter 15 Bluetooth Programming. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Chapter 16 Bonjour Programming. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Chapter 17 Apple Push Notification Services. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Chapter 18 Displaying Maps. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Part V Appendices. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Appendix A Answers to Exercises. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Appendix B Getting Around in Xcode. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Appendix C Getting Around in Interface Builder. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Appendix D Crash Course in Objective-C. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Index.</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/0470641657/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=0470641657&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51N6wU20lhL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>Java网络编程(第3版)</title>
    <url>/2020/04/19/B0011BD5DG/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Java网络编程(第3版)<br>作者信息： 作者: 哈诺德 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Java网络编程》不仅仅是对API的解释：它还展示了如何使用API。《Java网络编程》(第3版)有很多示例，包含了几千行可以实际工作的代码（所有代码都可以在线获得），实现了功能完整的网络客户端和服务器。无论是希望编写特殊用途的Web服务器、安全的在线订单接收程序、简单的组播代理还是电子邮件客户端，都会找到可供学习和借用的代码。    无论你是经验丰富的网络开发人员、Java程序员新手，还是只希望对Java网络编程稍有些了解的人，都会发现《Java网络编程》(第3版)将成为你的书库中一个重要的部分。一旦开始使用Java网络API，只要你能想到它就能够做得到。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前  言</span><br><span class="line">第一章  Java网络编程的原因</span><br><span class="line">  网络程序的功能</span><br><span class="line">  安全性</span><br><span class="line">  等等!还有更多!</span><br><span class="line">第二章  基本网络概念</span><br><span class="line">  网络</span><br><span class="line">  网络的分层</span><br><span class="line">  IP、TCP和UDP</span><br><span class="line">  Internet</span><br><span class="line">  客户／服务器模型</span><br><span class="line">  Internet标准</span><br><span class="line">第三章  基本Web概念</span><br><span class="line">  URI</span><br><span class="line">  HTML、SGML和XML</span><br><span class="line">    HTTP</span><br><span class="line">    MIME媒体类型</span><br><span class="line">    服务器端程序</span><br><span class="line">第四章  流</span><br><span class="line">  输出流</span><br><span class="line">  输人流</span><br><span class="line">  过滤器流</span><br><span class="line">  阅读器和书写器</span><br><span class="line">第五章  线程</span><br><span class="line">  运行线程</span><br><span class="line">  返回线程中的信息</span><br><span class="line">  同步</span><br><span class="line">  死锁</span><br><span class="line">  线程调度</span><br><span class="line">  线程池</span><br><span class="line">第六章  查找Internet地址</span><br><span class="line">  InetAddress类</span><br><span class="line">  Inet4Address和Inet6Address</span><br><span class="line">  NetworkInterface类</span><br><span class="line">  一些有用的程序</span><br><span class="line">第七章  U R L和U R I</span><br><span class="line">  URL类</span><br><span class="line">  URLEncoder和URLDecoder类</span><br><span class="line">  URI类</span><br><span class="line">  代理</span><br><span class="line">通过GET方法与服务器端程序通信</span><br><span class="line">访问受口令保护的网站</span><br><span class="line">第八章  Swing中的HTM L</span><br><span class="line">  组件上的HTML</span><br><span class="line">  JEditorPane</span><br><span class="line">  解析HTML</span><br><span class="line">  coOkie一</span><br><span class="line">第九章  客户端Socket</span><br><span class="line">  socket基础</span><br><span class="line">  用Telnet研究协议</span><br><span class="line">  Socket类</span><br><span class="line">  Socket异常</span><br><span class="line">  Socket地址</span><br><span class="line">  示例</span><br><span class="line">第十章  服务器socket</span><br><span class="line">  ServerSocket类</span><br><span class="line">  一些有用的服务器</span><br><span class="line">第十一章安全Socket</span><br><span class="line">  保护通信</span><br><span class="line">  创建安全客户端socket</span><br><span class="line">  SsLSocket类的方法</span><br><span class="line">  创建安全的服务器socket</span><br><span class="line">  SSLSerVerSocket类的方法</span><br><span class="line">第十二章  非阻塞I／O。</span><br><span class="line">  一个示例客户端</span><br><span class="line">  一个示例服务器</span><br><span class="line">  缓冲区</span><br><span class="line">  通道</span><br><span class="line">  就绪选择</span><br><span class="line">第十三章  UDP数据报和Socket</span><br><span class="line">    UDP协议</span><br><span class="line">    DatagramPacket类</span><br><span class="line">    DatagramSocket类</span><br><span class="line">    一些有用的应用程序</span><br><span class="line">    DatagramChannel</span><br><span class="line">第十四章  组播socket</span><br><span class="line">    何为组播socket?</span><br><span class="line">    使用组播socket</span><br><span class="line">    两个简单示例</span><br><span class="line">第十五章  URLConnection</span><br><span class="line">    打开URLConnection</span><br><span class="line">    读取服务器的数据</span><br><span class="line">    读取首部</span><br><span class="line">    配置连接</span><br><span class="line">    配置客户端的请求HTTP首部</span><br><span class="line">    向服务器写入数据</span><br><span class="line">    内容处理器</span><br><span class="line">    0bject方法</span><br><span class="line">    URLConnection的安全考虑</span><br><span class="line">    猜测MIME内容类型</span><br><span class="line">    HttpURLCOnnectiOn</span><br><span class="line">    缓存</span><br><span class="line">    JarURLCOnnectiOn</span><br><span class="line">第十六章  协议处理器</span><br><span class="line">  何为协议处理器7</span><br><span class="line">  URLStreamHandler类</span><br><span class="line">  编写协议处理器</span><br><span class="line">  更多协议处理器示例和技术</span><br><span class="line">  URLStreamHandlerFactory接口</span><br><span class="line">第十七章  内容处理器</span><br><span class="line">  何为内容处理器7</span><br><span class="line">  ContentHandler类</span><br><span class="line">  ContentHandlerFactory接口</span><br><span class="line">  FITS图片格式的内容处理器</span><br><span class="line">第十八  章远程方法调用</span><br><span class="line">  何为远程方法调用7</span><br><span class="line">  实现</span><br><span class="line">  在运行时加载类</span><br><span class="line">  java rmi包</span><br><span class="line">  jaVarmiregistry包</span><br><span class="line">  javarmiserver包</span><br><span class="line">第十九章  JavaMailAPI</span><br><span class="line">  何为JavaMail API?</span><br><span class="line">  发送电子邮件一</span><br><span class="line">  接收邮件</span><br><span class="line">  口令认证</span><br><span class="line">  地址一</span><br><span class="line">  URLName类</span><br><span class="line">  Message类</span><br><span class="line">  Part接口</span><br><span class="line">  多部分消息和附件</span><br><span class="line">  MIME消息</span><br><span class="line">  文件夹</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0011BD5DG/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0011BD5DG&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51BG9nLordL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Head First Java(中文版)(第2版)(涵盖Java5.0)</title>
    <url>/2020/04/19/B0011ESWGI/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Head First Java(中文版)(第2版)(涵盖Java5.0)<br>作者信息： 作者: 塞若 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Head First Java(中文版)(第2版)(涵盖Java5.0)》的图文并茂学习方式能让你快速地在脑海中掌握住知识。敞开心胸准备好学习这些关键性的主题：Java程序语言；面向对象程序开发；Swing图形化接口；使用Java API函数库；编写、测试与布署应用程序；处理异常；多线程；网络程序设计；集合与泛型。如果你想要看“一本正经”的书，去找其他的。但如果你真地想要好好地学习Java，你会需要《Head First Java》。这本书可是Amazon编辑推荐的十大好书之一!</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">序 1 进入Java的世界 Java的工作方式 Java的程序结构 剖析类 main（）方法 循环 条件分支 设计程序 术语制造机 谈话录 习题 2 拜访对象村 椅子大战 继承 覆盖 什么是类？ 创建你的第一个对象 使用main（） 猜数字 习题 3 认识变量 声明变量 Primitive主数据类型 Java关键字 引用变量 对象的声明与赋值 可回收堆空间 数组 习题 4 对象的行为 操作对象状态的方法 方法参数与返回类型 值传递 Getters与Setters 封装 数组中的引用 习题 5 超强力方法 创建战舰游戏 简单版 编写伪码 测试 编写程序 完成版 用Math.random（）产生随机数 预先输入好的程序 循环 类型转换 用Integer.parseInt（）转换字符串 习题 6 使用Java函数库 7 对象村的优质生活 8 深入多态 9 对象的前世今生 10 数字很重要 11 有风险的行为 12 看图说故事 13 使用Swing 14 保存对象 15 网络联机 16 数据结构 17 发布程序 18 分布式计算 附录A：程序料理决定版 附录B：十大遗珠之憾 索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0011ESWGI/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0011ESWGI&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/510548-Li3L._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法分析 Java语言描述(第2版)</title>
    <url>/2020/04/19/B001N6R9JK/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 数据结构与算法分析 Java语言描述(第2版)<br>作者信息： 作者: 韦斯 (Mark Allen Weiss) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《数据结构与算法分析:Java语言描述(第2版)》的特色如下：全面阐述新的Java 5.0编程语言和Java Collections库。改进内部设计，用图和实例阐述算法的实施步骤。第3章对表、栈和队列的讨论进行了全面修订。用一章专门讨论摊还分析和一些高级数据结构的实现。每章末尾的大量练习按照难易程度编排，以增强对关键概念的理解。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">译者序</span><br><span class="line">前言</span><br><span class="line">第1章 引论</span><br><span class="line">1.1 本书讨论的内容</span><br><span class="line">1.2 数学知识复习</span><br><span class="line">1.2.1 指数</span><br><span class="line">1.2.2 对数</span><br><span class="line">1.2.3 级数</span><br><span class="line">1.2.4 模运算</span><br><span class="line">1.2.5 证明的方法</span><br><span class="line">1.3 递归简论</span><br><span class="line">1.4 实现泛型特性构件pre-Java5</span><br><span class="line">1.4.1 使用Object表示泛型</span><br><span class="line">1.4.2 基本类型的包装</span><br><span class="line">1.4.3 使用接口类型表示泛型</span><br><span class="line">1.4.4 数组类型的兼容性</span><br><span class="line">1.5 利用Java5泛性实现泛型特性成分</span><br><span class="line">1.5.1 简单的泛型类和接口</span><br><span class="line">1.5.2 自动装箱&#x2F;拆箱</span><br><span class="line">1.5.3 带有限制的通配符</span><br><span class="line">1.5.4 泛型static方法</span><br><span class="line">1.5.5 类型限界</span><br><span class="line">1.5.6 类型擦除</span><br><span class="line">1.5.7 对于泛型的限制</span><br><span class="line">1.6 函数对象</span><br><span class="line">小结</span><br><span class="line">练习</span><br><span class="line">参考文献</span><br><span class="line">第2章 算法分析</span><br><span class="line">2.1 数学基础</span><br><span class="line">2.2 模型</span><br><span class="line">2.3 要分析的问题</span><br><span class="line">2.4 运行时间计算</span><br><span class="line">2.4.1 一个简单的例子</span><br><span class="line">2.4.2 一般法则</span><br><span class="line">2.4.3 最大子序列和问题的求解</span><br><span class="line">2.4.4 运行时间中的对数</span><br><span class="line">2.4.5 检验你的分析</span><br><span class="line">2.4.6 分析结果的准确性</span><br><span class="line">小结</span><br><span class="line">练习</span><br><span class="line">参考文献</span><br><span class="line">第3章 表、栈和队列</span><br><span class="line">3.1 抽象数据类型</span><br><span class="line">3.2 表ADT</span><br><span class="line">3.2.1 表的简单数组实现</span><br><span class="line">3.2.2 简单链表</span><br><span class="line">3.3 Java Collections API中的表</span><br><span class="line">3.3.1 Collection接口</span><br><span class="line">3.3.2 Iterator接口</span><br><span class="line">3.3.3 List接口、ArrayList类和LinkedList类</span><br><span class="line">3.3.4 例：remove方法对LinkedList类的使用</span><br><span class="line">3.3.5 关于ListIterator接口</span><br><span class="line">3.4 ArrayList类的实现</span><br><span class="line">3.4.1 基本类</span><br><span class="line">3.4.2 迭代器、Java嵌套类和内部类</span><br><span class="line">3.5 Linked List类的实现</span><br><span class="line">3.6 栈ADT</span><br><span class="line">3.6.1 栈模型</span><br><span class="line">3.6.2 栈的实现</span><br><span class="line">3.6.3 应用</span><br><span class="line">3.7 队列ADT</span><br><span class="line">3.7.1 队列模型</span><br><span class="line">3.7.2 队列的数组实现</span><br><span class="line">3.7.3 队列的应用</span><br><span class="line">小结</span><br><span class="line">练习</span><br><span class="line">第4章 树</span><br><span class="line">4.1 预备知识</span><br><span class="line">4.1.1 树的实现</span><br><span class="line">4.1.2 树的遍历及应用</span><br><span class="line">4.2 二叉树</span><br><span class="line">4.2.1 实现</span><br><span class="line">4.2.2 例子：表达式树</span><br><span class="line">4.3 查找树ADT——二叉查找树</span><br><span class="line">4.3.1 contains方法</span><br><span class="line">4.3.2 findMin方法和findMax方法</span><br><span class="line">4.3.3 insert方法</span><br><span class="line">4.3.4 remove方法</span><br><span class="line">4.3.5 平均情况分析</span><br><span class="line">4.4 AVL树</span><br><span class="line">4.4.1 单旋转</span><br><span class="line">4.4.2 双旋转</span><br><span class="line">4.5 伸展树</span><br><span class="line">4.5.1 一个简单的想法（不能直接使用）</span><br><span class="line">4.5.2 展开</span><br><span class="line">4.6 树的遍历</span><br><span class="line">4.7 B树</span><br><span class="line">4.8 标准库中的集合与映射</span><br><span class="line">4.8.1 关于Set接口</span><br><span class="line">4.8.2 关于Map接口</span><br><span class="line">4.8.3 TreeSet类和TreeMap类的实现</span><br><span class="line">4.8.4 使用多个映射的例</span><br><span class="line">小结</span><br><span class="line">练习</span><br><span class="line">参考文献</span><br><span class="line">第5章 散列</span><br><span class="line">5.1 一般想法</span><br><span class="line">5.2 散列函数</span><br><span class="line">5.3 分离链接法</span><br><span class="line">5.4 不用链表的散列表</span><br><span class="line">5.4.1 线性探测法</span><br><span class="line">5.4.2 平方探测法</span><br><span class="line">5.4.3 双散列</span><br><span class="line">5.5 再散列</span><br><span class="line">5.6 标准库中的散列表</span><br><span class="line">5.7 可扩散列</span><br><span class="line">小结</span><br><span class="line">练习</span><br><span class="line">参考文献</span><br><span class="line">第6章 优先队列（堆）</span><br><span class="line">6.1 模型</span><br><span class="line">6.2 一些简单的实现</span><br><span class="line">6.3 二叉堆</span><br><span class="line">6.3.1 结构性质</span><br><span class="line">6.3.2 堆序性质</span><br><span class="line">6.3.3 基本的堆操作</span><br><span class="line">6.3.4 其他的堆操作</span><br><span class="line">6.4 优先队列的应用</span><br><span class="line">6.4.1 选择问题</span><br><span class="line">6.4.2 事件模拟</span><br><span class="line">6.5 d-堆</span><br><span class="line">6.6 左式堆</span><br><span class="line">6.6.1 左式堆性质</span><br><span class="line">6.6.2 左式堆操作</span><br><span class="line">6.7 斜堆</span><br><span class="line">6.8 二项队列</span><br><span class="line">6.8.1 二项队列结构</span><br><span class="line">6.8.2 二项队列操作</span><br><span class="line">6.8.3 二项队列的实现</span><br><span class="line">6.9 标准库中的优先队列</span><br><span class="line">小结</span><br><span class="line">练习</span><br><span class="line">参考文献</span><br><span class="line">第7章 排序</span><br><span class="line">7.1 预备知识</span><br><span class="line">7.2 插入排序</span><br><span class="line">7.2.1 算法</span><br><span class="line">7.2.2 插入排序的分析</span><br><span class="line">7.3 一些简单排序算法的下界</span><br><span class="line">7.4 希尔排序</span><br><span class="line">7.5 堆排序</span><br><span class="line">7.6 归并排序</span><br><span class="line">7.7 快速排序</span><br><span class="line">7.7.1 选取枢纽元</span><br><span class="line">7.7.2 分割策略</span><br><span class="line">7.7.3 小数组</span><br><span class="line">7.7.4 实际的快速排序例程</span><br><span class="line">7.7.5 快速排序的分析</span><br><span class="line">7.7.6 选择问题的线性期望时间算法</span><br><span class="line">7.8 排序算法的一般下界</span><br><span class="line">7.9 桶式排序</span><br><span class="line">7.10 外部排序</span><br><span class="line">7.10.1 为什么需要一些新的算法</span><br><span class="line">7.10.2 外部排序模型</span><br><span class="line">7.10.3 简单算法</span><br><span class="line">7.10.4 多路合并</span><br><span class="line">7.10.5 多相合并</span><br><span class="line">7.10.6 替换选择</span><br><span class="line">小结</span><br><span class="line">练习题</span><br><span class="line">参考文献</span><br><span class="line">第8章 不相交集类</span><br><span class="line">8.1 等价关系</span><br><span class="line">8.2 动态等价性问题</span><br><span class="line">8.3 基本数据结构</span><br><span class="line">8.4 灵巧求并算法</span><br><span class="line">8.5 路径压缩</span><br><span class="line">8.6 路径压缩和按秩求并的最坏情形</span><br><span class="line">8.7 一个应用</span><br><span class="line">小结</span><br><span class="line">练习题</span><br><span class="line">参考文献</span><br><span class="line">第9章 图论算法</span><br><span class="line">9.1 若干定义</span><br><span class="line">9.2 拓扑排序</span><br><span class="line">9.3 最短路径算法</span><br><span class="line">9.3.1 无权最短路径</span><br><span class="line">9.3.2 Dijkstra算法</span><br><span class="line">9.3.3 具有负边值的图</span><br><span class="line">9.3.4 无圈图</span><br><span class="line">9.3.5 所有点对最短路径</span><br><span class="line">9.3.6 最短路径的例子</span><br><span class="line">9.4 网络流问题</span><br><span class="line">9.5 最小生成树</span><br><span class="line">9.5.1 Prim算法</span><br><span class="line">9.5.2 Kruskal算法</span><br><span class="line">9.6 深度优先搜索的应用</span><br><span class="line">9.6.1 无向图</span><br><span class="line">9.6.2 双连通性</span><br><span class="line">9.6.3 欧拉回路</span><br><span class="line">9.6.4 有向图</span><br><span class="line">9.6.5 查找强分支</span><br><span class="line">9.7 NP完全性介绍</span><br><span class="line">9.7.1 难与易</span><br><span class="line">9.7.2 NP类</span><br><span class="line">9.7.3 NP完全问题</span><br><span class="line">小结</span><br><span class="line">练习</span><br><span class="line">参考文献</span><br><span class="line">第10章 算法设计技巧</span><br><span class="line">10.1 贪婪算法</span><br><span class="line">10.1.1 一个简单的调度问题</span><br><span class="line">10.1.2 哈夫曼编码</span><br><span class="line">10.1.3 近似装箱问题</span><br><span class="line">10.2 分治算法</span><br><span class="line">10.2.1 分治算法的运行时间</span><br><span class="line">10.2.2 最近点问题</span><br><span class="line">10.2.3 选择问题</span><br><span class="line">10.2.4 一些算术问题的理论改进</span><br><span class="line">10.3 动态规划</span><br><span class="line">10.3.1 用一个表代替递归</span><br><span class="line">10.3.2 矩阵乘法的顺序安排</span><br><span class="line">10.3.3 最优二叉查找树</span><br><span class="line">10.3.4 所有点对最短路径</span><br><span class="line">10.4 随机化算法</span><br><span class="line">10.4.1 随机数发生器</span><br><span class="line">10.4.2 跳跃表</span><br><span class="line">10.4.3 素性测试</span><br><span class="line">10.5 回溯算法</span><br><span class="line">10.5.1 收费公路重建问题</span><br><span class="line">10.5.2 博弈</span><br><span class="line">小结</span><br><span class="line">练习</span><br><span class="line">参考文献</span><br><span class="line">第11章 摊还分析</span><br><span class="line">11.1 一个无关的智力问题</span><br><span class="line">11.2 二项队列</span><br><span class="line">11.3 斜堆</span><br><span class="line">11.4 斐波那契堆</span><br><span class="line">11.4.1 切除左式堆中的节点</span><br><span class="line">11.4.2 二项队列的懒惰合并</span><br><span class="line">11.4.3 斐波那契堆操作</span><br><span class="line">11.4.4 时间界的证明</span><br><span class="line">11.5 伸展树</span><br><span class="line">小结</span><br><span class="line">练习</span><br><span class="line">参考文献</span><br><span class="line">第12章 高级数据结构及其实现</span><br><span class="line">12.1 自顶向下伸展树</span><br><span class="line">12.2 红黑树</span><br><span class="line">12.2.1 自底向上的插入</span><br><span class="line">12.2.2 自顶向下红黑树</span><br><span class="line">12.2.3 自顶向下的删除</span><br><span class="line">12.3 确定性跳跃表</span><br><span class="line">12.4 AA树</span><br><span class="line">12.5 treap树</span><br><span class="line">12.6 k-d树</span><br><span class="line">12.7 配对堆</span><br><span class="line">小结</span><br><span class="line">练习</span><br><span class="line">参考文献</span><br><span class="line">索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001N6R9JK/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001N6R9JK&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51zi0VgO2yL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA核心技术卷2 高级特征</title>
    <url>/2020/04/19/B001O2SP2S/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： JAVA核心技术卷2 高级特征<br>作者信息： 作者: 霍斯特曼 (Cay S.Horstmann) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《JAVA核心技术卷2:高级特征》涵盖了Java SE 6平台的高级用户界面程序设计和企业特性。与第1卷（涵盖了核心的语言和类库特性）一样，本卷已经更新到了Java SE6。并且对新内容都作了重点标注。书中所有的示例程序都进行了详细的设计，用来演示最新的编程技术。并展示针对专业开发者在现实中所碰到的典型问题的最佳解决方案。《JAVA核心技术卷Ⅱ:高级特征》包含有关StAX API、JDBC 4、编译器API、脚本框架、闪屏和托盘API以及其他许多Java SE6改进特性的新章节。《JAVA核心技术卷2:高级特征》聚焦于Java语言中更高级的特性，包括下列内容：流与文件、网络、数据库编程、XML、JNDI与LDAP、国际化、高级GUI组件、Java 2D、JavaBeans、安全、RMI与Web服务、高级AWT、注解、本地方法。关于Java基础知识的讨论，包括接口与内部类、使用Swing的GUI编程、异常处理.泛型.集合和并发。读者可以查阅《Java核心技术，卷I：基础知识（原书第8版）》（ISBN：978-7-111-23950-5）。2006、2007年度CSDN、《程序员》杂志社、China-pub评选的十大IT技术图书之一、众多专业Java程序员启蒙读物、CSDN Java大版主等专家隆重推荐。针对Java SE 6平台进行了全面更新。涵盖Java语言高级特性。精心设计大量代码示例。与《Java编程思想》齐名的Java图书泰山北斗。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一章 流与文件</span><br><span class="line">1.1 流</span><br><span class="line">1.1.1 读入和写出字节</span><br><span class="line">1.1.2 完整的流家族</span><br><span class="line">1.1.3 组合流过滤器</span><br><span class="line">1.2 文本输入与输出</span><br><span class="line">1.2.1 如何写出文本输出</span><br><span class="line">1.2.2 如何读入文本输入</span><br><span class="line">1.2.3 以文本格式存储对象</span><br><span class="line">1.2.4 字符集</span><br><span class="line">1.3 读入和写出二进制数据</span><br><span class="line">1.3.1 随机访问文件</span><br><span class="line">1.4 ZIP文档</span><br><span class="line">1.5 对象流与序列化</span><br><span class="line">1.5.1 理解对象序列化的文件格式</span><br><span class="line">1.5.2 修改缺省的序列化机制</span><br><span class="line">1.5.3 序列化单例和类型安全的枚举</span><br><span class="line">1.5.4 版本管理</span><br><span class="line">1.5.5 为克隆使用序列化</span><br><span class="line">1.6 文件管理</span><br><span class="line">1.7 新I&#x2F;O</span><br><span class="line">1.7.1 内存映射文件</span><br><span class="line">1.7.2 缓冲区数据结构</span><br><span class="line">1.7.3 文件加锁机制</span><br><span class="line">1.8 正则表达式 </span><br><span class="line"></span><br><span class="line"> 第二章 XML 2.1 XML概述 2.1.1 XML文档的结构 2.2 解析XML文档 2.3 验证XML文档 2.3.1 文档类型定义 2.3.2 XML Schema 2.3.3 实用示例 2.4 使用XPath来定位信息 2.5 使用名字空间 2.6 流机制解析器 2.6.1 使用SAX解析器 2.6.2 使用StAX解析器 2.7 生成XML文档 2.7.1 使用StAX写出XML文档 2.8 XSL转换</span><br><span class="line"></span><br><span class="line"> 第三章 网络 3.1 连接到服务器 3.1.1 套接字超时 3.1.2 因特网地址 3.2 实现服务器 3.2.1 为多个客户端服务 3.2.2 半关闭 3.3 可中断套接字 3.4 发送E-Mail 3.5 建立URL连接 3.5.1 URL和URI 3.5.2 使用URL Connection获取信息 3.5.3 提交表单数据</span><br><span class="line"></span><br><span class="line"> 第四章 数据库编程 4.1 JDBC的设计 4.1.1 JDBC驱动程序类型 4.1.2 JDBC的典型用法 4.2 结构化查询语言 4.3 JDBC配置 4.3.1 数据库URL 4.3.2 驱动程序JAR文件 4.3.3 启动数据库 4.3.4 注册驱动器类 4.3.5 连接到数据库 4.4 执行SQL语句 4.4.1 管理连接、语句和结果集 4.4.2 分析SQL异常 4.4.3 组装数据库 4.5 执行查询操作 4.5.1 预备语句 4.5.2 读取和写出LOB 4.5.3 SQL转义 4.5.4 多结果集 4.5.5 获取自动生成键 4.6 可滚动和可更新的结果集 4.6.1 可滚动的结果集 4.6.2 可更新的结果集 4.7 行集 4.7.1 被缓存的行集 4.8 元数据 4.9 事务 4.9.1 保存点 4.9.2 批量更新 4.9.3 高级SQL类型 4.10 Web与企业应用中的连接管理 4.11 LDAP介绍 4.11.1 配置LDAP服务器 4.11.2 访问LDAP目录信息</span><br><span class="line"></span><br><span class="line"> 第五章 国际化 5.1 Locales 5.2 数字格式 5.2.1 货币 5.3 日期和时间 5.4 排序 5.4.1 排序强度 5.4.2 分解 10.5 消息格式化 10.5.1 选择格式 10.6 文本文件和字符集 10.6.1 源文件的字符编码 10.7 资源包 10.7.1 定位资源包 10.7.2 属性文件 10.7.3 包类 10.8 一个完整的例子</span><br><span class="line"></span><br><span class="line"> 第六章 高级Swing 6.1 列表 6.1.1 JList构件 6.1.2 列表模式 6.1.3 插入和移除值 6.1.4 值的绘制 6.2 表格 6.2.1 简单表格 6.2.2 表格模型 6.2.3对行和列的操作 6.3 树 6.3.1 简单的树 6.3.2 结点枚举 6.2.3 绘制结点 6.2.4 监听树事件 6.2.5 定制树模型 6.4 文本构件 6.4.1 文本构件中的修改跟踪 6.4.2 格式化的输入框 6.4.3 JSpinner构件 6.4.4 用JEditor Pane显示HTML 6.5 进度指示器 6.5.1 进度条 6.5.2 进度监视器 6.5.3 监视输入流的进度 6.6 构件组织器 6.6.1 分割面板 6.6.2 选项卡面板 6.6.3 桌面面板和内部框体 6.6.4 级联与平铺 6.6.5 否决属性设置</span><br><span class="line"></span><br><span class="line"> 第七章 高级 AWT 7.1 绘图操作流程 7.2 形状 7.2.1 使用形状类 7.3 区域 7.4 笔划 7.5 着色 7.6 坐标变换 7.7 剪切 7.8 透明与组合 7.9 绘图提示 7.10 图像的读取器和写入器 7.10.1 获得图像文件类型的读取器和写入器 7.10.2 读取和写入带有多个图像的文件 7.11 图像处理 7.11.1 构建光栅图像 7.11.2 图像过滤 7.12 打印 7.12.1 图形打印 7.12.2 打印多页文件 7.12.3 打印预览 7.12.4 打印服务程序 7.12.5 流打印服务程序 7.12.6 打印属性 7.13 剪贴板 7.13.1 数据传递的类和接口 7.13.2 传递文本 7.13.3 可传递的接口和数据风格 7.13.4 构建一个可传递的图像 7.13.5 通过系统剪贴板传递Java对象 7.13.6 使用本地剪贴板来传递对象引用 7.14 拖放操作 7.14.1 Swing对数据传递的支持 7.14.2 拖曳源 7.14.3 放置目标 7.15 平台集成 7.15.1 闪屏 7.15.2 启动桌面应用程序 7.15.3 系统托盘</span><br><span class="line"></span><br><span class="line"> 第八章 JavaBean构件 8.1 为何是Bean？ 8.2 编写Bean的过程 8.3 使用Bean构造应用程序 8.3.1 将Bean打包成JAR文件 8.3.2 在开发环境中组合Bean 8.4 Bean属性与事件的命名模式 8.5 Bean属性的类型 8.5.1 简单属性 8.5.2 索引属性 8.5.3 绑定属性 8.5.4 约束属性 8.6 BeanInfo类 8.7 属性编辑器 8.7.1 编写一个属性编辑器 8.8 定制器 8.8.1 编写一个定制器类 8.9 JavaBean持久化 8.9.1 JavaBean持久化可用于任何数据 8.9.2 一个JavaBean持久化的完整示例</span><br><span class="line"></span><br><span class="line"> 第九章 安全 9.1 类加载器 9.1.1 类加载器的层次结构 9.1.2 将类加载器作为命名空间 9.1.3 编写你自己的类加载器 9.2 字节码校验 9.3 安全管理器与访问权限 9.3.1 Java平台安全性 9.3.2 安全策略文件 9.3.3 定制权限 9.3.4 实现权限类 9.4 用户认证 9.4.1 JAAS 登录模块 9.5 数字签名 9.5.1 消息摘要 9.5.2 消息签名 9.5.3 X.509证书格式 9.5.4 校验签名 9.5.5 认证问题 9.5.6 证书签名 9.5.7 证书请求 9.6 代码签名 9.6.1 JAR文件签名 9.6.2 软件开发者证书 9.7 加密 9.7.1 对称密码 9.7.2 密钥生成 9.7.3 密码流 9.7.4 公共密钥密码</span><br><span class="line"></span><br><span class="line"> 第十章 分布式对象 10.1 客户与服务器的角色 10.2 远程方法调用 10.2.1 存根与参数编组 10.3 配置远程方法调用 10.3.1 接口与实现 10.3.2 RMI注册表 10.3.3 部署程序 10.3.4 记录RMI活动 10.4 远程方法中的参数和返回值 10.4.1 传递远程对象 10.4.2 传递非远程对象 10.4.3 动态类加载 10.4.4 具有多重接口的远程引用 10.4.5 远程对象与equals、hash Code和clone方法 10.5 远程对象激活 10.6 Web Services与JAX-WS 10.6.1 使用JAX-WS 10.6.2 Web服务的客户端 10.6.3 Amazon的E-Commerce服务</span><br><span class="line"></span><br><span class="line"> 第十一章 脚本、编译与注解处理 11.1 Java平台的脚本 11.1.1 获取脚本引擎 11.1.2 脚本赋值与绑定 11.1.3 重定向输入和输出 11.1.4 调用脚本的函数和方法 11.1.5 编译脚本 11.1.6 一个示例：用脚本处理GUI事件 11.2 编译器API 11.2.1 编译便捷之法 11.2.2 使用编译工具 11.2.3 一个示例：动态Java代码生成 11.3 使用注解 11.3.1 一个示例：注解事件处理器 11.4 注解语法 11.5 标准注解 11.5.1 用于编译的注解 11.5.2 用于管理资源的注解 11.5.3 元注解 11.6 源码级注解处理 11.7 字节码工程 11.7.1 载入时修改字节码</span><br><span class="line"></span><br><span class="line"> 第十二章 本地方法 12.1 从Java程序中调用C函数 12.2 数值参数与返回值 12.2.1 用printf格式化数字 12.3 字符串参数 12.4 访问对象域 12.4.1 访问实例域 12.4.2 访问静态域 12.5 编码签名 12.6 调用Java方法 12.6.1 实例方法 12.6.2 静态方法 12.6.3 构造器 12.6.4 替代方法调用 12.7 访问数组元素 12.8 错误处理 12.9 使用调用API 12.10 完整的示例：访问Windows注册表 12.10.1 Windows注册表概述 12.10.2 访问注册表的Java平台接口 12.10.3 以本地方法方式实现注册表访问函数</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001O2SP2S/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001O2SP2S&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51xfzJJIH9L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java编程思想(第4版)</title>
    <url>/2020/04/19/B0011F7WU4/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Java编程思想(第4版)<br>作者信息： 作者: 埃史尔 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Java编程思想(第4版)》获奖历史：·2003年《Software Development》杂志最佳书籍Jolt大奖·2003年《Java Developer’s Journal》读者选择最佳书籍奖·2001年《Java World》编辑选择最佳书籍奖·2000年《Java World》读者选择最佳书籍奖·1999年《Software Development》杂志最佳产品奖·1998年《Java Developer’s Journal》编辑选择最佳书籍奖</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">读者评论</span><br><span class="line">前言</span><br><span class="line">简介</span><br><span class="line">第1章 对象导论</span><br><span class="line">1.1 抽象过程</span><br><span class="line">1.2 每个对象都有一个接口</span><br><span class="line">1.3 每个对象都提供服务</span><br><span class="line">1.4 被隐藏的具体实现</span><br><span class="line">1.5 复用具体实现</span><br><span class="line">1.6 继承</span><br><span class="line">1.6.1 “是一个”（is-a）与“像是一个”（is-like-a）关系</span><br><span class="line">1.7 伴随多态的可互换对象</span><br><span class="line">1.8 单根继承结构</span><br><span class="line">1.9 容器</span><br><span class="line">1.9.1 参数化类型（范型）</span><br><span class="line">1.10 对象的创建和生命期</span><br><span class="line">1.11 异常处理：处理错误</span><br><span class="line">1.12 并发编程</span><br><span class="line">1.13 Java与Internet</span><br><span class="line">1.13.1 Web是什么</span><br><span class="line">1.13.2 客户端编程</span><br><span class="line">1.13.3 服务器端编程</span><br><span class="line">1.22 总结</span><br><span class="line">第2章 一切都是对象</span><br><span class="line">2.1 用引用操纵对象</span><br><span class="line">2.2 必须由你创建所有对象</span><br><span class="line">2.2.1 存储到什么地方</span><br><span class="line">2.2.2 特例：基本类型</span><br><span class="line">2.2.3 Java中的数组</span><br><span class="line">2.3 永远不需要销毁对象</span><br><span class="line">2.3.1 作用域</span><br><span class="line">2.3.2 对象的作用域</span><br><span class="line">2.4 创建新的数据类型：类</span><br><span class="line">2.4.1 域和方法</span><br><span class="line">2.4.2 基本成员默认值</span><br><span class="line">2.5 方法、参数和返回值</span><br><span class="line">2.5.1 参数列表</span><br><span class="line">2.6 构建一个Java程序</span><br><span class="line">2.6.1 名字可见性</span><br><span class="line">2.6.2 运用其他构件</span><br><span class="line">2.6.3 static 关键字</span><br><span class="line">2.7 你的第一个Java程序</span><br><span class="line">编译和运行</span><br><span class="line">2.8 注释和嵌入式文档</span><br><span class="line">2.8.1 注释文档</span><br><span class="line">2.8.2 语法</span><br><span class="line">2.8.3 嵌入式HTML</span><br><span class="line">2.8.4 一些标签示例</span><br><span class="line">2.8.5 文档示例</span><br><span class="line">2.9 编码风格</span><br><span class="line">2.10 总结</span><br><span class="line">2.11 练习</span><br><span class="line">第3章 操作符</span><br><span class="line">3.1 更简单的打印语句</span><br><span class="line">3.2 使用Java操作符</span><br><span class="line">3.3 优先级</span><br><span class="line">3.4 赋值</span><br><span class="line">3.4.1 方法调用中的别名问题</span><br><span class="line">3.5 算术操作符</span><br><span class="line">3.5.1 一元加、减操作符</span><br><span class="line">3.6 自动递增和递减</span><br><span class="line">3.7 关系操作符</span><br><span class="line">3.7.1 测试对象的等价性</span><br><span class="line">3.8 逻辑操作符</span><br><span class="line">3.8.1 短路</span><br><span class="line">3.9 直接常量</span><br><span class="line">3.9.1 指数记数法</span><br><span class="line">3.10 按位操作符</span><br><span class="line">3.11 移位操作符</span><br><span class="line">3.12 三元操作符 if-else</span><br><span class="line">3.13 字符串操作符 + 和 +&#x3D;</span><br><span class="line">3.14 使用操作符时常犯的错误</span><br><span class="line">3.15 类型转换操作符</span><br><span class="line">3.15.1 截尾和舍入</span><br><span class="line">3.15.2提升</span><br><span class="line">3.16 Java没有“sizeof”</span><br><span class="line">3.17 操作符小结</span><br><span class="line">3.18 总结</span><br><span class="line">第4章 控制执行流程</span><br><span class="line">4.1 true和false</span><br><span class="line">4.2 if-else</span><br><span class="line">4.3 迭代</span><br><span class="line">4.3.1 do-while</span><br><span class="line">4.3.2 for</span><br><span class="line">4.3.3 逗号操作符</span><br><span class="line">4.4 Foreach语法</span><br><span class="line">4.5 return</span><br><span class="line">4.6 break和 continue</span><br><span class="line">4.7 臭名昭著的“goto”</span><br><span class="line">4.8 switch</span><br><span class="line">4.9 总结</span><br><span class="line">第5章 初始化与清理</span><br><span class="line">5.1 用构造器确保初始化</span><br><span class="line">5.2 方法重载</span><br><span class="line">5.2.1 区分重载方法</span><br><span class="line">5.2.2 涉及基本类型的重载</span><br><span class="line">5.2.3 以返回值区分重载方法</span><br><span class="line">5.3 缺省构造器</span><br><span class="line">5.4 this关键字</span><br><span class="line">5.4.1 在构造器中调用构造器</span><br><span class="line">5.4.2 static的含义</span><br><span class="line">5.5 清理：终结处理和垃圾回收</span><br><span class="line">5.5.1 finalize()的用途何在</span><br><span class="line">5.5.2 你必须实施清理</span><br><span class="line">5.5.3 终结条件</span><br><span class="line">5.5.4 垃圾回收器如何工作</span><br><span class="line">5.6 成员初始化</span><br><span class="line">5.6.1 指定初始化</span><br><span class="line">5.7 构造器初始化</span><br><span class="line">5.7.1 初始化顺序</span><br><span class="line">5.7.2. 静态数据的初始化</span><br><span class="line">5.7.3. 显式的静态初始化</span><br><span class="line">5.7.4. 非静态实例初始化</span><br><span class="line">5.8 数组初始化</span><br><span class="line">5.8.1 可变参数列表</span><br><span class="line">5.9 枚举类型</span><br><span class="line">5.10 总结</span><br><span class="line">第6章 访问权限控制</span><br><span class="line">第7章 复用类</span><br><span class="line">第8章 多态</span><br><span class="line">第9章 接口</span><br><span class="line">第10章 内部类</span><br><span class="line">第11章 持有对象</span><br><span class="line">第12章 通过异常处理错误</span><br><span class="line">第13章 字符串</span><br><span class="line">第14章 类型信息</span><br><span class="line">第15章 泛型</span><br><span class="line">第16章 数组</span><br><span class="line">第17章 容器深入研究</span><br><span class="line">第18章 Java I&#x2F;O系统</span><br><span class="line">第19章 枚举类型</span><br><span class="line">第20章 注解</span><br><span class="line">第21章 并发</span><br><span class="line">第22章 图形化用户界面</span><br><span class="line">附录A 补充材料</span><br><span class="line">可下载的补充材料</span><br><span class="line">Thinking in C：Java的基础</span><br><span class="line">Java编程思想 研讨课</span><br><span class="line">Hands-on Java研讨课CD</span><br><span class="line">Thinking in Objects研讨课</span><br><span class="line">Thinking in Enterprise Java</span><br><span class="line">Thinking in Patterns(with Java)</span><br><span class="line">Thinking in Patterns研讨课</span><br><span class="line">设计咨询与复审</span><br><span class="line">附录B 资源</span><br><span class="line">软件</span><br><span class="line">编辑器与IDE</span><br><span class="line">书籍</span><br><span class="line">分析与设计</span><br><span class="line">Python</span><br><span class="line">我的著作列表</span><br><span class="line">索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0011F7WU4/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0011F7WU4&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51lMLob62AL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Sun 公司核心技术丛书 Effective Java中文版(第2版)</title>
    <url>/2020/04/19/B001PTGR52/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Sun 公司核心技术丛书 Effective Java中文版(第2版)<br>作者信息： 作者: Joshua Bloch [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Sun 公司核心技术丛书:Effective Java中文版(第2版)》内容全面，结构清晰，讲解详细。可作为技术人员的参考用书。编码平添乐趣，程序更加完美，高效成为习惯，工作如此轻松。你是否正在寻找一本能够更加深入地了解Java编程语言的书，以便编写出更清晰、更正确、更健壮且更易于重用的代码。不用找了！《Sun 公司核心技术丛书:Effective Java中文版(第2版)》为我们带来了共78条程序员必备的经验法则，针对你每天都会遇到的编程问题提出了最有效、最实用的解决方案。这本经典Jolt获奖作品实属众望所归。作者对新版进行了彻底的更新。涵盖了自第l版之后所引入的Java E5和Java SE 6的特性，同时开发了新的设计模式和语言习惯用法，介绍了如何充分利用从泛型到枚举、从注解到自动装箱的各种特性。每一章都包含几个“条目”，以简洁的形式呈现，自成独立的短文，它们提出了具体的建议，对于Java平台精妙之处的独到见解，以及优秀的代码范例。每个条目的综合描述和解释都阐明了应该怎么做，不应该怎么做，以及为什么。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">译者序</span><br><span class="line">序</span><br><span class="line">前言</span><br><span class="line">致谢</span><br><span class="line">第1章 引言</span><br><span class="line">第2章 创建和销毁对象</span><br><span class="line">第1条：考虑用静态工厂方法代替构造器</span><br><span class="line">第2条：遇到多个构造器参数时要考虑用构建器</span><br><span class="line">第3条：用私有构造器或者枚举类型强化Singleton属性</span><br><span class="line">第4条：通过私有构造器强化不可实例化的能力</span><br><span class="line">第5条：避免创建不必要的对象</span><br><span class="line">第6条：消除过期的对象引用</span><br><span class="line">第7条：避免使用终结方法 </span><br><span class="line"></span><br><span class="line"> 第3章 对于所有对象都通用的方法 第8条：覆盖equals时请遵守通用约定 第9条：覆盖equals时总要覆盖hashCode 第10条：始终要覆盖toString 第11条：谨慎地覆盖clone 第12条：考虑实现Comparable接口</span><br><span class="line"></span><br><span class="line"> 第4章 类和接口 第13条：使类和成员的可访问性最小化 第14条：在公有类中使用访问方法而非公有域 第15条：使可变性最小化 第16条：复合优先于继承 第17条：要么为继承而设计，并提供文档说明，要么就禁止继承 第18条：接口优于抽象类 第19条：接口只用于定义类型 第20条：类层次优于标签类 第21条：用函数对象表示策略 第22条：优先考虑静态成员类</span><br><span class="line"></span><br><span class="line"> 第5章 泛型 第23条：请不要在新代码中使用原生态类型 第24条：消除非受检警告 第25条：列表优先于数组 第26条：优先考虑泛型 第27条：优先考虑泛型方法 第28条：利用有限制通配符来提升API的灵活性 第29条：优先考虑类型安全的异构容器</span><br><span class="line"></span><br><span class="line"> 第6章 枚举和注解 第30条：用enum代替int常量 第31条：用实例域代替序数 第32条：用EnumSet代替位域 第33条：用EnumMap代替序数索引 第34条：用接口模拟可伸缩的枚举 第35条：注解优先于命名模式 第36条：坚持使用Override注解 第37条：用标记接口定义类型</span><br><span class="line"></span><br><span class="line"> 第7章 方法 第38条：检查参数的有效性 第39条：必要时进行保护性拷贝 第40条：谨慎设计方法签名 第41条：慎用重载 第42条：慎用可变参数 第43条：返回零长度的数组或者集合，而不是：null 第44条：为所有导出的API元素编写文档注释</span><br><span class="line"></span><br><span class="line"> 第8章 通用程序设计 第45条：将局部变量的作用域最小化 第46条：for-each循环优先于传统的for循环 第47条：了解和使用类库 第48条：如果需要精确的答案，请避免使用float和double 第49条：基本类型优先于装箱基本类型 第50条：如果其他类型更适合，则尽量避免使用字符串 第51条：当心字符串连接的性能 第52条：通过接口引用对象 第53条：接口优先于反射机制 第54条：谨慎地使用本地方法 第55条：谨慎地进行优化 第56条：遵守普遍接受的命名惯例</span><br><span class="line"></span><br><span class="line"> 第9章 异常 第57条：只针对异常的情况才使用异常 第58条：对可恢复的情况使用受检异常，对编程错误使用运行时异常 第59条：避免不必要地使用受检的异常 第60条：优先使用标准的异常 第61条：抛出与抽象相对应的异常 第62条：每个方法抛出的异常都要有文档 第63条：在细节消息中包含能捕获失败的信息 第64条：努力使失败保持原子性 第65条：不要忽略异常</span><br><span class="line"></span><br><span class="line"> 第10章 并发 第66条：同步访问共享的可变数据 第67条：避免过度同步 第68条：executor和task优先干线程 第69条：并发工具优先于wait和notify 第70条：线程安全性的文档化 第71条：慎用延迟初始化 第72条：不要依赖于线程调度器 第73条：避免使用线程组</span><br><span class="line"></span><br><span class="line"> 第11章 序列化 第74条：谨慎地实现Serializable接口 第75条：考虑使用自定义的序列化形式 第76条：保护性地编写readObject方法 第77条：对于实例控制，枚举类型优先于readResolve 第78条：考虑用序列化代理代替序列化实例</span><br><span class="line"></span><br><span class="line"> 附录 第1版与第2版条目对照 中英文术语对照 参考文献</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001PTGR52/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001PTGR52&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/514-GuJmACL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Struts 2.1权威指南</title>
    <url>/2020/04/19/B002A7XPPS/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Struts 2.1权威指南<br>作者信息： 作者: 浏览全部评论  [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Struts 2.1权威指南》特点为：1.经验丰富，针对性强《Struts 2.1权威指南》凝聚了作者大量的实际开发经验和感悟。作者依照读者的学习规律，首先介绍基本概念和基本操作，然后对内容进行深入讲解。2.讲解具体，示范典型书中通过大量的示范性实例(全书范例近百个)，逐一、详细地讲解了Struts2各知识点的用法，并细致地讲解每个用法的各种参数、选项，可以帮助读者入门到精通。3.配合案例，快速提高《Struts 2.1权威指南》最后配备了几个非常常见的案例，可以让读者在掌握前而的基础知识点的情况下，将所有知识融会贯通，把基础知识点应用项目开发过程中。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章  Struts 2概述 1</span><br><span class="line">1.1  MVC思想概述    2</span><br><span class="line">1.1.1  Web技术的发展   2</span><br><span class="line">1.1.2  Model 1和Model 2    4</span><br><span class="line">1.1.3  MVC思想及其优势    6</span><br><span class="line">1.1.4  常用的MVC框架   7</span><br><span class="line">1.2  Struts 2的起源和背景 8</span><br><span class="line">1.2.1  Struts 1简介及存在的问题 9</span><br><span class="line">1.2.2  WebWork简介    12</span><br><span class="line">1.2.3  Struts 2起源   15</span><br><span class="line">1.3  Struts 2体系介绍   16</span><br><span class="line">1.3.1  Struts 2框架架构 16</span><br><span class="line">1.3.2  Struts 2的配置文件  17</span><br><span class="line">1.3.3  Strut 2的标签库  18</span><br><span class="line">1.3.4  Struts 2的控制器组件   19</span><br><span class="line">1.4  Struts 2与Struts 1的对比   20</span><br><span class="line">1.5  WebWork和Struts 2对比   21</span><br><span class="line">1.6  本章小结   22 </span><br><span class="line"></span><br><span class="line"> 第2章 Struts 2下的HelloWorld 23 2.1 下载和安装Struts 2框架 23 2.2 从用户请求开始 25 2.3 创建Struts 2的Web应用 27 2.3.1 创建Web应用 27 2.3.2 增加Struts 2功能 28 2.4 实现控制器 28 2.4.1 实现控制器类 29 2.4.2 配置Action 30 2.4.3 增加视图资源完成应用 30 2.5 改进控制器 32 2.5.1 实现Action接口 32 2.5.2 跟踪用户状态 33 2.5.3 添加处理信息 35 2.5.4 输出处理信息 37 2.6 改进视图组件 39 2.6.1 改善输出页面 39 2.6.2 使用UI标签简化表单页面 40 2.7 完成程序国际化 42 2.7.1 定义国际化资源文件 42 2.7.2 加载资源文件 43 2.7.3 输出国际化信息 44 2.8 增加数据校验 46 2.8.1 继承ActionSupport 46 2.8.2 使用Struts 2的校验框架 49 2.9 本章小结 51</span><br><span class="line"></span><br><span class="line"> 第3章 Struts 2基础 52 3.1 WebWork的MVC实现 52 3.1.1 WebWork的下载和安装 53 3.1.2 实现Action 53 3.1.3 配置Action 56 3.1.4 完成数据校验 58 3.1.5 完成应用流程 59 3.2 在Eclipse中开发Struts 2 60 3.2.1 创建Web应用 61 3.2.2 增加Struts 2支持 63 3.2.3 部署Struts 2应用 64 3.2.4 增加应用的Action 65 3.3 Struts 2的基本流程 66 3.3.1 核心控制器：FilterDispatcher 66 3.3.2 业务控制器 67 3.3.3 Struts 2的模型组件 67 3.3.4 Struts 2的视图组件 68 3.3.5 Struts 2的运行流程 68 3.4 Struts 2的基本配置 69 3.4.1 配置web.xml文件 69 3.4.2 struts.xml配置文件 71 3.4.3 struts.properties配置文件 74 3.4.4 struts.xml文件结构 78 3.5 本章小结 82</span><br><span class="line"></span><br><span class="line"> 第4章 深入Struts 2 83 4.1 深入Struts 2的配置文件 83 4.1.1 Bean配置 84 4.1.2 常量配置 85 4.1.3 包配置 87 4.1.4 命名空间配置 89 4.1.5 包含配置 91 4.1.6 拦截器配置 91 4.2 Struts 2的Action 92 4.2.1 实现Action处理类 92 4.2.2 Action访问Servlet API 97 4.2.3 Action直接访问Servlet API 100 4.2.4 配置Action 103 4.2.5 配置Action的默认处理类 104 4.2.6 动态方法调用 105 4.2.7 为action元素指定method 4.2.7 属性 107 4.2.8 使用通配符 109 4.2.9 配置默认Action 115 4.3 管理处理结果 116 4.3.1 处理结果的改进 116 4.3.2 配置结果 117 4.3.3 Struts 2支持的处理结果 4.2.7 类型 118 4.3.4 plainText结果类型 120 4.3.5 redirect结果类型 123 4.3.6 redirectAction结果类型 124 4.3.7 动态结果 125 4.3.8 请求参数决定结果 126 4.3.9 全局结果 129 4.4 属性驱动和模型驱动 130 4.4.1 模型的作用 130 4.4.2 使用模型驱动 131 4.5 Struts 2的异常机制 134 4.5.1 Struts 2的异常处理哲学 135 4.5.2 声明式异常捕捉 136 4.5.3 输出异常信息 139 4.6 未知处理器 141 4.7 本章小结 143</span><br><span class="line"></span><br><span class="line"> 第5章 Struts 2的类型转换 144 5.1 类型转换的意义 145 5.1.1 表现层数据处理 145 5.1.2 类型转换 145 5.2 Struts 2内建的类型转换器 149 5.3 基于OGNL的类型转换 151 5.4 自定义类型转换器 155 5.4.1 系统需求 155 5.4.2 实现类型转换器 157 5.4.3 局部类型转换器 159 5.4.4 全局类型转换器 161 5.4.5 基于Struts 2的类型转换器 163 5.4.6 数组属性的类型转换器 165 5.4.7 集合属性的类型转换器 168 5.5 集合类型转换的高级特性 170 5.5.1 指定集合元素的类型 170 5.5.2 为Set集合的元素指定 4.2.7 索引属性 172 5.6 类型转换中错误处理 174 5.6.1 类型转换的错误处理流程 174 5.6.2 处理类型转换错误 176 5.6.3 输出类型转换错误 176 5.6.4 处理集合属性的转换错误 179 5.7 本章小结 182</span><br><span class="line"></span><br><span class="line"> 第6章 Struts 2的输入校验 183 6.1 输入校验概述 184 6.1.1 为什么需要输入校验 184 6.1.2 客户端校验 185 6.1.3 服务器端校验 187 6.1.4 类型转换和输入校验 191 6.2 基本输入校验 192 6.2.1 编写校验规则文件 192 6.2.2 国际化提示信息 195 6.2.3 使用客户端校验 197 6.3 校验器的配置风格 200 6.3.1 字段校验器配置风格 201 6.3.2 非字段校验器配置风格 201 6.3.3 短路校验器 203 6.3.4 校验顺序和短路 205 6.4 校验文件的搜索规则 205 6.5 内建校验器 208 6.5.1 注册校验器 208 6.5.2 必填校验器 210 6.5.3 必填字符串校验器 210 6.5.4 整数校验器 211 6.5.5 日期校验器 212 6.5.6 表达式校验器 213 6.5.7 字段表达式校验器 213 6.5.8 邮件地址校验器 214 6.5.9 网址校验器 215 6.5.10 Visitor校验器 216 6.5.11 转换校验器 219 6.5.12 字符串长度校验器 220 6.5.13 正则表达式校验器 221 6.6 基于Annotation的输入校验 221 6.7 手动完成输入校验 223 6.7.1 重写validate()方法 223 6.7.2 重写validateXxx()方法 225 6.7.3 Struts 2的输入校验流程 227 6.8 本章小结 228</span><br><span class="line"></span><br><span class="line"> 第7章 上传和下载文件 229 7.1 文件上传的原理 230 7.1.1 表单元素的enctype属性 230 7.1.2 手动上传 233 7.1.3 使用上传框架完成上传 235 7.2 Struts 2的文件上传 241 7.2.1 Struts 2的文件上传支持 241 7.2.2 实现文件上传的Action 242 7.2.3 配置文件上传的Action 244 7.2.4 手动实现文件过滤 246 7.2.5 拦截器实现文件过滤 249 7.2.6 输出错误提示 250 7.2.7 文件上传的常量配置 252 7.3 使用Pell上传 252 7.4 同时上传多个文件 253 7.4.1 使用数组同时上传多个文件 254 7.4.2 使用List同时上传多个文件 257 7.5 使用Struts 2控制文件下载 258 7.5.1 实现文件下载的Action 259 7.5.2 配置Action 260 7.5.3 下载前的授权控制 261 7.6 本章小结 263</span><br><span class="line"></span><br><span class="line"> 第8章 Struts 2的国际化 264 8.1 程序国际化简介 265 8.1.1 程序国际化的意义 265 8.1.2 Java国际化的思路 265 8.1.3 Java支持的语言和国家 266 8.1.4 完成程序国际化 267 8.1.5 使用MessageFormat处理 8.1.5 带占位符的消息 269 8.1.6 使用类文件代替资源文件 270 8.2 Struts 2的国际化入门 271 8.2.1 加载全局资源文件 271 8.2.2 访问国际化消息 272 8.2.3 输出带占位符的国际化消息 275 8.3 加载资源文件的不同方式 277 8.3.1 包范围资源文件 277 8.3.2 Action范围资源文件 279 8.3.3 临时指定资源文件 279 8.3.4 加载资源文件的顺序 281 8.4 允许用户自行选择程序语言 282 8.4.1 Struts 2国际化的运行机制 282 8.4.2 创建下拉列表框 283 8.4.3 选择程序语言 286 8.5 本章小结 287</span><br><span class="line"></span><br><span class="line"> 第9章 Struts 2的标签库 288 9.1 Struts 2标签库概述 289 9.1.1 标签的优势 289 9.1.2 Struts 2的标签分类 290 9.2 Struts 2标签入门 291 9.2.1 使用Struts 2标签的准备 291 9.2.2 Struts 2的OGNL表达式 9.2.2 语言 292 9.2.3 OGNL中的集合操作 295 9.2.4 访问静态成员 296 9.2.5 Lambda（λ）表达式 296 9.3 控制标签 297 9.3.1 if&#x2F;elseif&#x2F;else标签 297 9.3.2 iterator标签 298 9.3.3 append标签 300 9.3.4 generator标签 302 9.3.5 merge标签 304 9.3.6 subset标签 304 9.3.7 sort标签 307 9.4 数据标签 309 9.4.1 action标签 309 9.4.2 bean标签 311 9.4.3 date标签 313 9.4.4 debug标签 314 9.4.5 include标签 315 9.4.6 param标签 316 9.4.7 push标签 316 9.4.8 set标签 317 9.4.9 url标签 319 9.4.10 property标签 320 9.5 主题和模板 321 9.5.1 选择主题 321 9.5.2 自定义主题 323 9.6 表单标签 325 9.6.1 表单标签的通用属性 325 9.6.2 表单标签的name和 9.6.2 value属性 328 9.6.3 checkboxlist标签 328 9.6.4 combobox标签 331 9.6.5 doubleselect标签 331 9.6.6 head标签 334 9.6.7 optiontransferselect标签 334 9.6.8 select标签 336 9.6.9 radio标签 337 9.6.10 optgroup标签 338 9.6.11 token标签 340 9.6.12 updownselect标签 341 9.7 非表单标签 343 9.7.1 actionerror和actionmessage 9.7.1 标签 343 9.7.2 component标签 344 9.8 本章小结 347</span><br><span class="line"></span><br><span class="line"> 第10章 Struts 2的拦截器 348 10.1 理解拦截器 349 10.1.1 理解DRY规则 349 10.1.2 拦截器的意义 350 10.1.3 拦截器的实现原理 352 10.1.4 拦截器和AOP的关系 356 10.1.5 拦截器在Struts 2中的作用 357 10.2 拦截器配置初步 359 10.2.1 配置拦截器 359 10.2.2 使用拦截器 361 10.2.3 配置默认拦截器 362 10.3 Struts 2内建的拦截器 365 10.3.1 Struts 2内建的拦截器 365 10.3.2 struts-default.properties里 10.3.2 配置的拦截器 366 10.4 开发自己的拦截器 370 10.4.1 实现拦截器类 371 10.4.2 使用拦截器 372 10.4.3 拦截器和Struts 2插件的 10.4.3 关系 374 10.5 深入拦截器编程 375 10.5.1 拦截方法的拦截器 375 10.5.2 拦截器的执行顺序 378 10.5.3 拦截结果的监听器 380 10.5.4 覆盖拦截器栈里特定 10.5.4 拦截器的参数 381 10.6 拦截器示例：实现权限控制 383 10.6.1 实现拦截器类 383 10.6.2 配置权限控制拦截器 384 10.7 本章小结 386</span><br><span class="line"></span><br><span class="line"> 第11章 Struts 2的Ajax支持 387 11.1 Ajax概述 388 11.1.1 Ajax的起源和变革 388 11.1.2 Ajax的核心技术 391 11.2 Struts 2提供的Ajax支持 393 11.3 基于Dojo的异步表单 397 11.3.1 安装Dojo插件 398 11.3.2 定义异步表单 398 11.3.3 实现Action 400 11.3.4 实现服务器响应页面 402 11.4 基于Dojo的pub-sub事件 11.4 模型 403 11.4.1 pub-sub的原理 404 11.4.2 pub-sub的示例 405 11.4.3 阻止请求 407 11.5 基于Dojo的Ajax标签 407 11.5.1 div标签 407 11.5.2 submit和a标签 414 11.5.3 autocompleter标签 419 11.5.4 tabbedpanel标签 426 11.5.5 datetimepicker 430 11.5.6 tree和treenode 432 11.5.7 textarea 435 11.5.8 bind 436 11.6 基于JSON插件的Ajax 11.6 实现 438 11.6.1 JSON的基本知识 438 11.6.2 安装Struts 2的JSON插件 441 11.6.3 实现Action逻辑 441 11.6.4 实现JSP页面 443 11.7 本章小结 446</span><br><span class="line"></span><br><span class="line"> 第12章 Struts 2的REST支持 447 12.1 Codebehind插件和零配置 448 12.1.1 自动搜索Action 448 12.1.2 使用Annotation指定命名 12.1.2 空间、父包和结果映射 449 12.2 Convention插件和零配置 452 12.2.1 搜索Action 453 12.2.2 按约定映射Action 454 12.2.3 按约定映射Result 456 12.2.4 Action链的约定 459 12.2.5 自动重加载映射 461 12.3 Convention插件的相关常量 461 12.4 Convention的Annotation 462 12.4.1 Action配置相关的 12.4.1 Annotation 463 12.4.2 Result配置相关的 12.4.1 Annotation 464 12.4.3 包和命名空间相关的 12.4.1 Annotation 466 12.4.4 异常处理相关的Annotation 466 12.4.5 拦截器配置相关的 12.4.1 Annotation 468 12.5 REST简介 468 12.5.1 资源和标识符 469 12.5.2 操作资源的方式 470 12.6 Struts 2的REST支持 471 12.6.1 RestActionMapper简介 471 12.6.2 安装REST插件 472 12.6.3 实现支持REST的 12.6.3 Action类 473 12.6.4 实现视图层 478 12.7 本章小结 481</span><br><span class="line"></span><br><span class="line"> 第13章 使用FreeMarker作为</span><br><span class="line"></span><br><span class="line"> 第13章 表现层 482 13.1 体验FreeMarker 483 13.1.1 下载和安装FreeMarker 483</span><br><span class="line"></span><br><span class="line"> 13.1.2 在Java程序中使用 13.1.2 FreeMarker 483 13.1.3 在Web应用中使用 13.1.2 FreeMarker 485 13.2 FreeMarker的模板文件 489 13.2.1 模板结构 489 13.2.2 FTL指令规则 490 13.2.3 插值规则 490 13.3 表达式 492 13.3.1 直接指定值 492 13.3.2 输出变量值 494 13.3.3 字符串操作 496 13.3.4 集合连接运算符 497 13.3.5 Map连接运算符 497 13.3.6 算术运算符 498 13.3.7 比较运算符 499 13.3.8 逻辑运算符 499 13.3.9 内建函数 499 13.3.10 空值处理运算符 500 13.3.11 运算符优先级 500 13.4 FreeMarker的常用指令 501 13.4.1 if指令 501 13.4.2 switch、case、default、 13.4.2 break指令 502 13.4.3 list、break指令 502 13.4.4 include指令 503 13.4.5 import指令 503 13.4.6 noparse指令 503 13.4.7 escape、noescape指令 504 13.4.8 assign指令 505 13.4.9 setting指令 506 13.4.10 macro、nested、return指令 506 13.5 使用FreeMarker作为 13.5 Struts 2的视图技术 509 13.5.1 在FreeMarker模板中 13.5.1 使用Struts 2标签 509 13.5.2 使用Freemarker Result 512 13.5.3 解析模板中的变量 514 13.5.4 访问Servlet&#x2F;JSP范围的值 516 13.6 本章小结 517</span><br><span class="line"></span><br><span class="line"> 第14章 整合Spring 518 14.1 Spring简介 519 14.1.1 Spring的起源和核心 519 14.1.2 使用Spring的IoC容器 521 14.2 Struts 2插件 524 14.2.1 插件概述 524 14.2.2 插件开发概述 526 14.3 使用Spring插件完成整合 527 14.3.1 整合Spring前的准备工作 528 14.3.2 整合Spring的思考 531 14.4 让Spring管理控制器 532 14.4.1 整合流程 532 14.4.2 从页面请求开始 533 14.4.3 实现控制器逻辑 533 14.4.4 实现业务逻辑 535 14.5 使用自动装配 537 14.5.1 指定自动装配 537 14.5.2 修改配置文件 538 14.5.3 改变自动装配策略 539 14.6 本章小结 540</span><br><span class="line"></span><br><span class="line"> 第15章 整合JSF 541 15.1 JSF简介 541 15.1.1 JSF概述 542 15.1.2 JSF和Struts 2的对比 542 15.2 使用MyFaces 543 15.2.1 下载和安装MyFaces 543 15.2.2 从输入页面开始 545 15.2.3 在Web应用中配置MyFaces 547 15.2.4 实现后台Bean 548 15.2.5 定义导航规则 549 15.3 安装JSF插件 551 15.4 使用JSF插件 552 15.4.1 实现业务逻辑组件 553 15.4.2 列出全部图书 556 15.4.3 添加&#x2F;修改图书 558 15.5 整合JSF的思考 563 15.6 本章小结 564</span><br><span class="line"></span><br><span class="line"> 第16章 整合SiteMesh 565 16.1 SiteMesh简介 565 16.1.1 SiteMesh概述 566 16.1.2 下载和安装SiteMesh 567 16.1.3 定义装饰器页面 569 16.1.4 定义原始页面 570 16.1.5 更复杂的装饰器页面 572 16.2 使用SiteMesh插件 575 16.2.1 安装SiteMesh插件 575 16.2.2 在Struts 2中使用SiteMesh 577 16.3 本章小结 579</span><br><span class="line"></span><br><span class="line"> 第17章 整合JasperReports 580 17.1 JasperReports简介 581 17.1.1 下载和安装JasperReports 581 17.1.2 JasperReports初探 582 17.1.3 JasperReports的开发流程 588 17.1.4 解决PDF报表的中文问题 589 17.2 动态报表 590 17.2.1 带参数的报表 590 17.2.2 带查询的报表 594 17.2.3 以VO集合作为数据源的 17.2.3 动态报表 600 17.3 使用iReport设计报表 605 17.3.1 下载和安装iReport 605 17.3.2 使用iReport 607 17.3.3 建立数据源 608 17.3.4 设计报表布局 611 17.4 安装JasperReports插件 614 17.5 使用JasperReports报表 614 17.5.1 创建生成报表的Action 615 17.5.2 配置生成JasperReports 17.2.3 报表的Action 616 17.5.3 生成JasperReports报表 617 17.6 本章小结 618</span><br><span class="line"></span><br><span class="line"> 第18章 整合JFreeChart 619 18.1 JFreeChart简介 620 18.1.1 JFreeChart的下载和安装 620 18.1.2 使用JFreeChart 621 18.1.3 JFreeChart开发步骤 623 18.2 JFreeChart的常用统计图表 624 18.2.1 柱状图 625 18.2.2 折线图 629 18.2.3 时间顺序图 630 18.3 在网页中生成带交互功能的 18.3 统计图 633 18.4 安装JFreeChart插件 638 18.5 在Struts 2应用中使用 18.5 JFreeChart 639 18.5.1 创建Action类 639 18.5.2 配置Action 641 18.6 本章小结 642</span><br><span class="line"></span><br><span class="line"> 第19章 整合Hibernate 643 19.1 Hibernate概述 644 19.1.1 Hibernate的作用 644 19.1.2 Hibernate的优势 646 19.2 Hibernate开发入门 646 19.2.1 Hibernate下载和安装 646 19.2.2 使用Hibernate保存记录 647 19.2.3 使用Hibernate查询记录 652 19.3 Struts 2整合Hibernate的思考 654 19.3.1 自定义的整合方案 654 19.3.2 整合方案的实现策略 656 19.4 整合示例 656 19.4.1 持久层设计 656 19.4.2 DAO层设计 660 19.4.3 业务逻辑层设计 663 19.4.4 初始化组件工厂 665 19.4.5 控制器实现 666 19.5 整合后的思考和Spring框架 668 19.6 本章小结 669</span><br><span class="line"></span><br><span class="line"> 第20章 “零配置”案例：注册</span><br><span class="line"></span><br><span class="line"> 第20章 登录系统 670 20.1 系统概述 671 20.1.1 系统功能简介 671 20.1.2 系统总体设计 671 20.2 实现Hibernate持久层 672 20.2.1 编写持久化PO类 672 20.2.2 编写映射文件 673 20.3 实现DAO层 674 20.3.1 管理SessionFactory 674 20.3.2 编写DAO接口 675 20.3.3 实现DAO组件 677 20.3.4 配置DAO组件 679 20.4 实现业务逻辑层 679 20.4.1 定义业务逻辑组件接口 679 20.4.2 提供业务逻辑组件实现类 680 20.4.3 配置业务逻辑组件 682 20.5 使用Struts 2 683 20.5.1 整合Struts 2和Spring 683 20.5.2 处理登录 685 20.5.3 图形验证码 689 20.5.4 使用Ajax验证用户名 692 20.5.5 注册新用户 696 20.6 使用SiteMesh装饰页面 699 20.7 本章小结 700</span><br><span class="line"></span><br><span class="line"> 第21章 电子拍卖系统 701 21.1 系统功能简介和架构设计 702 21.1.1 系统功能简介 702 21.1.2 系统架构设计 702 21.1.3 相关技术介绍 703</span><br><span class="line"></span><br><span class="line"> 21.2 持久层设计 706 21.2.1 系统实体 706 21.2.2 系统E-R图和数据表 707 21.2.3 实现Hibernate PO 709 21.2.4 管理SessionFactory 718 21.3 实现系统DAO层 720 21.3.1 DAO的基础配置 721 21.3.2 实现系统DAO组件 721 21.3.3 配置系统DAO组件 728 21.4 实现业务逻辑层 729 21.4.1 定义业务逻辑组件接口 730 21.4.2 依赖注入DAO组件 732 21.4.3 业务逻辑组件中的异常 21.4.3 处理 733 21.4.4 处理用户竞价 735 21.4.5 判断拍卖物品状态 737 21.4.6 事务管理 740 21.4.7 配置业务层组件 741 21.5 实现系统Web层 744 21.5.1 配置Struts 2的核心Filter 744 21.5.2 处理用户登录 745 21.5.3 图形验证码 749 21.5.4 Web层的异常处理 750 21.5.5 登录控制 751 21.5.6 添加物品 753 21.5.7 处理用户竞价 760 21.6 使用SiteMesh页面装饰 766 21.6.1 在Struts 2中整合SiteMesh 21.6.1 页面装饰 766 21.6.2 定义页面装饰 767 21.7 本章小结 770</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B002A7XPPS/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B002A7XPPS&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51itAHrg7SL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript权威指南(第5版)</title>
    <url>/2020/04/19/B0012UMVYA/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： JavaScript权威指南(第5版)<br>作者信息： 作者: 弗拉纳根 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《JavaScript权威指南(第5版)》由机械工业出版社出版。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一章 JavaScript概述</span><br><span class="line">1.1 对JavaScript的误解</span><br><span class="line">1.2 JavaScript的版本</span><br><span class="line">1.3 客户端JavaScript</span><br><span class="line">1.4 其他环境中的JavaScript</span><br><span class="line">1.5 客户端的JavaScript：网页中的可执行内容</span><br><span class="line">1.6 客户端JavaScript的特性</span><br><span class="line">1.7 JavaScript的安全性</span><br><span class="line">1.8 例子：用JavaScript计算借贷支出</span><br><span class="line">1.9 如何使用本书其余的部分</span><br><span class="line">1.10 JavaScript探秘 </span><br><span class="line"></span><br><span class="line"> 第一部分 JavaScript的核心 第二章 词法结构 2.1 字符集 2.2 大小写敏感性 2.3 空白符和换行符 2.4 可选的分号 2.5 注释 2.6 直接量 2.7 标识符 2.8 保留字</span><br><span class="line"></span><br><span class="line"> 第三章 数据类型和值 3.1 数字 3.2 字符串 3.3 布尔值 3.4 函数 3.5 对象 3.6 数组 3.7 null 3.8 Undefined 3.9 Date对象 3.10 正则表达式 3.11 Error对象 3.12 基本数据类型的包装对象</span><br><span class="line"></span><br><span class="line"> 第四章 变量 4.1 变量的类型 4.2 变量的声明 4.3 变量的作用域 4.4 基本类型和引用类型 4.5 无用存储单元的收集 4.6 作为属性的变量 4.7 深入理解变量作用域</span><br><span class="line"></span><br><span class="line"> 第五章 表达式和运算符 5.1 表达式 5.2 运算符概述 5.3 算术运算符 5.4 相等运算符 5.5 关系运算符 5.6 字符串运算符 5.7 逻辑运算符 5.8 逐位运算符 5.9 赋值运算符 5.10 其他运算符</span><br><span class="line"></span><br><span class="line"> 第六章 语句 6.1 表达式语句 6.2 复合语句 6.3 if语句 6.4 else if语句 6.5 switch语句 6.6 while语句 6.7 do／while语句 6.8 for语句 6.9 for／in 6.10 标签语句 6.11 break语句 6.12 continue语句 6.13 var语句 6.14 function语句 6.15 return语句 6.16 throw语句 6.17 try／catch／finally 6.18 with语句 6.19 空语句 6.20 JavaScript语句小结</span><br><span class="line"></span><br><span class="line"> 第七章 函数 7.1 函数的定义和调用 7.2 作为数据的函数 7.3 函数的作用域：调用对象 7.4 函数的实际参数：Arguments对象 7.5 函数的属性和方法</span><br><span class="line"></span><br><span class="line"> 第八章 对象 8.1 对象和属性 8.2 构造函数 8.3 方法 8.4 原型对象和继承 8.5 面向对象的JavaScript 8.6 作为关联数组的对象 8.7 对象的属性和方法</span><br><span class="line"></span><br><span class="line"> 第九章 数组 9.1 数组和数组元素 9.2 数组的方法</span><br><span class="line"></span><br><span class="line"> 第十章 使用正则表达式的模式匹配 10.1 正则表达式的定义 10.2 用于模式匹配的String方法 10.3 RegExp对象</span><br><span class="line"></span><br><span class="line"> 第十一章 JavaScript的更多主题 11.1 数据类型转换 11.2 使用值和使用引用 11.3 无用存储单元收集 11.4 词法作用域和嵌套函数 11.5 Function()构造函数和函数直接量 11.6 Netscape公司的JavaScript1.2的不兼容性</span><br><span class="line"></span><br><span class="line"> 第二部分 客户端JavaScript 第十二章 Web浏览器中的JavaScript 12.1 Web浏览器环境 12.2 在HTML中嵌入JavaScript 12.3 JavaScript程序的执行</span><br><span class="line"></span><br><span class="line"> 第十三章 窗口和框架 13.1 Window对象概述 13.2 简单的对话框 13.3 状态栏 13.4 超时设定和时间间隔 13.5 错误处理 13.6 Navigator对象 13.7 Screen对象 13.8 Window对象的控制方法 13. 9 Location对象 13.10 History对象 13.11 多窗口和多框架</span><br><span class="line"></span><br><span class="line"> 第十四章 Document对象 14.1 Document对象概览 14.2 动态生成的文档 14.3 Document对象的颜色属性 14.4 Document对象的信息属性 14.5 表单 14.6 图像 14.7 链接 14.8 锚 14.9 小程序 14.10 嵌入式数据</span><br><span class="line"></span><br><span class="line"> 第十五章 表单和表单元素 15.1 Form对象 15.2 定义表单元素 15.3 脚本化表单元 15.4 表单验证示例</span><br><span class="line"></span><br><span class="line"> 第十六章 脚本化cookie 16.1 cookie概览 16.2 cookie的储存 16.3 cookie的读取 16.4 cookie示例</span><br><span class="line"></span><br><span class="line"> 第十七章 文档对象模型 17.1 DOM概览 17.2 使用DOM的核心API 17.3 DOM与Internet Explorer 4的兼容性 17.4 DOM与Netscape 4的兼容性 17.5 简便方法：Traversal和Range API</span><br><span class="line"></span><br><span class="line"> 第十八章 级联样式表和动态HTML 18.1 CSS的样式和样式表 18.2 用CSS进行元素定位 18.3 脚本祥式 18.4 第四代浏览器中的DHTML 18.5 关于样式和样式表的其他DOM API</span><br><span class="line"></span><br><span class="line"> 第十九章 事件和事件处理 19.1 基本事件处理 19.2 2级DOM中的高级事件处理 19.3 Internet Explorer事件模型 19.4 Netscape 4事件模型</span><br><span class="line"></span><br><span class="line"> 第二十章 兼容性 20.1 平台和浏览器的兼容性 20.2 语言版本的兼容性 20.3 非JavaScript浏览器的兼容性.</span><br><span class="line"></span><br><span class="line"> 第二十一章 JavaScript的安全性 21.1 JavaScript与安全性 21.2 受限制的特性 21.3 同源策略 21.4 安全区和签名脚本</span><br><span class="line"></span><br><span class="line"> 第二十二章 在JavaScript中使用Java 22.1 脚本化Java小程序 22.2 在Java中使用JavaScript 22.3 直接使用Java类 22.4 LiveConnect数据类型 22.5 LiveConnect数据转换 22.6 JavaObJect对象在JavaScript中的转换 22.7 从Java到JavaScript的数据转换</span><br><span class="line"></span><br><span class="line"> 第三部分 JavaScript核心参考手册 JavaScript核心参考手册</span><br><span class="line"></span><br><span class="line"> 第四部分 客户端JavaScript参考手册 客户端JavaScript参考手册</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0012UMVYA/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0012UMVYA&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51mpe75zP8L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Java软件结构与数据结构(第3版)</title>
    <url>/2020/04/19/B002MUB66I/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Java软件结构与数据结构(第3版)<br>作者信息： 作者: John Lewis [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Java软件结构与数据结构(第3版)》的写作方法是建立在一些我们强烈推荐的重要原则之上的。首先，我们以一种连贯叙述的方式介绍在《Java软件结构与数据结构(第3版)》中将要考察的各种集合。其次，我们强调完美软件设计技巧的重要性。第三，我们对《Java软件结构与数据结构(第3版)》结构加以组织以支持和强化《Java软件结构与数据结构(第3版)》的重要目标：即数据结构与算法的学习。我们将更深入地考察这些原则。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 概述 1</span><br><span class="line">1.1 软件质量 1</span><br><span class="line">1.1.1 正确性 2</span><br><span class="line">1.1.2 可靠性 2</span><br><span class="line">1.1.3 健壮性 3</span><br><span class="line">1.1.4 可用性 3</span><br><span class="line">1.1.5 可维护性 3</span><br><span class="line">1.1.6 可重用性 4</span><br><span class="line">1.1.7 可移植性 4</span><br><span class="line">1.1.8 运行效率 4</span><br><span class="line">1.1.9 质量问题 5</span><br><span class="line">1.2 数据结构 5</span><br><span class="line">1.2.1 一个物理示例 5</span><br><span class="line">1.2.2 以集装箱作为对象 7</span><br><span class="line">关键概念小结 7</span><br><span class="line">自测题 8</span><br><span class="line">练习题 8</span><br><span class="line">自测题答案 8 </span><br><span class="line"></span><br><span class="line"> 第2章 算法分析 9 2.1 算法效率分析 9 2.2 增长函数与大O记法 10 2.3 增长函数的比较 12 2.4 时间复杂度分析 13 2.4.1 循环运行的复杂度分析 13 2.4.2 嵌套循环的复杂度分析 14 2.4.3 方法调用的复杂度分析 15 关键概念小结 16 自测题 16 练习题 17 自测题答案 17 参考文献 18</span><br><span class="line"></span><br><span class="line"> 第3章 集合 19 3.1 概述 19 3.1.1 抽象数据类型 20 3.1.2 Java集合API 21 3.2 栈集合 22 3.3 主要的面向对象概念 23 3.3.1 继承 24 3.3.2 类层次 25 3.3.3 Object类 26 3.3.4 多态性 27 3.3.5 引用与类层次 28 3.3.6 泛型 29 3.4 栈ADT 30 接口 30 3.5 使用栈计算后缀表达式 32 3.6 异常 38 3.6.1 异常消息 39 3.6.2 try语句 39 3.6.3 异常传播 40 3.7 用数组实现栈 41 管理容量 41 3.8 ArrayStack类 42 3.8.1 构造函数 43 3.8.2 push操作 44 3.8.3 pop操作 45 3.8.4 peek操作 46 3.8.5 其他操作 46 关键概念小结 46 自测题 47 练习题 48 程序设计项目 48 自测题答案 49</span><br><span class="line"></span><br><span class="line"> 第4章 链式结构 51 4.1 链接作为引用 51 4.2 管理链表 53 4.2.1 访问元素 53 4.2.2 插入结点 54 4.2.3 删除结点 55 4.2.4 哑结点 55 4.3 无链接的元素 56 双向链表 56</span><br><span class="line"></span><br><span class="line"> 4.4 用链表实现栈 57 4.4.1 LinkedStack类 57 4.4.2 push操作 60 4.4.3 pop操作 61 4.4.4 其他操作 62 4.5 使用栈来穿越迷宫 62 4.6 java.util.Stack类实现栈 67 4.6.1 独有的操作 68 4.6.2 继承与实现 68 关键概念小结 69 自测题 69 练习题 69 程序设计项目 70 自测题答案 70</span><br><span class="line"></span><br><span class="line"> 第5章 队列 72 5.1 概述 72 5.2 使用队列：代码密钥 75 5.3 使用队列：售票口模拟 77 5.4 用链表实现队列 81 5.4.1 enqueue操作 83 5.4.2 dequeue操作 84 5.4.3 其他操作 85 5.5 用数组实现队列 85 5.5.1 enqueue操作 88 5.5.2 dequeue操作 90 5.5.3 其他操作 90 关键概念小结 90 自测题 91 练习题 91 程序设计项目 92 自测题答案 92</span><br><span class="line"></span><br><span class="line"> 第6章 列表 94 6.1 概述 94 6.1.1 迭代器 96 6.1.2 往列表添加元素 97 6.1.3 接口与多态性 98 6.2 有序列表使用示例：联赛主办者 104 6.3 索引列表使用示例：Josephus问题 109</span><br><span class="line"></span><br><span class="line"> 6.4 使用数组实现列表 111 6.4.1 remove操作 112 6.4.2 contains操作 114 6.4.3 iterator操作 115 6.4.4 有序列表的add操作 117 6.4.5 无序列表的特有操作 118 6.4.6 无序列表的addAfter操作 118 6.5 使用链表实现列表 119 6.5.1 remove操作 119 6.5.2 双向链表 121 6.5.3 iterator操作 124 6.6 Java集合API中的列表 126 6.6.1 Cloneable接口 126 6.6.2 Serializable接口 127 6.6.3 RandomAccess接口 127 6.6.4 java.util.Vector接口 127 6.6.5 java.util.ArrayList接口 129 6.6.6 java.util.LinkedList接口 130 关键概念小结 132 自测题 133 练习题 133 程序设计项目 134 自测题答案 134</span><br><span class="line"></span><br><span class="line"> 第7章 递归 136 7.1 递归地思考 136 7.1.1 无穷递归 137 7.1.2 数学中的递归 138 7.2 递归地编程 138 7.2.1 递归与迭代 140 7.2.2 直接递归与间接递归 140 7.3 使用递归 141 7.3.1 穿越迷宫 141 7.3.2 汉诺塔 145 7.4 递归算法分析 149 关键概念小结 150 自测题 151 练习题 151 程序设计项目 152 自测题答案 153</span><br><span class="line"></span><br><span class="line"> 第8章 排序与查找 154 8.1 查找 154 8.1.1 静态方法 155 8.1.2 泛型方法 155 8.1.3 线性查找法 156 8.1.4 二分查找法 157 8.1.5 查找算法的比较 159 8.2 排序 160 8.2.1 选择排序法 162 8.2.2 插入排序法 164 8.2.3 冒泡排序法 165 8.2.4 快速排序法 167 8.2.5 归并排序法 170 8.3 基数排序法 171 关键概念小结 175 自测题 176 练习题 176 程序设计项目 177 自测题答案 177</span><br><span class="line"></span><br><span class="line"> 第9章 树 178 9.1 概述 178 树的分类 179 9.2 实现树的策略 180 9.2.1 树的数组实现之计算策略 180 9.2.2 树的数组实现之模拟链接策略 181 9.2.3 树的分析 182 9.3 树的遍历 182 9.3.1 前序遍历 183 9.3.2 中序遍历 183 9.3.3 后序遍历 184 9.3.4 层序遍历 184 9.4 二叉树 185 9.5 使用二叉树：表达式树 188 9.6 用链表实现二叉树 197 9.6.1 find方法 199 9.6.2 iteratorInOrder方法 201 9.7 用数组实现二叉树 202 9.7.1 find方法 203 9.7.2 iteratorInOrder方法 204 关键概念小结 205 自测题 205 练习题 206 程序设计项目 206 自测题答案 206</span><br><span class="line"></span><br><span class="line"> 第10章 二叉查找树 208 10.1 概述 208 10.2 用链表实现二叉查找树 211 10.2.1 addElement操作 211 10.2.2 removeElement操作 213 10.2.3 removeAllOccurrences操作 216 10.2.4 removeMin操作 217 10.3 用数组实现二叉查找树 218 10.3.1 addElement操作 219 10.3.2 removeElement操作 221 10.3.3 replace操作 223 10.3.4 removeAllOccurrences操作 227 10.3.5 removeMin操作 227 10.4 用有序列表实现二叉查找树 228 BinarySearchTreeList实现的分析 231 10.5 平衡二叉查找树 232 10.5.1 右旋 233 10.5.2 左旋 233 10.5.3 右左旋 234 10.5.4 左右旋 234 10.6 实现二叉查找树：AVL树 235 10.6.1 AVL树的右旋 235 10.6.2 AVL树的左旋 236 10.6.3 AVL树的右左旋 236 10.6.4 AVL树的左右旋 236 10.7 实现二叉查找树：红黑树 237 10.7.1 红黑树中的元素插入 237 10.7.2 红黑树中的元素删除 239 10.8 实现二叉查找树：Java集合API 241 关键概念小结 243 自测题 244 练习题 245 程序设计项目 245 自测题答案 246 参考文献 247</span><br><span class="line"></span><br><span class="line"> 第11章 优先队列与堆 248 11.1 堆 248 11.1.1 addElement操作 250 11.1.2 removeMin操作 251 11.1.3 findMin操作 252 11.2 使用堆：优先级队列 252 11.3 用链表实现堆 256 11.3.1 addElement操作 257 11.3.2 removeMin操作 259 11.3.3 findMin操作 261 11.4 用数组实现堆 261 11.4.1 addElement操作 262 11.4.2 removeMin操作 263 11.4.3 findMin操作 265 11.5 使用堆：堆排序 265 关键概念小结 266 自测题 267 练习题 267 程序设计项目 268 自测题答案 268</span><br><span class="line"></span><br><span class="line"> 第12章 多路查找树 270 12.1 整合树的概念 270 12.2 2-3树 270 12.2.1 往2-3树中插入元素 271 12.2.2 从2-3树中删除元素 273 12.3 2-4树 275 12.4 B树 276 12.4.1 B*树 277 12.4.2 B+树 277 12.4.3 B树的分析 278 12.5 B树的实现策略 278 关键概念小结 279 自测题 279 练习题 279 程序设计项目 280 自测题答案 280 参考文献 281</span><br><span class="line"></span><br><span class="line"> 第13章 图 282 13.1 无向图 282 13.2 有向图 284 13.3 网络 285 13.4 常用的图算法 286 13.4.1 遍历 286 13.4.2 测试连通性 289 13.4.3 最小生成树 290 13.4.4 判定最短路径 293 13.5 图的实现策略 293 13.5.1 邻接列表 293 13.5.2 邻接矩阵 294 13.6 用邻接矩阵实现无向图 295 13.6.1 addEdge方法 298 13.6.2 addVertex方法 299 13.6.3 expandCapacity方法 300 13.6.4 其他方法 300 关键概念小结 300 自测题 301 练习题 301 程序设计项目 302 自测题答案 302 参考文献 303</span><br><span class="line"></span><br><span class="line"> 第14章 散列 304 14.1 概述 304 14.2 散列函数 305 14.2.1 余数法 306 14.2.2 折叠法 306 14.2.3 平方取中法 307 14.2.4 基数转换法 307 14.2.5 数字分析法 307 14.2.6 长度相关法 307 14.2.7 Java语言中的散列函数 308 14.3 解决冲突 308 14.3.1 链地址法 308 14.3.2 开放地址法 310 14.4 从散列表删除元素 312 14.4.1 从链地址实现中删除 312 14.4.2 从开放地址实现中删除 312 14.5 Java集合API中的散列表 313 14.5.1 Hashtable类 313 14.5.2 HashSet类 314 14.5.3 HashMap类 315 14.5.4 IdentityHashMap类 316 14.5.5 WeakHashMap类 317 14.5.6 LinkedHashSet与LinkedHashMap 318 关键概念小结 319 自测题 319 练习题 320 程序设计项目 320 自测题答案 321</span><br><span class="line"></span><br><span class="line"> 第15章 Set与Map集合 323 15.1 Set集合 323 15.2 使用Set：bingo程序 326 15.3 用数组实现Set 329 15.3.1 add操作 330 15.3.2 addAll操作 332 15.3.3 removeRandom操作 332 15.3.4 remove操作 333 15.3.5 union操作 334 15.3.6 contains操作 335 15.3.7 equals操作 336 15.3.8 其他操作 337 15.3.9 UML描述 337 15.4 用链表实现Set 338 15.4.1 add操作 338 15.4.2 removeRandom操作 339 15.4.3 remove操作 340 15.4.4 其他操作 341 15.5 Map集合与Java集合API 341 关键概念小结 342 自测题 343 练习题 343 程序设计项目 343 自测题答案 344</span><br><span class="line"></span><br><span class="line"> 附录A UML 346 A.1 统一建模语言 346 A.2 UML类图 346 A.3 UML关系 347 关键概念小结 349 自测题 350 练习题 350 自测题答案 350</span><br><span class="line"></span><br><span class="line"> 附录B 面向对象设计 351 B.1 概述 351 B.2 使用对象 351 B.2.1 抽象 352 B.2.2 创建对象 353 B.3 类库与包 354 import声明 355 B.4 状态与行为 355 B.5 类 356 实例数据 359 B.6 封装 359 B.6.1 可见性修饰符 360 B.6.2 局部数据 361 B.7 构造函数 361 B.8 方法重载 362 B.9 再谈引用 363 B.9.1 空引用 363 B.9.2 this引用 364 B.9.3 别名 365 B.9.4 垃圾回收 367 B.9.5 将对象作为参数传递 367 B.10 static修饰符 368 B.10.1 静态变量 368 B.10.2 静态方法 369 B.11 包装类 369 B.12 接口 370 B.12.1 Comparable接口 371 B.12.2 Iterator接口 372 B.13 继承 372 B.13.1 派生类 373 B.13.2 protected修饰符 375 B.13.3 super引用 375 B.13.4 重载方法 376 B.14 类的层次结构 376 B.14.1 Object类 377 B.14.2 抽象类 378 B.14.3 接口的层次结构 379 B.15 多态性 379 B.15.1 引用和类的层次结构 380 B.15.2 基于继承的多态性 381 B.15.3 基于接口的多态性 382 B.16 泛型 384 B.17 异常 385 B.17.1 异常消息 385 B.17.2 try语句 386 B.17.3 异常传播 387 B.17.4 异常类的层次结构 387 关键概念小结 388 自测题 390 练习题 390 程序设计项目 391 自测题答案 392</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B002MUB66I/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B002MUB66I&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51yCNEOeomL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>iphone3开发基础教程</title>
    <url>/2020/04/19/B002VEDBMW/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： iphone3开发基础教程<br>作者信息： 作者: 马克(Dave Mark) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《iphone3开发基础教程》是Amazon计算机榜首图书，创造销售奇迹的经典著作，针对iPhoe SDK 3新特性全面改版，从这里，拥抱软件开发的未来。Apple公司的iPflone开创了移动平台新纪元！而最新版iPhone 3做了不少改进，如强化应用程序对GPS的支持，还增加了众多新功能，如全系统搜索、支持复制和粘贴、收发多媒体信息等。iPhone 3与App Store的绝配为全世界的程序员提供了一个施展才华的全新大舞台。只要有新奇的创意，你完全有可能像开发iStloot游戏的Ethan Nicliolas（日收入2万多美元）和开发Trism游戏的Steve Demmeter（月收入超过10万美元）那样，单枪匹马即可赢得全球市场，成功创业，改变自己的人生。上一版英文原版问世以来在Anlazor、计算机图书排行榜持续雄踞榜首，总排名一度在20名左右，被奉为经典。而中文版出版后也迅速荣登各大网店排行榜榜首，并创造了半年内印刷四次的销售奇迹。书中从到Apple网站注册账号，下载和安装免费iPhone SDK开始，清晰透彻地讲述了创建iPhone应用程序的全过程。作者在探讨基本概念和各个关键特性（iPhone界面元素、数据保存、SQLite3、Quarrtz和OpenGL ES、手势支持、本地化、Core Location等）时，提供了丰富的实例。更难得的是，《iphone3开发基础教程》始终强调iPhone开发中的各种最佳实践，即使是有经验的开发人员，也会因此受益匪浅。《iphone3开发基础教程》新版针对iPhone SDK 3做了大幅修订，力求使新老读者都能觉得物有所值。作者在纠正上一版错误的基础上，不仅更新了所有项目代码，使之兼容新旧SDK，还新增了不少内容，进一步阐明一些读者反馈的比较难懂的主题。此外，书中还为Core Data增加了一个新项目。立即展卷阅读，开始神奇的iPhone开发之旅吧。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 欢迎来到iPhone的世界 1</span><br><span class="line">1.1 关于本书 1</span><br><span class="line">1.2 必要条件 1</span><br><span class="line">1.3 必备知识 3</span><br><span class="line">1.4 编写iPhone应用程序有何不同 4</span><br><span class="line">1.4.1 只有一个正在运行的应用程序 4</span><br><span class="line">1.4.2 只有一个窗口 4</span><br><span class="line">1.4.3 受限访问 5</span><br><span class="line">1.4.4 有限的响应时间 5</span><br><span class="line">1.4.5 有限的屏幕大小 5</span><br><span class="line">1.4.6 有限的系统资源 5</span><br><span class="line">1.4.7 不支持垃圾收集 6</span><br><span class="line">1.4.8 新功能 6</span><br><span class="line">1.4.9 与众不同的方法 6</span><br><span class="line">1.5 本书内容 6</span><br><span class="line">1.6 本次更新的内容 7</span><br><span class="line">1.7 准备开始吧 7 </span><br><span class="line"></span><br><span class="line"> 第2章 创建基本项目 8 2.1 在Xcode中设置项目 8 2.2 Interface Builder简介 13 2.2.1 nib文件的构成 14 2.2.2 在视图中添加标签 15 2.3 美化iPhone应用程序 17 2.4 小结 20</span><br><span class="line"></span><br><span class="line"> 第3章 处理基本交互 21 3.1 MVC范型 21 3.2 创建项目 22 3.3 创建视图控制器 22 3.3.1 输出口 23 3.3.2 操作 24 3.3.3 将操作和输出口添加到视图控制器 24 3.3.4 将操作和输出口添加到实现文件 26 3.4 使用应用程序委托 30 3.5 编辑MainWindow.xib 33 3.6 编辑Button_FunViewController.xib 34 3.6.1 在Interface Builder中创建视图 34 3.6.2 连接所有元素 36 3.6.3 测试 39 3.7 小结 39</span><br><span class="line"></span><br><span class="line"> 第4章 更丰富的用户界面 40 4.1 满是控件的屏幕 40 4.2 活动、静态和被动控件 42 4.3 创建应用程序 42 4.3.1 导入图像 42 4.3.2 实现图像视图和文本字段 43 4.3.3 添加图像视图 44 4.3.4 添加文本字段 47 4.3.5 设置第二个文本字段的属性 50 4.3.6 连接输出口 50 4.4 构建和运行 51 4.4.1 完成输入后关闭键盘 51 4.4.2 通过触摸背景关闭键盘 52 4.5 实现滑块和标签 54 4.5.1 确定输出口 54 4.5.2 确定操作 54 4.5.3 添加输出口和操作 54 4.5.4 添加滑块和标签 55 4.5.5 连接操作和输出口 56 4.6 实现开关、按钮和分段控件 57 4.6.1 确定输出口 57 4.6.2 确定操作 57 4.6.3 添加开关、按钮和分段控件 59 4.6.4 连接开关输出口和操作 60 4.6.5 添加按钮 61 4.7 实现操作表和警报 62 4.7.1 遵从操作表委托方法 62 4.7.2 显示操作表 62 4.7.3 操作表委托和创建警报 64 4.8 美化按钮 66 4.8.1 viewDidLoad方法 66 4.8.2 控件状态 67 4.8.3 可拉伸图像 67 4.9 成为出色的内存使用者 67 4.10 小结 68</span><br><span class="line"></span><br><span class="line"> 第5章 自动旋转和自动调整大小 70 5.1 使用自动调整属性处理旋转 71 5.1.1 指定旋转支持 71 5.1.2 使用自动调整属性设计界面 73 5.1.3 自动调整属性 74 5.1.4 设置按钮的自动调整属性 75 5.2 在旋转时重构视图 76 5.2.1 声明和连接输出口 77 5.2.2 在旋转时移动按钮 77 5.3 切换视图 79 5.3.1 确定输出口 80 5.3.2 确定动作 80 5.3.3 声明动作和输出口 80 5.3.4 设计两个视图 81 5.3.5 实现交换和动作 82 5.4 小结 84</span><br><span class="line"></span><br><span class="line"> 第6章 多视图应用程序 85 6.1 View Switcher应用程序 87 6.2 多视图应用程序的体系结构 88 6.3 构建View Switcher 88 6.3.1 创建视图控制器和nib文件 89 6.3.2 修改应用程序委托 91 6.3.3 SwitchViewController.h 92 6.3.4 修改MainWindow.xib 92 6.3.5 编写SwitchViewController.m 95 6.3.6 实现内容视图 98 6.4 制作转换动画 101 6.5 小结 103</span><br><span class="line"></span><br><span class="line"> 第7章 标签栏与选取器 104 7.1 Pickers应用程序 104 7.2 委托和数据源 106 7.3 建立工具栏框架 106 7.3.1 创建文件 107 7.3.2 添加根视图控制器 108 7.4 实现日期选取器 112 7.5 实现单个组件选取器 114 7.5.1 声明输出口和操作 114 7.5.2 构建视图 115 7.5.3 将控制器实现为数据源和委托 115 7.6 实现多组件选取器 120 7.6.1 声明输出口和操作 120 7.6.2 构建视图 120 7.6.3 实现控制器 121 7.7 实现独立组件 123 7.8 使用自定义选取器创建简单游戏 130 7.8.1 编写控制器头文件 130 7.8.2 构建视图 130 7.8.3 添加图像资源 131 7.8.4 实现控制器 131 7.8.5 spin方法 134 7.8.6 viewDidLoad方法 135 7.8.7 最后的细节 137 7.8.8 链接Audio Toolbox框架 140 7.9 小结 141</span><br><span class="line"></span><br><span class="line"> 第8章 表视图简介 142 8.1 表视图基础 142 8.2 实现一个简单的表 145 8.2.1 设计视图 145 8.2.2 编写控制器 146 8.3 添加一个图像 149 8.4 附加配置 151 8.4.1 设置缩进级别 152 8.4.2 处理行的选择 152 8.4.3 更改字体大小和行高 154 8.4.4 委托还能做什么 155 8.5 定制表视图单元 155 8.5.1 单元应用程序 155 8.5.2 向表视图单元添加子视图 156 8.5.3 使用UITableViewCell的自定义子类 159 8.6 分组分区和索引分区 163 8.6.1 构建视图 163 8.6.2 导入数据 164 8.6.3 实现控制器 164 8.6.4 添加索引 168 8.7 实现搜索栏 168 8.7.1 重新考虑设计 168 8.7.2 深层可变副本 169 8.7.3 更新控制器头文件 170 8.7.4 修改视图 171 8.7.5 修改控制器实现 173 8.8 小结 183</span><br><span class="line"></span><br><span class="line"> 第9章 导航控制器和表视图 184 9.1 导航控制器 184 9.1.1 栈的性质 184 9.1.2 控制器栈 185 9.2 由6个部分组成的分层应用程序：Nav 185 9.3 构建Nav应用程序的骨架 188 9.3.1 创建第一级视图控制器 188 9.3.2 设置导航控制器 189 9.4 第一个子控制器：展示按钮视图 194 9.5 第二个子控制器：校验表 201 9.6 第三个子控制器：表行上的控件 205 9.7 第四个子控制器：可移动的行 211 9.7.1 编辑模式 211 9.7.2 创建一个新的二级控制器 212 9.8 第五个子控制器：可删除的行 217 9.9 第六个子控制器：可编辑的详细窗格 222 9.9.1 创建数据模型对象 222 9.9.2 创建控制器 224 9.9.3 创建详细视图控制器 227 9.10 其他内容 240 9.11 小结 243</span><br><span class="line"></span><br><span class="line"> 第10章 应用程序设置和用户默认设置 244 10.1 设置束 244 10.2 AppSettings应用程序 245 10.3 创建项目 247 10.4 使用设置束 248 10.4.1 在项目中添加设置束 248 10.4.2 设置属性列表 249 10.4.3 添加文本字段设置 250 10.4.4 添加安全文本字段设置 252 10.4.5 添加多值字段 252 10.4.6 添加拨动开关设置 253 10.4.7 添加滑块设置 254 10.4.8 添加子设置视图 255 10.5 读取应用程序中的设置 256 10.6 更改应用程序中的默认设置 260 10.7 小结 263</span><br><span class="line"></span><br><span class="line"> 第11章 基本数据持久性 264 11.1 应用程序的沙盒 264 11.1.1 获取Documents目录 265 11.1.2 获取tmp目录 266 11.2 文件保存策略 266 11.2.1 单个文件持久性 266 11.2.2 多个文件持久性 267 11.3 持久保存应用程序数据 267 11.4 持久性应用程序 268 11.4.1 创建持久性项目 269 11.4.2 设计持久性应用程序视图 269 11.4.3 编辑持久性类 270 11.4.4 对模型对象进行归档 273 11.4.5 实现NSCopying 275 11.5 归档应用程序 276 11.5.1 实现FourLines类 277 11.5.2 实现PersistenceView-Controller类 278 11.6 使用iPhone的嵌入式SQLite3 280 11.7 使用Core Data 289 11.7.1 实体和托管对象 291 11.7.2 键&#x2F;值编码 292 11.7.3 在上下文中结合它们 292 11.7.4 创建新托管对象 293 11.7.5 检索托管对象 293 11.7.6 设计数据模型 294 11.7.7 创建持久视图和控制器 297 11.7.8 将持久视图控制器设置为应用程序的根控制器 302 11.8 小结 303</span><br><span class="line"></span><br><span class="line"> 第12章 使用Quartz和OpenGL绘图 304 12.1 图形世界的两个视图 304 12.2 本章的绘图应用程序 305 12.3 Quart绘图方法 305 12.3.1 Quartz 2D的图形上下文 305 12.3.2 坐标系 306 12.3.3 指定颜色 307 12.3.4 在上下文中绘制图像 308 12.3.5 绘制形状：多边形、直线和曲线 309 12.3.6 Quartz 2D工具示例：模式、梯度、虚线模式 309 12.4 构建QuartzFun应用程序 309 12.4.1 创建随机颜色 310 12.4.2 定义应用程序常量 311 12.4.3 实现QuartzFunView框架 312 12.4.4 向视图控制器中添加输出口和操作 314 12.4.5 更新QuartzFunViewContro-ller.xib 316 12.4.6 绘制直线 317 12.4.7 绘制矩形和椭圆形 319 12.4.8 绘制图像 320 12.4.9 优化QuartzFun应用程序 322 12.5 一些OpenGL ES基础知识 325 12.5.1 构建GLFun应用程序 326 12.5.2 设计Nib、添加框架、运行应用程序 335 12.6 小结 335</span><br><span class="line"></span><br><span class="line"> 第13章 轻击、触摸和手势 336 13.1 多触摸术语 336 13.2 响应者链 337 13.3 多触摸体系结构 338 13.4 触摸浏览器应用程序 339 13.5 Swipes应用程序 342 13.6 实现多个轻扫动作 345 13.7 检测多次轻击 347 13.8 检测捏合操作 351 13.9 自己定义手势 354 13.10 小结 358</span><br><span class="line"></span><br><span class="line"> 第14章 使用Core Location定位功能 359 14.1 位置管理器 359 14.1.1 设置所需的精度 360 14.1.2 设置距离筛选器 360 14.1.3 启动位置管理器 360 14.1.4 更明智地使用位置管理器 360 14.2 位置管理器委托 361 14.2.1 获取位置更新 361 14.2.2 使用CLLocation获取纬度和经度 361 14.2.3 错误通知 362 14.3 尝试使用Core Location 363 14.3.1 更新位置管理器 367 14.3.2 确定移动距离 367 14.4 小结 368</span><br><span class="line"></span><br><span class="line"> 第15章 加速计 369 15.1 加速计物理学 369 15.2 访问加速计 370 15.2.1 UIAcceleration 370 15.2.2 实现accelerometer: didAccelerate:方法 371 15.3 摇动与击碎 373 15.3.1 用于击碎的代码 373 15.3.2 加载模拟文件 376 15.3.3 完好如初——复原触摸 377 15.4 滚弹珠程序 377 15.4.1 实现Ball View控制器 378 15.4.2 编写Ball View 379 15.4.3 计算小球运动 382 15.5 小结 385</span><br><span class="line"></span><br><span class="line"> 第16章 iPhone照相机和照片库 386 16.1 使用图像选取器和UIImagePicker-Controller 386 16.2 实现图像选取器控制器委托 387 16.3 实际测试照相机和库 389 16.3.1 设计界面 390 16.3.2 实现照相机视图控制器 390 16.4 小结 394</span><br><span class="line"></span><br><span class="line"> 第17章 应用程序本地化 395 17.1 本地化体系结构 395 17.2 使用字符串文件 396 17.3 现实中的iPhone：本地化应用程序 398 17.3.1 查看当前区域设置 401 17.3.2 测试LocalizeMe 401 17.3.3 本地化nib文件 402 17.3.4 查看本地化的项目结构 403 17.3.5 本地化图像 405 17.3.6 本地化应用程序图标 406 17.3.7 生成和本地化字符串文件 406 17.4 小结 409</span><br><span class="line"></span><br><span class="line"> 第18章 未来之路 410 18.1 别陷进单一的思路里 410 18.1.1 苹果公司的文档 410 18.1.2 邮件列表 411 18.1.3 论坛 411 18.1.4 网站 411 18.1.5 博客 412 18.1.6 Dave和Jeff的博客及Twitter 412 18.1.7 参考图书 412 18.1.8 如果仍未解决问题 412 18.2 再会 412</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B002VEDBMW/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B002VEDBMW&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51scqo9tR8L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>Web编程入门经典 HTML、XHTML和CSS(第2版)</title>
    <url>/2020/04/19/B0036WSTQ6/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Web编程入门经典 HTML、XHTML和CSS(第2版)<br>作者信息： 作者: 达科特(Jon Duckett) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Web编程入门经典:HTML、XHTML和CSS(第2版)》是由清华大学出版社出版的。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 创建结构化文档</span><br><span class="line">1.1 结构化文档组成的Web</span><br><span class="line">1.2 XHTML简介</span><br><span class="line">1.3 核心元素和属性</span><br><span class="line">1.3.1 元素</span><br><span class="line">1.3.2 元素</span><br><span class="line">1.3.3 元素</span><br><span class="line">1.3.4 元素</span><br><span class="line">1.4 属性组</span><br><span class="line">1.4.1 核心属性</span><br><span class="line">1.4.2 国际化属性</span><br><span class="line">1.4.3 UI事件</span><br><span class="line">1.5 基本文本格式</span><br><span class="line">1.5.1 空格和流</span><br><span class="line">1.5.2 使用hn元素创建题头</span><br><span class="line">1.5.3 使用 元素创建段落 1.5.4 使用 元素创建换行 1.5.5 使用 </span><br><span class="line"></span><br><span class="line"> 元素创建预先格式化的文本</span><br><span class="line">1.6 表现元素</span><br><span class="line">1.6.1 元素</span><br><span class="line">1.6.2 元素 1.6.3 元素（逐渐淘汰） 1.6.4 元素和元素（逐渐淘汰） 1.6.5 元素 1.6.6 元素 1.6.7 元素 1.6.8 元素 1.6.9 元素 1.6.10 元素 1.7 短语元素 1.7.1 元素添加强调 1.7.2 元素添加着重强调 1.7.3 用于缩写词的元素 1.7.4 用于首字母缩写词的元素 1.7.5 用于特殊术语的元素 1.7.6 用于引用文本的 元素 1.7.7 用于短引用的元素 1.7.8 用于引证的元素 1.7.9 用于代码的元素 1.7.10 用于通过键盘输入的文本的元素 1.7.11 用于编程变量的元素 1.7.12 用于程序输出的元素 1.7.13 用于地址的 元素 1.8 列表 1.8.1 利用 元素创建无序列表 1.8.2 有序列表 1.8.3 定义列表 1.8.4 列表的嵌套 1.9 编辑文本 1.9.1 使用 元素指示新添加的文本 1.9.2 使用 元素指示删除的文本 1.10 利用字符实体表示特殊字符 1.11 注释 1.12 元素（逐渐淘汰） 1.13 理解块级元素和内联元素 1.14 利用 元素和元素分组元素 1.15 本章小结 1.16 练习 第2章 链接和导航 2.1 基本链接 2.1.1 链接到其他文档 2.1.2 链接到e-mail地址 2.2 理解目录和目录结构 2.2.1 链接的目标位置 2.2.2 URL的组成 2.2.3 绝对URL和相对URL 2.2.4 元素 2.3 利用元素创建链接 2.3.1 利用href属性创建源锚点 2.3.2 利用name和id属性创建目的地锚点（链接到页面的特定部分） 2.3.3 元素的其他属性 2.4 高级e-mail链接 2.5 本章小结 2.6 练习 第3章 图像和对象 3.1 在站点中添加图像 3.1.1 图像格式的类型 3.1.2 位图图像 3.1.3 矢量图像 3.1.4 使用元素添加图像 3.2 利用元素添加其他对象 3.2.1 元素的属性 3.2.2 元素 3.2.3 在页面中添加Flash电影 3.3 使用图像作为链接 3.4 图像映射 3.4.1 服务器端图像映射 3.4.2 客户端图像映射 3.5 本章小结 3.6 练习 第4章 表 4.1 表简介 4.2 基本表元素和属性 4.2.1 创建表的元素创建表单 5.2.1 action属性 5.2.2 method属性 5.2.3 id属性 5.2.4 name属性（逐渐淘汰） 5.2.5 onsubmit属性 5.2.6 onreset属性 5.2.7 enctype属性 5.2.8 accept-charset属性 5.2.9 accept属性 5.2.10 target属性 5.2.11 空白和 元素 5.3 表单控件 5.3.1 文本输入 5.3.2 按钮 5.3.3 复选框 5.3.4 单选按钮 5.3.5 选项框 5.3.6 文件选项框 5.3.7 隐藏控件 5.3.8 对象控件 5.4 利用元素为控件创建标签 5.5 利用 元素和元素结构化表单 5.6 焦点 5.6.1 焦点移动顺序 5.6.2 访问键 5.7 禁用的或只读的控件 5.8 向服务器发送表单数据 5.8.1 HTTPget 5.8 2HTTPpost 5.9 本章小结 5.10 练习 第6章 框架 6.1 框架集简介 6.2 使用框架的时机 6.3 元素 6.3.1 cols属性 6.3.2 rows属性 6.3.3 针对元素的浏览器专用扩展 6.4 元素 6.4.1 src属性 6.4.2 name属性 6.4.3 frameborder属性 6.4.4 marginwidth属性和marginheight属性 6.4.5 noresize属性 6.4.6 scrolling属性 6.4.7 longdesc属性 6.5 元素 6.6 创建框架之间的链接 6.7 框架集的嵌套 6.8 利用&lt;iframe&gt;元素创建浮动框架或内联框架 6.9 本章小结 6.10 练习 第7章 层叠样式表 7.1 CSS简介 7.1.1 一个基本的示例 7.1.2 继承 7.2 添加CSS规则的位置 7.2.1 &lt;link&gt;元素 7.2.2 &lt;style&gt;元素 7.2.3 外部CSS样式表的优点 7.3 CSS特性 7.4 控制字体 7.4.1 font-family特性 7.4.2 font-size特性 7.4.3 font-weight特性 7.4.4 font-style特性 7.4.5 font-variant特性 7.4.6 font-stretch特性 7.4.7 font-size.adiust特性 7.5 文本格式化 7.5.1 color特性 7.5.2 text-align特性 7.5.3 vertical-align特性 7.5.4 text-decoration特性 7.5.5 text-indent特性 7.5.6 text-shadow特性 7.5.7 text-transform特性 7.5.8 letter-spacing特性 7.5.9 word-spacing特性 7.5.10 white-space特性 7.5.11 direction特性 7.5.12 unicode-bidi特性 7.6 文本伪类 7.6.1 first-letter伪类 7.6.2 first-line伪类 7.7 选择器 7.7.1 通用选择器 7.7.2 类型选择器 7.7.3 类选择器 7.7.4 id选择器 7.7.5 子选择器 7.7.6 后继选择器 7.7.7 相邻兄弟选择器 7.7.8 利用子选择器和相邻兄弟选择器降低标记中类的相关性 7.7.9 属性选择器 7.8 长度 7.8.1 绝对单位 7.8.2 相对单位 7.8.3 百分比 7.9 框模型简介 7.9.1 演示框模型的示例 7.9.2 Border特性 7.9.3 padding特性 7.9.4 margin特性 7.9.5 面积 7.10 本章小结 7.11 练习 第8章 更多层叠样式表 8.1 链接 8.2 背景 8.2.1 background-color特性 8.2.2 background-image特性 8.2.3 background-repeat特性 8.2.4 background-position特性（用于固定背景的位置） 8.2.5 background-attachment特性（用于水印） 8.2.6 background特性（获得良好支持的简写形式） 8.3 列表 8.3.1 list-style-type特性 8.3.2 list-style-position特性 8.3.3 list-style-image特性 8.3.4 list-style特性（简写形式） 8.3.5 marker-offset特性 8.4 表 8.4.1 表的特性 8.4.2 border-collapse特性 8.4.3 border-spacing特性 8.4.4 caption.side特性 8.4.5 empty-cells特性 8.4.6 table-layout特性 8.5 外边框 8.5.1 outline-width特性 8.5.2 outline-style特性 8.5.3 outline-color特性 8.5.4 outline特性（简写形式） 8.6 ：focus伪类和：active伪类 8.7 生成的内容 8.7.1 ：before和：after伪元素 8.7.2 content特性 8.8 其他特性 8.8.1 cursor特性 8.8.2 display特性 8.8.3 visibility特性 8.9 额外的规则 8.9.1 @import规则：模块化的样式表 8.9.2 @charset规则 8.9.3 1important规则 8.10 CSS的定位功能 8.10.1 普通流 8.10.2 position特性 8.10.3 框偏移特性 8.10.4 相对定位 8.10.5 绝对定位 …… 第9章 页面布局 第10章 设计问题 第11章 学习JavaScript 第12章 应用JavaScript 第13章 在Web上发布站点 附录 &lt;&#x2F;div&gt; &lt;h3 class&#x3D;&quot;productDescriptionSource&quot;&gt;序言&lt;&#x2F;h3&gt; &lt;div class&#x3D;&quot;productDescriptionWrapper&quot;&gt; 目前关于设计和构建Web页面的书籍很多，因此首先感谢您选择阅读本书。本书与其他书籍的不同点是什么呢？Web概念已经出现了十多年，在这期间引入了大量用于创建Web页面的技术，其中一些技术目前还在使用，而其他技术已经消失。许多介绍如何编写Web页面的书籍是相同书籍早期版本的修订，因此仍然采用与以前版本相同的介绍方法。而本书的目的是介绍如何为当今以及将来的Web创建页面。因此，读者阅读完本书之后，仍可将其作为一本有用的参考书放在身边，在需要时随时翻阅。 曾经有一段时间，编写Web页面的程序员仅需要掌握一种编程语言，即HTML语言。但是随着Web技术的发展，为了创建有效并吸引人的Web页面，程序员需要学习更多的技术，需要掌握多种不同语言，主要包括： ·HTML和XHTML：HTML和XHTML用于解释Web页面的结构。它们用于指明哪些文本作为题头，段落的起始位置和结束位置在何处，哪些图像应当出现在文档中，以及指定不同页面之间的链接。不应当将。HTML和XHTML看作是两种独立的语言。相反，可以将XHTML看作是与HTML的最新版本非常相似的语言。 ·CSS：CSS用于控制文档的外观。例如，可以使用CSS指定字型应该是较大的、粗体的Arial字型，或者指定页面的背景应该是亮绿色。另外，还可以使用CSS控制不同项在页面上的位置。例如，利用CSS将文本放置在同一个页面的两列中。 ·JavaScript：利用JavaScript可以在创建的Web页面上添加交互性，并且可以操作显示Web页面的浏览器。 尽管事实上需要掌握多种语言（而不只是HTML），但是可以将HTML看作熟悉Web的好机会，因为HTML中用于创建Web页面的许多技术拥有成熟的、有利的方法；或者将其看作“最佳实践”，因为可以利用它创建完整的Web站点。本书简介 本书将介绍如何利用HTML和XHTML控制Web页面的结构，如何利用CSS赋予Web页面样式，如何利用JavaScfipt添加交互性。但是，只是学习最新的技术并不能确保编写出优秀的Web页面。由于用于编写Web页面的技术不断改进，因此浏览器（用于访问Web的程序和设备）也在改进。浏览器反映——并且有时甚至是通知——用于创建Web页面的语言的发展方向。问题在于并不是每个人都在其计算机上安装了最新软件，因此人们不仅希望编写出的Web页面能够充分利用浏览器的最新功能，而且希望确保Web页面能够在当今仍然流行的较老浏览器上正确显示。 &lt;&#x2F;div&gt; &lt;h3 class&#x3D;&quot;productDescriptionSource&quot;&gt;文摘&lt;&#x2F;h3&gt; &lt;div class&#x3D;&quot;productDescriptionWrapper&quot;&gt; 插图： &lt;img src&#x3D;http:&#x2F;&#x2F;g-ec4.images-amazon.com&#x2F;images&#x2F;G&#x2F;28&#x2F;cn-legacy&#x2F;b&#x2F;b0036wstq6_01_amzn.jpg&gt; 工作原理 您已经多次遇到这段代码中的大部分内容。但是，这段代码主要关注于&lt;img／&gt;元素，每一个&lt;img／&gt;元素添加一幅新图像。在这个示例中存在3个&lt;img／&gt;元素。 &lt;imgsrc&#x3D;&quot;images／apple.jpg&quot;alt&#x3D;&quot;Phot00fredapple&quot;width&#x3D;&#x3D;&quot;130&quot;height&#x3D;&quot;130&quot;／&gt; 其中src属性指示图像的URL。这个示例中的URL都是相对于images目录的URL，images目录包含在与示例页面相同的目录中。在第2章中提到，组织文件结构非常重要——在这里可以了解这种重要性的原因（可以清晰地表明图像应当位于站点结构中）。 编写的每一个&lt;img／&gt;元素中都应当使用alt属性。如果浏览器无法加载图像，则将显示该属性的内容，并且如果访问者视力受损，该属性值也能告诉他们图像的内容。 width属性和height属性用于告诉浏览器图像的显示大小。通过包含这些属性，浏览器能够更快地布局页面，因为它能够在不等待图像下载完成的情况下显示页面中的其他项。虽然可以使用这两个属性放大或缩小图像，但最好让图像具有希望使用的尺寸。如果让图像更小，应该保存它的一个新版本，而不只是使用这两个属性，这样能够节省访问者的时间和带宽。 3.2 利用&lt;object&gt;元素添加其他对象 W3C在。HTML4中引入了&lt;object&gt;元素，目的是利用它在文档中嵌入所有类型的媒体，除了图像之外，还包括MP3文件、Flash电影、QuickTime电影、JavaScfipt对象、Java小程序等。W3C甚至希望最终可以利用&lt;object&gt;元素在文档中包含图像。 虽然我们习惯于浏览器支持GIF、JPEG图像甚至最近出现的：PNG图像，但并不习惯于其支持MP3声音文件、Flash电影、QuickTime电影或者Java应用程序。当然，对于后面的几种媒体，通常可以使用&lt;object&gt;元素在页面中包含其他一些类型的软件，以便播放或加载相应的媒体文件。例如： ·利用Flash播放器播放：Flash电影； ·利用Windows MediaPlayer播放Windows媒体文件； ·可以在多种播放器中播放MP3，包括。Flash播放器、windows Media播放器、 Quick TimePlayer。 因此，当需要在Web页面中嵌入声音、视频或Java／JavaScript应用程序时，不仅需要具有相应的文件，而且需要选择一种应用程序嵌入到页面中，用于播放／运行该文件。 在页面中包含正确的工具是一项复杂的操作，因为并不是所有的计算机都安装希望使用的应用程序。另外，每一种播放器都具有很多不同的版本。在编写本书时，在Web页面中嵌入移动图形和视频的最常用方式是使用Flash（Flash用于服务站点中的大多数视频和音频文件，例如YouTube站点和MySpace站点）。但是，虽然Flash通常被认为已经在世界上超过95％的计算机上安装，但Flash播放器仅在最新的版本中才支持播放音频和视频。 &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; amznJQ.available(&quot;jQuery&quot;, function() &#123; var seeAllCustomerImage &#x3D; jQuery(&quot;#see-all-customer-image-and-share&quot;); var seeAllCustomerImagelinkHtml &#x3D; &#39;&lt;a href&#x3D;&quot;&#x2F;gp&#x2F;customer-media&#x2F;upload&#x2F;B0036WSTQ6?ie&#x3D;UTF8&amp;rnd&#x3D;1387986207&quot;&gt;共享你的图片&lt;&#x2F;a&gt;&#39;; seeAllCustomerImage.append(seeAllCustomerImagelinkHtml); &#125;); &lt;&#x2F;script&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; amznJQ.onCompletion(&#39;amznJQ.criticalFeature&#39;, function() &#123; var imageBlockData &#x3D; eval(&quot;(&quot;+&#39;&#123;&quot;linkArgs&quot;:&#123;&quot;seeAllCustomerMediaAndShare&quot;:&quot;共享你的图片&quot;,&quot;seeAllImagesAndVideoText&quot;:&quot;查看所有 1 张图片&quot;,&quot;asin&quot;:&quot;B0036WSTQ6&quot;,&quot;customerImageNum&quot;:0&#125;,&quot;imageData&quot;:&#123;&quot;x&quot;:&#123;&quot;seeAllMediaLinkHtml&quot;:&quot;&lt;a href&#x3D;\\&quot;#\\&quot; onclick&#x3D;\\&quot;return false;\\&quot;&gt; 查看所有 1 张图片 &lt;&#x2F;a&gt;&quot;,&quot;thumbHeight&quot;:32,&quot;largeHeight&quot;:&quot;300&quot;,&quot;thumbWidth&quot;:32,&quot;hasAnnotations&quot;:0,&quot;totalCount&quot;:1,&quot;seeAllImagesAndVideoText&quot;:&quot;查看所有 1 张图片&quot;,&quot;imgsWithAnnotations&quot;:[],&quot;videoCount&quot;:0,&quot;hiResHeight&quot;:1500,&quot;thumbImageSpace&quot;:7,&quot;medias&quot;:[&#123;&quot;largeImage&quot;:&quot;http:&#x2F;&#x2F;ec4.images-amazon.com&#x2F;images&#x2F;I&#x2F;51nWDd%2BQrXL._SL500_PIsitb-sticker-arrow-big,TopRight,35,-73_OU28_AA300_.jpg&quot;,&quot;largeImageId&quot;:&quot;main_image_0&quot;,&quot;thumbImageHtml&quot;:&quot;\\n\\n\\n\\n &lt;div id&#x3D;\\&quot;thumb_image_0\\&quot; class&#x3D;\\&quot;thumb selected\\&quot;&gt;&lt;img alt&#x3D;\\&quot;\\&quot; src&#x3D;\\&quot;http:&#x2F;&#x2F;ec4.images-amazon.com&#x2F;images&#x2F;I&#x2F;51nWDd%2BQrXL._SL75_AA32_.jpg\\&quot;&gt;&lt;&#x2F;div&gt;\\n\\n\\n\\n\\n\\n\\n&quot;,&quot;stretchyImages&quot;:null,&quot;originalLargeImage&quot;:&quot;http:&#x2F;&#x2F;ec4.images-amazon.com&#x2F;images&#x2F;I&#x2F;51nWDd%2BQrXL._SL500_PIsitb-sticker-arrow-big,TopRight,35,-73_OU28_.jpg&quot;,&quot;largeImageHtml&quot;:&quot;\\n\\n\\n \\n&lt;div id&#x3D;\\&quot;main_image_0\\&quot; class&#x3D;\\&quot;main-image-shot\\&quot;&gt;\\n &lt;div class&#x3D;\\&quot;main-image-outer-wrapper\\&quot;&gt;\\n &lt;div class&#x3D;\\&quot;main-image-middle-wrapper\\&quot;&gt;\\n &lt;div class&#x3D;\\&quot;main-image-inner-wrapper\\&quot;&gt;\\n &lt;img src&#x3D;\\&quot;http:&#x2F;&#x2F;ec4.images-amazon.com&#x2F;images&#x2F;I&#x2F;51nWDd%2BQrXL._SL500_PIsitb-sticker-arrow-big,TopRight,35,-73_OU28_AA300_.jpg\\&quot;\\n &#x2F;&gt;\\n &lt;&#x2F;div&gt;\\n &lt;&#x2F;div&gt;\\n &lt;&#x2F;div&gt;\\n&lt;&#x2F;div&gt;\\n\\n\\n\\n\\n\\n\\n&quot;,&quot;originalWidth&quot;:386,&quot;hiResImage&quot;:null,&quot;originalHeight&quot;:550,&quot;thumbImage&quot;:&quot;http:&#x2F;&#x2F;ec4.images-amazon.com&#x2F;images&#x2F;I&#x2F;51nWDd%2BQrXL._SL75_AA32_.jpg&quot;,&quot;imageId&quot;:&quot;image_0&quot;,&quot;caption&quot;:&quot;&quot;,&quot;type&quot;:&quot;productImage&quot;,&quot;clickAction&quot;:&quot;open_iv&quot;,&quot;thumbImageId&quot;:&quot;thumb_image_0&quot;&#125;],&quot;hiResWidth&quot;:1500,&quot;productImageCount&quot;:1,&quot;customerImageCount&quot;:0,&quot;isUploadCustomerImageDisable&quot;:0,&quot;largeWidth&quot;:&quot;300&quot;&#125;&#125;,&quot;productTitle&quot;:&quot;Web编程入门经典:HTML、XHTML和CSS(第2版)&quot;,&quot;hasAnnotations&quot;:0,&quot;productGroupID&quot;:&quot;book_display_on_website&quot;,&quot;initialSetIndex&quot;:&quot;x&quot;,&quot;ivResources&quot;:&#123;&quot;ivStaticImages&quot;:&#123;&quot;spinner&quot;:&quot;http:&#x2F;&#x2F;g-ec4.images-amazon.com&#x2F;images&#x2F;G&#x2F;28&#x2F;ui&#x2F;loadIndicators&#x2F;loading-large_labeled._V200622904_.gif&quot;,&quot;zoomOut&quot;:&quot;http:&#x2F;&#x2F;g-ec4.images-amazon.com&#x2F;images&#x2F;G&#x2F;28&#x2F;detail-page&#x2F;cursors&#x2F;zoom-out._V199309491_.bmp&quot;,&quot;boxSpinner&quot;:&quot;http:&#x2F;&#x2F;g-ec4.images-amazon.com&#x2F;images&#x2F;G&#x2F;28&#x2F;ui&#x2F;loadIndicators&#x2F;loading-large_boxed._V200459489_.gif&quot;,&quot;videoSWFPath&quot;:&quot;http:&#x2F;&#x2F;g-ec4.images-amazon.com&#x2F;images&#x2F;G&#x2F;28&#x2F;misc&#x2F;untranslatable-image-id.jpg&quot;,&quot;noWordsSpinner&quot;:&quot;http:&#x2F;&#x2F;g-ec4.images-amazon.com&#x2F;images&#x2F;G&#x2F;28&#x2F;ui&#x2F;loadIndicators&#x2F;loading-large._V201045688_.gif&quot;,&quot;zoomIn&quot;:&quot;http:&#x2F;&#x2F;g-ec4.images-amazon.com&#x2F;images&#x2F;G&#x2F;28&#x2F;detail-page&#x2F;cursors&#x2F;zoom-in._V199309503_.bmp&quot;,&quot;arrow&quot;:&quot;http:&#x2F;&#x2F;g-ec4.images-amazon.com&#x2F;images&#x2F;G&#x2F;28&#x2F;javascripts&#x2F;lib&#x2F;popover&#x2F;images&#x2F;light&#x2F;sprite-vertical-popover-arrow._V176699844_.png&quot;,&quot;videoThumbIcon&quot;:&quot;http:&#x2F;&#x2F;g-ec4.images-amazon.com&#x2F;images&#x2F;G&#x2F;28&#x2F;Quarterdeck&#x2F;en_US&#x2F;images&#x2F;video.gif&quot;&#125;,&quot;ivStaticStrings&quot;:&#123;&quot;playVideo&quot;:&quot;点击上面播放视频&quot;,&quot;images&quot;:&quot;图片&quot;,&quot;video&quot;:&quot;视频&quot;,&quot;videos&quot;:&quot;视频&quot;,&quot;close&quot;:&quot;关闭&quot;,&quot;pleaseSelect&quot;:&quot;请选择&quot;,&quot;clickToExpand&quot;:&quot;点击打开扩展视图&quot;,&quot;allMedia&quot;:&quot;全部格式&quot;&#125;&#125;,&quot;allCustomerImagesWithAnnotaion&quot;:[],&quot;videoPlayerConfig&quot;:&#123;&quot;swf&quot;:&quot;http:&#x2F;&#x2F;g-ec4.images-amazon.com&#x2F;images&#x2F;G&#x2F;28&#x2F;misc&#x2F;untranslatable-image-id.jpg&quot;&#125;,&quot;maxImageHeight&quot;:&quot;300&quot;,&quot;asin&quot;:&quot;B0036WSTQ6&quot;,&quot;useIV&quot;:1,&quot;arrowButtonImageSet&quot;:&#123;&quot;deactivatedBack&quot;:&quot;http:&#x2F;&#x2F;g-ec4.images-amazon.com&#x2F;images&#x2F;G&#x2F;28&#x2F;x-locale&#x2F;image-block&#x2F;hori-deactivated-left._V394121828_.png&quot;,&quot;clickedNext&quot;:&quot;http:&#x2F;&#x2F;g-ec4.images-amazon.com&#x2F;images&#x2F;G&#x2F;28&#x2F;x-locale&#x2F;image-block&#x2F;hori-clicked-right._V394121831_.png&quot;,&quot;deactivatedNext&quot;:&quot;http:&#x2F;&#x2F;g-ec4.images-amazon.com&#x2F;images&#x2F;G&#x2F;28&#x2F;x-locale&#x2F;image-block&#x2F;hori-deactivated-right._V394121831_.png&quot;,&quot;normalNext&quot;:&quot;http:&#x2F;&#x2F;g-ec4.images-amazon.com&#x2F;images&#x2F;G&#x2F;28&#x2F;x-locale&#x2F;image-block&#x2F;hori-normal-right._V394121833_.png&quot;,&quot;clickedBack&quot;:&quot;http:&#x2F;&#x2F;g-ec4.images-amazon.com&#x2F;images&#x2F;G&#x2F;28&#x2F;x-locale&#x2F;image-block&#x2F;hori-clicked-left._V394121832_.png&quot;,&quot;normalBack&quot;:&quot;http:&#x2F;&#x2F;g-ec4.images-amazon.com&#x2F;images&#x2F;G&#x2F;28&#x2F;x-locale&#x2F;image-block&#x2F;hori-normal-left._V394121829_.png&quot;&#125;,&quot;placeHolderImageUrl&quot;:&quot;http:&#x2F;&#x2F;g-ec4.images-amazon.com&#x2F;images&#x2F;G&#x2F;28&#x2F;nav2&#x2F;dp&#x2F;no-image-no-ciu._V192234541_AA300_.gif&quot;,&quot;hasVideo&quot;:0,&quot;useTwister&quot;:0,&quot;disableNoImageMessage&quot;:1,&quot;isUploadCustomerImageDisable&quot;:0,&quot;imageSize&quot;:&#123;&quot;thumbHeight&quot;:32,&quot;hiResHeight&quot;:1500,&quot;hiResWidth&quot;:1500,&quot;largeWidth&quot;:&quot;300&quot;,&quot;largeHeight&quot;:&quot;300&quot;,&quot;thumbWidth&quot;:32&#125;,&quot;useChromelessVideoPlayer&quot;:0,&quot;isTablets&quot;:0&#125;&#39;+&quot;)&quot;); amznJQ.available(&quot;jQuery&quot;, function() &#123; var seeAllMedialink &#x3D; jQuery(&quot;#see-all-image-and-video&quot;); seeAllMedialink.empty(); var seeAllMedialinkHtml &#x3D; &#39;&lt;a href&#x3D;&quot;#&quot; onclick&#x3D;&quot;return false;&quot;&gt; 查看所有 1 张图片 &lt;&#x2F;a&gt;&#39;; seeAllMedialink.append(seeAllMedialinkHtml); var IVLoadingSpinner &#x3D;jQuery(&quot;&lt;img&gt;&lt;&#x2F;img&gt;&quot;); IVLoadingSpinner.attr(&quot;id&quot;, &quot;loadingImage&quot;); IVLoadingSpinner.attr(&quot;src&quot;, imageBlockData.ivResources.ivStaticImages[&quot;noWordsSpinner&quot;]); IVLoadingSpinner.css(&#123;&quot;position&quot;:&quot;absolute&quot;,&quot;z-index&quot;: &quot;200&quot;, &quot;top&quot;:&quot;0px&quot;, &quot;left&quot;:&quot;0px&quot;, &quot;display&quot;:&quot;none&quot;&#125;); IVLoadingSpinner.insertBefore(jQuery(&quot;#image-block-widget&quot;)); &#125;); amznJQ.available(&quot;defaultInit&quot;, function() &#123; new ImageBlockInit(&#123;&#39;data&#39;:imageBlockData&#125;); &#125;); &#125;); &lt;&#x2F;script&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; if (window.amznJQ) &#123; amznJQ.onCompletion(&#39;amznJQ.criticalFeature&#39;, function() &#123; var precacheDetailImages &#x3D; function(imageUrls, pids) &#123; function transformUrl(imgUrl, pid) &#123; var suffix &#x3D; &#39;._SL500_AA300_.jpg&#39;, defaultApparel &#x3D; &#39;._AA300_.jpg&#39;, imgUrlSplit &#x3D; imgUrl.split(&quot;._&quot;); if (imgUrlSplit.length) &#123; var prefix &#x3D; imgUrlSplit[0]; if ((!pid &amp;&amp; storeName &#x3D;&#x3D; &quot;books&quot;) || pid &#x3D;&#x3D; &quot;books_display_on_website&quot;) &#123; if (imgUrl.match(&quot;PIsitb-sticker-arrow&quot;))&#123; var OUID &#x3D; imgUrl.substr(imgUrl.indexOf(&#39;_OU&#39;), 6); var lookInsideSticker &#x3D; &#39;._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20&#39;+ OUID +&#39;.jpg&#39;; urls.push(prefix + lookInsideSticker); &#125; else &#123; urls.push(prefix + suffix); &#125; &#125; else if ((!pid &amp;&amp; storeName &#x3D;&#x3D; &quot;apparel&quot;) || pid &#x3D;&#x3D; &quot;apparel_display_on_website&quot;) &#123; urls.push(prefix + defaultApparel); &#125; else if ((!pid &amp;&amp; storeName &#x3D;&#x3D; &quot;shoes&quot;) || pid &#x3D;&#x3D; &quot;shoes_display_on_website&quot;) &#123; urls.push(prefix + defaultApparel); &#125; else &#123; urls.push(prefix + suffix); &#125; &#125; &#125;; var urls &#x3D; [], numImgsPreload &#x3D; Math.min(6, imageUrls.length), storeName &#x3D; &quot;books&quot;; for (var i &#x3D; 0; i &lt; numImgsPreload; i++)&#123; var currPid &#x3D; (pids &amp;&amp; pids.length) ? pids[i] : &quot;&quot;; transformUrl(imageUrls[i], currPid); &#125; for (var j &#x3D; 0; j &lt; urls.length; j++) &#123; var img &#x3D; new Image(); img.src &#x3D; urls[j]; &#125; &#125;; var win &#x3D; jQuery(window); var feature &#x3D; jQuery(&quot;#purchaseShvl&quot;); var shvlPresent &#x3D; feature.length &gt; 0 ? 1:0; var lastCheck &#x3D; 0; var pending &#x3D; 0; var onScrollPrecache &#x3D; function() &#123; if (pending) &#123; return; &#125; var lastCheckDiff &#x3D; new Date().getTime() - lastCheck; var checkDelay &#x3D; (lastCheckDiff &lt; 200 ? 200 - lastCheckDiff : 10); pending &#x3D; 1; var u &#x3D; function() &#123; if(shvlPresent &amp;&amp; (win.scrollTop() + win.height() &gt; feature.offset().top + 200)) &#123; var p &#x3D; precacheDetailImages, $ &#x3D; jQuery; if (p) &#123; var selector &#x3D; &quot;#purchaseButtonWrapper&quot;; var imgElems &#x3D; $(selector).find(&quot;a &gt; div &gt; img&quot;); var pgs, imgs &#x3D; [], i &#x3D; imgElems.length; while (i-- &gt; 0) &#123; imgs[i] &#x3D; $(imgElems[i]).attr(&#39;src&#39;); &#125; p(imgs,pgs); &#125; &#x2F;&#x2F; unbind listening on scroll once pre-caching completed $(window).unbind(&#39;scroll&#39;, onScrollPrecache); return; &#125; pending &#x3D; 0; &#x2F;&#x2F;precache not execute yet, wait next invoke lastCheck &#x3D; new Date().getTime(); &#125;; setTimeout(u, checkDelay); return; &#125;; jQuery(window).bind(&#39;scroll&#39;, onScrollPrecache); &#125;); &#125; &lt;&#x2F;script&gt; &lt;div style&#x3D;&quot;clear: left; padding-bottom: 4px;&quot;&gt; &lt;span class&#x3D;&quot;caretback&quot;&gt;&amp;#139;&amp;nbsp;&lt;&#x2F;span&gt; &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.amazon.cn&#x2F;Web%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-HTML-XHTML%E5%92%8CCSS-%E8%BE%BE%E7%A7%91%E7%89%B9&#x2F;dp&#x2F;B0036WSTQ6&quot;&gt;返回商品介绍页&lt;&#x2F;a&gt; &lt;&#x2F;div&gt; &lt;br &#x2F;&gt; &lt;div id&#x3D;&quot;navFooter&quot; role&#x3D;&quot;contentinfo&quot;&gt;&lt;table class&#x3D;&quot;navFooterVerticalColumn&quot; cellspacing&#x3D;&quot;0&quot; align&#x3D;&quot;center&quot;&gt;&lt;tr&gt;&lt;td class&#x3D;&quot;navFooterLinkCol&quot;&gt;&lt;div class&#x3D;&quot;navFooterColHead&quot;&gt;了解我们&lt;&#x2F;div&gt;&lt;ul&gt;&lt;li class&#x3D;&quot;nav_first&quot;&gt;&lt;a href&#x3D;&quot;&#x2F;careers&quot; class&#x3D;&quot;nav_a&quot;&gt;人才招聘&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li&gt;&lt;a href&#x3D;&quot;&#x2F;b?ie&#x3D;UTF8&amp;node&#x3D;292590071&quot; class&#x3D;&quot;nav_a&quot;&gt;关于我们&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;nav_last&quot;&gt;&lt;a href&#x3D;&quot;&#x2F;gp&#x2F;press&quot; class&#x3D;&quot;nav_a&quot;&gt;新闻中心&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;&#x2F;td&gt;&lt;td class&#x3D;&quot;navFooterColSpacerInner&quot;&gt;&lt;&#x2F;td&gt;&lt;td class&#x3D;&quot;navFooterLinkCol&quot;&gt;&lt;div class&#x3D;&quot;navFooterColHead&quot;&gt;合作信息&lt;&#x2F;div&gt;&lt;ul&gt;&lt;li class&#x3D;&quot;nav_first&quot;&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;kaidian.amazon.cn&#x2F;?ld&#x3D;AZCNSOAFooter&quot; class&#x3D;&quot;nav_a&quot;&gt;我要开店&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;kaidian.amazon.cn&#x2F;services&#x2F;fulfilment-by-amazon&#x2F;benefit&#x2F;?ld&#x3D;AZCNFBA-Footer&quot; class&#x3D;&quot;nav_a&quot;&gt;亚马逊物流&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li&gt;&lt;a href&#x3D;&quot;&#x2F;lianmeng&#x2F;default.asp&quot; class&#x3D;&quot;nav_a&quot;&gt;加入联盟&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;nav_last&quot;&gt;&lt;a href&#x3D;&quot;&#x2F;gp&#x2F;feature.html?ie&#x3D;UTF8&amp;docId&#x3D;192638&quot; class&#x3D;&quot;nav_a&quot;&gt;合作伙伴&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;&#x2F;td&gt;&lt;td class&#x3D;&quot;navFooterColSpacerInner&quot;&gt;&lt;&#x2F;td&gt;&lt;td class&#x3D;&quot;navFooterLinkCol&quot;&gt;&lt;div class&#x3D;&quot;navFooterColHead&quot;&gt;购物资讯&lt;&#x2F;div&gt;&lt;ul&gt;&lt;li class&#x3D;&quot;nav_first&quot;&gt;&lt;a href&#x3D;&quot;&#x2F;gp&#x2F;sitemap&#x2F;ts_aps_a&quot; class&#x3D;&quot;nav_a&quot;&gt;潜力搜索&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li&gt;&lt;a href&#x3D;&quot;&#x2F;gp&#x2F;sitemap&#x2F;tp_aps_a&quot; class&#x3D;&quot;nav_a&quot;&gt;潜力商品&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li&gt;&lt;a href&#x3D;&quot;&#x2F;gp&#x2F;sitemap&#x2F;sg_a&quot; class&#x3D;&quot;nav_a&quot;&gt;购物指南&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;nav_last&quot;&gt;&lt;a href&#x3D;&quot;&#x2F;gp&#x2F;sitemap&#x2F;p_a&quot; class&#x3D;&quot;nav_a&quot;&gt;热门促销&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;&#x2F;td&gt;&lt;td class&#x3D;&quot;navFooterColSpacerInner&quot;&gt;&lt;&#x2F;td&gt;&lt;td class&#x3D;&quot;navFooterLinkCol&quot;&gt;&lt;div class&#x3D;&quot;navFooterColHead&quot;&gt;帮助服务&lt;&#x2F;div&gt;&lt;ul&gt;&lt;li class&#x3D;&quot;nav_first&quot;&gt;&lt;a href&#x3D;&quot;&#x2F;gp&#x2F;help&#x2F;customer&#x2F;display.html?ie&#x3D;UTF8&amp;nodeId&#x3D;200345350&quot; class&#x3D;&quot;nav_a&quot;&gt;付款与退款&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li&gt;&lt;a href&#x3D;&quot;&#x2F;mn&#x2F;remitlist&quot; class&#x3D;&quot;nav_a&quot;&gt;汇款单招领&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li&gt;&lt;a href&#x3D;&quot;&#x2F;gp&#x2F;help&#x2F;customer&#x2F;display.html?ie&#x3D;UTF8&amp;nodeId&#x3D;200345620&quot; class&#x3D;&quot;nav_a&quot;&gt;发货与配送&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li&gt;&lt;a href&#x3D;&quot;&#x2F;gp&#x2F;css&#x2F;returns&#x2F;homepage.html&quot; class&#x3D;&quot;nav_a&quot;&gt;退货与换货&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;nav_last&quot;&gt;&lt;a href&#x3D;&quot;&#x2F;gp&#x2F;help&#x2F;customer&#x2F;display.html&quot; class&#x3D;&quot;nav_a&quot;&gt;帮助&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt; &lt;div class&#x3D;&quot;navFooterLine navFooterLogoLine&quot;&gt;&lt;a href&#x3D;&quot;&#x2F;&quot;&gt;&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;g-ec4.images-amazon.com&#x2F;images&#x2F;G&#x2F;28&#x2F;gno&#x2F;images&#x2F;general&#x2F;navAmazonLogoFooter._V169459411_.gif&quot; width&#x3D;&quot;137&quot; alt&#x3D;&quot;amazon.cn&quot; height&#x3D;&quot;19&quot; border&#x3D;&quot;0&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;navFooterLine navFooterLinkLine navFooterPadItemLine navFooterLineDivider&quot;&gt;&lt;ul&gt;&lt;li class&#x3D;&quot;nav_first&quot;&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.amazon.com&#x2F;&quot; class&#x3D;&quot;nav_a&quot;&gt;美国&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.amazon.ca&#x2F;&quot; class&#x3D;&quot;nav_a&quot;&gt;加拿大&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.amazon.com.br&quot; class&#x3D;&quot;nav_a&quot;&gt;巴西&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.amazon.com.mx&#x2F;&quot; class&#x3D;&quot;nav_a&quot;&gt;墨西哥&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.amazon.co.uk&#x2F;&quot; class&#x3D;&quot;nav_a&quot;&gt;英国&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.amazon.fr&#x2F;&quot; class&#x3D;&quot;nav_a&quot;&gt;法国&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.amazon.it&#x2F;&quot; class&#x3D;&quot;nav_a&quot;&gt;意大利&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.amazon.es&#x2F;&quot; class&#x3D;&quot;nav_a&quot;&gt;西班牙&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.amazon.de&#x2F;&quot; class&#x3D;&quot;nav_a&quot;&gt;德国&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.amazon.co.jp&#x2F;&quot; class&#x3D;&quot;nav_a&quot;&gt;日本&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.amazon.in&#x2F;&quot; class&#x3D;&quot;nav_a&quot;&gt;印度&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;nav_last&quot;&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.amazon.com.au&quot; class&#x3D;&quot;nav_a&quot;&gt;澳大利亚&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&amp;nbsp;亚马逊家族网站:&lt;ul&gt;&lt;li class&#x3D;&quot;nav_first nav_last&quot;&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.shopbop.com&#x2F;cn&#x2F;welcome&quot; class&#x3D;&quot;nav_a&quot;&gt;Shopbop&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;navFooterLine navFooterLinkLine navFooterPadItemLine navFooterLineDivider&quot;&gt;&lt;ul&gt;&lt;li class&#x3D;&quot;nav_first&quot;&gt;&lt;a href&#x3D;&quot;&#x2F;gp&#x2F;help&#x2F;customer&#x2F;display.html?ie&#x3D;UTF8&amp;nodeId&#x3D;200347160&quot; class&#x3D;&quot;nav_a&quot;&gt;使用条件&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;nav_last&quot;&gt;&lt;a href&#x3D;&quot;&#x2F;gp&#x2F;help&#x2F;customer&#x2F;display.html?ie&#x3D;UTF8&amp;nodeId&#x3D;200347130&quot; class&#x3D;&quot;nav_a&quot;&gt;隐私声明&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&amp;nbsp;© 1999-2013 Amazon.com, Inc. or its affiliates&lt;ul&gt;&lt;&#x2F;ul&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;navFooterLine navFooterLinkLine navFooterPadItemLine&quot;&gt;&lt;ul&gt;&lt;li class&#x3D;&quot;nav_first nav_last&quot;&gt;互联网药品信息服务资格证书 (京)-非经营性-2012-0005&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;navFooterLine navFooterLinkLine navFooterPadItemLine&quot;&gt;&lt;ul&gt;&lt;li class&#x3D;&quot;nav_first&quot;&gt;京公网安备110105004167号&lt;&#x2F;li&gt;&lt;li&gt;增值电信业务经营许可证：&lt;&#x2F;li&gt;&lt;li&gt;&lt;a href&#x3D;&quot;&#x2F;gp&#x2F;redirect.html?location&#x3D;http:&#x2F;&#x2F;www.miibeian.gov.cn&#x2F;&amp;token&#x3D;109E030170D6ED5EEB5D2C65F846C7F93C688EB9&quot; class&#x3D;&quot;nav_a&quot;&gt;合字 B2-20090004&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;li class&#x3D;&quot;nav_last&quot;&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;qyxy.baic.gov.cn&#x2F;kscx&#x2F;kscxAction%21view.dhtml?kscxModel.reg_bus_ent_id&#x3D;716FD6738F544098A5D9948C83BC228D&amp;flag_cer&#x3D;0&quot; class&#x3D;&quot;nav_a&quot;&gt;营业执照：110105001308484&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;!-- whfh-6gpcvaN+&#x2F;yZs8u4WFGoarZpl8Ny8W2cKi54b2Zz9HiE&#x3D; rid-18K0K21FNAMSSG4HST14 --&gt; &lt;!--AMZNJQFINAL--&gt; &lt;div id&#x3D;&quot;amznCompressDiv&quot;&gt; &lt;&#x2F;div&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; if (window.amznJQ) &#123; amznJQ.onReady(&#39;jQuery&#39;, function () &#123; document.cookie&#x3D;&quot;GZ&#x3D;0;path&#x3D;&#x2F;&quot;; setTimeout(function() &#123; jQuery(&#39;#amznCompressDiv&#39;).append(&#39;&lt;iframe id&#x3D;&quot;amznCompressIframe&quot; width&#x3D;&quot;0&quot; height&#x3D;&quot;0&quot; frameborder&#x3D;&quot;0&quot; style&#x3D;&quot;display:none&quot;&gt; &lt;&#x2F;iframe&gt;&#39;); jQuery(&#39;#amznCompressIframe&#39;).attr(&#39;src&#39;, &#39;&#x2F;gp&#x2F;compression&#x2F;base&#x2F;detail&#39;); &#125;, 3000); &#125;); &#125; &lt;&#x2F;script&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; &lt;&#x2F;style&gt;&lt;&#x2F;iframe&gt; 元素 4.2.2 包含表行的 元素 4.2.3 表示表单元格的 元素和 元素 4.3 高级表 4.3.1 将表划分为表头、表主体和表尾 4.3.2 在表中添加 4.3.3 使用colspan属性跨越多列 4.3.4 使用rowspan属性跨越多行 4.3.5 使用 元素分组列 4.3.6 利用 元素让列共享样式 4.4 表的可访问性问题 4.4.1 表的线性化 4.4.2 用于布局的表线性化 4.4.3 用于数据的表线性化 4.5 本章小结 4.6 练习 第5章 表单 5.1 表单简介 5.2 利用</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0036WSTQ6/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0036WSTQ6&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51nWDd%2BQrXL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>Java消息服务(第2版)(Java消息服务英文)</title>
    <url>/2020/04/19/B003CT4KIE/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Java消息服务(第2版)(Java消息服务英文)<br>作者信息： 作者: 布朗(Mark Richards) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Java消息服务(第2版·影印版)》由东南大学出版社出版。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Foreword</span><br><span class="line">Preface</span><br><span class="line">1. Messaging Basics</span><br><span class="line">The Advantages of Messaging</span><br><span class="line">Heterogeneous Integration</span><br><span class="line">Reduce System Bottlenecks</span><br><span class="line">Increase Scalability</span><br><span class="line">Increase End User Productivity</span><br><span class="line">Architecture Flexibility and Agility</span><br><span class="line">Enterprise Messaging</span><br><span class="line">Centralized Architectures</span><br><span class="line">Decentralized Architectures</span><br><span class="line">Hybrid Architectures</span><br><span class="line">Centralized Architecture As a Model</span><br><span class="line">Messaging Models</span><br><span class="line">Point-to-Point</span><br><span class="line">Publish-and-Subscribe</span><br><span class="line">JMS API</span><br><span class="line">Point-to-Point API</span><br><span class="line">Publish-and-Subscribe API</span><br><span class="line">Real-World Scenarios</span><br><span class="line">Service-Oriented Architecture</span><br><span class="line">Event-Driven Architecture</span><br><span class="line">Heterogeneous Platform Integration</span><br><span class="line">Enterprise Application Integration</span><br><span class="line">Business-to-Business</span><br><span class="line">Geographic Dispersion</span><br><span class="line">Information Broadcasting</span><br><span class="line">Building Dynamic Systems</span><br><span class="line">RPC Versus Asynchronous Messaging</span><br><span class="line">Tightly Coupled RPC</span><br><span class="line">Enterprise Messaging </span><br><span class="line"></span><br><span class="line"> Developing a Simple Example The Chat Application Getting Started with the Chat Example Examining the Source Code Sessions and Threading Anatomy of a JMS Message Headers Automatically Assigned Headers Developer-Assigned Headers Properties Application-Specific Properties JMS-Defined Properties Provider-Specific Properties Message Types Message TextMessage ObjectMessage BytesMessage StreamMessage MapMessage Read-Only Messages Client-Acknowledged Messages Interoperability and Portability of Messages Point-to-Point Messaging Point-to-Point Overview When to Use Point-to-Point Messaging The QBorrower and QLender Application Configuring and Running the Application The QBorrower Class The QLender Class Message Correlation Dynamic Versus Administered Queues Load Balancing Using Multiple Receivers Examining a Queue Publish-and-Subscribe Messaging Publish-and-Subscribe Overview When to Use Publish-and-Subscribe Messaging The TBorrower and TLender Application Configuring and Running the Application The TLender Class The TBorrower Class Durable Versus Nondurable Subscribers Dynamic Versus Administered Subscribers Unsubscribing Dynamic Durable Subscribers Temporary Topics Message Filtering Message Selectors Identifiers Literals Comparison Operators Arithmetic Operators Declaring a Message Selector Message Selector Examples Managing Claims in an HMO Notification of Certain Bids on Inventory Priority Handling Stock Trade Order Auditing Not Delivered Semantics Design Considerations Guaranteed Messaging and Transactions Guaranteed Messaging Message Autonomy Store-and-Forward Messaging Message Acknowledgments and Failure Conditions Message Acknowledgments AUTO_ACKNOWLEDGE DUPS_OK_ACKNOWLEDGE CLIENT_ACKNOWLEDGE Message Groups and Acknowledgment Handling Redelivery of Messages in an Application Message Groups Example Message Grouping and Multiple Receivers Transacted Messages Creating and Using a JMS Transaction Transacted Session Example Distributed Transactions Lost Connections The ExceptionListener Example Dead Message Queues Java EE and Message-Driven Beans Java EE Overview Enterprise JavaBeans Enterprise JavaBeans 3.0 (EJB3) Overview Simplified Bean Development Dependency Injection Simplified Callback Methods Programmatic Defaults Interceptors Java Persistence API JMS Resources in Java EE The JNDI Environment Naming Context (ENC) Message-Driven Beans Concurrent Processing and Scalability Defining Message-Driven Beans Message-Driven Bean Use Cases Message Facade Transformation and Routing Spring and JMS Spring Messaging Architecture JmsTemplate Overview Send Methods convertAndSend Methods receive and receiveSelected Methods receiveAndConvert Methods Connection Factories and JMS Destinations Using JNDI Using Native Classes Sending Messages Using the send Method Using the convertAndSend Method Using a Nondefault JMS Destination Receiving Messages Synchronously Message-Driven POJOs The Spring Message Listener Container MDP Option 1: Using the MessageListener Interface MDP Option 2: Using the SessionAwareMessageListener Interface MDP Option 3: Using the MessageListenerAdapter Message Conversion Limitations The Spring JMS Namespace [jms:listener-container] Element Properties [jms:listener] Element Properties Deployment Considerations Performance, Scalability, and Reliability Determining Message Throughput Requirements Testing the Real-World Scenario To Multicast or Not to Multicast TCP&#x2F;IP UDP IP Multicast Messaging Over IP Multicast The Bottom Line Security Authentication Authorization Secure Communication Firewalls and HTTP Tunneling Connecting to the Outside World Bridging to Other Messaging Systems Messaging Design Considerations Internal Versus External Destination Internal Destination Topology External Destination Topology Request&#x2F;Reply Messaging Design Messaging Design Anti-Patterns Single-Purpose Queue Message Priority Overuse Message Header Misuse The Java Message Service API Message Headers Message Properties Installing and Configuring ActiveMQ Index</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B003CT4KIE/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B003CT4KIE&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/511KOHo6BkL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery攻略</title>
    <url>/2020/04/19/B0046XB3HG/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： jQuery攻略<br>作者信息： 作者: 哈瓦尼(B.M.Harwani) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《jQuery攻略》：jQuery是目前应用最广泛的。JavaScript框架之一，已经成为微软ASP.NET、Visual Studio和诺基亚Web Run Time等主流开发平台的重要组成部分。借助jQuery的魔力，数十行。JavaScrip代码可以被神奇地压缩成区区几行。诸多Web开发人员就是在那一瞬间深深迷恋上了这个方便快捷、功能完备的利器。《jQuery攻略》从实际应用角度出发，介绍了使用jQuery的方方面面。不仅包括处理字符串等比较基础的内容。还涉及表单验证、视觉特效等进阶知识，以及如何使用它来实现Ajax功能。如何使用插件得到更高的开发效率，等等，几乎囊括了在使用jQuery的过程中遇到的各类问题。此外。作者按照“问题描述——解决方案——知其所以然”的思路组织全书内容，将各种实用的jQuery技巧穿插在案例中，使读者轻松掌握jQuery。  jQuery专家力作  jQuery实用技巧大全  深入浅出，切中肯綮</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 jQuery基础知识 1</span><br><span class="line">1.1 jQuery的安装 1</span><br><span class="line">1.2 选择DOM节点 2</span><br><span class="line">1.3 延迟JavaScript的执行 3</span><br><span class="line">1.4 把CSS应用到元素上 3</span><br><span class="line">1.5 选择一系列非标准的HTML元素 4</span><br><span class="line">1.6 计数DOM节点和显示其文本 5</span><br><span class="line">1.7 获得一个元素的HTML代码 7</span><br><span class="line">1.8 改变DOM节点的内容 8</span><br><span class="line">1.9 快速创建DOM节点 9</span><br><span class="line">1.10 为不同HTML元素分配相同类名并对它们应用样式 12</span><br><span class="line">1.11 小结 13 </span><br><span class="line"></span><br><span class="line"> 第2章 数组和字符串 14 2.1 利用数组在列表中显示名字 14 2.2 操作数组元素 17 2.3 筛选数组元素，只显示所需的数据 19 2.4 字符串数组和数值数组的排序 22 2.5 拆分数组 24 2.6 合并数组 26 2.7 把数值数组转换成字符串，并查找其子字符串 27 2.8 创建对象数组 28 2.9 为对象数组排序 30 2.10 小结 32</span><br><span class="line"></span><br><span class="line"> 第3章 事件处理 33 3.1 查找被点击的按钮 34 3.2 自动触发事件 37 3.3 点击之后禁用按钮 39 3.4 处理鼠标事件 40 3.5 查明哪个鼠标键被按下 43 3.6 查找鼠标按下时的屏幕坐标 44 3.7 动态地突出显示文本 45 3.8 随着鼠标移动使图像明亮或模糊 47 3.9 查明元素何时获得和失去焦点 49 3.10 在按钮上应用悬停效果 50 3.11 切换应用一个CSS类 52 3.12 创建基于图像的变换 54 3.13 为响应事件而添加和删除文本 57 3.14 应用样式作为对事件的响应 58 3.15 显示文字气球 60 3.16 创建“返回顶部”链接 63 3.17 提供“更多……”链接 64 3.18 以动画效果显示文本 67 3.19 以滑动效果来替换文本 70 3.20 使图像滚动 71 3.21 确定被按下的键 75 3.22 防止事件冒泡 77 3.23 链接多个活动 80 3.24 小结 81</span><br><span class="line"></span><br><span class="line"> 第4章 表单验证 82 4.1 确认必需字段不留空 82 4.2 验证数字字段 84 4.3 验证电话号码 88 4.4 验证用户ID 90 4.5 验证日期 92 4.6 验证电子邮件地址 94 4.7 检查复选框是否被选中 96 4.8 检查单选按钮是否被选中 99 4.9 检查select元素中的选项是否被选中 101 4.10 把样式应用到选项和表格按钮 104 4.11 一步选择或取消所有的复选框 107 4.12 验证两个字段 110 4.13 验证密码和确认密码字段是否匹配 113 4.14 禁用某些字段 116 4.15 验证整个表单 118 4.16 表单数据序列化 128 4.17 小结 132</span><br><span class="line"></span><br><span class="line"> 第5章 页面导航 133 5.1 编写面包屑菜单 133 5.2 把悬停效果添加到菜单项 135 5.3 创建上下文菜单 137 5.4 创建具有快捷键的导航菜单 140 5.5 创建一个右键单击上下文菜单 144 5.6 创建具有独立菜单项的两个菜单 147 5.7 建立包含子菜单项的两个菜单 149 5.8 创建折叠式菜单 153 5.9 创建动态可视化菜单 156 5.10 小结 161</span><br><span class="line"></span><br><span class="line"> 第6章 视觉特效 162 6.1 水平和垂直显示图片 162 6.2 创建水平滑动的图片浏览器 165 6.3 显示一幅图片，点击时向左滚动并消失 166 6.4 创建图片，使它向左滚动消失，然后从右侧重新出现 169 6.5 使图片在浏览器窗口中间滚动 171 6.6 在鼠标悬停时依次显示图片 172 6.7 垂直滚动图片 175 6.8 水平滚动图片 179 6.9 创建新闻滚动浏览器 183 6.10 在鼠标悬停时显示放大的图片 188 6.11 按页显示图片 193 6.12 在任意两个方向上切换图片 196 6.13 编写钟摆式滚动器 199 6.14 使用数组来滚动图片 202 6.15 小结 205</span><br><span class="line"></span><br><span class="line"> 第7章 处理表格 206 7.1 在鼠标悬停时突出显示行 206 7.2 交替突出显示相邻列 207 7.3 过滤行 211 7.4 隐藏选定列 213 7.5 分页显示表格 215 7.6 展开和折叠列表项 218 7.7 展开和折叠行 221 7.8 对列表项目排序 226 7.9 对表格排序 227 7.10 过滤表格中的行 233 7.11 小结 235</span><br><span class="line"></span><br><span class="line"> 第8章 Ajax 237 8.1 显示欢迎信息 237 8.2 执行认证 241 8.3 验证用户名 243 8.4 验证邮件地址 246 8.5 使用自动完成 252 8.6 导入HTML 256 8.7 取得JSON数据 259 8.8 取得XML数据 261 8.9 分页显示表格 265 8.10 小结 268</span><br><span class="line"></span><br><span class="line"> 第9章 使用插件 269 9.1 对表格的任一列进行过滤，并且可以设置每页的行数 269 9.2 为图片添加注解 271 9.3 拖放表格中的行 273 9.4 取得、序列化并清理表单控件 275 9.5 通过Ajax提交表单 277 9.6 找到元素的准确位置和大小 281 9.7 以传送带的方式显示图片 284 9.8 使用datepicker选择日期 286 9.9 对表格排序 288 9.10 小结 289</span><br><span class="line"></span><br><span class="line"> 第10章 使用CSS 290 10.1 区分HTML元素 291 10.2 向内嵌在一个元素中的另一个元素应用样式 292 10.3 缩进段落 293 10.4 将段落的首字母设为大写 294 10.5 去除标题和段落之间的间隔 295 10.6 向标题文字应用样式 297 10.7 缩进多个段落的第一行 297 10.8 创建带有悬挂缩进的段落 298 10.9 创建带有边框的提取引用 299 10.10 创建带有图片的提取引用 301 10.11 向列表项应用列表属性 302 10.12 只对选定的列表项应用样式 303 10.13 在列表项之间放置分隔线 306 10.14 向列表应用图片标记 307 10.15 创建水平显示的列表 308 10.16 在超链接上应用样式 309 10.17 为HTML元素赋予不同的尺寸 311 10.18 放置HTML元素 313 10.19 创建多栏的布局 314 10.20 使文字围绕图片显示 316 10.21 在图片背后放置阴影 317 10.22 当鼠标移过链接的时候改变鼠标样式 319 10.23 在指定的区域中显示长文字 320 10.24 创建圆角的栏 322 10.25 应用文字装饰 323 10.26 缩放图片 324 10.27 设置背景图片 326 10.28 使背景图片在浏览器中央显示 327 10.29 保持背景图片固定 328 10.30 小结 330</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0046XB3HG/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0046XB3HG&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51X8l3Vn6TL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>iPhone开发秘籍(第2版)</title>
    <url>/2020/04/19/B004BA21TI/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： iPhone开发秘籍(第2版)<br>作者信息： 作者: 萨丹(Erica Sadun) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《iPhone开发秘籍(第2版)》：iPhone开发的重量级参考书揭示官方文档未详述的细节代码示例清晰易懂想要为iPhone和iPod touch构建应用吗？是否已投身iPhone应用开发之列，并想迅速提升自己的功力？《iPhone开发秘籍(第2版)》将为你提供专家级的指导，带你领略绝妙的代码示例！《iPhone开发秘籍(第2版)》在第一版的基础上进行了全面修订和大量扩充，当之无愧地成为iPhone开发的必备佳作。《iPhone开发秘籍(第2版)》面向已经熟悉ObjectiVe-C、Xcode和C0coa框架的中高级iPhone和Mac开发人员。并简单介绍TObjective-C、Xcode和Inte rface Builder-以便没有这些语言（或工具）使用经验的开发人员也能够快速融入Mac／iPhone世界。《iPhone开发秘籍(第2版)》这一版新增内容主要包括：使用iPhone SDK设计和定制界面使用手势、触摸和其他高级界面功能充分挖掘表、视图、视图控制器和动画的潜力使用进度条、状态栏更新和其他指示器使用推送通知功能发送消息用MediaKit播放音频与视频使用地址簿、Core Locatjon和传感器连接网络和Web服务使MapKit~Google Mobile Maps嵌入地图使用GameKit构建多人游戏使用Core Data构建数据驱动的应用使用StoreKit开发应用内购买的功能与服务使用辅助功能构建残障人士可访问的应用</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 iphone sdk简介 1</span><br><span class="line">1.1 iphone开发人员计划 1</span><br><span class="line">1.1.1 在线开发人员计划 1</span><br><span class="line">1.1.2 标准开发人员计划 2</span><br><span class="line">1.1.3 企业开发人员计划 2</span><br><span class="line">1.1.4 大学开发人员计划 2</span><br><span class="line">1.1.5 注册 2</span><br><span class="line">1.2 开始 2</span><br><span class="line">1.2.1 下载sdk 2</span><br><span class="line">1.2.2 开发设备 3</span><br><span class="line">1.2.3 模拟器的限制 4</span><br><span class="line">1.2.4 tethering 4</span><br><span class="line">1.3 理解型号差异 5</span><br><span class="line">1.3.1 摄像头 5</span><br><span class="line">1.3.2 扬声器和麦克风 5</span><br><span class="line">1.3.3 手机 6</span><br><span class="line">1.3.4 core location的差异 6</span><br><span class="line">1.3.5 振动支持和接近传感器 6</span><br><span class="line">1.3.6 处理器速度 6</span><br><span class="line">1.3.7 opengl es 7</span><br><span class="line">1.4 平台限制 7</span><br><span class="line">1.4.1 存储限制 7</span><br><span class="line">1.4.2 数据访问限制 7</span><br><span class="line">1.4.3 内存限制 7</span><br><span class="line">1.4.4 交互限制 8</span><br><span class="line">1.4.5 电量限制 8</span><br><span class="line">1.4.6 应用程序限制 8</span><br><span class="line">1.4.7 用户行为限制 9</span><br><span class="line">1.5 sdk限制 9</span><br><span class="line">1.6 使用开发人员门户 9</span><br><span class="line">1.6.1 建立团队 10</span><br><span class="line">1.6.2 请求证书 10</span><br><span class="line">1.6.3 注册设备 11</span><br><span class="line">1.6.4 注册应用程序标识符 11</span><br><span class="line">1.6.5 设置 12</span><br><span class="line">1.7 组建iphone项目 12</span><br><span class="line">1.7.1 iphone应用程序的主干 13</span><br><span class="line">1.7.2 main.m 14</span><br><span class="line">1.7.3 应用程序委托 15</span><br><span class="line">1.7.4 视图控制器 16</span><br><span class="line">1.7.5 关于本书示例代码的说明 16</span><br><span class="line">1.8 iphone应用程序组件 17</span><br><span class="line">1.8.1 应用程序文件夹层次结构 17</span><br><span class="line">1.8.2 可执行文件 17</span><br><span class="line">1.8.3 info.plist文件 17</span><br><span class="line">1.8.4 图标和默认图像 19</span><br><span class="line">1.8.5 nib文件 20</span><br><span class="line">1.8.6 应用程序束中不存在的文件 20</span><br><span class="line">1.8.7 ipa归档 20</span><br><span class="line">1.8.8 沙盒 20</span><br><span class="line">1.9 编程范例 21</span><br><span class="line">1.9.1 面向对象编程 21</span><br><span class="line">1.9.2 模型-视图-控制器 22</span><br><span class="line">1.10 小结 27 </span><br><span class="line"></span><br><span class="line"> 第2章 构建第一个项目 28 2.1 创建新项目 28 2.2 用模板构建hello world应用程序 29 2.2.1 创建新项目 29 2.2.2 project窗口 30 2.2.3 detail窗格 31 2.2.4 编辑器窗口 32 2.2.5 查看项目 32 2.2.6 打开视图控制器.xib 33 2.2.7 编辑视图 34 2.2.8 运行应用程序 34 2.3 使用模拟器 35 2.4 极简单的hello world 36 2.4.1 浏览sdk api 38 2.4.2 将interface builder文件转换成objective-c代码 39 2.5 使用调试器 41 2.5.1 设置断点 41 2.5.2 打开调试器 41 2.5.3 运行程序 41 2.5.4 查看标签 42 2.5.5 设置另一个断点 42 2.5.6 使用文本消息 43 2.5.7 移动clear log按钮 43 2.5.8 启用zombie 44 2.6 内存管理 45 2.6.1 泄漏 45 2.6.2 缓存 45 2.7 秘诀：使用instruments检测内存泄漏 46 2.8 秘诀：使用instruments监视缓存对象的内存分配 48 2.9 使用clang静态分析器 50 2.10 针对iphone进行构建 51 2.10.1 安装开发配置 51 2.10.2 编辑应用程序标识符 51 2.10.3 设置code signing identity 52 2.10.4 编译和运行hello world应用程序 53 2.10.5 对编译后的应用程序签名 53 2.11 从xcode到iphone：organizer interface 54 2.11.1 projects and sources列表 54 2.11.2 devices列表 55 2.11.3 iphone development tools列表 55 2.11.4 summary选项卡 55 2.11.5 console选项卡 56 2.11.6 crash logs选项卡 56 2.11.7 screenshot选项卡 57 2.12 使用编译器指令 57 2.12.1 获得特定于iphone的定义 58 2.12.2 运行时检查 58 2.12.3 记忆标记 59 2.12.4 折叠方法 60 2.13 针对发布进行构建 60 2.14 清除构建 61 2.14.1 针对app store进行编译 62 2.14.2 调试app store上传 63 2.15 针对临时发布进行构建 64 2.15.1 注册设备 64 2.15.2 构建临时配置 64 2.15.3 在项目中添加授权文件 64 2.15.4 在设置中添加授权文件 64 2.15.5 构建临时应用程序 65 2.15.6 为临时发布添加图片 65 2.16 定制xcode标识 66 2.17 创建自定义xcode模板 66 2.17.1 覆盖com.yourcompany 67 2.17.2 构建其他模板 67 2.18 并排查看代码 68 2.19 小结 69</span><br><span class="line"></span><br><span class="line"> 第3章 objective-c训练营 70 3.1 objective-c编程语言 70 3.2 类与对象 70 3.2.1 创建对象 72 3.2.2 内存分配 72 3.2.3 释放内存 73 3.3 方法、消息和选择器 73 3.3.1 动态类型检查 74 3.3.2 继承方法 75 3.3.3 声明方法 76 3.3.4 实现方法 76 3.3.5 类方法 78 3.3.6 快速枚举 78 3.4 类层次结构 79 3.5 日志信息 79 3.6 属性 81 3.6.1 点表示法 81 3.6.2 属性与内存管理 81 3.6.3 创建属性 82 3.6.4 创建自定义的取值方法和赋值方法 83 3.6.5 属性的特性 84 3.7 简单的内存管理 85 3.7.1 创建对象 85 3.7.2 创建自动释放的对象 86 3.7.3 自动释放对象的生命周期 87 3.7.4 保留自动释放的对象 87 3.7.5 已保留属性 87 3.7.6 高保留计数 89 3.7.7 创建对象的其他方式 90 3.7.8 释放对象 91 3.8 创建单例 93 3.9 类别（扩展类） 93 3.10 协议 94 3.10.1 定义协议 95 3.10.2 合并协议 95 3.10.3 增加回调 95 3.10.4 声明可选回调 96 3.10.5 实现可选回调 96 3.10.6 符合协议 97 3.11 foundation类 97 3.11.1 字符串 98 3.11.2 数字与日期 101 3.11.3 集合 103 3.12 补充内容：消息转发 107 3.12.1 实现消息转发 108 3.12.2 使用转发消息 109 3.12.3 思路整理 109 3.12.4 超级简单的转发 110 3.13 小结 110</span><br><span class="line"></span><br><span class="line"> 第4章 设计界面 111 4.1 uiview和uiwindow 111 4.1.1 显示数据的视图 111 4.1.2 做出选择的视图 112 4.1.3 控件 112 4.1.4 表格和拾取器 113 4.1.5 栏 113 4.1.6 进度与活动 114 4.2 uiviewcontroller 114 4.2.1 uiviewcontroller 114 4.2.2 uinavigationcontroller 115 4.2.3 uitabbarcontroller 115 4.2.4 表格控制器 115 4.2.5 地址簿控制器 116 4.2.6 uiimagepickercontroller 116 4.2.7 邮件撰写 116 4.2.8 gkpeerpickercontroller 116 4.2.9 media player控制器 117 4.3 视图设计几何学 117 4.3.1 状态栏 117 4.3.2 导航栏、工具栏和选项卡栏 118 4.3.3 键盘和拾取器 119 4.3.4 文本字段 120 4.3.5 uiscreen类 120 4.4 构建界面 120 4.5 实战演练：使用ib构建温度单位转换器 121 4.5.1 新建项目 121 4.5.2 添加媒体 121 4.5.3 interface builder 121 4.5.4 编辑导航栏 122 4.5.5 替换主视图 123 4.5.6 启用仿真元素 123 4.5.7 创建图像背景 123 4.5.8 添加标签和视图 123 4.5.9 测试界面 124 4.5.10 添加出口和动作 124 4.5.11 检查新类头 125 4.5.12 添加连接 126 4.5.13 获取紫色 126 4.5.14 定义转换方法 127 4.5.15 运行应用程序 127 4.6 实战演练：手动构建温度单位转换器界面 127 4.7 实战演练：创建混合转换器 130 4.7.1 清理基本模板 131 4.7.2 通过.xib添加新视图控制器类 131 4.7.3 设计界面 131 4.7.4 编辑视图控制器实现 132 4.7.5 编辑main.m 132 4.7.6 运行应用程序 133 4.8 实战演练：直接从代码加载.xib文件 133 4.8.1 清理.xib 134 4.8.2 更新loadview 134 4.9 针对旋转进行设计 134 4.10 启用旋转 135 4.11 自动调整大小 136 4.11.1 自动调整大小示例 136 4.11.2 评估自动调整大小选项 138 4.12 移动视图 138 4.13 交换视图 141 4.14 补充内容：6个有用的interface builder技巧 142 4.15 小结 143</span><br><span class="line"></span><br><span class="line"> 第5章 使用视图控制器 144 5.1 使用导航控制器开发 144 5.1.1 设置导航控制器 144 5.1.2 推入和弹出视图控制器 145 5.1.3 导航项类 145 5.1.4 模态演示 146 5.2 实用工具函数 146 5.3 秘诀：构建一个简单的双项菜单 147 5.4 秘诀：添加一个分段控件 149 5.5 秘诀：在视图控制器之间导航 150 5.6 秘诀：使用创意弹出选项 152 5.6.1 加载一个视图控制器数组 152 5.6.2 推入临时视图 152 5.7 秘诀：演示一个自定义模态信息视图 153 5.8 秘诀：选项卡栏 155 5.9 秘诀：记住选项卡状态 157 5.10 补充点：interface builder和选项卡栏控制器 160 5.11 小结 161</span><br><span class="line"></span><br><span class="line"> 第6章 组合视图和动画 162 6.1 视图层次结构 162 6.2 秘诀：建立视图层次结构树 163 6.3 秘诀：查询子视图 164 6.4 管理子视图 166 6.4.1 添加子视图 166 6.4.2 重新排序和删除子视图 166 6.4.3 视图回调 166 6.5 秘诀：标记和检索视图 167 6.6 秘诀：命名视图 168 6.7 视图的几何特征 172 6.7.1 框架 172 6.7.2 变换 173 6.7.3 坐标系 173 6.8 秘诀：视图框架的处理 173 6.8.1 调整大小 174 6.8.2 cgrect和中心 175 6.8.3 其他实用工具方法 176 6.9 秘诀：移动带边界的视图到任意位置 179 6.10 秘诀：视图变形 180 6.11 显示和交互特性 183 6.12 uiview动画 183 6.12.1 建立uiview动画块 184 6.12.2 动画回调 184 6.13 秘诀：视图的淡入和淡出 185 6.14 秘诀：视图交换 186 6.15 秘诀：翻转视图 187 6.16 秘诀：使用core animation transitions 188 6.17 秘诀：一般的core animation调用 190 6.18 翻页过渡 192 6.19 秘诀：当视图显示时反弹视图 193 6.20 秘诀：图像视图动画 195 6.21 补充内容：给视图添加映射 196 6.22 小结 199</span><br><span class="line"></span><br><span class="line"> 第7章 图像处理 201 7.1 秘诀：查找和加载图像 201 7.1.1 读取图像数据 201 7.1.2 加载图像文件 203 7.2 秘诀：从iphone相册访问照片 205 7.2.1 使用图像拾取器 206 7.2.2 添加2.x支持 206 7.2.3 添加3.1支持 206 7.2.4 拾取视频 206 7.3 秘诀：选择和定制相册中的图像 208 7.4 秘诀：拍摄照片并将照片写到相册上 210 7.5 秘诀：将图片保存到documents文件夹 212 7.6 秘诀：通过电子邮件发送图片 213 7.7 秘诀：捕捉定时拍摄的照片 214 7.8 秘诀：使用定制摄像头覆盖图 216 7.9 秘诀：在可滚动视图中显示图像 218 7.10 秘诀：创建多图像分页滚动 220 7.11 秘诀：从头开始创建新图像 221 7.12 秘诀：构建图像缩略图 224 7.13 调整照片方向 227 7.14 捕捉屏幕截图 229 7.15 秘诀：直接处理位图 230 7.15.1 在位图上下文中绘制 230 7.15.2 应用图像处理 232 7.15.3 图像处理实况 233 7.16 补充内容：灰度模式 236 7.17 小结 237</span><br><span class="line"></span><br><span class="line"> 第8章 手势和触摸 238 8.1 触摸 238 8.1.1 阶段 238 8.1.2 触摸和视图方法 239 8.1.3 触摸视图 239 8.1.4 多点触摸 240 8.2 秘诀：添加一个简单直观的操作界面 240 8.3 秘诀：限制移动 241 8.4 秘诀：测试触摸 242 8.5 秘诀：测试位图上的触摸 243 8.6 秘诀：向直接操作界面添加持久性 246 8.6.1 存储状态 246 8.6.2 恢复状态 247 8.7 秘诀：通过归档实现持久性 248 8.8 秘诀：添加撤销支持 250 8.8.1 创建撤销管理器 250 8.8.2 子视图撤销支持 250 8.8.3 使用导航栏 250 8.8.4 注册撤销 251 8.9 秘诀：添加晃动控制的撤销支持 252 8.9.1 添加撤销和恢复的动作名称 253 8.9.2 提供晃动以编辑支持 253 8.9.3 设置第一个响应程序 253 8.10 秘诀：屏幕绘图 254 8.11 秘诀：线的计算 255 8.12 秘诀：检测圆形 257 8.13 秘诀：多点触摸 259 8.14 秘诀：区分手势 260 8.15 补充内容：交互式调整大小和旋转 264 8.16 小结 269</span><br><span class="line"></span><br><span class="line"> 第9章 构建和使用控件 270 9.1 uicontrol类 270 9.1.1 控件种类 270 9.1.2 控件事件 270 9.2 按钮 272 9.3 在interface builder中添加按钮 273 9.3.1 样式 273 9.3.2 连接按钮与动作 274 9.3.3 假按钮 275 9.4 在xcode中构建定制按钮 275 9.5 多行按钮文本 277 9.6 向按钮添加动画元素 277 9.7 秘诀：为按钮响应制作动画效果 278 9.8 秘诀：使用开关 279 9.9 秘诀：添加定制滑块缩略图 281 9.9.1 定制uislider 281 9.9.2 增加效能 282 9.10 秘诀：创建一个可两次点击的分段控件 286 9.11 秘诀：子类化uicontrol 287 9.11.1 跟踪触摸 288 9.11.2 分派事件 288 9.12 秘诀：关闭uitextfield键盘 290 9.12.1 文本特征属性 291 9.12.2 其他文本字段属性 291 9.13 秘诀：关闭uitextview键盘 292 9.14 秘诀：构建更好的文本编辑器 294 9.15 秘诀：文本输入筛选 296 9.16 秘诀：添加一个页面指示器控件 298 9.17 秘诀：创建一个可定制的分页滚动条 300 9.18 秘诀：构建工具栏 304 9.18.1 在xcode中构建工具栏 305 9.18.2 工具栏提示 307 9.19 补充内容：智能标签 307 9.20 小结 308</span><br><span class="line"></span><br><span class="line"> 第10章 提醒用户 309 10.1 通过警告框直接与用户对话 309 10.1.1 构建简单的警告框 309 10.1.2 警告框委托 310 10.1.3 显示警告框 311 10.1.4 警告框类 311 10.2 秘诀：无按钮警告框 312 10.3 秘诀：使用run循环创建模态警告框 313 10.4 秘诀：要求用户进行文本输入 316 10.5 秘诀：对警告框视图使用可变参数 318 10.6 秘诀：展示简单的菜单 319 10.7 秘诀：在动作表中显示文本 321 10.8 “please wait”：向用户显示进度 321 10.9 秘诀：构建uiprogressview 322 10.10 构建定制覆盖图 324 10.11 秘诀：可点击的覆盖图 326 10.12 秘诀：可调整方向的滚动警告框 327 10.13 秘诀：使用网络活动指示器 329 10.14 秘诀：给应用程序贴标记 329 10.15 秘诀：简单的音频警告 330 10.15.1 系统声音 330 10.15.2 震动 331 10.15.3 警告 331 10.15.4 延迟 332 10.16 补充内容：展示音量警告框 333 10.17 小结 333</span><br><span class="line"></span><br><span class="line"> 第11章 创建和管理表格视图 335 第12章 使用gamekit和bonjour进行连接 391 第13章 网络连接 432 第14章 设备能力 471 第15章 音频、视频和媒体工具 488 第16章 推送通知 525 第17章 使用core location和mapkit 552 第18章 连接地址簿 578 第19章 使用core data 605 第20章 storekit：应用程序内购买 623 第21章 辅助功能以及其他iphone os服务 637 附录a info.plist密钥 653</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B004BA21TI/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B004BA21TI&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/5173KmpKyHL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员的思维修炼 开发认知潜能的九堂课</title>
    <url>/2020/04/19/B004GCCAFQ/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 程序员的思维修炼 开发认知潜能的九堂课<br>作者信息： 作者: 亨特(Andy Hunt) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《程序员的思维修炼:开发认知潜能的九堂课》：做一名程序员，就意味着要不断地学习，不但要学习新技术，还要学习怎么解决应用领域的问题，要了解用户社区的奇思妙想，要适应同事的怪癖，等等。在《程序员的思维修炼:开发认知潜能的九堂课》中。作者将带领大家共同经历一次有关认知科学、神经学、学习和行为理论的旅程，探索人类大脑令人惊奇的工作机制，并研究如何克服这一系统局限来提高自己的学习和思考技能。书中主要内容包括：成为一名专家级程序员的关键要素，大脑运行机制简介，如何正确使用和调试大脑。改进学习能力的具体技巧，如何通过自我引导积累经验。控制注意力的方法。为了让读者加深印象。作者还特别设立了一个“实践单元”，其中包括具体的练习和实验，旨在让读者真正掌握所学内容。生命中没有什么是一成不变的。人们需要改变自己的习惯和方法。不论你是程序员、软件公司管理者、技术奇人还是思想家。或者你只是想让自己的大脑更聪明一点儿，所有尝试改变自己的人，请把《程序员的思维修炼:开发认知潜能的九堂课》当作改变的开始……</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 绪论 1</span><br><span class="line">1.1 再提“实用” 3</span><br><span class="line">1.2 关注情境 4</span><br><span class="line">1.3 所有人都关注这些技能 5</span><br><span class="line">1.4 本书结构 6</span><br><span class="line">1.5 致谢 9 </span><br><span class="line"></span><br><span class="line"> 第2章 从新手到专家的历程 11 2.1 新手与专家 12 2.2 德雷福斯模型的5个阶段 15 2.3 现实中的德雷福斯模型：赛马和赛羊 21 2.4 有效地使用德雷福斯模型 26 2.5 警惕工具陷阱 32 2.6 再一次考虑情境 34 2.7 日常的德雷福斯模型 35</span><br><span class="line"></span><br><span class="line"> 第3章 认识你的大脑 37 3.1 双CPU模式 38 3.2 随时(24×7)记录想法 42 3.3 L型和R型的特征 45 3.4 R型的崛起 51 3.5 R型看森林，L型看树木 56 3.6 DIY脑部手术和神经可塑性 57 3.7 如何更上一层楼 58</span><br><span class="line"></span><br><span class="line"> 第4章 利用右脑 60 4.1 启动感观输入 60 4.2 用右脑画画 62 4.3 促成R型到L型的转换 66 4.4 收获R型线索 76 4.5 收获模式 85 4.6 正确理解 91</span><br><span class="line"></span><br><span class="line"> 第5章 调试你的大脑 93 5.1 了解认知偏见 94 5.2 认清时代影响 102 5.3 了解个性倾向 109 5.4 找出硬件问题 112 5.5 现在我不知道该思考什么 116</span><br><span class="line"></span><br><span class="line"> 第6章 主动学习 119 6.1 学习是什么……不是什么 119 6.2 瞄准SMART目标 122 6.3 建立一个务实的投资计划 126 6.4 使用你的原生学习模式 130 6.5 一起工作，一起学习 134 6.6 使用增强的学习法 136 6.7 使用SQ3R法主动阅读 137 6.8 使用思维导图 140 6.9 利用文档的真正力量 146 6.10 以教代学 148 6.11 付诸实践 149</span><br><span class="line"></span><br><span class="line"> 第7章 积累经验 150 7.1 为了学习而玩耍 150 7.2 利用现有知识 154 7.3 正确对待实践中的失败 155 7.4 了解内在诀窍 158 7.5 压力扼杀认知 162 7.6 想象超越感观 165 7.7 像专家一样学习 169</span><br><span class="line"></span><br><span class="line"> 第8章 控制注意力 171 8.1 提高注意力 172 8.2 通过分散注意力来集中注意力 177 8.3 管理知识 179 8.4 优化当前情境 185 8.5 积极地管理干扰 190 8.6 保持足够大的情境 195 8.7 如何保持注意力 199</span><br><span class="line"></span><br><span class="line"> 第9章 超越专家 200 9.1 有效的改变 200 9.2 明天上午做什么 202 9.3 超越专家 203</span><br><span class="line"></span><br><span class="line"> 附录A 图片授权 206 附录B 参考文献 207</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B004GCCAFQ/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B004GCCAFQ&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51S-hW1JAOL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>it文化</tag>
      </tags>
  </entry>
  <entry>
    <title>编程人生 15位软件先驱访谈录</title>
    <url>/2020/04/19/B004GCCAGK/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 编程人生 15位软件先驱访谈录<br>作者信息： 作者: 塞贝尔(Peter Seibel) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《编程人生:15位软件先驱访谈录》是他在近80个小时的访谈录音基础上整理汇编而成的。放下手头的工作。听听这些软件先驱们的故事和建议，眼界可以更开阔。思路可以更清晰，方向可以更明确。人生可以更精彩。作者Peter Seibel采访了下面这15位世界级编程大师。世界顶尖的程序员是怎么走上编程道路的?他们的编程工作创造和改变了人类历史，在这一过程中都有哪些经验和教训?他们对计算机软件行业的过去、现在和未来有什么独到的见解?他们对培养、发现、选拔、面试优秀的程序员有什么建议?</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1篇 Jamie Zawinski 1</span><br><span class="line">第2篇 Brad Fitzpatrick 37</span><br><span class="line">第3篇 Douglas Crockford 69</span><br><span class="line">第4篇 Brendan Eich 101</span><br><span class="line">第5篇 Joshua Bloch 129</span><br><span class="line">第6篇 Joe Armstrong 157</span><br><span class="line">第7篇 Simon Peyton Jones 185</span><br><span class="line">第8篇 Peter Norvig 221</span><br><span class="line">第9篇 Guy Steele 253</span><br><span class="line">第10篇 Dan Ingalls 289</span><br><span class="line">第11篇 L Peter Deutsch 321</span><br><span class="line">第12篇 Ken Thompson 347</span><br><span class="line">第13篇 Fran Allen 375</span><br><span class="line">第14篇 Bernie Cosell 401</span><br><span class="line">第15篇 Donald Knuth 435</span><br><span class="line">参考书目 471</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B004GCCAGK/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B004GCCAGK&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41aSyiW1CTL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>it文化</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery权威指南</title>
    <url>/2020/04/19/B004I6DWX4/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： jQuery权威指南<br>作者信息： 作者: 陶国荣 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《jQuery权威指南》内容全面，系统地讲解了jQuery的方方面面，实战性强，全书包含118个示例和2个综合案例，资深专家亲自执笔，4大专业社区一致鼎力推荐。jQuery是继Prototype之后的又一个优秀JavaScript框架，深受全球开发者欢迎，已经成为Web开发领域的事实标准。iQLJery以其轻巧的体积、强大的选择器、出色的DOM封装、丰富的插件支持使得广大的Web前端开发者得心应手，极大地提高了他们的开发效率；此外，jQuery中完善的Ajax功能、行为与结构层的分离、可靠的事件处理机制也同样使得Web后端开发者如虎添翼，使用少量代码就可以实现复杂的功能。特别是新版本1.4.X的发布，jQuery在功能和性能方面都有质的提升，极大地满足了广大开发者提出的更高要求。因此，为了提高Web开发的效率和强化Web应用的功能，熟练使用iQuery是Web开发者必备的一种能力。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">第1章 jquery开发入门</span><br><span class="line">1.1 jquery概述</span><br><span class="line">1.1.1 认识jquery</span><br><span class="line">1.1.2 jquery基本功能</span><br><span class="line">1.1.3 搭建jquery开发环境</span><br><span class="line">1.1.4 编写第一个简单的jquery应用</span><br><span class="line">1.1.5 jquery程序的代码风格</span><br><span class="line">1.2 jquery的简单应用</span><br><span class="line">1.2.1 jquery访问dom对象</span><br><span class="line">1.2.2 jquery控制dom对象</span><br><span class="line">1.2.3 jquery控制页面css</span><br><span class="line">1.3 本章小结 </span><br><span class="line"></span><br><span class="line"> 第2章 jquery选择器 2.1 jquery选择器概述 2.1.1 什么是选择器 2.1.2 选择器的优势 2.2 jquery选择器详解 2.2.1 基本选择器 2.2.2 层次选择器 2.2.3 简单过滤选择器 2.2.4 内容过滤选择器 2.2.5 可见性过滤选择器 2.2.6 属性过滤选择器 2.2.7 子元素过滤选择器 2.2.8 表单对象属性过滤选择器 2.2.9 表单选择器 2.3 综合案例分析-导航条在项目中的应用 2.3.1 需求分析 2.3.2 效果界面 2.3.3 功能实现 2.3.4 代码分析 2.4 本章小结</span><br><span class="line"></span><br><span class="line"> 第3章 jquery操作dom 3.1 dom基础 3.2 访问元素 3.2.1 元素属性操作 3.2.2 元素内容操作 3.2.3 获取或设置元素值 3.2.4 元素样式操作 3.3 创建节点元素 3.4 插入节点 3.4.1 内部插入节点方法 3.4.2 外部插入节点方法 3.5 复制节点 3.6 替换节点 3.7 包裹节点 3.8 遍历元素 3.9 删除元素 3.1 0综合案例分析-数据删除和图片预览在项目中的应用 3.1 0.1 需求分析 3.1 0.2 效果界面 3.1 0.3 功能实现 3.1 0.4 代码分析 3.1 1本章小结</span><br><span class="line"></span><br><span class="line"> 第4章 jquery中的事件与应用 4.1 事件机制 4.2 页面载入事件 4.2.1 ready（）方法的工作原理 4.2.2 ready（）方法的几种相同写法 4.3 绑定事件 4.4 切换事件 4.4.1 hover（）方法 4.4.2 toggle（）方法 4.5 移除事件 4.6 其他事件 4.6.1 方法one（） 4.6.2 方法trigger（） 4.7 表单应用 4.7.1 文本框中的事件应用 4.7.2 下拉列表框中的事件应用 4.8 列表应用 4.9 网页选项卡的应用 4.10 综合案例分析-删除数据时的提示效果在项目中的应用 4.10.1 需求分析 4.10.2 效果界面 4.10.3 功能实现 4.10.4 代码分析 4.11 本章小结</span><br><span class="line"></span><br><span class="line"> 第5章 jquery的动画与特效 5.1 显示与隐藏 5.1.1 show（）与hide（）方法 5.1.2 动画效果的show（）与hide（）方法 5.1.3 toggle（）方法 5.2 滑动 5.2.1 slidedown（）与slideup方法 5.2.2 slidetoggle（）方法 5.3 淡入淡出 5.3.1 fadein（）与fadeout（）方法 5.3.2 fadeto（）方法 5.4 自定义动画 5.4.1 简单的动画 5.4.2 移动位置的动画 5.4.3 队列中的动画 5.4.4 动画停止和延时 5.5 动画效果综述 5.5.1 各种动画方法说明 5.5.2 使用animate（）方法代替其他动画效果 5.6 综合案例分析-动画效果浏览相册中的图片 5.6.1 需求分析 5.6.2 效果界面 5.6.3 功能实现 5.6.4 代码分析 5.7 本章小结</span><br><span class="line"></span><br><span class="line"> 第6章 ajax在jquery中的应用 6.1 加载异步数据 6.1.1 传统的javascript方法 6.1.2 jquery中的load（）方法 6.1.3 jquery中的全局函数getjson（） 6.1.4 jquery中的全局函数getscript（） 6.1.5 jquery中异步加载xml文档 6.2 请求服务器数据 6.2.1 $.get（）请求数据 6.2.2 $.post（）请求数据 6.2.3 serialize（）序列化表单 6.3 $.ajax（）方法 6.3.1 $.ajax（）的基本概念 6.3.2 $.ajaxsetup（）设置全局ajax 6.4 ajax中的全局事件 6.4.1 ajax全局事件的基本概念 6.4.2 ajaxstart与ajaxstop全局事件 6.5 综合案例分析-用ajax实现新闻点评即时更新 6.5.1 需求分析 6.5.2 效果界面 6.5.3 功能实现 6.5.4 代码分析 6.6 本章小结</span><br><span class="line"></span><br><span class="line"> 第7章 jquery常用插件 7.1 jquery插件概述 7.2 验证插件validate 7.3 表单插件form 7.4 cookie插件cookie 7.5 搜索插件autocomplete 7.6 图片灯箱插件notesforlightbox 7.7 右键菜单插件contextmenu 7.8 图片放大镜插件jqzoom 7.9 自定义jquery插件 7.9.1 插件的种类 7.9.2 插件开发要点 7.9.3 开发插件示例 7.10 综合案例分析-使用uploadify插件实现文件上传功能 7.10.1 需求分析 7.10.2 效果界面 7.10.3 功能实现 7.10.4 代码分析 7.11 本章小结</span><br><span class="line"></span><br><span class="line"> 第8章 jqueryui插件 8.1 认识jqueryui 8.2 jqueryui交互性插件 8.2.1 拖曳插件 8.2.2 放置 8.2.3 排序插件 8.3 jqueryui微型插件 8.3.1 折叠面板插件 8.3.2 日历 8.3.3 选项卡插件 8.3.4 对话框插件 8.4 综合案例分析-使用jqueryui插件以拖动方式管理相册 8.4.1 需求分析 8.4.2 效果界面 8.4.3 功能实现 8.4.4 代码分析 8.5 本章小结</span><br><span class="line"></span><br><span class="line"> 第9章 jquery实用工具函数 9.1 什么是工具函数 9.2 工具函数的分类 9.2.1 浏览器的检测 9.2.2 数组和对象的操作 9.2.3 字符串操作 9.2.4 测试操作 9.2.5 url操作 9.3 工具函数的扩展 9.4 其他工具函数-$.proxy（） 9.5 综合案例分析-使用jquery扩展工具函数实现对字符串指定类型的检测 9.5.1 需求分析 9.5.2 效果界面 9.5.3 功能实现 9.5.4 代码分析 9.6 本章小结</span><br><span class="line"></span><br><span class="line"> 第10章 jquery性能优化与最佳实践 10.1 优化选择器执行的速度 10.1.1 优先使用id与标记选择器 10.1.2 使用jquery对象缓存 10.1.3 给选择器一个上下文 10.2 处理选择器中的不规范元素标志 10.2.1 选择器中含有特殊符号 10.2.2 选择器中含有空格符号 10.3 优化事件中的冒泡现象 10.4 使用data（）方法缓存数据 10.5 解决jquery库与其他库的冲突 10.5.1 jquery在其他库前导入 10.5.2 jquery在其他库后导入 10.6 使用子查询优化选择器性能 10.7 减少对dom元素直接操作 10.8 正确区分dom对象与jquery对象 10.8.1 dom对象与jquery对象的定义 10.8.2 dom对象与jquery对象的类型转换 10.9 本章小结</span><br><span class="line"></span><br><span class="line"> 第11章 综合案例开发 案例1：切割图片 案例2：在线聊天室 本章小结</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B004I6DWX4/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B004I6DWX4&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41rOHAiZrYL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript DOM编程艺术(第2版)</title>
    <url>/2020/04/19/B004VJM5KE/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： JavaScript DOM编程艺术(第2版)<br>作者信息： 作者: 基思 (Jeremy Keith) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《JavaScript DOM编程艺术(第2版)》编辑推荐：Amazom超级畅销书最新，释放JavaScript和DOM编程的惊人潜力，涵养HTML5及jQuery。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 JavaScript简史 1</span><br><span class="line">1.1 JavaScript的起源 1</span><br><span class="line">1.2 DOM 2</span><br><span class="line">1.3 浏览器战争 3</span><br><span class="line">1.3.1 DHTML 3</span><br><span class="line">1.3.2 浏览器之间的冲突 3</span><br><span class="line">1.4 制定标准 4</span><br><span class="line">1.4.1 浏览器以外的考虑 4</span><br><span class="line">1.4.2 浏览器战争的结局 5</span><br><span class="line">1.4.3 崭新的起点 5</span><br><span class="line">1.5 小结 6 </span><br><span class="line"></span><br><span class="line"> 第2章 JavaScript语法 8 2.1 准备工作 8 2.2 语法 10 2.2.1 语句 10 2.2.2 注释 10 2.2.3 变量 11 2.2.4 数据类型 14 2.2.5 数组 16 2.2.6 对象 18 2.3 操作 19 2.4 条件语句 21 2.4.1 比较操作符 22 2.4.2 逻辑操作符 23 2.5 循环语句 24 2.5.1 while循环 24 2.5.2 for循环 25 2.6 函数 26 2.7 对象 29 2.7.1 内建对象 30 2.7.2 宿主对象 31 2.8 小结 31</span><br><span class="line"></span><br><span class="line"> 第3章 DOM 32 3.1 文档:DOM中的“D” 32 3.2 对象:DOM中的“O” 32 3.3 模型:DOM中的“M” 33 3.4 节点 35 3.4.1 元素节点 35 3.4.2 文本节点 35 3.4.3 属性节点 36 3.4.4 CSS 36 3.4.5 获取元素 38 3.4.6 盘点知识点 42 3.5 获取和设置属性 43 3.5.1 get Attribute 43 3.5.2 set Attribute 44 3.6 小结 45</span><br><span class="line"></span><br><span class="line"> 第4章 案例研究:JavaScript图片库 46 4.1 标记 46 4.2 JavaScript 48 4.2.1 非DOM解决方案 49 4.2.2 最终的函数代码清单 50 4.3 应用这个JavaScript函数 50 4.4 对这个函数进行扩展 52 4.4.1 child Nodes属性 53 4.4.2 node Type属性 54 4.4.3 在标记里增加一段描述 54 4.4.4 用JavaScript改变这段描述 55 4.4.5 node Value属性 56 4.4.6 first Child和last Child属性 56 4.4.7 利用node Value属性刷新这段描述 57 4.5 小结 60</span><br><span class="line"></span><br><span class="line"> 第5章 最佳实践 61 5.1 过去的错误 61 5.1.1 不要怪罪JavaScript 61 5.1.2 Flash的遭遇 62 5.1.3 质疑一切 63 5.2 平稳退化 63 5.2.1 “javascript:”伪协议 64 5.2.2 内嵌的事件处理函数 65 5.2.3 谁关心这个 65 5.3 向CSS学习 66 5.3.1 结构与样式的分离 66 5.3.2 渐进增强 67 5.4 分离JavaScript 68 5.5 向后兼容 70 5.5.1 对象检测 70 5.5.2 浏览器嗅探技术 71 5.6 性能考虑 72 5.6.1 尽量少访问DOM和尽量减少标记 72 5.6.2 合并和放置脚本 73 5.6.3 压缩脚本 73 5.7 小结 74</span><br><span class="line"></span><br><span class="line"> 第6章 案例研究:图片库改进版 75 6.1 快速回顾 75 6.2 它支持平稳退化吗 76 6.3 它的JavaScript与HTML标记是分的吗 77 6.3.1 添加事件处理函数 77 6.3.2 共享onload事件 82 6.4 不要做太多的假设 84 6.5 优化 86 6.6 键盘访问 88 6.7 把JavaScript与CSS结合起来 90 6.8 DOM Core和HTML-DOM 93 6.9 小结 94</span><br><span class="line"></span><br><span class="line"> 第7章 动态创建标记 96 7.1 一些传统方法 96 7.1.1 document. write 96 7.1.2 inner HTML属性 98 7.2 DOM方法 101 7.2.1 create Element方法 101 7.2.2 append Child方法 102 7.2.3 create Text Node方法 103 7.2.4 一个更复杂的组合 105 7.3 重回图片库 107 7.3.1 在已有元素前插入一个新元素 108 7.3.2 在现有方法后插入一个新元素 109 7.3.3 图片库二次改进版 111 7.4 Ajax 114 7.4.1 XML Http Request对象 115 7.4.2 渐进增强与Ajax 119 7.4.3 Hijax 120 7.5 小结 121</span><br><span class="line"></span><br><span class="line"> 第8章 充实文档的内容 122 8.1 不应该做什么 122 8.2 把“不可见”变成“可见” 123 8.3 内容 123 8.3.1 选用HTML、XHTML还是HTML5 124 8.3.2 CSS 126 8.3.3 JavaScript 127 8.4 显示“缩略语列表” 127 8.4.1 编写display Abbreviations函数 128 8.4.2 创建标记 130 8.4.3 一个浏览器“地雷” 135 8.5 显示“文献来源链接表” 138 8.6 显示“快捷键清单” 143 8.7 检索和添加信息 146 8.8 小结 147</span><br><span class="line"></span><br><span class="line"> 第9章 CSS-DOM 148 9.1 三位一体的网页 148 9.1.1 结构层 148 9.1.2 表示层 148 9.1.3 行为层 149 9.1.4 分离 150 9.2 style属性 150 9.2.1 获取样式 151 9.2.2 设置样式 156 9.3 何时该用DOM脚本设置样式 158 9.3.1 根据元素在节点树里的位置来设置样式 158 9.3.2 根据某种条件反复设置某种样式 161 9.3.3 响应事件 165 9.4 class Name属性 167 9.5 小结 171</span><br><span class="line"></span><br><span class="line"> 第10章 用JavaScript实现动画效果 172 10.1 动画基础知识 172 10.1.1 位置 172 10.1.2 时间 175 10.1.3 时间递增量 175 10.1.4 抽象 178 10.2 实用的动画 184 10.2.1 提出问题 184 10.2.2 解决问题 186 10.2.3 CSS 187 10.2.4 JavaScript 189 10.2.5 变量作用域问题 192 10.2.6 改进动画效果 193 10.2.7 添加安全检查 196 10.2.8 生成HTML标记 198 10.3 小结 200</span><br><span class="line"></span><br><span class="line"> 第11章 HTML5 201 11.1 HTML5简介 201 11.2 来自朋友的忠告 203 11.3 几个示例 204 11.3.1 Canvas 205 11.3.2 音频和视频 209 11.3.3 表单 215 11.4 HTML5还有其他特性吗 219 11.5 小结 219</span><br><span class="line"></span><br><span class="line"> 第12章 综合示例 220 12.1 项目简介 220 12.1.1 原始资料 220 12.1.2 站点结构 220 12.1.3 页面结构 221 12.2 设计 222 12.3 CSS 223 12.3.1 颜色 225 12.3.2 布局 226 12.3.3 版式 228 12.4 标记 229 12.5 JavaScript 230 12.5.1 页面突出显示 231 12.5.2 JavaScript幻灯片 235 12.5.3 内部导航 239 12.5.4 JavaScript图片库 242 12.5.5 增强表格 245 12.5.6 增强表单 249 12.5.7 压缩代码 263 12.6 小结 264 附录 JavaScript库 265</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B004VJM5KE/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B004VJM5KE&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51wpFR5o5ML._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>iPhone 4与iPad开发基础教程</title>
    <url>/2020/04/19/B005B9CLSY/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： iPhone 4与iPad开发基础教程<br>作者信息： 作者: Dave Mark [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>由马克和纳丁等编著的《iPhone4与iPad开发基础教程》将带你走上创建iOS应用程序的大道。我们的目标是让你通过初步学习，理解iOS应用程序的运行和构建方式。在学习过程中，你将创建一系列小型应用程序，每个应用程序都会突出某些iOS特性，展示如何控制这些特性或与其交互。如果你扎实地掌握了本书中的基本知识，充分发挥自己的创造力，并且坚定不移，同时借助苹果公司大量翔实的文档，你就具备了创建专业级iPhone和iPad应用程序所需的一切条件。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目　录 </span><br><span class="line"></span><br><span class="line"> 第1章　欢迎来到iPhone世界　1 1.1　关于本书　1 1.2　必要条件　1 1.2.1　开发者的选择　3 1.2.2　必备知识　4 1.3　编写iOS应用程序有何不同　4 1.3.1　只有一个应用程序正在运行　5 1.3.2　只有一个窗口　5 1.3.3　受限访问　5 1.3.4　有限的响应时间　5 1.3.5　有限的屏幕大小　5 1.3.6　有限的系统资源　6 1.3.7　不支持垃圾收集　6 1.3.8　新功能　6 1.3.9　与众不同的方法　7 1.4　本书内容　7 1.5　本次更新的内容　8 1.6　准备开始吧　8</span><br><span class="line"></span><br><span class="line"> 第2章　创建基本项目　9 2.1　在Xcode中设置项目　9 2.2　Interface Builder简介　14 2.2.1　nib文件的构成　15 2.2.2　在视图中添加标签　16 2.2.3　改变属性　18 2.3　美化iPhone应用程序　19 2.4　小结　22</span><br><span class="line"></span><br><span class="line"> 第3章　处理基本交互　23 3.1　MVC范型　23 3.2　创建项目　24 3.3　创建视图控制器　24 3.3.1　输出口　25 3.3.2　操作　26 3.3.3　将操作和输出口添加到视图控制器　27 3.3.4　将操作和输出口添加到实现文件　30 3.4　使用应用程序委托　34 3.5　编辑MainWindow.xib　36 3.6　编辑Button_FunViewController.xib　37 3.6.1　在Interface Builder中创建视图　37 3.6.2　连接所有元素　40 3.6.3　测试　43 3.7　小结　43</span><br><span class="line"></span><br><span class="line"> 第4章　更丰富的用户界面　44 4.1　满是控件的屏幕　44 4.2　活动和被动控件　46 4.3　创建应用程序　46 4.4　实现图像视图和文本字段　47 4.4.1　确定输出口　47 4.4.2　确定操作　48 4.4.3　添加图像视图　49 4.4.4　添加文本字段　52 4.4.5　设置第二个文本字段的属性　55 4.4.6　连接输出口　55 4.5　关闭键盘　55 4.5.1　完成输入后关闭键盘　56 4.5.2　通过触摸背景关闭键盘　57 4.6　实现滑块和标签　59 4.6.1　确定输出口和操作　59 4.6.2　添加输出口和操作　60 4.6.3　添加滑块和标签　61 4.6.4　连接操作和输出口　62 4.7　实现开关、按钮和分段控件　62 4.7.1　添加输出口和操作　62 4.7.2　添加开关、按钮和分段控件　65 4.7.3　连接开关输出口和操作　66 4.7.4　添加按钮　66 4.8　实现操作表和警报　67 4.8.1　遵从操作表委托方法　67 4.8.2　显示操作表　68 4.8.3　使用操作表委托　70 4.9　美化按钮　71 4.9.1　viewDidLoad方法　71 4.9.2　控件状态　72 4.9.3　可拉伸图像　72 4.10　成为出色的内存使用者　73 4.11　小结　74</span><br><span class="line"></span><br><span class="line"> 第5章　自动旋转和自动调整大小　75 5.1　自动旋转机制　75 5.2　使用自动调整属性处理旋转　77 5.2.1　指定旋转支持　77 5.2.2　使用自动调整属性设计界面　79 5.2.3　大小检查器的自动调整属性　80 5.2.4　设置按钮的自动调整属性　81 5.3　在旋转时重构视图　82 5.3.1　声明和连接输出口　83 5.3.2　在旋转时移动按钮　84 5.4　切换视图　85 5.4.1　确定输出口和操作　86 5.4.2　声明操作和输出口　87 5.4.3　设计两个视图　88 5.4.4　实现交换和操作　88 5.5　小结　91</span><br><span class="line"></span><br><span class="line"> 第6章　多视图应用程序　92 6.1　多视图应用程序的常见类型　92 6.2　多视图应用程序的体系结构　94 6.2.1　根控制器　95 6.2.2　内容视图剖析　96 6.3　构建View Switcher　96 6.3.1　创建视图控制器和nib文件　97 6.3.2　修改应用程序委托　99 6.3.3　SwitchViewController.h　101 6.3.4　添加视图控制器　101 6.3.5　构建包含工具栏的视图　103 6.3.6　编写根视图控制器　104 6.3.7　实现内容视图　108 6.3.8　制作转换动画　110 6.4　小结　113</span><br><span class="line"></span><br><span class="line"> 第7章　标签栏与选取器　114 7.1　Pickers应用程序　114 7.2　委托和数据源　117 7.3　建立工具栏框架　117 7.3.1　创建文件　117 7.3.2　添加根视图控制器　118 7.3.3　编辑MainWindow.xib　120 7.3.4　连接输出口，然后运行　123 7.4　实现日期选取器　124 7.5　实现单个组件选取器　126 7.5.1　声明输出口和操作　126 7.5.2　构建视图　127 7.5.3　将控制器实现为数据源和委托　127 7.6　实现多组件选取器　131 7.6.1　声明输出口和操作　131 7.6.2　构建视图　132 7.6.3　实现控制器　132 7.7　实现独立组件　135 7.8　使用自定义选取器创建简单游戏　141 7.8.1　编写控制器头文件　141 7.8.2　构建视图　142 7.8.3　添加图像资源　143 7.8.4　实现控制器　143 7.8.5　最后的细节　149 7.8.6　链接Audio Toolbox框架　153 7.9　小结　154</span><br><span class="line"></span><br><span class="line"> 第8章　表视图简介　155 8.1　表视图基础　156 8.1.1　表视图和表视图单元　156 8.1.2　分组表和无格式表　157 8.2　实现一个简单的表　158 8.2.1　设计视图　158 8.2.2　编写控制器　158 8.2.3　添加一个图像　161 8.2.4　表视图单元样式　163 8.2.5　设置缩进级别　165 8.2.6　处理行的选择　165 8.2.7　更改字体大小和行高　167 8.3　定制表视图单元　168 8.3.1　单元应用程序　　168 8.3.2　使用UITableViewCell的自定义子类　172 8.4　分组分区和索引分区　176 8.4.1　构建视图　176 8.4.2　导入数据　177 8.4.3　实现控制器　177 8.4.4　添加索引　181 8.5　实现搜索栏　181 8.5.1　重新考虑设计　181 8.5.2　深层可变副本　182 8.5.3　更新控制器头文件　184 8.5.4　修改视图　185 8.5.5　修改控制器实现　186 8.6　小结　197</span><br><span class="line"></span><br><span class="line"> 第9章　导航控制器和表视图　198 9.1　导航控制器　198 9.1.1　栈的性质　198 9.1.2　控制器栈　199 9.2　由6个部分组成的分层应用程序：Nav　200 9.2.1　子控制器　200 9.2.2　Nav应用程序的骨架　203 9.2.3　第一个子控制器：展示按钮视图　209 9.2.4　第二个子控制器：校验表　217 9.2.5　第三个子控制器：表行上的控件　221 9.2.6　第四个子控制器：可移动的行　227 9.2.7　第五个子控制器：可删除的行　233 9.2.8　第六个子控制器：可编辑的详细窗格　239 9.2.9　其他内容　257 9.3　小结　260</span><br><span class="line"></span><br><span class="line"> 第10章　iPad开发注意事项　261 10.1　分割视图和浮动窗口　261 10.2　创建SplitView项目　263 10.3　xib定义结构　264 10.4　代码定义功能　265 10.5　显示总统信息　272 10.6　创建浮动窗口　276 10.7　小结　282</span><br><span class="line"></span><br><span class="line"> 第11章　应用程序设置和用户默认设置　283 11.1　设置束　283 11.2　AppSettings应用程序　284 11.2.1　创建项目　286 11.2.2　使用设置束　286 11.2.3　读取应用程序中的设置　297 11.2.4　更改应用程序中的默认设置　302 11.2.5　实现逼真效果　305 11.3　小结　307</span><br><span class="line"></span><br><span class="line"> 第12章　保存数据　308 12.1　应用程序的沙盒　308 12.1.1　获取Documents目录　309 12.1.2　获取tmp目录　310 12.2　文件保存策略　310 12.2.1　单个文件持久性　310 12.2.2　多个文件持久性　311 12.3　属性列表　311 12.3.1　属性列表序列化　311 12.3.2　持久性应用程序的第一个版本　312 12.4　对模型对象进行归档　317 12.4.1　符合NSCoding　318 12.4.2　实现NSCopying　319 12.4.3　对数据对象进行归档和取消归档　319 12.4.4　归档应用程序　320 12.5　使用iPhone的嵌入式SQLite3　324 12.5.1　创建或打开数据库　325 12.5.2　绑定变量　327 12.5.3　SQLite3应用程序　327 12.6　使用Core Data　334 12.6.1　实体和托管对象　335 12.6.2　Core Data应用程序　339 12.7　小结　348</span><br><span class="line"></span><br><span class="line"> 第13章　Grand Central Dispatch、后台处理及其应用　349 13.1　Grand Central Dispatch　349 13.2　SlowWorker简介　350 13.3　线程基础知识　352 13.4　工作单元　353 13.5　GCD：低级队列　354 13.5.1　傻瓜式操作　354 13.5.2　改进SlowWorker　355 13.6　后台处理　360 13.6.1　应用程序生命周期　361 13.6.2　状态更改通知　361 13.6.3　创建State Lab　363 13.6.4　执行状态　364 13.6.5　利用执行状态更改　365 13.6.6　处理不活动状态　366 13.6.7　处理后台状态　370 13.7　小结　378</span><br><span class="line"></span><br><span class="line"> 第14章　使用Quartz和OpenGL绘图　379 14.1　图形世界的两个视图　379 14.2　Quart绘图方法　380 14.2.1　Quartz 2D的图形上下文　380 14.2.2　坐标系　381 14.2.3　指定颜色　382 14.2.4　在上下文中绘制图像　383 14.2.5　绘制形状：多边形、直线和曲线　383 14.2.6　Quartz 2D工具示例：模式、梯度、虚线模式　384 14.3　QuartzFun应用程序　384 14.3.1　构建QuartzFun应用程序　384 14.3.2　添加Quartz Drawing代码　394 14.3.3　优化QuartzFun应用程序　398 14.4　GLFun应用程序　401 14.4.1　构建GLFun应用程序　402 14.4.2　使用OpenGL绘图　404 14.4.3　完成GLFun　411 14.5　小结　411</span><br><span class="line"></span><br><span class="line"> 第15章　轻击、触摸和手势　412 15.1　多触摸术语　412 15.2　响应者链　413 15.2.1　响应者链中的对象　413 15.2.2　转发事件：保持响应者链的活动状态　414 15.3　多触摸体系结构　415 15.3.1　将触摸相关代码放在何处　415 15.3.2　4个手势通知方法　415 15.4　检测触摸　416 15.4.1　构建一个Touch Explorer应用程序　417 15.4.2　运行Touch Explorer　419 15.5　检测轻扫　419 15.5.1　构建Swipes应用程序　420 15.5.2　使用自动手势识别　423 15.5.3　实现多个轻扫动作　424 15.6　检测多次轻击　425 15.7　检测捏合操作　430 15.8　创建和使用自定义手势　433 15.8.1　定义选中标记手势　433 15.8.2　将勾选标记手势附加到视图　435 15.9　小结　437</span><br><span class="line"></span><br><span class="line"> 第16章　Core Location定位功能　438 16.1　位置管理器　438 16.1.1　设置所需的精度　439 16.1.2　设置距离筛选器　439 16.1.3　启动位置管理器　439 16.1.4　更明智地使用位置管理器　440 16.2　位置管理器委托　440 16.2.1　获取位置更新　440 16.2.2　使用CLLocation获取纬度和经度　440 16.2.3　错误通知　442 16.3　尝试使用Core Location　442 16.3.1　更新位置管理器　446 16.3.2　确定移动距离　447 16.4　小结　447</span><br><span class="line"></span><br><span class="line"> 第17章　加速计　448 17.1　加速计物理学　448 17.2　不要忘记旋转　449 17.3　Core Motion和动作管理器　449 17.3.1　基于事件的动作　450 17.3.2　主动动作访问　455 17.3.3　加速计结果　457 17.4　检测摇动　458 17.4.1　Baked-In摇动　459 17.4.2　摇动与击碎　459 17.5　将加速计用作方向控制器　464 17.5.1　滚弹珠程序　464 17.5.2　编写Ball View　466 17.5.3　计算小球运动　469 17.6　小结　472</span><br><span class="line"></span><br><span class="line"> 第18章　iPhone照相机和照片库　473 18.1　使用图像选取器和UIImagePicker-Controller　474 18.2　实现图像选取器控制器委托　475 18.3　实际测试照相机和库　476 18.3.1　设计界面　477 18.3.2　实现照相机视图控制器　477 18.4　小结　481</span><br><span class="line"></span><br><span class="line"> 第19章　应用程序本地化　482 19.1　本地化体系结构　482 19.2　字符串文件　483 19.2.1　字符串文件里面是什么　484 19.2.2　本地化的字符串宏　484 19.3　现实中的iPhone：本地化应用程序　485 19.3.1　创建LocalizeMe　485 19.3.2　测试LocalizeMe　489 19.3.3　本地化nib文件　489 19.3.4　本地化图像　492 19.3.5　生成和本地化字符串文件　493 19.3.6　本地化应用程序显示名称　495 19.4　小结　496</span><br><span class="line"></span><br><span class="line"> 第20章 未来之路　497 20.1　别陷进单一的思路里　497 20.1.1　苹果公司的文档　497 20.1.2　邮件列表　498 20.1.3　论坛　498 20.1.4　网站　499 20.1.5　博客　499 20.2　参考资料　500 20.3　作者　501 20.4　再会　501</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B005B9CLSY/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B005B9CLSY&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/510qhkBmQEL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5游戏开发</title>
    <url>/2020/04/19/B005V9BBFS/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： HTML5游戏开发<br>作者信息： 作者: Jeanine Meyer [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>今天，大多数现代浏览器都已经支持HTML5。学习体验HTML5带给Web开发的便捷、快速和强大功能，是每一位Web设计和开发人员的当务之急。    迈耶编著的《HTML5游戏开发》通过人们熟悉的一个个游戏让读者轻松掌握HTML5、CSS和JavaScript的新特性，并将这些特性灵活应用到Web开发中。书中主要介绍了使用carwas元素直接在屏幕上绘图、添加图像和编写文本，只使用HTML5、CSS和JavaScript在网站上加入视频和音频。使用事件处理响应鼠标事件和按键。使用定时事件生成动画。验证表单输入，在玩家的计算机上存储迷宫布局之类的信息并按需重新加载。跟随作者的指引。你也能开发出妙趣横生的小游戏。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目　录 </span><br><span class="line"></span><br><span class="line"> 第1章　基础知识　1 1.1　引言　1 1.2　关键需求　3 1.3　HTML5、CSS和JavaScript特性　3 1.3.1　基本HTML 结构和标记　4 1.3.2　JavaScript编程　9 1.4　构建自己的应用　10 1.5　测试和上传应用　16 1.6　小结　16</span><br><span class="line"></span><br><span class="line"> 第2章　骰子游戏　17 2.1　引言　17 2.2　关键需求　20 2.3　HTML5、CSS和JavaScript特性　20 2.3.1　伪随机处理和数学表达式　20 2.3.2　变量和赋值语句　21 2.3.3　程序员自定义函数　22 2.3.4　条件语句：if和switch　23 2.3.5　在画布上绘图　25 2.4　构建自己的应用　34 2.4.1　掷一个骰子　35 2.4.2　掷两个骰子　40 2.4.3　完整的craps游戏　44 2.5　测试和上传应用　50 2.6　小结　51</span><br><span class="line"></span><br><span class="line"> 第3章　弹跳球　52 3.1　引言　52 3.2　关键需求　54 3.3　HTML5、CSS和JavaScript特性　55 3.4　构建自己的应用　64 3.5　测试和上传　74 3.6　小结　74</span><br><span class="line"></span><br><span class="line"> 第4章　炮弹和弹弓　75 4.1　引言　75 4.2　关键需求　78 4.3　HTML5、CSS和JavaScript特性　79 4.3.1　数组和程序员自定义对象　79 4.3.2　绘图旋转和平移　80 4.3.3　绘制线段　84 4.3.4　拉弹弓的鼠标事件　85 4.3.5　使用数组接合改变显示元素列表　87 4.3.6　点之间的距离　87 4.4　构建自己的应用　88 4.4.1　有大炮、角度和速度的炮弹应用　92 4.4.2　弹弓：使用鼠标设置飞行参数　98 4.5　测试和上传应用　106 4.6　小结　106</span><br><span class="line"></span><br><span class="line"> 第5章　记忆力(注意力)游戏　107 5.1　引言　107 5.2　关键需求　111 5.3　HTML5、CSS和JavaScript特性　112 5.3.1　表示扑克牌　112 5.3.2　使用Date 确定时间　113 5.3.3　提供暂停　114 5.3.4　绘制文本　114 5.3.5　绘制多边形　116 5.3.6　洗牌　117 5.3.7　单击牌的实现　118 5.3.8　防止某些作弊行为　119 5.4　构建自己的应用　119 5.5　测试和上传应用　132 5.6　小结　132</span><br><span class="line"></span><br><span class="line"> 第6章　猜谜游戏　133 6.1　引言　133 6.2　关键需求　137 6.3　HTML5、CSS和JavaScript特性　138 6.3.1　存储和获取数组信息　138 6.3.2　程序执行时创建HTML　140 6.3.3　使用JavaScript代码修改CSS来改变元素　142 6.3.4　使用form和input元素的文本反馈　144 6.3.5　表现视频　144 6.4　构建自己的应用　146 6.5　测试和上传应用　157 6.6　小结　157</span><br><span class="line"></span><br><span class="line"> 第7章　迷宫　158 7.1　引言　158 7.2　关键需求　162 7.3　HTML5、CSS和JavaScript特性　162 7.3.1　墙和token的表示　163 7.3.2　建立和定位墙的鼠标事件　163 7.3.3　检测箭头按键　164 7.3.4　token与墙的碰撞检测　165 7.3.5　使用本地存储　167 7.3.6　为本地存储编码数据　172 7.3.7　单选按钮　174 7.4　构建自己的应用　174 7.5　测试和上传应用　189 7.6　小结　189</span><br><span class="line"></span><br><span class="line"> 第8章　石头剪刀布　191 8.1　引言　191 8.2　关键需求　194 8.3　HTML5、CSS和JavaScript特性　195 8.3.1　为玩家提供图片按钮　195 8.3.2　生成计算机动作　199 8.3.3　启动　206 8.4　构建自己的应用　206 8.5　测试和上传应用　212 8.6　小结　213</span><br><span class="line"></span><br><span class="line"> 第9章　上吊小人游戏　214 9.1　引言　214 9.2　关键需求　221 9.3　HTML5、CSS和JavaScript特性　222 9.3.1　将单词表存储为一个在外部脚本文件中定义的数组　222 9.3.2　生成和定位HTML 标记，使标记作为按钮并禁用这些按钮　223 9.3.3　在画布上逐步绘制　225 9.3.4　维护游戏状态并确定输赢　226 9.3.5　检查猜测，设置textContent显示秘密词中的字母　227 9.4　构建自己的应用　228 9.5　测试和上传应用　236 9.6　小结　236</span><br><span class="line"></span><br><span class="line"> 第10章　黑桃J　237 10.1　引言　237 10.2　关键需求　242 10.3　HTML5、CSS和JavaScript特性　242 10.4　构建自己的应用　249 10.5　测试和上传应用　258 10.6　小结　258</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B005V9BBFS/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B005V9BBFS&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51D0%2BorTLJL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>黑客 计算机革命的英雄</title>
    <url>/2020/04/19/B005Z7FABC/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 黑客 计算机革命的英雄<br>作者信息： 作者: 里夫 (Steven Levy) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《黑客:计算机革命的英雄》由Steven Levy所著，黑客文化和伦理的奠基之作，计算机专业人士必读。二十五周年新版，涵盖比尔·盖茨、马克·扎克伯格、理查德·斯托曼、史蒂夫·沃兹尼克等著名黑客的最新资料。多年前，射击游戏之父、Doom游戏的作者约翰·卡马克由于读到《黑客:计算机革命的英雄》，坚定了游戏开发的决心。谷歌首席信息官本·弗里德也是《黑客:计算机革命的英雄》的忠实读者。探寻黑客文化的本质，体会黑客精神的精髓。“黑客”一词来源于英语动词hack，原意为“劈、砍”，也就意味着“辟出、开辟”后来，hack的含义演变为用有效的手段解决某一个问题。1984年，Steven Levy编著的“黑客》一书追溯了黑客传统和历史，讲述黑客的人生和故事，归纳黑客创造的技术奇迹，总结黑客文化和伦理。《黑客:计算机革命的英雄》第一次将黑客的价值观总结为六条“黑客伦理”，直到今天这几条伦理仍为这方面的经典论述，对计算机的访问（以及任何可能帮助你认识我们这个世界的事物）应该是不受限制的，完全的任何人都有动手尝试的权利！所有的信息都应该可以自由获取。不迷信权威——促进分权评判黑客的标准应该是他们的技术，而不是那些没有实际用途的指标，比如学位、年龄、种族或职位。你可以在计算机上创造出艺术与美。计算机技术可以让你的生活更美好。《黑客》一书依然是后人无法超越的一本巅峰之作《黑客:计算机革命的英雄》写于20世纪80年代初期，当时正是PC崛起计算机解放浪潮的初期当然不可否认，随着计算机不断社会化，黑客的组成和社会内涵已经发生了巨大变化，但是，不管“黑客”这个概念如何被曲解《黑客》一书已经为黑客确立了真正的历史传统和严谨祖训，它们不可动摇地传承着，为无数的黑客带来了积极的影响。2010年4月，在《黑客》一书出版25周年之际，《连线》杂志最近发表了作者Steven Levy的文章，讲述了他近期再访书中名人的感受，同时阐述了黑客对网络发展的影响。时隔25年，经典著作《黑客》再度出版，涵盖比尔·盖茨、马克·扎克伯格、理查德·斯托曼、史蒂夫·沃兹尼克等著名黑客的最新资料；将“黑客精神”和“黑客伦理”传承给下一代冉冉升起的黑客。黑客文化和伦理的奠基之作，计算机专业人士必读，25周年新版，涵盖比尔·盖茨、马克·扎克伯格、理查德·斯托曼、史蒂夫·沃兹尼克等著名黑客的最新资料，多年前，射击游戏之父，Doom游戏的作者约翰·卡马克由于读到本书而坚定了游戏开发的决心，谷歌首席信息官本·弗里德也是本书的忠实读者，探寻黑客文化的本质，体会黑客精神的精髓。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">本书人物谱（也包括计算机）：“巫师”和他们的机器</span><br><span class="line">第一部分 真正的黑客</span><br><span class="line">剑桥：20世纪50年代和60年代</span><br><span class="line">第1章 技术模型铁路俱乐部</span><br><span class="line">第2章 黑客伦理</span><br><span class="line">第3章 太空大战</span><br><span class="line">第4章 格林布莱特和高斯珀</span><br><span class="line">第5章 午夜计算机改装组织</span><br><span class="line">第6章 成功者和失败者</span><br><span class="line">第7章 《生命》游戏 </span><br><span class="line"></span><br><span class="line"> 第二部分 硬件黑客 加州北部：20世纪70年代 第8章 2100年大叛乱 第9章 每个人都能成为上帝 第10章 家酿计算机俱乐部 第11章 Tiny BASIC 第12章 天才沃兹 第13章 秘密</span><br><span class="line"></span><br><span class="line"> 第三部分 游戏黑客 Sierras：20世纪80年代 第14章 巫师和公主 第15章 联盟之道 第16章 第三代黑客 第17章 夏令营 第18章 《青蛙过河》 第19章 苹果节 第20章 巫师大比拼</span><br><span class="line"></span><br><span class="line"> 第四部分 最后一名真正的黑客 剑桥：1983 最后一名真正的黑客 编后记：十年以后 编后记：2010 备注 致谢 作者简介</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B005Z7FABC/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B005Z7FABC&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51MoaMVpV%2BL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>it文化</tag>
      </tags>
  </entry>
  <entry>
    <title>研磨Struts2</title>
    <url>/2020/04/19/B005XISP7E/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 研磨Struts2<br>作者信息： 作者: 陈臣 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《研磨Struts2》：超过450分钟的Struts2课堂教学视频，提供配书视频对应的PPT、课堂讲义和源代码。Struts2的架构和运行流程、Action、Result和Intercepter、值栈的功能和使用OGNL、Struts2标签体系、Struts2对Ajax的支持、Struts2对文件上传下载的支持、防止重复提交和进度条、整合Spring、JFreeChart、SiteMeth、Struts2的国际化、使用Struts2的验证框架和类型转换、Struts2对零配置的支持。国内知名的高端Java实训机构：一个能让你学到真实本领的Java学习基地！一个能帮助你真正解决就业问题的机构！在Java私塾：高薪就业根本就不是问题。更好的职业发展才是硬道理。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 Struts2概述</span><br><span class="line">1.1 MVC模式</span><br><span class="line">1.1.1 MVC模式简介</span><br><span class="line">1.1.2 MVC模式基础</span><br><span class="line">1.1.3 MVC模式作用</span><br><span class="line">1.1.4 Model2模型中的MVC</span><br><span class="line">1.2 Struts2基础</span><br><span class="line">1.2.1 Strutsl时代</span><br><span class="line">1.2.2 Struts2出世</span><br><span class="line">1.2.3 Struts2基本组成</span><br><span class="line">1.2.4 Struts2能干什么</span><br><span class="line">1.3 Struts2和MVC </span><br><span class="line"></span><br><span class="line"> 第2章 struts2的HelloWorId 2.1 概述 2.2 准备开发环境和运行环境 2.2.1 配置JDK 2.2.2 下载并安装：Eclipse 2.2.3 下载Tomcat并在Eclipse里面引用Tomcat 2.2.4 下载Struts2以及认识Struts2包结构 2.3 从Servlet+JSP+JavaBean实现MVC开始 2.3.1 起点概述 2.3.2 建立动态的Web工程 2.3.3 配置工程运行环境 2.3.4 编写JavaBean 2.3.5 编写Servlet 2.3.6 配置web.xml 2.3.7 编写登录页面 2.3.8 编写欢迎页面 2.3.9 测试示例 2.3.10 中文处理 2.4 Struts2的HelloWorld 2.4.1 概述 2.4.2 配置Struts2的运行环境 2.4.3 实现动作类（Action） 2.4.4 配置struts.xml 2.4.5 制作登录页面 2.4.6 制作欢迎页面 2.4.7 测试示例 2.5 开发中的一些小窍门 2.5.1 概述 2.5.2 使用DTD来获得XML帮助 2.5.3 在新建菜单中添加JSP 2.5.4 获得Action的全类名 2.5.5 获得JSP在Web工程中的绝对路径</span><br><span class="line"></span><br><span class="line"> 第3章 struts2的架构和运行流程 3.1 Struts2的系统架构 3.1.1 Struts2的系统架构 3.1.2 各模块说明 3.2 Struts2的运行流程 3.3 Struts2的核心概念 3.4 小结</span><br><span class="line"></span><br><span class="line"> 第4章 Action 4.1 Action基础 4.1.1 Action是什么 4.1.2.Action能干什么 4.1.3 Action的基本配置 4.2 Action的实现 4.2.1 POJO的实现 4.2.2 实现Action接口 4.2.3 继承ActionSupport类 4.2.4 execute方法内部实现方式 4.2.5 简单的单元测试 4.3 Action的数据 4.3.1 数据来源 4.3.2 基本的数据对应方式 4.3.3 传入非String类型的值 4.3.4 如何处理传入多个值 4.4 Action的配置 4.4.1 〈package〉的配置 4.4.2 〈action〉的配置 4.4.3 分模块配置方式 4.4.4 使用通配符 4.4.5 默认类配置方式 4.5 Action的其他重要知识 4.5.1 Action的生命周期 4.5.2 调用非execute方法</span><br><span class="line"></span><br><span class="line"> 第5章 ResuIt 5.1 Result基础 5.1.1 Result是什么和能干什么 5.1.2 Result和ResultType 5.1.3 Result有什么 5.2 预定义的Result 5.2.1 预定义的ResultType 5.2.2 如何配置使用 5.2.3 名称为dispatcher的ResultType 5.2.4 名称为redirect的ResultType 5.2.5 名称为chain的ResultType 5.2.6 名称为FreeMarker的ResultType 5.2.7 其他ResultType 5.3 全局Result 5.3.1 全局Result概述 5.3.2 配置和使用 5.3.3 搜寻Result的顺序 5.3.4 应用示例 5.4.使用通配符 5.5 Struts2的异常映射 5.5.1 异常映射基础 5.5.2 局部异常映射与全局异常映射 5.5.3 在页面输出异常信息 5.6 PreResultListener 5.6.1 什么是PreResultListener 5.6.2 PreResultListener实现示例 5.7 自定义Result 5.7.1 自定义Result概述 5.7.2 开发自定义Result</span><br><span class="line"></span><br><span class="line"> 第6章 拦截器 6.1 拦截器基础 6.1.1 拦截器是什么 6.1.2 拦截器的优点 6.1.3 拦截器有什么 6.2 预定义的拦截器 6.2.1 预定义的拦截器 6.2.2 预定义的拦截器栈 6.2.3 预定义拦截器的配置使用 6.2.4 拦截器的调用顺序 6.2.5 实践一下 6.3 自定义的拦截器 6.3.1 什么是自定义的拦截器 6.3.2 开发自定义拦截器 6.3.3 向拦截器传入参数 6.4 两个有用的拦截器 6.4.1 更强大的logger拦截器 6.4.2 登录检查拦截器</span><br><span class="line"></span><br><span class="line"> 第7章 值栈和0GNL 7.1 值栈 7.1.1 值栈是什么 7.1.2 值栈能干什么 7.1.3 值栈有什么 7.1.4 ActionContext的基本使用 7.1.5 ValueStack的基本使用 7.2 OGNL 7.2.1 0GNL概述 7.2.2 OGNL的基本使用 …… 附录A 参考文献</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B005XISP7E/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B005XISP7E&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/5104ErqWf7L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5与CSS3实战指南</title>
    <url>/2020/04/19/B00647RUGK/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： HTML5与CSS3实战指南<br>作者信息： 作者: 威尔(Estelle Weyl) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《HTML5与CSS3实战指南》：在我们酷炫的示例网站上查看HTML5和CSS3的魔力，采用SVG和Carwas来为图形提供最大的灵活性，使用地理定位等新API创建卓越的Web应用程序。《HTML5与CSS3实战指南》将向读者展示如何使用前沿的Web开发技术——HTML5与CSS3来开发动态Web站点。《HTML5与CSS3实战指南》涵盖了零基础开发Web站点的所有知识，通过学习《HTML5与CSS3实战指南》，读者将掌握HTML5中可用的全新语义标记，以及如何在不求助复杂解决方案的情况下使用CSS3来开发Web站点。您将学习如何：通过使用HTML5自身的Video元素来摆脱Flash的束缚，使用@font-face设置完全支持您的信息的类型，构建用户喜欢的具有智能验证功能的Web表单，构建运行在移动环境中的现代Web应用程序，使用SVG和carwas迅速创建动态、高效的图形，使用全新的API添加地理定位和离线Web应用等功能。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 HTML5和CSS3简介 1</span><br><span class="line">1.1 什么是HTML5 1</span><br><span class="line">1.2 如何发展至今 2</span><br><span class="line">1.3 我们为什么应关注HTML5 4</span><br><span class="line">1.4 什么是CSS3 4</span><br><span class="line">1.5 我们为什么应关注CSS3 5</span><br><span class="line">1.6 在现实中，我们想做的是什么 6</span><br><span class="line">1.6.1 多种浏览器的市场 6</span><br><span class="line">1.6.2 不断发展的移动市场 7</span><br><span class="line">1.7 实际应用 8 </span><br><span class="line"></span><br><span class="line"> 第2章 HTML5样式的标记 11 2.1 The HTML5 Herald简介 11 2.2 基本的HTML5模板 12 2.2.1 Doctype 13 2.2.2 html元素 14 2.2.3 head元素 14 2.2.4 公平竞争 16 2.2.5 剩余部分是历史简介 17 2.3 HTML5常见问题 18 2.3.1 为什么这些变更仍能够在旧版浏览器中工作 18 2.3.2 是否需要关闭所有标签 20 2.3.3 关于其他的基于XHTML的语法使用习惯 20 2.4 定义页面结构 22 2.4.1 header元素 22 2.4.2 section元素 23 2.4.3 article元素 24 2.4.4 nav元素 25 2.4.5 aside元素 26 2.4.6 footer元素 27 2.5 构建The HTML5 Herald 28 2.6 小结 30</span><br><span class="line"></span><br><span class="line"> 第3章 关于HTML5语义的更多内容 31 3.1 关于内容类型的新视角 31 3.2 文档大纲 33 3.3 最新消息 34 3.4 更多新元素 37 3.4.1 figure和figcaption元素 37 3.4.2 mark元素 38 3.4.3 progress和meter元素 38 3.4.4 time元素 39 3.5 对现有功能的更改 41 3.5.1 单词“Deprecated”是被弃用的 41 3.5.2 链接中的block元素 41 3.5.3 黑体文本 41 3.5.4 斜体文本 42 3.5.5 大号和小号文体 43 3.5.6 引起争议的cite元素 43 3.5.7 描述(不是定义)列表 43 3.6 其他新元素及功能 44 3.6.1 details元素 44 3.6.2 自定义的有序列表 45 3.6.3 作用域样式 45 3.6.4 script元素的async属性 45 3.7 验证HTML5文档 46 3.8 小结 48</span><br><span class="line"></span><br><span class="line"> 第4章 HTML5表单 49 4.1 工具箱中的相关工具 49 4.2 HTML5表单属性 51 4.2.1 required属性 51 4.2.2 placeholder属性 55 4.2.3 pattern属性 58 4.2.4 disabled属性 59 4.2.5 readonly属性 59 4.2.6 multiple属性 60 4.2.7 form属性 60 4.2.8 autocomplete属性 61 4.2.9 datalist元素和list属性 61 4.2.10 autofocus属性 62 4.3 HTML5新表单输入类型 62 4.3.1 search 63 4.3.2 Email Addresses 64 4.3.3 URL 65 4.3.4 Telephone Numbers 66 4.3.5 Numbers 66 4.3.6 Ranges 67 4.3.7 Colors 68 4.3.8 Dates和Times 69 4.4 HTML5中的其他新表单控件 71 4.4.1 output元素 72 4.4.2 keygen元素 72 4.5 对现有表单控件及属性的更改 72 4.5.1 form元素 72 4.5.2 optgroup元素 73 4.5.3 textarea元素 73 4.6 小结 73</span><br><span class="line"></span><br><span class="line"> 第5章 HTML5音频和视频 75 5.1 历史简介 75 5.2 目前状况 76 5.2.1 视频容器格式 76 5.2.2 视频编解码器 77 5.2.3 音频编解码器 77 5.2.4 当前浏览器使用哪种组合 77 5.3 标记 78 5.3.1 启用本机控件 78 5.3.2 autoplay属性 79 5.3.3 loop属性 80 5.3.4 preload属性 80 5.3.5 poster属性 81 5.3.6 audio属性 81 5.3.7 添加对多种视频格式的支持 81 5.3.8 资源顺序 82 5.3.9 关于Internet Explorer 6～8 83 5.3.10 MIME类型 85 5.4 用于网络的视频文件解码 86 5.5 创建自定义控件 86 5.5.1 让我们从一些标记和设计开始 87 5.5.2 介绍媒体元素API 88 5.5.3 播放和暂停视频 90 5.5.4 视频音轨的静音与取消静音 93 5.5.5 视频结束播放的响应 94 5.5.6 更新视频播放的时间 94 5.5.7 媒体元素API的其他一些功能 97 5.6 关于音频 99 5.7 可访问的媒体 99 5.8 小结 100</span><br><span class="line"></span><br><span class="line"> 第6章 CSS3简介 101 6.1 改进旧版浏览器 101 6.2 CSS3选择器 102 6.2.1 关系选择器 102 6.2.2 属性选择器 104 6.2.3 伪类 105 6.2.4 结构化伪类 107 6.2.5 伪元素和生成的内容 110 6.3 CSS3颜色 111 6.3.1 RGBA 112 6.3.2 HSL和HSLA 113 6.3.3 不透明度 114 6.4 实际应用 114 6.5 圆角：border-radius 116 6.6 投影 118 6.7 文本阴影 122 6.8 更多阴影 122 6.9 小结 123</span><br><span class="line"></span><br><span class="line"> 第7章 CSS3渐变和多背景 125 7.1 线性渐变 126 7.1.1 W3C语法 127 7.1.2 旧WebKit语法 130 7.1.3 实际应用 131 7.1.4 使用SVG的线性渐变 133 7.1.5 使用Internet Explorer滤镜的线性渐变 135 7.1.6 便捷的工具 136 7.2 径向渐变 136 7.2.1 W3C语法 137 7.2.2 旧WebKit语法 139 7.2.3 实际应用 140 7.3 重复渐变 141 7.4 多背景图像 142 7.5 背景大小 145 7.6 小结 147</span><br><span class="line"></span><br><span class="line"> 第8章 CSS3转换和过渡 149 8.1 转换 149 8.1.1 平移 150 8.1.2 缩放 152 8.1.3 旋转 153 8.1.4 倾斜 154 8.1.5 更改转换的原点 154 8.1.6 对Internet Explorer 8及更早版本的支持 155 8.2 过渡 156 8.2.1 transition-property 157 8.2.2 transition-duration 158 8.2.3 transition-timing-function 159 8.2.4 transition-delay 160 8.2.5 transition简写属性 160 8.2.6 多个过渡 161 8.3 动画 162 8.3.1 关键帧 162 8.3.2 动画属性 164 8.4 小结 167</span><br><span class="line"></span><br><span class="line"> 第9章 嵌入字体和多列布局 169 9.1 Web字体和@font-face 169 9.1.1 实现@font-face 170 9.1.2 声明字体来源 172 9.1.3 字体属性描述符 174 9.1.4 Unicode范围 175 9.1.5 应用字体 176 9.1.6 法律因素 176 9.1.7 创建各种字体文件类型：Font Squirrel 177 9.1.8 其他考虑因素 180 9.2 CSS3多列布局 180 9.2.1 column-count属性 181 9.2.2 column-gap属性 182 9.2.3 column-width属性 182 9.2.4 columns简写属性 184 9.2.5 列和height属性 184 9.2.6 其他列功能 185 9.2.7 其他考虑因素 186 9.2.8 渐进增强 187 9.3 媒体查询 188 9.3.1 什么是媒体查询 188 9.3.2 语法 189 9.3.3 媒体查询的灵活性 190 9.3.4 浏览器支持 190 9.3.5 其他阅读材料 191 9.4 小结 191</span><br><span class="line"></span><br><span class="line"> 第10章 地理定位、离线Web应用和Web存储 193 10.1 地理定位 194 10.1.1 隐私问题 195 10.1.2 地理定位方法 195 10.1.3 使用Modernizr检查支持 196 10.1.4 获取当前位置 196 10.1.5 地理定位的Position对象 197 10.1.6 获取经度和纬度 198 10.1.7 加载地图 199 10.1.8 关于旧式移动设备的结束语 204 10.2 离线Web应用 204 10.2.1 工作原理：HTML5应用程序缓存 205 10.2.2 设置站点离线工作 205 10.2.3 获取离线存储站点的权限 208 10.2.4 离线测试 208 10.2.5 使The HTML5 Herald离线可用 210 10.2.6 离线Web应用存储的限制 211 10.2.7 后备部分 211 10.2.8 刷新缓存 213 10.2.9 我们在线吗 214 10.2.10 其他阅读材料 215 10.3 Web存储 215 10.3.1 两种存储 216 10.3.2 Web存储数据的外观 217 10.3.3 获取和设置数据 218 10.3.4 转换存储的数据 218 10.3.5 快捷方式 219 10.3.6 删除条目和清除数据 219 10.3.7 存储限制 219 10.3.8 安全考虑 220 10.3.9 将Web存储添加到The HTML5 Herald 221 10.3.10 用网页审查工具查看Web存储值 224 10.4 其他HTML5 API 226 10.4.1 网络工作者 226 10.4.2 网络套接字 227 10.4.3 Web SQL和IndexedDB 227 10.5 返回到绘制面板 228</span><br><span class="line"></span><br><span class="line"> 第11章 画布、SVG和拖放 229 11.1 画布 229 11.1.1 关于画布的一些历史 230 11.1.2 创建画布元素 230 11.1.3 在画布上绘制 232 11.1.4 获取背景 232 11.1.5 用颜色填充画笔 233 11.1.6 在画布上绘制矩形 234 11.1.7 画布坐标系统 234 11.1.8 fillStyle的变化 235 11.1.9 通过创建路径绘制其他形状 237 11.1.10 存储画布绘制 240 11.1.11 在画布上绘制图像 241 11.1.12 处理图像 243 11.1.13 将彩色图像转换为黑白图像 244 11.1.14 getImageData的安全性错误 247 11.1.15 用画布测试视频 247 11.1.16 在画布上显示文字 250 11.1.17 关注可访问性 254 11.1.18 其他阅读材料 254 11.2 SVG 254 11.2.1 在SVG上绘制 255 11.2.2 使用Inkscape创建SVG图像 258 11.2.3 SVG过滤器 258 11.2.4 使用Rapha?l库 259 11.2.5 画布与SVG 261 11.3 拖放 262 11.3.1 给WAI-ARIA猫喂食 263 11.3.2 使元素可拖动 264 11.3.3 DataTransfer对象 265 11.3.4 接受可以放下的元素 266 11.3.5 其他阅读材料 269 11.4 结束了，朋友们！ 269 附录A Modernizr 271 附录B WAI-ARIA 277 附录C 微数据 281</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00647RUGK/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00647RUGK&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51oc8alcfrL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>疯狂Java 突破程序员基本功的16课(修订版)</title>
    <url>/2020/04/19/B006P9B1XA/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 疯狂Java 突破程序员基本功的16课(修订版)<br>作者信息： 作者: 李刚 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《疯狂Java：突破程序员基本功的16课(修订版)》：疯狂源自梦想，技术成就辉煌。你是否在求职时被鄙视“基本功不扎实”而万分惭愧？《疯狂Java：突破程序员基本功的16课(修订版)》能检验你的基本功，并让你弥补不足。《疯狂Java：突破程序员基本功的16课(修订版)》归纳了Java学习者、工作者在学习、工作过程中最欠缺的技术短板，形成内存管理、常见的陷阱、数据结构、程序调试、软件测试等16堂必修课。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1课　数组与内存控制　</span><br><span class="line">1.1　数组初始化　</span><br><span class="line">1.1.1　Java数组是静态的　</span><br><span class="line">1.1.2　数组一定要初始化吗　</span><br><span class="line">1.1.3　基本类型数组的初始化　</span><br><span class="line">1.1.4　引用类型数组的初始化　</span><br><span class="line">1.2　使用数组　</span><br><span class="line">1.2.1　数组元素就是变量　</span><br><span class="line">1.2.2　没有多维数组　</span><br><span class="line">1.3　小结　 </span><br><span class="line"></span><br><span class="line"> 第2课　对象与内存控制　 2.1　实例变量和类变量　 2.1.1　实例变量和类变量的属性　 2.1.2　实例变量的初始化时机　 2.1.3　类变量的初始化时机　 2.2　父类构造器　 2.2.1　隐式调用和显式调用　 2.2.2　访问子类对象的实例变量　 2.2.3　调用被子类重写的方法　 2.3　父子实例的内存控制　 2.3.1　继承成员变量和继承方法的区别　 2.3.2　内存中子类实例　 2.3.3　父、子类的类变量　 2.4　final修饰符　 2.4.1　final修饰的变量　 2.4.2　执行“宏替换”的变量　 2.4.3　final方法不能被重写　 2.4.4　内部类中的局部变量　 2.5　小结　</span><br><span class="line"></span><br><span class="line"> 第3课　常见Java集合的实现细节　 3.1　Set和Map　 3.1.1　Set和Map的关系　 3.1.2　HashMap和HashSet　 3.1.3　TreeMap和TreeSet　 3.2　Map和List　 3.2.1　Map的values()方法　 3.2.2　Map和List的关系　 3.3　ArrayList和LinkedList　 3.3.1　Vector和ArrayList的区别　 3.3.2　ArrayList和LinkedList的实现差异　 3.3.3　ArrayList和LinkedList的性能分析和适用场景　 3.4　Iterator迭代器　 迭代时删除指定元素　 3.5　小结　</span><br><span class="line"></span><br><span class="line"> 第4课　Java的内存回收　 4.1　Java引用的种类　 4.1.1　对象在内存中状态　 4.1.2　强引用　 4.1.3　软引用　 4.1.4　弱引用　 4.1.5　虚引用　 4.2　Java的内存泄漏　 4.3　垃圾回收机制　 4.3.1　垃圾回收的基本算法　 4.3.2　堆内存的分代回收　 4.3.3　与垃圾回收的附加选项　 4.3.4　常见垃圾回收器　 4.4　内存管理的小技巧　 4.4.1　尽量使用直接量　 4.4.2　使用StringBuilder和StringBuffer进行字符串连接　 4.4.3　尽早释放无用对象的引用　 4.4.4　尽量少用静态变量　 4.4.5　避免在经常调用的方法、循环中创建Java对象　 4.4.6　缓存经常使用的对象　 4.4.7　尽量不要使用finalize方法　 4.4.8　考虑使用SoftReference　 4.5　小结　</span><br><span class="line"></span><br><span class="line"> 第5课　表达式中的陷阱　 5.1　关于字符串的陷阱　 5.1.1　JVM对字符串的处理　 5.1.2　不可变的字符串　 5.1.3　字符串比较　 5.2　表达式类型的陷阱　 5.2.1　表达式类型的自动提升　 5.2.2　复合赋值运算符的陷阱　 5.3　输入法导致的陷阱　 5.4　注释的字符必须合法　 5.5　转义字符的陷阱　 5.5.1　慎用字符的Unicode转义形式　 5.5.2　中止行注释的转义字符　 5.6　泛型可能引起的错误　 5.6.1　原始类型变量的赋值　 5.6.2　原始类型带来的擦除　 5.6.3　创建泛型数组的陷阱　 5.7　正则表达式的陷阱　 5.8　多线程的陷阱　 5.8.1　不要调用run方法　 5.8.2　静态的同步方法　 5.8.3　静态初始化块启动新线程执行初始化　 5.8.4　注意多线程执行环境　 5.9　小结　</span><br><span class="line"></span><br><span class="line"> 第6课　流程控制的陷阱　 6.1　switch语句陷阱　 6.1.1　default分支永远会执行吗　 6.1.2　break的重要性　 6.1.3　switch表达式的类型　 6.2　标签引起的陷阱　 6.3　if语句的陷阱　 6.3.1　else隐含的条件　 6.3.2　小心空语句　 6.4　循环体的花括号　 6.4.1　什么时候可以省略花括号　 6.4.2　省略花括号的危险　 6.5　for循环的陷阱　 6.5.1　分号惹的祸　 6.5.2　小心循环计数器的值　 6.5.3　浮点数作循环计数器　 6.6　foreach循环的循环计数器　 6.7　小结　</span><br><span class="line"></span><br><span class="line"> 第7课　面向对象的陷阱　 7.1　instanceof运算符的陷阱　 7.2　构造器的陷阱　 7.2.1　构造器之前的void　 7.2.2　构造器创建对象吗　 7.2.3　无限递归的构造器　 7.3　持有当前类的实例　 7.4　到底调用哪个重载的方法　 7.5　方法重写的陷阱　 7.5.1　重写private方法　 7.5.2　重写其他访问权限的方法　 7.6　非静态内部类的陷阱　 7.6.1　非静态内部类的构造器　 7.6.2　非静态内部类不能拥有静态成员　 7.6.3　非静态内部类的子类　 7.7　static关键字　 7.7.1　静态方法属于类　 7.7.2　静态内部类的限制　 7.8　native方法的陷阱　 7.9　小结　</span><br><span class="line"></span><br><span class="line"> 第8课　异常捕捉的陷阱　 8.1　正确关闭资源的方式　 8.2　finally块的陷阱　 8.2.1　finally的执行规则　 8.2.2　finally块和方法返回值　 8.3　catch块的用法　 8.3.1　catch块的顺序　 8.3.2　不要用catch代替流程控制　 8.3.3　只能catch可能抛出的异常　 8.3.4　做点实际的修复　 8.4　继承得到的异常　 8.5　小结　</span><br><span class="line"></span><br><span class="line"> 第9课　线性表　 9.1　线性表概述　 9.1.1　线性表的定义及逻辑结构　 9.1.2　线性表的基本操作　 9.2　顺序存储结构　 9.3　链式存储结构　 9.3.1　单链表上的基本运算　 9.3.2　循环链表　 9.3.3　双向链表　 9.4　线性表的分析　 9.4.1　线性表的实现分析　 9.4.2　线性表的功能　 9.5　小结　</span><br><span class="line"></span><br><span class="line"> 第10课　栈和队列　 10.1　栈　 10.1.1　栈的基本定义　 10.1.2　栈的常用操作　 10.1.3　栈的顺序存储结构及实现　 10.1.4　栈的链式存储结构及实现　 10.1.5　Java集合中的栈　 10.2　队列　 10.2.1　队列的基本定义　 10.2.2　队列的常用操作　 10.2.3　队列的顺序存储结构及实现　 10.2.4　循环队列　 10.2.5　队列的链式存储结构及实现　 10.2.6　Java集合中的队列　 10.3　双向队列　 10.4　小结　</span><br><span class="line"></span><br><span class="line"> 第11课　树和二叉树　 11.1　树的概述　 11.1.1　树的定义和基本术语　 11.1.2　树的基本操作　 11.1.3　父节点表示法　 11.1.4　子节点链表示法　 11.2　二叉树　 11.2.1　二叉树的定义和基本概念　 11.2.2　二叉树的基本操作　 11.2.3　二叉树的顺序存储　 11.2.4　二叉树的二叉链表存储　 11.2.5　二叉树的三叉链表存储　 11.3　遍历二叉树　 11.3.1　先序遍历　 11.3.2　中序遍历　 11.3.3　后序遍历　 11.3.4　广度优先(按层)遍历　 11.4　森林、树和二叉树的转换　 11.4.1　森林、树和二叉树的转换　 11.4.2　树的链表存储　 11.5　哈夫曼树　 11.5.1　哈夫曼树的定义和基本概念　 11.5.2　创建哈夫曼树　 11.5.3　哈夫曼编码　 11.6　排序二叉树　 11.7　红黑树　 11.7.1　插入操作　 11.7.2　删除操作　 11.8　小结　</span><br><span class="line"></span><br><span class="line"> 第12课　常用的内部排序　 12.1　排序的基本概念　 12.1.1　排序概述　 12.1.2　内部排序的分类　 12.2　选择排序法　 12.2.1　直接选择排序　 12.2.2　堆排序　 12.3　交换排序　 12.3.1　冒泡排序　 12.3.2　快速排序　 12.4　插入排序　 12.4.1　直接插入排序　 12.4.2　折半插入排序　 12.4.3　Shell排序　 12.5　归并排序　 12.6　桶式排序　 12.7　基数排序　 12.8　小结　</span><br><span class="line"></span><br><span class="line"> 第13课　程序开发　 13.1　扎实的基本功　 13.1.1　快速的输入能力　 13.1.2　编程实现能力　 13.1.3　快速排错　 13.2　程序开发之前　 13.2.1　分析软件的组件模型　 13.2.2　建立软件的数据模型　 13.3　弄清程序的具体实现　 13.3.1　各组件如何通信　 13.3.2　人机交互的实现　 13.3.3　复杂算法的分析　 13.4　编写开发文档　 13.4.1　绘制建模图、流程图　 13.4.2　提供简要说明　 13.4.3　编写伪码实现　 13.5　编码实现和开发心态　 13.5.1　开发是复杂的　 13.5.2　开发过程是漫长的　 13.6　小结　</span><br><span class="line"></span><br><span class="line"> 第14课　程序调试　 14.1　程序的可调试性　 14.1.1　增加注释　 14.1.2　使用log　 14.2　程序调试的基本方法　 14.2.1　借助编译器的代码审查　 14.2.2　跟踪程序执行流程　 14.2.3　断点调试　 14.2.4　隔离调试　 14.2.5　错误重现　 14.3　记录常见错误　 14.3.1　常见异常可能的错误原因　 14.3.2　常见运行时异常可能的错误原因　 14.4　程序调试的整体思路　 14.4.1　分段调试　 14.4.2　分模块调试　 14.5　调试心态　 14.5.1　谁都会出错　 14.5.2　调试比写程序更费时　 14.6　小结　</span><br><span class="line"></span><br><span class="line"> 第15课　使用IDE工具　 15.1　何时开始利用IDE工具　 15.2　IDE工具概述　 15.2.1　IDE工具的基本功能　 15.2.2　常见的Java IDE工具　 15.3　项目管理　 15.3.1　建立项目　 15.3.2　自动编译　 15.3.3　自动部署、运行　 15.4　代码管理　 15.4.1　向导式的代码生成　 15.4.2　代码生成器　 15.4.3　代码提示　 15.4.4　自动代码补齐　 15.4.5　实时错误提示　 15.5　项目调试　 15.5.1　设置断点　 15.5.2　单步调试　 15.5.3　步入、步出　 15.6　团队协作功能　 作为版本控制工具的客户端　 15.7　小结　</span><br><span class="line"></span><br><span class="line"> 第16课　软件测试　 16.1　软件测试概述　 16.1.1　软件测试的概念和目的　 16.1.2　软件测试的分类　 16.1.3　开发活动和测试活动　 16.1.4　常见的Bug管理工具　 16.2　单元测试　 16.2.1　单元测试概述　 16.2.2　单元测试的逻辑覆盖　 16.2.3　JUnit介绍　 16.2.4　JUnit的用法　 16.3　系统测试和自动化测试　 16.3.1　系统测试概述　 16.3.2　自动化测试　 16.3.3　常见自动化测试工具　 16.4　性能测试　 16.4.1　性能测试概述　 16.4.2　性能测试的相关概念　 16.4.3　常见性能测试工具　 16.5　小结</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B006P9B1XA/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B006P9B1XA&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51ipsS6k29L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>编写高质量代码 改善Java程序的151个建议</title>
    <url>/2020/04/19/B006Q5NH1M/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 编写高质量代码 改善Java程序的151个建议<br>作者信息： 作者: 秦小波 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《编写高质量代码:改善Java程序的151个建议》：大多数Java程序员都会在前进的道路上被以下几类问题所困扰：一、来自于语言本身的问题。例如：覆写变长方法为什么会出现不能编译的情况？final修饰的int类型常量竟然在运行期被修改？匿名类是否有构造函数？它与普通类的构造函数有何不同？为什么要把受检异常转化为非受检异常？二、来自于程序设计和常用API的问题。例如：如何用一行代码实现两个集合的交、差、并集？如何才能动态加载一个类？数组如何动态加载？在switch中使用枚举类型，为什么会出现NullPointer Exception异常？为什么使用了volatile关键字后数据还是出现混乱？显式锁（Lock类）和内部锁（synchronized关键宇）完全一样吗？三、来自于程序架构和思想方面的问题。例如：Java的性能是否曾经让你担忧过？或者曾经让你很受伤？到底是该多采用开源工具还是自己写工具类？若采用开源工具，有什么评测标准？什么样的代码风格才是优秀的？怎么才能让一个团队保持同样的风格？如果你曾经为诸如此类的问题感到疑惑不解或顿然大悟，说明你正在向Java技术的巅峰攀登，正在成长为“振臂一呼，应者云集”的技术大牛，恭喜你！《编写高质量代码:改善Java程序的151个建议》从不同的侧面出发，对Java编码中各种棘手的疑难杂症和常见问题奉献了真知灼见，相信你一定能从中受益。从语法、程序设计和架构、工具和框架、编码风格、编程思想，5个方面深入探讨编写高质量Java代码的技巧、禁忌和最佳实践。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">第1章　java开发中通用的方法和准则</span><br><span class="line">建议1: 不要在常量和变量中出现易混淆的字母</span><br><span class="line">建议2: 莫让常量蜕变成变量</span><br><span class="line">建议3: 三元操作符的类型务必一致</span><br><span class="line">建议4: 避免带有变长参数的方法重载</span><br><span class="line">建议5: 别让null值和空值威胁到变长方法</span><br><span class="line">建议6: 覆写变长方法也循规蹈矩</span><br><span class="line">建议7: 警惕自增的陷阱</span><br><span class="line">建议8: 不要让旧语法困扰你</span><br><span class="line">建议9: 少用静态导入</span><br><span class="line">建议10: 不要在本类中覆盖静态导入的变量和方法</span><br><span class="line">建议11: 养成良好习惯,显式声明uid</span><br><span class="line">建议12: 避免用序列化类在构造函数中为不变量赋值</span><br><span class="line">建议13: 避免为final变量复杂赋值</span><br><span class="line">建议14: 使用序列化类的私有方法巧妙解决部分属性持久化问题</span><br><span class="line">建议15: break万万不可忘</span><br><span class="line">建议16: 易变业务使用脚本语言编写</span><br><span class="line">建议17: 慎用动态编译</span><br><span class="line">建议18: 避免instanceof非预期结果</span><br><span class="line">建议19: 断言绝对不是鸡肋</span><br><span class="line">建议20: 不要只替换一个类 </span><br><span class="line"></span><br><span class="line"> 第2章　基本类型 建议21: 用偶判断,不用奇判断 建议22: 用整数类型处理货币 建议23: 不要让类型默默转换 建议24: 边界,边界,还是边界 建议25: 不要让四舍五入亏了一方 建议26: 提防包装类型的null值 建议27: 谨慎包装类型的大小比较 建议28: 优先使用整型池 建议29: 优先选择基本类型 建议30: 不要随便设置随机种子</span><br><span class="line"></span><br><span class="line"> 第3章　类、对象及方法 建议31: 在接口中不要存在实现代码 建议32: 静态变量一定要先声明后赋值 建议33: 不要覆写静态方法 建议34: 构造函数尽量简化 建议35: 避免在构造函数中初始化其他类 建议36: 使用构造代码块精炼程序 建议37: 构造代码块会想你所想 建议38: 使用静态内部类提高封装性 建议39: 使用匿名类的构造函数 建议40: 匿名类的构造函数很特殊 建议41: 让多重继承成为现实 建议42: 让工具类不可实例化 建议43: 避免对象的浅拷贝 建议44: 推荐使用序列化实现对象的拷贝 建议45: 覆写equals方法时不要识别不出自己 建议46: equals应该考虑null值情景 建议47: 在equals中使用getclass进行类型判断 建议48: 覆写equals方法必须覆写hashcode方法 建议49: 推荐覆写tostring方法 建议50: 使用package-info类为包服务 建议51: 不要主动进行垃圾回收</span><br><span class="line"></span><br><span class="line"> 第4章　字符串 建议52: 推荐使用string直接量赋值 建议53: 注意方法中传递的参数要求 建议54: 正确使用string、stringbuffer、stringbuilder 建议55: 注意字符串的位置 建议56: 自由选择字符串拼接方法 建议57: 推荐在复杂字符串操作中使用正则表达式 建议58: 强烈　建议使用utf编码 建议59: 对字符串排序持一种宽容的心态</span><br><span class="line"></span><br><span class="line"> 第5章　数组和集合 建议60: 性能考虑,数组是首选 建议61: 若有必要,使用变长数组 建议62: 警惕数组的浅拷贝 建议63: 在明确的场景下,为集合指定初始容量 建议64: 多种最值算法,适时选择 建议65: 避开基本类型数组转换列表陷阱 建议66: aslist方法产生的list对象不可更改 建议67: 不同的列表选择不同的遍历方法 建议68: 频繁插入和删除时使用linkedlist 建议69: 列表相等只需关心元素数据 建议70:子列表只是原列表的一个视图 建议71: 推荐使用sublist处理局部列表 建议72: 生成子列表后不要再操作原列表 建议73: 使用comparator进行排序 建议74: 不推荐使用binarysearch对列表进行检索 建议75: 集合中的元素必须做到compareto和equals同步 建议76: 集合运算时使用更优雅的方式 建议77: 使用shuffle打乱列表 建议78: 减少hashmap中元素的数量 建议79: 集合中的哈希码不要重复 建议80: 多线程使用vector或hashtable 建议81: 非稳定排序推荐使用list 建议82: 由点及面,一叶知秋-集合大家族</span><br><span class="line"></span><br><span class="line"> 第6章　枚举和注解 建议83: 推荐使用枚举定义常量 建议84: 使用构造函数协助描述枚举项 建议85: 小心switch带来的空值异常 建议86: 在switch的default代码块中增加assertionerror错误 建议87: 使用valueof前必须进行校验 建议88: 用枚举实现工厂方法模式更简洁 建议89: 枚举项的数量限制在64个以内 建议90: 小心注解继承 建议91: 枚举和注解结合使用威力更大 建议92: 注意@override不同版本的区别</span><br><span class="line"></span><br><span class="line"> 第7章　泛型和反射 建议93: java的泛型是类型擦除的 建议94: 不能初始化泛型参数和数组 建议95: 强制声明泛型的实际类型 建议96: 不同的场景使用不同的泛型通配符 建议97: 警惕泛型是不能协变和逆变的 建议98: 　建议采用的顺序是list[t]、list[?]、list[object] 建议99: 严格限定泛型类型采用多重界限 建议100: 数组的真实类型必须是泛型类型的子类型 建议101: 注意class类的特殊性 建议102: 适时选择getdeclared×××和get××× 建议103: 反射访问属性或方法时将accessible设置为true 建议104: 使用forname动态加载类文件 建议105: 动态加载不适合数组 建议106: 动态代理可以使代理模式更加灵活 建议107: 使用反射增加装饰模式的普适性 建议108: 反射让模板方法模式更强大 建议109: 不需要太多关注反射效率</span><br><span class="line"></span><br><span class="line"> 第8章　异常 建议110: 提倡异常封装 建议111: 采用异常链传递异常 建议112: 受检异常尽可能转化为非受检异常 建议113: 不要在finally块中处理返回值 建议114: 不要在构造函数中抛出异常 建议115: 使用throwable获得栈信息 建议116: 异常只为异常服务 建议117: 多使用异常,把性能问题放一边</span><br><span class="line"></span><br><span class="line"> 第9章　多线程和并发 建议118: 不推荐覆写start方法 建议119: 启动线程前stop方法是不可靠的 建议120: 不使用stop方法停止线程 建议121: 线程优先级只使用三个等级 建议122: 使用线程异常处理器提升系统可靠性 建议123: volatile不能保证数据同步 建议124: 异步运算考虑使用callable接口 建议125: 优先选择线程池 建议126: 适时选择不同的线程池来实现 建议127: lock与synchronized是不一样的 建议128: 预防线程死锁 建议129: 适当设置阻塞队列长度 建议130: 使用countdownlatch协调子线程 建议131: cyclicbarrier让多线程齐步走</span><br><span class="line"></span><br><span class="line"> 第10章　性能和效率 建议132: 提升java性能的基本方法 建议133: 若非必要,不要克隆对象 建议134: 推荐使用“望闻问切”的方式诊断性能 建议135: 必须定义性能衡量标准 建议136: 枪打出头鸟-解决首要系统性能问题 建议137: 调整jvm参数以提升性能 建议138: 性能是个大“咕咚”</span><br><span class="line"></span><br><span class="line"> 第11章　开源世界 建议139: 大胆采用开源工具 建议140: 推荐使用guava扩展工具包 建议141: apache扩展包 建议142: 推荐使用joda日期时间扩展包 建议143: 可以选择多种collections扩展</span><br><span class="line"></span><br><span class="line"> 第12章　思想为源 建议144: 提倡良好的代码风格 建议145: 不要完全依靠单元测试来发现问题 建议146: 让注释正确、清晰、简洁 建议147: 让接口的职责保持单一 建议148: 增强类的可替换性 建议149: 依赖抽象而不是实现 建议150: 抛弃7条不良的编码习惯 建议151: 以技术员自律而不是工人</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B006Q5NH1M/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B006Q5NH1M&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41%2BTTT46AQL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>深入剖析Tomcat</title>
    <url>/2020/04/19/B006R3TUIC/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 深入剖析Tomcat<br>作者信息： 作者: 克尼亚万 (Bubi Kurniawan) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《深入剖析Tomcat》编辑推荐：深入理解Tomcat的必读之作，欲知其然，更欲知其所以然。《深入剖析Tomcat》以Tomcat 4和Tomcat 5两个版本为基础，从建立一个最简单的连接开始，深入介绍Tomcat的体系结构。从连接器到最终的JMX管理，循序渐进，层层深入。每一章有配有相关代码，既是对理论内容的具体展现，也可以帮助读者编写一个实用的应用服务器。在内容上，《深入剖析Tomcat》更关注对Tomcat基本体系结构的讲解，并没有涉及在实际应用中的具体实现细节。希望读者在阅读的时候，着重把握Torrical的一些设计思想，在此基础上，再针对某一方面进行深入的学习和研究。《深入剖析Tomcat》深入剖析Tomcat 4和Tomcat 5中的每个组件，并揭示其内部工作原理。通过学习《深入剖析Tomcat》，你不仅可以自行开发Tomcat组件，而且可以扩展已有的组件。《深入剖析Tomcat》主要内容：如何开发Java Web服器。Tomcat是否会为每个servlet类创建多个实例。Tomcat如何运行一个实现Simple Thread Model接El的servlet类。servlet容器的两个主要模块：连接器和servlet容器。如何构建或者扩展已有的连接器。4种servlet容器：Engine、Host、Context和Wrapper。T0mcat如何管理Session，以及如何在分布式环境下扩展Session管理器。Tomcat中的类载入器和如何创建自定义载入器。Tomcat如何实现安全性和基本／基于表单／摘要的身份验证。Tomcat中的领域与登录配置是如何工作的。Tomcat如何处理配制文件（server.xml），以及如何通过Digester库将XML元素转换Java对象。Tomcat中的关闭钩子。JMX、Apache的Commons Modeler和Tomcat中的JMX托管资源。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">译者序</span><br><span class="line">前言</span><br><span class="line">第1章 一个简单的Web服务器</span><br><span class="line">1.1 HTTP</span><br><span class="line">1.1.1 HTTP请求</span><br><span class="line">1.1.2 HTTP响应</span><br><span class="line">1.2 Socket类</span><br><span class="line">1.3 应用程序</span><br><span class="line">1.3.1 HttpServer类</span><br><span class="line">1.3.2 Request类</span><br><span class="line">1.3.3 Response类</span><br><span class="line">1.3.4 运行应用程序</span><br><span class="line">1.4 小结 </span><br><span class="line"></span><br><span class="line"> 第2章 一个简单的servlet容器 2.1 javax.servlet.Servlet接口 2.2 应用程序 2.2.1 HttpServer1类 2.2.2 Request类 2.2.3 Response类 2.2.4 StaticResourceProcessor类 2.2.5 servletProcessor1类 2.2.6 运行应用程序 2.3 应用程序 2.4 小结</span><br><span class="line"></span><br><span class="line"> 第3章 连接器 3.1 StringManager类 3.2 应用程序 3.2.1 启动应用程序 3.2.2 HttpConnector类 3.2.3 创建HttpRequest对象 3.2.4 创建HttpResponse对象 3.2.5 静态资源处理器和servlet处理器 3.2.6 运行应用程序 3.3 小结</span><br><span class="line"></span><br><span class="line"> 第4章 Tomcat的默认连接器 4.1 HTTP1.1 的新特性 4.1.1 持久连接 4.1.2 块编码 4.1.3 状态码100的使用 4.2 Connector接口 4.3 HttpConnector类 4.3.1 创建服务器套接字 4.3.2 维护HttpProcessor实例 4.3.3 提供HTTP请求服务 4.4 HttpProcessor类 4.5 Request对象 4.6 Response对象 4.7 处理请求 4.7.1 解析连接 4.7.2 解析请求 4.7.3 解析请求头 4.8 简单的Container应用程序 4.9 小结</span><br><span class="line"></span><br><span class="line"> 第5章 servlet容器 5.1 Container接口 5.2 管道任务 5.2.1 Pipeline接口 5.2.2 Valve接口 5.2.3 ValveContext接口 5.2.4 Contained接口 5.3 Wrapper接口 5.4 Context接口 5.5 Wrapper应用程序 5.5.1 ex05.pyrmont.core.SimpleLoader类 5.5.2 ex05.pyrmont.core.SimplePipeline类 5.5.3 ex05.pyrmont.core.SimpleWrapper类 5.5.4 ex05.pyrmont.core.SimpleWrapperValve类 5.5.5 ex05.pyrmont.valves.ClientIPLoggerValve类 5.5.6 ex05.pyrmont.valves.HeaderLoggerValve类 5.5.7 ex05.pyrmont.startup.Bootstrap 5.5.8 运行应用程序 5.6 Context应用程序 5.6.1 ex05.pyrmont.core.SimpleContextValve类 5.6.2 ex05.pyrmont.core.SimpleContextMapper类 5.6.3 ex05.pyrmont.core.SimpleContext类 5.6.4 ex05.pyrmont.startup.Bootstrap 5.6.5 运行应用程序 5.7 小结</span><br><span class="line"></span><br><span class="line"> 第6章 生命周期 6.1 Lifecycle接口 6.2 LifecycleEvent类 6.3 LifecycleListener接口 6.4 LifecycleSupport类 6.5 应用程序 6.5.1 ex06.pyrmont.core.SimpleContext类 6.5.2 ex06.pyrmont.core.SimpleContextLifecycleListener类 6.5.3 ex06.pyrmont.core.SimpleLoader类 6.5.4 ex06.pyrmont.core.SimplePipeline类 6.5.5 ex06.pyrmont.core.SimpleWrapper类 6.5.6 运行应用程序 6.6 小结</span><br><span class="line"></span><br><span class="line"> 第7章 日志记录器 7.1 Logger接口 7.2 Tomcat的日志记录器 7.2.1 LoggerBase类 7.2.2 SystemOutLogger类 7.2.3 SystemErrLogger类 7.2.4 FileLogger类 7.3 应用程序 7.4 小结</span><br><span class="line"></span><br><span class="line"> 第8章 载入器 8.1 Java的类载入器 8.2 Loader接口 8.3 Reloader接口 8.4 WebappLoader类 8.4.1 创建类载入器 8.4.2 设置仓库 8.4.3 设置类路径 8.4.4 设置访问权限 8.4.5 开启新线程执行类的重新载入 8.5 WebappClassLoader类 8.5.1 类缓存 8.5.2 载入类 8.5.3 应用程序 8.6 运行应用程序 8.7 小结</span><br><span class="line"></span><br><span class="line"> 第9章 Session管理 9.1 Session对象 9.1.1 Session接口 9.1.2 StandardSession类 9.1.3 StandardSessionFacade类 9.2 Manager 9.2.1 Manager接口 9.2.2 ManagerBase类 9.2.3 StandardManager类 9.2.4 PersistentManagerBase类 9.2.5 PersistentManager类 9.2.6 DistributedManager类 9.3 存储器 9.3.1 StoreBase类 9.3.2 FileStore类 9.3.3 JDBCStore类 9.4 应用程序 9.4.1 Bootstrap类 9.4.2 SimpleWrapperValve类 9.4.3 运行应用程序 9.5 小结</span><br><span class="line"></span><br><span class="line"> 第10章 安全性 10.1 领域 10.2 GenericPrincipal类 10.3 LoginConfig类 10.4 Authenticator接口 10.5 安装验证器阀 10.6 应用程序 10.6.1 ex10.pyrmont.core.SimpleContextConfig类 10.6.2 ex10.pyrmont.realm.SimpleRealm类 10.6.3 ex10.pyrmont.realm.SimpleUserDatabaseRealm 10.6.4 ex10.pyrmont.startup.Bootstrap1类 10.6.5 ex10.pyrmont.startup.Bootstrap2类 10.6.6 运行应用程序 10.7 小结</span><br><span class="line"></span><br><span class="line"> 第11章 StandardWrapper 11.1 方法调用序列 11.2 SingleThreadModel 11.3 StandardWrapper 11.3.1 分配servlet实例 11.3.2 载入servlet类 11.3.3 ServletConfig对象 11.3.4 servlet容器的父子关系 11.4 StandardWrapperFacade类 11.5 StandardWrapperValve类 11.6 FilterDef类 11.7 ApplicationFilterConfig类 11.8 ApplicationFilterChain类 11.9 应用程序 11.1 0小结</span><br><span class="line"></span><br><span class="line"> 第12章 StandardContext类 12.1 StandardContext的配置 12.1.1 StandardContext类的构造函数 12.1.2 启动StandardContext实例 12.1.3 invoke()方法 12.2 StandardContextMapper类 12.3 对重载的支持 12.4 backgroundProcess()方法 12.5 小结</span><br><span class="line"></span><br><span class="line"> 第13章 Host和Engine 13.1 Host接口 13.2 StandardHost类 13.3 StandardHostMapper类 13.4 StandardHostValve类 13.5 为什么必须要有一个Host容器 13.6 应用程序1 13.7 Engine接口 13.8 StandardEngine类 13.9 StandardEngineValve类 13.1 0应用程序2 13.1 1小结</span><br><span class="line"></span><br><span class="line"> 第14章 服务器组件和服务组件 14.1 服务器组件 14.2 StandardServer类 14.2.1 initialize()方法 14.2.2 start()方法 14.2.3 stop()方法 14.2.4 await()方法 14.3 Service接口 14.4 StandardService类 14.4.1 connector和container 14.4.2 与生命周期有关的方法 14.5 应用程序 14.5.1 Bootstrap类 14.5.2 Stopper类 14.5.3 运行应用程序 14.6 小结</span><br><span class="line"></span><br><span class="line"> 第15章 Digester库 15.1 Digester库 15.1.1 Digester类 15.1.2 Digester库示例1 15.1.3 Digester库示例2 15.1.4 Rule类 15.1.5 Digester库示例3：使用Rule Set 15.2 Context Config类 15.2.1 default Config()方法 15.2.2 application Config()方法 15.2.3 创建Web Digester 15.3 应用程序 15.4 小结</span><br><span class="line"></span><br><span class="line"> 第16章 关闭钩子 16.1 关闭钩子的例子 16.2 Tomcat中的关闭钩子 16.3 小结</span><br><span class="line"></span><br><span class="line"> 第17章 启动Tomcat 17.1 Catalina类 17.1.1 start()方法 17.1.2 stop()方法 17.1.3 启动Digester对象 17.1.4 关闭Digester对象 17.2 Bootstrap类 17.3 在Windows平台上运行Tomcat 17.3.1 如何编写批处理文件 17.3.2 catalina.bat批处理文件 17.3.3 在Windows平台上启动Tomcat 17.3.4 在Windows平台上关闭Tomcat 17.4 在Linux平台上运行Tomcat 17.4.1 如何编写UNIX&#x2F;Linux Shell脚本 17.4.2 catalina.sh脚本 17.4.3 在UNIX&#x2F;Linux平台上启动Tomcat 17.4.4 在UNIX&#x2F;Linux平台上关闭Tomcat 17.5 小结</span><br><span class="line"></span><br><span class="line"> 第18章 部署器 18.1 部署一个Web应用程序 18.1.1 部署一个描述符 18.1.2 部署一个WAR文件 18.1.3 部署一个目录 18.1.4 动态部署 18.2 Deploy接口 18.3 Standard Host Deployer类 18.3.1 安装一个描述符 18.3.2 安装一个WAR文件或目录 18.3.3 启动Context实例 18.3.4 停止一个Context实例 18.4 小结</span><br><span class="line"></span><br><span class="line"> 第19章 Manager应用程序的servlet类 19.1 使用Manager应用程序 19.2 Containerservlet接口 19.3 初始化Manager Servlet 19.4 列出已经部署的Web应用程序 19.5 启动Web应用程序 19.6 关闭Web应用程序 19.7 小结</span><br><span class="line"></span><br><span class="line"> 第20章 基于JMX的管理 20.1 JMX简介 20.2 JMXAPI 20.2.1 MBean Server类 20.2.2 ObjectName类 20.3 标准MBean 20.4 模型MBean 20.4.1 MBeanInfo接口与ModelM BeanInfo接口 20.4.2 Model MBean示例 20.5 Commons Modeler库 20.5.1 MBean描述符 20.5.2 mbean元素示例 20.5.3 自己编写一个模型MBean类 20.5.4 Registry类 20.5.5 Managed Bean 20.5.6 BaseModel MBean 20.5.7 使用Modeler库API 20.6 Catalian中的MBean 20.6.1 ClassName MBean类 20.6.2 StandardServer MBean类 20.6.3 MBeanFactory类 20.6.4 MBeanUtil 20.7 创建Catalina的MBean 20.8 应用程序 20.9 小结</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B006R3TUIC/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B006R3TUIC&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/518Ij54WcLL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程实战</title>
    <url>/2020/04/19/B0077K9XHW/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Java并发编程实战<br>作者信息： 作者: 盖茨 (Brian Goetz) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Java并发编程实战》第16届Jolt大奖提名图书，JavaOne大会最畅销图书，了解Java并发编程必读佳作。线程是Java平台的基础组成部分之一。随着多核处理器逐渐成为主流，如何高效地使用并发已成为构建高性能应用程序的重要因素。Java SE 5和Java 6在并发程序开发方面取得了巨大的进步，在其Java虚拟机中能支持一些高性能的并且具有高可伸缩性的并发类，此外还支持一组新的并发基础构建模块。在《Java并发编程实战》中，这些新功能的编写者们不仅介绍了它们的工作原理和使用方式，还介绍了隐藏在这些功能背后的研究背景与设计模式。然而，在开发、测试以及调试多线程的程序时仍然存在巨大的困难。开发人员很容易编写出一些看似能正常工作，但在一些情况下仍然会失败的程序（包括在正式发布的产品中，以及在高负载环境中）。《Java并发编程实战》不仅讲解了并发的理论基础，还介绍了各种实际的开发技术，这些知识对于构建可靠的、可伸缩的以及可维护的并发应用程序来说非常有用。《Java并发编程实战》并不仅是简单地罗列出各种并发API以及机制，而是详细地介绍了许多设计原则、设计模式以及思维模式，这些内容使得开发人员更容易构建出正确的并且高性能的并发程序。《Java并发编程实战》主要内容包括：并发性与线程安全性的基本概念，构建以及组合各种线程安全类的技术，使用java.util.concurrent包中的各种井发构建基础模块，性能优化中的注意事项，如何测试并发程序，以及一些高级主题，包括原子变量，无阻塞算法及JAVA内存模。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对本书的赞誉</span><br><span class="line">译者序</span><br><span class="line">前　言</span><br><span class="line">第1章　简介</span><br><span class="line">1.1　并发简史</span><br><span class="line">1.2　线程的优势</span><br><span class="line">1.2.1　发挥多处理器的强大能力</span><br><span class="line">1.2.2　建模的简单性</span><br><span class="line">1.2.3　异步事件的简化处理</span><br><span class="line">1.2.4　响应更灵敏的用户界面</span><br><span class="line">1.3　线程带来的风险</span><br><span class="line">1.3.1　安全性问题</span><br><span class="line">1.3.2　活跃性问题</span><br><span class="line">1.3.3　性能问题</span><br><span class="line">1.4　线程无处不在</span><br><span class="line">第一部分　基础知识 </span><br><span class="line"></span><br><span class="line"> 第2章　线程安全性 2.1　什么是线程安全性 2.2　原子性 2.2.1　竞态条件 2.2.2　示例:延迟初始化中的竞态条件 2.2.3　复合操作 2.3　加锁机制 2.3.1　内置锁 2.3.2　重入 2.4　用锁来保护状态 2.5　活跃性与性能</span><br><span class="line"></span><br><span class="line"> 第3章　对象的共享 3.1　可见性 3.1.1　失效数据 3.1.2　非原子的64位操作 3.1.3　加锁与可见性 3.1.4　Volatile变量 3.2　发布与逸出 3.3　线程封闭 3.3.1　Ad-hoc线程封闭 3.3.2　栈封闭 3.3.3　ThreadLocal类 3.4　不变性 3.4.1　Final域 3.4.2　示例:使用Volatile类型来发布不可变对象 3.5　安全发布 3.5.1　不正确的发布:正确的对象被破坏 3.5.2 　不可变对象与初始化安全性 3.5.3　安全发布的常用模式 3.5.4　事实不可变对象 3.5.5　可变对象 3.5.6　安全地共享对象</span><br><span class="line"></span><br><span class="line"> 第4章　对象的组合 4.1　设计线程安全的类 4.1.1　收集同步需求 4.1.2　依赖状态的操作 4.1.3　状态的所有权 4.2　实例封闭 4.2.1　Java监视器模式 4.2.2　示例:车辆追踪 4.3　线程安全性的委托 4.3.1　示例:基于委托的车辆追踪器 4.3.2　独立的状态变量 4.3.3　当委托失效时 4.3.4　发布底层的状态变量 4.3.5　示例:发布状态的车辆追踪器 4.4　在现有的线程安全类中添加功能 4.4.1　客户端加锁机制 4.4.2　组合 4.5　将同步策略文档化</span><br><span class="line"></span><br><span class="line"> 第5章　基础构建模块 5.1　同步容器类 5.1.1　同步容器类的问题 5.1.2　迭代器与Concurrent-Modification Exception 5.1.3　隐藏迭代器 5.2　并发容器 5.2.1　Concurrent Hash Map 5.2.2　额外的原子Map操作 5.2.3　Copy On Write Array List 5.3　阻塞队列和生产者-消费者模式 5.3.1　示例:桌面搜索 5.3.2　串行线程封闭 5.3.3　双端队列与工作密取 5.4　阻塞方法与中断方法 5.5　同步工具类 5.5.1　闭锁 5.5.2　Future Task 5.5.3　信号量 5.5.4　栅栏 5.6　构建高效且可伸缩的结果缓存 第二部分　结构化并发应用程序</span><br><span class="line"></span><br><span class="line"> 第6章　任务执行 6.1　在线程中执行任务 6.1.1　串行地执行任务 6.1.2　显式地为任务创建线程 6.1.3　无限制创建线程的不足 6.2　Executor框架 6.2.1　示例:基于Executor的Web服务器 6.2.2　执行策略 6.2.3　线程池 6.2.4　Executor的生命周期 6.2.5　延迟任务与周期任务 6.3　找出可利用的并行性 6.3.1　示例:串行的页面渲染器 6.3.2　携带结果的任务Callable与Future 6.3.3　示例:使用Future实现页面渲染器 6.3.4　在异构任务并行化中存在的局限 6.3.5　Completion Service:Executor与Blocking Queue 6.3.6　示例:使用Completion Service实现页面渲染器 6.3.7　为任务设置时限 6.3.8　示例:旅行预定门户网站</span><br><span class="line"></span><br><span class="line"> 第7章　取消与关闭 7.1　任务取消 7.1.1　中断 7.1.2　中断策略 7.1.3　响应中断 7.1.4　示例:计时运行 7.1.5　通过Future来实现取消 7.1.6　处理不可中断的阻塞 7.1.7　采用New Task For来封装非标准的取消 7.2　停止基于线程的服务 7.2.1　示例:日志服务 7.2.2　关闭Executor Service 7.2.3　“毒丸”对象 7.2.4　示例:只执行一次的服务 7.2.5　Shutdown Now的局限性 7.3　处理非正常的线程终止 7.4　JVM关闭 7.4.1　关闭钩子 7.4.2　守护线程 7.4.3　终结器</span><br><span class="line"></span><br><span class="line"> 第8章　线程池的使用 8.1　在任务与执行策略之间的隐性耦合 8.1.1　线程饥饿死锁 8.1.2　运行时间较长的任务 8.2　设置线程池的大小 8.3　配置Thread Pool Executor 8.3.1　线程的创建与销毁 8.3.2　管理队列任务 8.3.3　饱和策略 8.3.4　线程工厂 8.3.5　在调用构造函数后再定制Thread Pool Executor 8.4　扩展 Thread Pool Executor 8.5　递归算法的并行化</span><br><span class="line"></span><br><span class="line"> 第9章　图形用户界面应用程序 9.1　为什么GUI是单线程的 9.1.1　串行事件处理 9.1.2　Swing中的线程封闭机制 9.2　短时间的GUI任务 9.3　长时间的GUI任务 9.3.1　取消 9.3.2　进度标识和完成标识 9.3.3　Swing Worker 9.4　共享数据模型 9.4.1　线程安全的数据模型 9.4.2　分解数据模型 9.5　其他形式的单线程子系统 第三部分　活跃性、性能与测试</span><br><span class="line"></span><br><span class="line"> 第10章　避免活跃性危险 10.1　死锁 10.1.1　锁顺序死锁 10.1.2　动态的锁顺序死锁 10.1.3　在协作对象之间发生的死锁 10.1.4　开放调用 10.1.5　资源死锁 10.2　死锁的避免与诊断 10.2.1　支持定时的锁 10.2.2　通过线程转储信息来分析死锁 10.3　其他活跃性危险 10.3.1　饥饿 10.3.2　糟糕的响应性 10.3.3　活锁</span><br><span class="line"></span><br><span class="line"> 第11章　性能与可伸缩性 11.1　对性能的思考 11.1.1　性能与可伸缩性 11.1.2　评估各种性能权衡因素 11.2　Amdahl定律 11.2.1　示例:在各种框架中隐藏的串行部分 11.2.2　Amdahl定律的应用 11.3　线程引入的开销 11.3.1　上下文切换 11.3.2　内存同步 11.3.3　阻塞 11.4　减少锁的竞争 11.4.1　缩小锁的范围(“快进快出”) 11.4.2　减小锁的粒度 11.4.3　锁分段 11.4.4　避免热点域 11.4.5　一些替代独占锁的方法 11.4.6　监测CPU的利用率 11.4.7　向对象池说“不” 11.5　示例:比较Map的性能 11.6　减少上下文切换的开销</span><br><span class="line"></span><br><span class="line"> 第12章　并发程序的测试 12.1　正确性测试 12.1.1　基本的单元测试 12.1.2　对阻塞操作的测试 12.1.3　安全性测试 12.1.4　资源管理的测试 12.1.5　使用回调 12.1.6　产生更多的交替操作 12.2　性能测试 12.2.1　在PutTakeTest中增加计时功能 12.2.2　多种算法的比较 12.2.3　响应性衡量 12.3　避免性能测试的陷阱 12.3.1　垃圾回收 12.3.2　动态编译 12.3.3　对代码路径的不真实采样 12.3.4　不真实的竞争程度 12.3.5　无用代码的消除 12.4　其他的测试方法 12.4.1　代码审查 12.4.2　静态分析工具 12.4.3　面向方面的测试技术 12.4.4　分析与监测工具 第四部分　高级主题</span><br><span class="line"></span><br><span class="line"> 第13章　显式锁 13.1　Lock与 Reentrant Lock 13.1.1　轮询锁与定时锁 13.1.2　可中断的锁获取操作 13.1.3　非块结构的加锁 13.2　性能考虑因素 13.3　公平性 13.4　在synchronized和Reentrant Lock之间进行选择 13.5　读-写锁</span><br><span class="line"></span><br><span class="line"> 第14章　构建自定义的同步工具 14.1　状态依赖性的管理 14.1.1　示例:将前提条件的失败传递给调用者 14.1.2　示例:通过轮询与休眠来实现简单的阻塞 14.1.3　条件队列 14.2　使用条件队列 14.2.1　条件谓词 14.2.2　过早唤醒 14.2.3　丢失的信号 14.2.4　通知 14.2.5　示例:阀门类 14.2.6　子类的安全问题 14.2.7　封装条件队列 14.2.8　入口协议与出口协议 14.3　显式的Condition对象 14.4　Synchronizer剖析 14.5　Abstract Queued Synchronizer 14.6　java.util.concurrent同步器类中的 AQS 14.6.1　ReentrantLock 14.6.2　Semaphore与CountDownLatch 14.6.3　FutureTask 14.6.4　ReentrantReadWriteLock</span><br><span class="line"></span><br><span class="line"> 第15章　原子变量与非阻塞同步机制 15.1　锁的劣势 15.2　硬件对并发的支持 15.2.1　比较并交换 15.2.2　非阻塞的计数器 15.2.3　JVM对CAS的支持 15.3　原子变量类 15.3.1　原子变量是一种“更好的volatile” 15.3.2　性能比较:锁与原子变量 15.4　非阻塞算法 15.4.1　非阻塞的栈 15.4.2　非阻塞的链表 15.4.3　原子的域更新器 15.4.4　ABA问题</span><br><span class="line"></span><br><span class="line"> 第16章　Java内存模型 16.1　什么是内存模型,为什么需要它 16.1.1　平台的内存模型 16.1.2　重排序 16.1.3　Java内存模型简介 16.1.4　借助同步 16.2　发布 16.2.1　不安全的发布 16.2.2　安全的发布 16.2.3　安全初始化模式 16.2.4　双重检查加锁 16.3　初始化过程中的安全性 附录A　并发性标注 参考文献</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0077K9XHW/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0077K9XHW&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51PSBtsarqL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>王志刚作品系列 HTML5移动开发即学即用(双色)</title>
    <url>/2020/04/19/B007EWGFZG/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 王志刚作品系列 HTML5移动开发即学即用(双色)<br>作者信息： 作者: 王志刚 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《HTML5移动开发即学即用(双色)》编辑推荐：HTML5已经广泛应用于各智能移动终端设备上，而且绝大部分技术已经被各种最新版本的测览器所支持：•逐一剖析HTML5标准中包含的最新技术•详细介绍了HTML5新标准中提供的各种API•各种各样的应用实例，可以直接应用于自己的HTML5程序中。书中几乎涵盖了HTML5规范中涉及的所有技水（还在酝酿中的Indexed Database除外），是您能找到的真正的HTML5技术大全。包含作者精心编写的，运行于常用PC测览器以及智能手机上的应用实例，操作性与实用性俱佳，可以让您做到即学即用。讲解兼顾常用的PC浏览器以及当前流行的各种智能移动设备，作者丰富的移动开发经验会让你受益匪浅。双色印刷，既美观大方，又方便您的阅读。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 HTML5概要</span><br><span class="line">1.1 HTML5的发展历程</span><br><span class="line">1.1.1 HTML标准概要 </span><br><span class="line">1.1.2 HTML5标准的产生 </span><br><span class="line">1.2 HTML5与HTML4的区别</span><br><span class="line">1.3 HTML5中的API</span><br><span class="line">1.3.1 HTML5标准自带的API </span><br><span class="line">1.3.2 WHATWG创建的API</span><br><span class="line">1.3.3 HTML5相关API</span><br><span class="line">1.4 HTML5 API受支持现状</span><br><span class="line">1.5 HTML5编程的基础</span><br><span class="line">1.5.1 常用Web技术概述 </span><br><span class="line">1.5.2 HTML5程序的书写方式 </span><br><span class="line"></span><br><span class="line"> 第2章 Canvas 2.1 Canvas基础 2.1.1 Canvas的规范概要 2.1.2 Canvas的基本用法 2.1.3 第一个Canvas程序 2.1.4 路径 2.1.5 颜色定义 2.1.6 绘制方法介绍 2.2 绘制渐变效果 2.2.1 线性渐变与圆形渐变 2.2.2 线性渐变 2.2.3 圆形渐变 2.2.4 Context的属性 2.3 绘制图像 2.3.1 Canvas中的图像绘制 2.3.2 像素处理 2.4 绘制数据图表 2.4.1 绘制方格图 2.4.2 数据图表 2.5 旋转与变形 2.5.1 变形方法 2.5.2 移动与扩大&#x2F;缩小 2.5.3 变形的保存与恢复 2.5.4 旋转 2.5.5 变形矩阵 2.6 绘制文本 2.6.1 绘制文本概述 2.6.2 对齐方式 2.6.3 基准线 2.6.4 绘制竖线图表 2.7 Canvas实现动画效果 2.7.1 圆球跳动的动画 2.7.2 待机动画</span><br><span class="line"></span><br><span class="line"> 第3章 CSS3基础 3.1 CSS3基础应用 3.1.1 阴影 3.1.2 颜色的指定 3.1.3 变形 3.2 CSS3动画 3.2.1 CSS3的动画功能基础 3.2.2 动画的定义方法 3.3 特效 3.3.1 圆角 3.3.2 渐变效果 3.3.3 倒影 3.3.4 多栏目布局</span><br><span class="line"></span><br><span class="line"> 第4章 SVG 4.1 SVG基础 4.1.1 SVG规范概要 4.1.2 SVG的特征 4.1.3 SVG与Canvas比较 4.1.4 SVG与HTML 4.2 SVG的语法基础 4.2.1 文档类型与根元素 4.2.2 SVG的基本图形 4.2.3 SVG的修饰 4.3 SVG与JavaScript结合的实例</span><br><span class="line"></span><br><span class="line"> 第5章 Video ＆ Audio 5.1 ＜video＞ 与＜audio＞概要 5.1.1 视频与音频处理革命 5.1.2 ＜video＞ 与＜audio＞基础 5.2 Video和Audio的方法与属性 5.3 事件以及事件的发生顺序 5.3.1 事件概要 5.3.2 事件的发生顺序 5.4 使用Video实现实时字幕 5.4.1 HTML代码 5.4.2 脚本代码 5.5 视频与Canvas的组合技巧 5.5.1 在Canvas上绘制视频影像 5.5.2 对视频进行黑白影像变换 5.5.3 显示加工后的视频 5.6 创建简易音频播放器 5.6.1 播放音频 5.6.2 在脚本中控制音频 5.6.3 检查音频文件是否可播放 5.6.4 显示播放时间 5.7 制作乐器演奏程序 5.7.1 通过点击演奏 5.7.2 通过按键演奏 5.8 制作可变速视频播放器 5.8.1 HTML代码 5.8.2 实现各按钮功能 5.8.3 制作控制速度的滑块</span><br><span class="line"></span><br><span class="line"> 第6章 拖放 6.1 拖放基础 6.1.1 规范概要 6.1.2 File API 6.1.3 浏览器支持现状 6.2 网页控件对象的拖放 6.2.1 实例概要 6.2.2 详细代码 6.2.3 事件与dataTransfer 6.2.4 Internat Explorer中实现方法 6.3 桌面文件的拖放实例 6.3.1 实例概要 6.3.2 详细代码 6.3.3 拖放相关事件处理 6.3.4 拖入文件的API 6.3.5 读取文件内容的API 6.3.6 文件读取时的事件 6.3.7 文件导入的进度 6.3.8 文件数据的读取</span><br><span class="line"></span><br><span class="line"> 第7章 实现脱机Web应用程序 7.1 脱机Web应用程序概要 7.1.1 缓存清单 7.2 脱机Web应用程序实例 7.2.1 关于缓存更新 7.3 Cache-manifest的语法规则 7.3.1 FALLBACK段落 7.3.2 NETWORK段落 7.4 在JavaScript中对缓存进行控制 7.5 通过JavaScript创建缓存监视实例</span><br><span class="line"></span><br><span class="line"> 第8章 WebSocket 8.1 WebSocket概要 8.1.1 WebSocket协议 8.2 WebSocket简单实例 8.2.1 客户端代码 8.2.2 服务器端处理的实现 8.3 多个WebSocket连接的处理 8.4 子协议的构筑与应用</span><br><span class="line"></span><br><span class="line"> 第9章 Web Workers 9.1 Web Workers概要 9.2 Hell Web Workers实例 9.3 计算素数个数 9.4 importScripts的应用</span><br><span class="line"></span><br><span class="line"> 第10章 本地数据保存 10.1 Web Storage 10.1.1 Web Storage概要 10.1.2 localStorage应用 10.1.3 使用localStorage创建简易记事本 10.1.4 保存应用程序中的用户设置 10.2 Web SQL Database 10.2.1 Web SQL Database概要 10.2.2 Web SQL Database的基本使用方法 10.2.3 创建ToDo记事本</span><br><span class="line"></span><br><span class="line"> 第11章 Geolocation 11.1 Geolocation概要 11.1.1 如何获取定位信息 11.1.2 支持情况 11.2 HTML5中定义的Geolocation规范 11.2.1 Geolocation 11.2.2 get Current Position 11.2.3 Position对象 11.2.4 PostionError对象 11.2.5 watch Position 11.2.6 clearWatch 11.3 Google Maps API 11.3.1 显示地图的基本方法 11.3.2 显示标记 11.4 美食餐饮店记录程序</span><br><span class="line"></span><br><span class="line"> 附录A 实用开发环境的构筑 附录B JavaScript 的ECMA-262 3rd Edition 与5th Edition的区别 附录C CSS Transitions 与 Animations 索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B007EWGFZG/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B007EWGFZG&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51OSff7q6nL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 4实战 iPhone与iPad应用开发</title>
    <url>/2020/04/19/B007SS0XEK/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： iOS 4实战 iPhone与iPad应用开发<br>作者信息： 作者: Jocelyn harrington [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《iOS 4实战:iPhone与iPad应用开发》由人民邮电出版社出版。iOS 4的SDK新增了一些强大的功能，比如多任务、GCD、代码块和lAd。随着Xcode 4的发布，即使读者之前不熟悉Objective-C。如果使用它进行编程，也会比以往任何时候都容易。哈灵顿等编著的《iOS 4实战:iPhone与iPad应用开发》是针对Xcode 4编写的详尽实用指南，介绍了从设置开发环境到编写代码和开发完美iOS商业应用程序在内的整个过程。书中提供了大量示例，包括聊天客户端、视频游戏、交互性地图和后台播放音频。读者还将学习如何在现有的iOS 3应用程序中使用iOS 4新增的功能。通过《iOS 4实战:iPhone与iPad应用开发》的学习，读者将会成为一名技术全面的iOS 4开发人员。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 Ios 4简介</span><br><span class="line">1.1 人人为我，我为人人：IOS 平台</span><br><span class="line">1.2 理解iPhone 和iPad的触摸式交互</span><br><span class="line">1.3 为使用SDK做准备</span><br><span class="line">1.3.1安装 SDK</span><br><span class="line">1.3.2 剖析SDK</span><br><span class="line">1.4 IOS简介</span><br><span class="line">1.4.1 剖析Iso</span><br><span class="line">1.4.2 ios的对象层次结构</span><br><span class="line">1.4.3 窗口和视图</span><br><span class="line">1.5 IOS方法</span><br><span class="line">1.5.1创建对象</span><br><span class="line">1.5.2 内存管理</span><br><span class="line">1.5.3 事件响应</span><br><span class="line">1.5.4 生命周期管理</span><br><span class="line">1.6 如何将想法变成应用程序</span><br><span class="line">1.6.1 一览表</span><br><span class="line">1.6.2 您的应用程序属于哪一类</span><br><span class="line">1.6.3利用应用程序赚钱</span><br><span class="line">1.7 小结 </span><br><span class="line"></span><br><span class="line"> 第2章 学习Objective-C 2.1 Objective-C简介 2.2 消息 2.2.1 带参数的消息 2.2.2 嵌套的消息 2.2.3 消息接收方 2.3 类定义 2.3.1 接口 2.3.2 实现 2.3.3 对象实例化 2.4 属性 2.4.1 属性的用途 2.4.2 设置属性 2.4.3 使用存取器 2.4.4 句点语法 2.4.5 属性的复杂度 2.5 编译指令 2.6 类别和协议 2.6.1 类别 2.6.2 协议 2.7 Objective-C总结 2.8 小结</span><br><span class="line"></span><br><span class="line"> 第3章 使用Xcode 4 第4章 Xcode 与调试 第5章 基本视图控制器 第6章 监视事件和操作 第7章 高级视图控制器 第8章 数据：操作、首选项和文件 第9章 数据：高级技术 第10章 定位：加速计、位置和指南针 第11章 多煤体：图像和相机 第12章 多煤体：音频及其录制 第13章 图形：Quartz、Core Animation和OpenGL 第14章 Web视图和网络协议 第15章 使用Game Kit建立对等连接 第16章 在iPhone 和iPad上使用Event Kit 第17章 本地通知服务推送通知服务 第18章 框架Map Kit 第19章 使用Store Kit 实现程序内购买 第20章 利用iAd赚钱 第21章 多任务简介 第22章 深入探讨多任务 附录A Ios 类参考 附录B 外部资源和参考资料 附录C 发布应用程序 附录D 让应用程序能在iPad上运行</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B007SS0XEK/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B007SS0XEK&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/514VSyBEPfL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>O’Reilly精品图书系列 JavaScript权威指南(第6版)</title>
    <url>/2020/04/19/B007VISQ1Y/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： O’Reilly精品图书系列 JavaScript权威指南(第6版)<br>作者信息： 作者: 弗兰纳根(David Flanagan) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《O’Reilly精品图书系列:JavaScript权威指南(第6版)》编辑推荐：经典权威的JavaScript工具书，是程序员学习核心JavaScript语言和由Web浏览器定义的JavaScript API的指南和综合参考手册。第6版涵盖HTML5和ECMAScript5。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言1</span><br><span class="line">第1章JavaScript概述 5</span><br><span class="line">1.1JavaScript语言核心 8</span><br><span class="line">1.2客户端JavaScript 12</span><br><span class="line">第一部分JavaScript语言核心</span><br><span class="line">第2章词法结构 25</span><br><span class="line">2.1字符集 25</span><br><span class="line">2.2注释 27</span><br><span class="line">2.3直接量 27</span><br><span class="line">2.4标识符和保留字 28</span><br><span class="line">2.5可选的分号 30</span><br><span class="line">第3章类型、值和变量 32</span><br><span class="line">3.1数字 34</span><br><span class="line">3.2文本 38</span><br><span class="line">3.3布尔值 43</span><br><span class="line">3.4null和undefined 44</span><br><span class="line">3.5全局对象 45</span><br><span class="line">3.6包装对象 46</span><br><span class="line">3.7不可变的原始值和可变的对象引用 47</span><br><span class="line">3.8类型转换 48</span><br><span class="line">3.9变量声明 55</span><br><span class="line">3.10变量作用域 56</span><br><span class="line">第4章表达式和运算符 60</span><br><span class="line">4.1原始表达式 60</span><br><span class="line">4.2对象和数组的初始化表达式 61</span><br><span class="line">4.3函数定义表达式 62</span><br><span class="line">4.4属性访问表达式 63</span><br><span class="line">4.5调用表达式 64</span><br><span class="line">4.6对象创建表达式 64</span><br><span class="line">4.7运算符概述 65</span><br><span class="line">4.8算术表达式 69</span><br><span class="line">4.9关系表达式 74</span><br><span class="line">4.10逻辑表达式 79</span><br><span class="line">4.11赋值表达式 81</span><br><span class="line">4.12表达式计算 83</span><br><span class="line">4.13其他运算符 86</span><br><span class="line">第5章语句 91</span><br><span class="line">5.1表达式语句 92</span><br><span class="line">5.2复合语句和空语句 92</span><br><span class="line">5.3声明语句 94</span><br><span class="line">5.4条件语句 96</span><br><span class="line">5.5循环 101</span><br><span class="line">5.6跳转 106</span><br><span class="line">5.7其他语句类型 113</span><br><span class="line">5.8JavaScript语句小结 116</span><br><span class="line">第6章对象 118</span><br><span class="line">6.1创建对象 120</span><br><span class="line">6.2属性的查询和设置 123</span><br><span class="line">6.3删除属性 127</span><br><span class="line">6.4检测属性 128</span><br><span class="line">6.5枚举属性 130</span><br><span class="line">6.6属性getter和setter 132</span><br><span class="line">6.7属性的特性 134</span><br><span class="line">6.8对象的三个属性 138</span><br><span class="line">6.9序列化对象 141</span><br><span class="line">6.10对象方法 142</span><br><span class="line">第7章数组 144</span><br><span class="line">7.1创建数组 144</span><br><span class="line">7.2数组元素的读和写 145</span><br><span class="line">7.3稀疏数组 147</span><br><span class="line">7.4数组长度 148</span><br><span class="line">7.5数组元素的添加和删除 149</span><br><span class="line">7.6数组遍历 149</span><br><span class="line">7.7多维数组 151</span><br><span class="line">7.8数组方法152</span><br><span class="line">7.9ECMAScript5中的数组方法 156</span><br><span class="line">7.10数组类型 160</span><br><span class="line">7.11类数组对象 161</span><br><span class="line">7.12作为数组的字符串 163</span><br><span class="line">第8章函数 165</span><br><span class="line">8.1函数定义 166</span><br><span class="line">8.2函数调用 168</span><br><span class="line">8.3函数的实参和形参 173</span><br><span class="line">8.4作为值的函数 178</span><br><span class="line">8.5作为命名空间的函数 181</span><br><span class="line">8.6闭包 182</span><br><span class="line">8.7函数属性、方法和构造函数 188</span><br><span class="line">8.8函数式编程 194</span><br><span class="line">第9章类和模块 201</span><br><span class="line">9.1类和原型 202</span><br><span class="line">9.2类和构造函数 203</span><br><span class="line">9.3JavaScript中Java式的类继承 207</span><br><span class="line">9.4类的扩充 210</span><br><span class="line">9.5类和类型 212</span><br><span class="line">9.6JavaScript中的面向对象技术 217</span><br><span class="line">9.7子类 230</span><br><span class="line">9.8ECMAScript5中的类 239</span><br><span class="line">9.9模块 248</span><br><span class="line">第10章正则表达式的模式匹配 253</span><br><span class="line">10.1正则表达式的定义 253</span><br><span class="line">10.2用于模式匹配的String方法 261</span><br><span class="line">10.3RegExp对象 263</span><br><span class="line">第11章JavaScript的子集和扩展 267</span><br><span class="line">11.1JavaScript的子集 268</span><br><span class="line">11.2常量和局部变量 271</span><br><span class="line">11.3解构赋值 274</span><br><span class="line">11.4迭代 276</span><br><span class="line">11.5函数简写 285</span><br><span class="line">11.6多catch从句 285</span><br><span class="line">11.7E4X:ECMAScriptforXML 286</span><br><span class="line">第12章服务器端JavaScript 290</span><br><span class="line">12.1用Rhino脚本化Java 291</span><br><span class="line">12.2用Node实现异步I&#x2F;O 297</span><br><span class="line">第二部分客户端JavaScript</span><br><span class="line">第13章Web浏览器中的JavaScript 309</span><br><span class="line">13.1客户端JavaScript 309</span><br><span class="line">13.2在HTML里嵌入JavaScript 313</span><br><span class="line">13.3JavaScript程序的执行 319</span><br><span class="line">13.4兼容性和互用性 326</span><br><span class="line">13.5可访问性 333</span><br><span class="line">13.6安全性 334</span><br><span class="line">13.7客户端框架 339</span><br><span class="line">第14章Window对象 341</span><br><span class="line">14.1计时器 342</span><br><span class="line">14.2浏览器定位和导航 343</span><br><span class="line">14.3浏览历史 345</span><br><span class="line">14.4浏览器和屏幕信息 346</span><br><span class="line">14.5对话框 348</span><br><span class="line">14.6错误处理 351</span><br><span class="line">14.7作为Window对象属性的文档元素 351</span><br><span class="line">14.8多窗口和窗体 353</span><br><span class="line">第15章脚本化文档 361</span><br><span class="line">15.1DOM概览 362</span><br><span class="line">15.2选取文档元素 364</span><br><span class="line">15.3文档结构和遍历 371</span><br><span class="line">15.4属性 375</span><br><span class="line">15.5元素的内容 378</span><br><span class="line">15.6创建、插入和删除节点 382</span><br><span class="line">15.7例子：生成目录表 387</span><br><span class="line">15.8文档和元素的几何形状和滚动 389</span><br><span class="line">15.9HTML表单 396</span><br><span class="line">15.10其他文档特性 404</span><br><span class="line">第16章脚本化CSS 410</span><br><span class="line">16.1CSS概览 411</span><br><span class="line">16.2重要的CSS属性 416</span><br><span class="line">16.3脚本化内联样式 427</span><br><span class="line">16.4查询计算出的样式 431</span><br><span class="line">16.5脚本化CSS类 433</span><br><span class="line">16.6脚本化样式表 436</span><br><span class="line">第17章事件处理 440</span><br><span class="line">17.1事件类型 442</span><br><span class="line">17.2注册事件处理程序 451</span><br><span class="line">17.3事件处理程序的调用 454</span><br><span class="line">17.4文档加载事件 459</span><br><span class="line">17.5鼠标事件 461</span><br><span class="line">17.6鼠标滚轮事件 465</span><br><span class="line">17.7拖放事件 468</span><br><span class="line">17.8文本事件 475</span><br><span class="line">17.9键盘事件 478</span><br><span class="line">第18章脚本化HTTP 484</span><br><span class="line">18.1使用XMLHttpRequest 487</span><br><span class="line">18.2借助 </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   返回商品介绍页 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 了解我们 人才招聘 关于我们 新闻中心 合作信息 我要开店 亚马逊物流 加入联盟 合作伙伴 帮助和购物指南 付款与退款 汇款单招领 发货与配送 退货与换货 帮助 美国 加拿大 巴西 墨西哥 英国 法国 意大利 西班牙 德国 日本 印度 澳大利亚  亚马逊家族网站: Amazon Web Services Shopbop 使用条件 隐私声明 基于兴趣的广告  © 1999-2014 Amazon.com, Inc. or its affiliates 北京市公安局朝阳分局备案110105004167 | 增值电信业务经营许可证合字 B2-20090004 互联网药品信息服务资格证书 京-非经营性-2012-0005 | 出版物经营许可证新出发京批字第直0852号 网络文化经营许可证京网文[2012] 0405 -126号 | 营业执照： 110105001308484</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B007VISQ1Y/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B007VISQ1Y&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51QWrj6sodL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Node Web开发</title>
    <url>/2020/04/19/B007ZXYK38/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Node Web开发<br>作者信息： 作者: David Herron [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>1.作者权威。2.简明实用。3.剖析新的开发平台（Node）。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 Node入门</span><br><span class="line">1.1 Node能做什么</span><br><span class="line">1.2 为什么要使用Node</span><br><span class="line">1.2.1 架构问题：线程，还是异步事件驱动</span><br><span class="line">1.2.2 性能和利用率</span><br><span class="line">1.2.3 服务器利用率、成本和绿色Web托管服务</span><br><span class="line">1.3 Node、Node.js还是Node .JS</span><br><span class="line">1.4 小结</span><br><span class="line">第2章 安装并配置Node</span><br><span class="line">2.1 系统要求</span><br><span class="line">2.2 在符合POSIX标准的系统上安装</span><br><span class="line">2.3 在Mac OS X上安装开发者工具</span><br><span class="line">2.3.1 在home目录下安装</span><br><span class="line">2.3.2 在系统级目录下安装Node</span><br><span class="line">2.3.3 在Mac OS X上使用MacPorts安装</span><br><span class="line">2.3.4 在Mac OS X上使用homebrew安装</span><br><span class="line">2.3.5 在Linux上使用软件包管理系统安装</span><br><span class="line">2.3.6 同时安装并维护多个Node</span><br><span class="line">2.4 验证安装成功与否</span><br><span class="line">2.4.1 Node命令行工具</span><br><span class="line">2.4.2 用Node运行简单的脚本</span><br><span class="line">2.4.3 用Node启动服务器</span><br><span class="line">2.5 安装npm——Node包管理器</span><br><span class="line">2.6 系统启动时自动启动Node服务器</span><br><span class="line">2.7 小结</span><br><span class="line">第3章 Node模块</span><br><span class="line">3.1 什么是模块</span><br><span class="line">3.1.1 Node模块</span><br><span class="line">3.1.2 Node解析require（‘module&#39;）的方式</span><br><span class="line">3.2 Node包管理器</span><br><span class="line">3.2.1 npm包的格式</span><br><span class="line">3.2.2 查找npm包</span><br><span class="line">3.2.3 使用npm命令</span><br><span class="line">3.2.4 Node包版本的标识和范围</span><br><span class="line">3.2.5 CommonJS模块</span><br><span class="line">3.3 小结</span><br><span class="line">第4章 几种典型的简单应用</span><br><span class="line">4.1 Math Wizard</span><br><span class="line">4.2 不依赖框架的实现</span><br><span class="line">4.2.1 路由请求</span><br><span class="line">4.2.2 处理URL查询参数</span><br><span class="line">4.2.3 乘法运算</span><br><span class="line">4.2.4 其他数学函数的执行</span><br><span class="line">4.2.5 扩展Math Wizard</span><br><span class="line">4.2.6 长时间运行的运算（斐波那契数）</span><br><span class="line">4.2.7 还缺什么功能</span><br><span class="line">4.2.8 使用Connect框架实现Math Wizard</span><br><span class="line">4.2.9 安装和设置Connect</span><br><span class="line">4.2.10 使用Connect</span><br><span class="line">4.3 使用Express框架实现Math Wizard</span><br><span class="line">4.3.1 准备工作</span><br><span class="line">4.3.2 处理错误</span><br><span class="line">4.3.3 参数化的URL和数据服务</span><br><span class="line">4.4 小结</span><br><span class="line">第5章 简单的Web服务器、EventEmitter和HTTP客户端</span><br><span class="line">5.1 通过EventEmitter发送和接收事件</span><br><span class="line">5.2 HTTP Sniffer——监听HTTP会话</span><br><span class="line">5.3 基本的Web服务器</span><br><span class="line">5.4 MIME类型和MIME npm包</span><br><span class="line">5.5 处理cookie</span><br><span class="line">5.6 虚拟主机和请求路由</span><br><span class="line">5.7 发送HTTP客户端请求</span><br><span class="line">5.8 小结</span><br><span class="line">第6章 存取数据</span><br><span class="line">6.1 Node的数据存储引擎</span><br><span class="line">6.2 SQLite3——轻量级的进程内SQL引擎</span><br><span class="line">6.2.1 安装SQLite 3</span><br><span class="line">6.2.2 用SQLite3实现便签应用</span><br><span class="line">6.2.3 在Node中使用其他SQL数据库</span><br><span class="line">6.3 Mongoose</span><br><span class="line">6.3.1 安装Mongoose</span><br><span class="line">6.3.2 用Mongoose实现便签应用</span><br><span class="line">6.3.3 对MongoDB数据库的其他支持</span><br><span class="line">6.4 如何实现用户验证</span><br><span class="line">6.5 小结</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B007ZXYK38/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B007ZXYK38&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51lFofdabeL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出CoffeeScript</title>
    <url>/2020/04/19/B00812OXGQ/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 深入浅出CoffeeScript<br>作者信息： 作者: Trevor Burnham [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>CoffeeScript之父Jeremy Ashkenas作序推荐；</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章入门指南</span><br><span class="line">1.1安装CoffeeScript</span><br><span class="line">1.2 CoffeeScript编辑器</span><br><span class="line">1.3“邂逅”coffee</span><br><span class="line">1.3.1编译为JavaScript</span><br><span class="line">1.3.2 REPL</span><br><span class="line">1.4调试CoffeeScript</span><br><span class="line">1.5预备</span><br><span class="line">第2章函数、作用域和上下文</span><br><span class="line">2.1函数基础知识</span><br><span class="line">2.1.1访问arguments对象</span><br><span class="line">2.1.2条件表达式和异常</span><br><span class="line">2.2作用域：你在哪里看到它们</span><br><span class="line">2.3上下文</span><br><span class="line">2.4属性参数（@arg）</span><br><span class="line">2.5默认参数（arg&#x3D;）</span><br><span class="line">2.6参数列（…）</span><br><span class="line">2.7项目：5×5游戏输入分析器</span><br><span class="line">2.8做得好，年轻的学徒</span><br><span class="line">2.9练习</span><br><span class="line">第3章集合与迭代</span><br><span class="line">3.1作为哈希表的对象</span><br><span class="line">3.1.1 JavaScript基础知识：一节JavaScript补习课</span><br><span class="line">3.1.2精简的JSON</span><br><span class="line">3.1.3 同名键值对</span><br><span class="line">3.1.4吸收操作符：‘a？.b’</span><br><span class="line">3.2数组</span><br><span class="line">3.2.1 区间</span><br><span class="line">3.2.2切分和剪接</span><br><span class="line">3.3集合的迭代</span><br><span class="line">3.4条件迭代</span><br><span class="line">3.5列表解析</span><br><span class="line">3.6模式匹配（或解构赋值）</span><br><span class="line">3.7项目：5×5单人游戏</span><br><span class="line">3.8进阶</span><br><span class="line">3.9练习</span><br><span class="line">第4章模块与类</span><br><span class="line">4.1模块：解构程序</span><br><span class="line">4.2原型的威力</span><br><span class="line">4.3类：原型函数</span><br><span class="line">4.4使用extends来继承</span><br><span class="line">4.5项目：重构5×5游戏</span><br><span class="line">4.5.1 Dictionary类</span><br><span class="line">4.5.2 Grid类</span><br><span class="line">4.5.3 Ptayer类</span><br><span class="line">4.5.4 Console.Coffee接口</span><br><span class="line">4.6就如“一勺糖”</span><br><span class="line">4.7练习</span><br><span class="line">第5章jQuery Web交互开发</span><br><span class="line">5.1 jQuery之道</span><br><span class="line">5.2操作DOM</span><br><span class="line">5.3学会选择</span><br><span class="line">5.4响应事件</span><br><span class="line">5.5项目：基于浏览器的5×5游戏</span><br><span class="line">5.5.1 index.html</span><br><span class="line">5.5.2 style.CSS</span><br><span class="line">5.5.3 jq5×5.coffee</span><br><span class="line">5.6未来是jQuery化的</span><br><span class="line">5.7练习</span><br><span class="line">第6章Node.js服务器端程序</span><br><span class="line">6.1 什么是Node.js</span><br><span class="line">6.2使用exports和require构建模块化代码</span><br><span class="line">6.3异步思想</span><br><span class="line">6.4项目：多人5×5游戏</span><br><span class="line">6.4.1 5×5server.coffee</span><br><span class="line">6.4.2 5×5client coffee</span><br><span class="line">6.4.3都结束了</span><br><span class="line">6.5客户端、服务器端——有何不同</span><br><span class="line">6.6练习</span><br><span class="line">附录A练习答案</span><br><span class="line">附录B运行CoffeeScript的几种方法</span><br><span class="line">附录C JavaScript开发者备忘录</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00812OXGQ/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00812OXGQ&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41wf9WaiVDL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java 7 核心技术与最佳实践</title>
    <url>/2020/04/19/B00826MHMS/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 深入理解Java 7 核心技术与最佳实践<br>作者信息： 作者: 成富 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《深入理解Java 7:核心技术与最佳实践》是学习Java 7新功能和新特性以及深入理解Java核心技术的最佳选择之一。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">Java的挑战与展望</span><br><span class="line">第1章  Java 7语法新特性</span><br><span class="line">  1.1  Coin项目介绍</span><br><span class="line">  1.2  在switch语句中使用字符串</span><br><span class="line">    1.2.1  基本用法</span><br><span class="line">    1.2.2  实现原理</span><br><span class="line">    1.2.3  枚举类型</span><br><span class="line">  1.3  数值字面量的改进</span><br><span class="line">    1.3.1  二进制整数字面量</span><br><span class="line">    1.3.2  在数值字面量中使用下划线</span><br><span class="line">  1.4  优化的异常处理</span><br><span class="line">    1.4.1  异常的基础知识</span><br><span class="line">    1.4.2  创建自己的异常</span><br><span class="line">    1.4.3  处理异常</span><br><span class="line">    1.4.4  Java 7的异常处理新特性</span><br><span class="line">  1.5  try-with-resources语句</span><br><span class="line">  1.6  优化变长参数的方法调用</span><br><span class="line">  1.7  小结</span><br><span class="line">第2章  Java语言的动态性</span><br><span class="line">  2.1  脚本语言支持API</span><br><span class="line">    2.1.1  脚本引擎</span><br><span class="line">    2.1.2  语言绑定</span><br><span class="line">    2.1.3  脚本执行上下文</span><br><span class="line">    2.1.4  脚本的编译</span><br><span class="line">    2.1.5  方法调用</span><br><span class="line">    2.1.6  使用案例</span><br><span class="line">  2.2  反射API</span><br><span class="line">    2.2.1  获取构造方法</span><br><span class="line">    2.2.2  获取域</span><br><span class="line">    2.2.3  获取方法</span><br><span class="line">    2.2.4  操作数组</span><br><span class="line">    2.2.5  访问权限与异常处理</span><br><span class="line">  2.3  动态代理</span><br><span class="line">    2.3.1  基本使用方式</span><br><span class="line">    2.3.2  使用案例</span><br><span class="line">  2.4  动态语言支持</span><br><span class="line">    2.4.1  Java语言与Java虚拟机</span><br><span class="line">    2.4.2  方法句柄</span><br><span class="line">    2.4.3  invokedynamic才旨令</span><br><span class="line">  2.5  小结</span><br><span class="line">第3章  Java I&#x2F;O</span><br><span class="line">  3.1  流</span><br><span class="line">    3.1.1  基本输入流</span><br><span class="line">    3.1.2  基本输出流</span><br><span class="line">    3.1.3  输入流的复用</span><br><span class="line">    3.1.4  过滤输入输出流</span><br><span class="line">    3.1.5  其他输入输出流</span><br><span class="line">    3.1.6  字符流</span><br><span class="line">  3.2  缓冲区</span><br><span class="line">    3.2.1  基本用法</span><br><span class="line">    3.2.2  字节缓冲区</span><br><span class="line">  ……</span><br><span class="line">第4章  国际化与本地化</span><br><span class="line">第5章  图形用户界面</span><br><span class="line">第6章  Java 7其他重要更新</span><br><span class="line">第7章  Java虚拟机</span><br><span class="line">第8章  Java源代码和字节代码操作</span><br><span class="line">第9章  Java类加载器</span><br><span class="line">第10章  对象生命周期</span><br><span class="line">第11章  多线程与并发编程实践</span><br><span class="line">第12章  Java泛型</span><br><span class="line">第13章  Java安全</span><br><span class="line">第14章  超越Java 7</span><br><span class="line">附录A  OpenJDK</span><br><span class="line">附录B  Java简史</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00826MHMS/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00826MHMS&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51bwX5D6lrL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5从入门到精通</title>
    <url>/2020/04/19/B008JQME0Q/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： HTML5从入门到精通<br>作者信息： 作者: 万姆朋(Faithe Wempen) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《HTML5从入门到精通》采用经典的Step by Step风格，一次呈现一个知识点，一次提供一个步骤式的动手练习，旨在帮助新手快速入门。《HTML5从入门到精通》特别针对初学者，在每一章设计有相应的练习和重要知识点回顾，以帮助他们学以致用，迅速掌握HTML5。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第Ⅰ部分 初探HTML</span><br><span class="line">第1章 编辑和查看HTML文件</span><br><span class="line">在记事本中打开网页</span><br><span class="line">添加数据文件位置到“收藏”列表中</span><br><span class="line">用Windows资源管理器打开一个文件</span><br><span class="line">在Web浏览器中预览网页</span><br><span class="line">编辑、保存和查看更改</span><br><span class="line">要点</span><br><span class="line">第2章 设置文档结构</span><br><span class="line">指定文件类型</span><br><span class="line">创建HTML部分、头部和主体部分</span><br><span class="line">创建段落和换行符</span><br><span class="line">指定网页标题和元标记符</span><br><span class="line">发布文件到服务器</span><br><span class="line">要点</span><br><span class="line">第3章 用标记符来格式化文本</span><br><span class="line">创建标题</span><br><span class="line">应用粗体和斜体格式</span><br><span class="line">应用上标和下标格式</span><br><span class="line">使用固定宽度和预格式化文字</span><br><span class="line">格式化分段引文</span><br><span class="line">设置IE的查看方式</span><br><span class="line">要点</span><br><span class="line">第4章 使用列表和背景</span><br><span class="line">创建项目符号列表和编号列表</span><br><span class="line">嵌套列表</span><br><span class="line">更改项目符号或数字符号</span><br><span class="line">指定编号列表的起始数字</span><br><span class="line">创建定义列表</span><br><span class="line">插入特殊字符</span><br><span class="line">插入水平线</span><br><span class="line">选择背景颜色和前景颜色</span><br><span class="line">指定颜色</span><br><span class="line">背景颜色的应用</span><br><span class="line">前景颜色的应用</span><br><span class="line">指定背景图片文件</span><br><span class="line">要点</span><br><span class="line">第5章 创建超文本链接和锚</span><br><span class="line">超文本链接到一个网页</span><br><span class="line">使用部分路径和文件名</span><br><span class="line">使用相对路径和绝对路径</span><br><span class="line">设置目标窗口</span><br><span class="line">超文本链接到一个e—mail地址</span><br><span class="line">创建并超文本链接到锚</span><br><span class="line">超文本链接到其他的内容</span><br><span class="line">要点</span><br><span class="line">第Ⅱ部分 样式表和图片</span><br><span class="line">第6章 样式表基础</span><br><span class="line">理解样式</span><br><span class="line">创建样式规则</span><br><span class="line">嵌套式标记符的样式创建</span><br><span class="line">为应用样式而创建类和标识</span><br><span class="line">超文本链接的样式应用</span><br><span class="line">创建并链接外来样式表</span><br><span class="line">要点</span><br><span class="line">第7章 使用样式表改变文本格式</span><br><span class="line">指定字体系列</span><br><span class="line">设定字体的尺寸和颜色</span><br><span class="line">应用粗体和斜体</span><br><span class="line">应用删除线和下划线</span><br><span class="line">创建内联跨度</span><br><span class="line">调整字符间距</span><br><span class="line">要点</span><br><span class="line">第8章 使用样式表改变段落格式</span><br><span class="line">段落缩进</span><br><span class="line">添加段落边框</span><br><span class="line">设定边框样式</span><br><span class="line">设定边框间空</span><br><span class="line">指定边框宽度和颜色</span><br><span class="line">边框各边的格式化</span><br><span class="line">同时设定边框的四边</span><br><span class="line">设定段落的水平对齐</span><br><span class="line">在段落中设定行间距</span><br><span class="line">要点</span><br><span class="line">第9章 图像显示</span><br><span class="line">选择图像格式</span><br><span class="line">创建供网页使用的图像</span><br><span class="line">嵌入图像</span><br><span class="line">调整页面中的元素</span><br><span class="line">调控图像的尺寸和边距</span><br><span class="line">为图像添加超文本链接</span><br><span class="line">使用缩略图</span><br><span class="line">图像的替代文本</span><br><span class="line">向图表添加标题</span><br><span class="line">要点</span><br><span class="line">第Ⅲ部分 页面布局和导航</span><br><span class="line">第10章 创建导航机制</span><br><span class="line">设计网站结构</span><br><span class="line">创建文本导航栏</span><br><span class="line">创建图形导航栏</span><br><span class="line">创建图像映射</span><br><span class="line">自动跳转到另一个网址</span><br><span class="line">要点</span><br><span class="line">第11章 创建分区式版式</span><br><span class="line">理解HTML5语义标记符</span><br><span class="line">开始考虑区域</span><br><span class="line">创建区域</span><br><span class="line">创建HTML5语义布局</span><br><span class="line">区域定位</span><br><span class="line">将区域悬浮在右面或者左面</span><br><span class="line">在网页中定位区域</span><br><span class="line">为区域定义格式</span><br><span class="line">要点</span><br><span class="line">第12章 创建表格</span><br><span class="line">创建简单表格</span><br><span class="line">定义表格大小</span><br><span class="line">定义列的宽度</span><br><span class="line">合并表格的单元格</span><br><span class="line">为页面布局使用表格</span><br><span class="line">要点</span><br><span class="line">第13章 设置表格格式</span><br><span class="line">应用表格边框</span><br><span class="line">使用属性设置边框</span><br><span class="line">使用样式来显示边框</span><br><span class="line">设置背景填充和前景填充</span><br><span class="line">改变单元格填充、间距和对齐</span><br><span class="line">设置单元格填充</span><br><span class="line">设置单元格间距</span><br><span class="line">设置水平对齐和垂直对齐</span><br><span class="line">要点</span><br><span class="line">第14章 创建用户表单</span><br><span class="line">创建简单表单</span><br><span class="line">创建文本框</span><br><span class="line">电子邮件和网址的特殊输入类型</span><br><span class="line">创建文本区域</span><br><span class="line">创建提交按钮或清除按钮</span><br><span class="line">创建默认或占位符文本</span><br><span class="line">创建复选框和选择按钮</span><br><span class="line">创建列表</span><br><span class="line">HTML5中增加的输入类型</span><br><span class="line">理解CGI和其他高级工具</span><br><span class="line">要点</span><br><span class="line">第15章 嵌入音频和视频</span><br><span class="line">HTML5中音频和视频有哪些新变化</span><br><span class="line">HTML多媒体基础知识</span><br><span class="line">多媒体格式和容器</span><br><span class="line">编&#x2F;解码器：解码视频和音频</span><br><span class="line">选择哪种格式？</span><br><span class="line">文件大小和质量</span><br><span class="line">视频编码</span><br><span class="line">嵌入视频片段</span><br><span class="line">介绍 标记符 标记符：备用计划 将视频片段放到网页上 在网页上集成音频 通过 标记符播放音频 在老版本浏览器中播放音频 在网页中放入音频片段 要点 第16章 加入JavaScript和外部内容 画布介绍 简单介绍JavaScript 在网页中加入JavaScript 你的第一个JavaScript网页 用户的浏览器可能禁用JavaScript JavaScript事件和jQuery 获得iQuery工具 准备好使用jQuery 用iQuery选择元素 JavaScript的函数调用 用iQuery和JavaScript来响应事件 用iQuery和JavaScript来验证表单 使用HTML5 标记符 在网页中包括外部内容 要点 第Ⅳ部分 创建HTML代码的其他方式 第17章 HTML与Expression Web Expression Web的界面 创建网站和网页 使用CSS模板创建网页 嵌入图片 导入一个图像文件夹 在网页中放入图像 添加分区的背景文件 格式化字符文本 分区格式化 嵌入超文本链接 要点 附录A 可用性设计 附录B 可访问性设计 附录C HTML5中添加和去掉的标记符 词汇表   &lt;&#x2F;canvas&gt;&lt;&#x2F;audio&gt;&lt;&#x2F;embed&gt;&lt;&#x2F;video&gt;</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B008JQME0Q/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B008JQME0Q&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/512H9adYViL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS应用开发攻略</title>
    <url>/2020/04/19/B0096NOIEG/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： iOS应用开发攻略<br>作者信息： 作者: Matt Drance [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>亚马逊五星级评价针对问题提供解决方案代码丰富，实战性强助你iOS开发中攻城拔寨</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目　录 </span><br><span class="line"></span><br><span class="line"> 第1章　UI攻略　1 攻略1　添加基本的启动画面切换　1 攻略2　让启动画面的切换更有吸引力　7 攻略3　为定制的通知视图添加动画　12 攻略4　创建可重用的开关按钮　15 攻略5　形成带彩色纹理的圆角视图　19 攻略6　组装可重用的网页视图　22 攻略7　定制滑动条与进度条　25 攻略8　打造自己的手势识别器　27 攻略9　创建独立的警告视图　30 攻略10　表示带属性字符串的标签　35 攻略11　滚动无止境的专辑封面墙　39 攻略12　从专辑封面墙播放乐曲　42 攻略13　享受自动滚动的文本视图　47 攻略14　创建个性化的数值控件　50</span><br><span class="line"></span><br><span class="line"> 第2章　表格与滚动视图攻略　56 攻略15　简化表格单元格的生成　56 攻略16　在Nib中使用智能表格单元格　59 攻略17　定位单元格子视图　63 攻略18　组织复杂的表格视图　65 攻略19　生成双色表格视图　70 攻略20　给表格视图添加边框阴影　73 攻略21　在滚动视图中使用静态内容　79 攻略22　创建旋转翻页的滚动视图　82</span><br><span class="line"></span><br><span class="line"> 第3章　绘图攻略　86 攻略23　绘制梯度填充的贝塞尔轨迹　87 攻略24　创建多个动画的动态图像　91 攻略25　创建组合与变换的视图　93 攻略26　对梯度图层实施动画　95 攻略27　重新打造阴影　98 攻略28　显示带动画的视图　100 攻略29　构造简单的发射器　102 攻略30　翻卷页面显示新视图　106</span><br><span class="line"></span><br><span class="line"> 第4章　网络攻略　111 攻略31　改进网络活动指示器　111 攻略32　简化Web服务的连接　113 攻略33　格式化简单的HTTP POST　116 攻略34　通过HTTP上传文件　120</span><br><span class="line"></span><br><span class="line"> 第5章　运行库攻略　127 攻略35　使用新式的Objective-C类设计　127 攻略36　生成智能调试输出　130 攻略37　设计智能化的User Defaults访问　133 攻略38　扫描与遍历视图层次结构　136 攻略39　初始化基本数据模型　142 攻略40　在范畴中存储数据　146</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0096NOIEG/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0096NOIEG&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51SWmEcfZLL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>Java程序性能优化 让你的Java程序更快、更稳定</title>
    <url>/2020/04/19/B009GT0H4U/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Java程序性能优化 让你的Java程序更快、更稳定<br>作者信息： 作者: 葛一鸣 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Java程序性能优化:让你的Java程序更快、更稳定》适合所有Java程序员、软件设计师、架构师以及软件开发爱好者，对于有一定经验的Java工程师，《Java程序性能优化:让你的Java程序更快、更稳定》更能帮助突破技术瓶颈，深入Java内核开发！一个优秀的程序员，不仅要会编写程序，更要会编写高质量的程序感受Java开发中的大智慧，让你的Java程序更优美。专注于Java应用程序的优化方法、技巧和思想，深入剖析软件设计层面、代码层面、JVM虚拟机层面的优化方法。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章Java性能调优概述</span><br><span class="line">1.1性能概述</span><br><span class="line">1.1.1看懂程序的性能</span><br><span class="line">1.1.2性能的参考指标</span><br><span class="line">1.1.3木桶原理与性能瓶颈</span><br><span class="line">1.1.4Amdahl定律</span><br><span class="line">1.2性能调优的层次</span><br><span class="line">1.2.1设计调优</span><br><span class="line">1.2.2代码调优</span><br><span class="line">1.2.3JVM调优</span><br><span class="line">1.2.4数据库调优</span><br><span class="line">1.2.5操作系统调优</span><br><span class="line">1.3基本调优策略和手段</span><br><span class="line">1.3.1优化的一般步骤</span><br><span class="line">1.3.2系统优化注意事项</span><br><span class="line">1.4小结</span><br><span class="line">第2章设计优化</span><br><span class="line">2.1善用设计模式</span><br><span class="line">2.1.1单例模式</span><br><span class="line">2.1.2代理模式</span><br><span class="line">2.1.3享元模式</span><br><span class="line">2.1.4装饰者模式</span><br><span class="line">2.1.5观察者模式</span><br><span class="line">2.1.6Value Object模式</span><br><span class="line">2.1.7业务代理模式</span><br><span class="line">2.2常用优化组件和方法</span><br><span class="line">2.2.1缓冲（Buffer）</span><br><span class="line">2.2.2缓存（Cache）</span><br><span class="line">2.2.3对象复用——“池”</span><br><span class="line">2.2.4并行替代串行</span><br><span class="line">2.2.5负载均衡</span><br><span class="line">2.2.6时间换空间</span><br><span class="line">2.2.7空间换时间</span><br><span class="line">2.3小结</span><br><span class="line">第3章Java程序优化</span><br><span class="line">3.1字符串优化处理</span><br><span class="line">3.1.1String对象及其特点</span><br><span class="line">3.1.2subString（）方法的内存泄漏</span><br><span class="line">3.1.3字符串分割和查找</span><br><span class="line">3.1.4StringBuffer和StringBuilder</span><br><span class="line">3.2核心数据结构</span><br><span class="line">3.2.1List接口</span><br><span class="line">3.2.2Map接口</span><br><span class="line">3.2.3Set接口</span><br><span class="line">3.2.4优化集合访问代码</span><br><span class="line">3.2.5RandomAccess接口</span><br><span class="line">3.3使用NIO提升性能</span><br><span class="line">3.3.1NIO的Buffer类族和Channel</span><br><span class="line">3.3.2Buffer的基本原理</span><br><span class="line">3.3.3Buffer的相关操作</span><br><span class="line">3.3.4MappedByteBuffer性能评估</span><br><span class="line">3.3.5直接内存访问</span><br><span class="line">3.4引用类型</span><br><span class="line">3.4.1强引用</span><br><span class="line">3.4.2软引用</span><br><span class="line">3.4.3弱引用</span><br><span class="line">3.4.4虚引用</span><br><span class="line">3.4.5WeakHashMap类及其实现</span><br><span class="line">3.5有助于改善性能的技巧</span><br><span class="line">3.5.1慎用异常</span><br><span class="line">3.5.2使用局部变量</span><br><span class="line">3.5.3位运算代替乘除法</span><br><span class="line">3.5.4替换switch</span><br><span class="line">3.5.5一维数组代替二维数组</span><br><span class="line">3.5.6提取表达式</span><br><span class="line">3.5.7展开循环</span><br><span class="line">3.5.8布尔运算代替位运算</span><br><span class="line">3.5.9使用arrayCopy（）</span><br><span class="line">3.5.10使用Buffer进行I∕O操作</span><br><span class="line">3.5.11使用clone（）代替new</span><br><span class="line">3.5.12静态方法替代实例方法</span><br><span class="line">3.6小结</span><br><span class="line">第4章并行程序开发及优化</span><br><span class="line">4.1并行程序设计模式</span><br><span class="line">4.1.1Future模式</span><br><span class="line">4.1.2Master—Worker模式</span><br><span class="line">4.1.3Guarded Suspension模式</span><br><span class="line">4.1.4不变模式</span><br><span class="line">4.1.5生产者—消费者模式</span><br><span class="line">4.2JDK多任务执行框架</span><br><span class="line">4.2.1无限制线程的缺陷</span><br><span class="line">4.2.2简单的线程池实现</span><br><span class="line">4.2.3Executor框架</span><br><span class="line">4.2.4自定义线程池</span><br><span class="line">4.2.5优化线程池大小</span><br><span class="line">4.2.6扩展ThreadPoolExecutor</span><br><span class="line">4.3JDK并发数据结构</span><br><span class="line">4.3.1并发List</span><br><span class="line">4.3.2并发Set</span><br><span class="line">4.3.3并发Map</span><br><span class="line">4.3.4并发Queue</span><br><span class="line">4.3.5并发Deque</span><br><span class="line">4.4并发控制方法</span><br><span class="line">4.4.1Java内存模型与volatile</span><br><span class="line">4.4.2同步关键字synchronized</span><br><span class="line">4.4.3ReentrantLock重入锁</span><br><span class="line">4.4.4ReadWriteLock读写锁</span><br><span class="line">4.4.5Condition对象</span><br><span class="line">4.4.6Semaphore信号量</span><br><span class="line">4.4.7ThreadLocal线程局部变量</span><br><span class="line">4.5“锁”的性能和优化</span><br><span class="line">4.5.1线程的开销</span><br><span class="line">4.5.2避免死锁</span><br><span class="line">4.5.3减小锁持有时间</span><br><span class="line">4.5.4减小锁粒度</span><br><span class="line">4.5.5读写分离锁来替换独占锁</span><br><span class="line">4.5.6锁分离</span><br><span class="line">4.5.7重入锁（ReentrantLock）和内部锁（synchronized）</span><br><span class="line">4.5.8锁粗化（LockCoarsening）</span><br><span class="line">4.5.9自旋锁（Spinning Lock）</span><br><span class="line">4.5.10锁消除（Lock Elimination）</span><br><span class="line">4.5.11锁偏向（BiasedLock）</span><br><span class="line">4.6无锁的并行计算</span><br><span class="line">4.6.1非阻塞的同步∕无锁</span><br><span class="line">4.6.2原子操作</span><br><span class="line">4.6.3Amino框架介绍</span><br><span class="line">4.6.4Amino集合</span><br><span class="line">4.6.5Amino树</span><br><span class="line">4.6.6Amino图</span><br><span class="line">4.6.7Amino简单调度模式</span><br><span class="line">4.7协程</span><br><span class="line">4.7.1协程的概念</span><br><span class="line">4.7.2Kilim框架简介</span><br><span class="line">4.7.3Task及其状态</span><br><span class="line">4.7.4Fiber及其状态</span><br><span class="line">4.7.5Kilim开发环境配置</span><br><span class="line">4.7.6Kilim之Hello World</span><br><span class="line">4.7.7多任务通信</span><br><span class="line">4.7.8Kilim实例及性能评估</span><br><span class="line">4.8小结</span><br><span class="line">第5章JVM调优</span><br><span class="line">5.1 Java虚拟机内存模型</span><br><span class="line">5.1.1程序计数器</span><br><span class="line">5.1.2Java虚拟机栈</span><br><span class="line">5.1.3本地方法栈</span><br><span class="line">5.1.4Java堆</span><br><span class="line">5.1.5方法区</span><br><span class="line">5.2JVM内存分配参数</span><br><span class="line">5.2.1设置最大堆内存</span><br><span class="line">5.2.2设置最小堆内存</span><br><span class="line">5.2.3设置新生代</span><br><span class="line">5.2.4设置持久代</span><br><span class="line">5.2.5设置线程栈</span><br><span class="line">5.2.6堆的比例分配</span><br><span class="line">5.2.7堆分配参数总结</span><br><span class="line">5.3垃圾收集基础</span><br><span class="line">5.3.1垃圾收集的作用</span><br><span class="line">5.3.2垃圾回收算法与思想</span><br><span class="line">5.3.3垃圾收集器的类型</span><br><span class="line">5.3.4评价GC策略的指标</span><br><span class="line">5.3.5新生代串行收集器</span><br><span class="line">5.3.6老年代串行收集器</span><br><span class="line">5.3.7并行收集器</span><br><span class="line">5.3.8新生代并行回收（Parallel Scavenge）收集器</span><br><span class="line">5.3.9老年代并行回收收集器</span><br><span class="line">5.3.10CMS收集器</span><br><span class="line">5.3.11G1收集器（Garbage First）</span><br><span class="line">5.3.12Stop the World案例</span><br><span class="line">5.3.13收集器对系统性能的影响</span><br><span class="line">5.3.14GC相关参数总结</span><br><span class="line">5.4常用调优案例和方法</span><br><span class="line">5.4.1将新对象预留在新生代</span><br><span class="line">5.4.2大对象进入老年代</span><br><span class="line">5.4.3设置对象进入老年代的年龄</span><br><span class="line">5.4.4稳定与震荡的堆大小</span><br><span class="line">5.4.5吞吐量优先案例</span><br><span class="line">5.4.6使用大页案例</span><br><span class="line">5.4.7降低停顿案例</span><br><span class="line">5.5实用JVM参数</span><br><span class="line">5.5.1JIT编译参数</span><br><span class="line">5.5.2堆快照（堆Dump）</span><br><span class="line">5.5.3错误处理</span><br><span class="line">5.5.4取得GC信息</span><br><span class="line">5.5.5类和对象跟踪</span><br><span class="line">5.5.6控制GC</span><br><span class="line">5.5.7选择类校验器</span><br><span class="line">5.5.8Solaris下线程控制</span><br><span class="line">5.5.9使用大页</span><br><span class="line">5.5.10压缩指针</span><br><span class="line">5.6实战JVM调优</span><br><span class="line">5.6.1Tomcat简介与启动加速</span><br><span class="line">5.6.2Web应用程序介绍</span><br><span class="line">5.6.3JMeter介绍与使用</span><br><span class="line">5.6.4调优前Web应用运行状况</span><br><span class="line">5.6.5调优过程</span><br><span class="line">5.7总结</span><br><span class="line">……</span><br><span class="line">第6章Java性能调优工具</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B009GT0H4U/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B009GT0H4U&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51uVkTYhKTL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>编码 隐匿在计算机软硬件背后的语言</title>
    <url>/2020/04/19/B009RSXIB4/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 编码 隐匿在计算机软硬件背后的语言<br>作者信息： 作者: 查尔斯•佩措尔德 (Charles Petzold) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>不管你是计算机高手，还是对这个神奇的机器充满敬畏之心的菜鸟，都不妨翻阅《编码:隐匿在计算机软硬件背后的语言》一下，读一读大师的经典作品，必然会有收获。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1至亲密友</span><br><span class="line">2编码与组合</span><br><span class="line">3布莱叶盲文与二进制码</span><br><span class="line">4手电筒的剖析</span><br><span class="line">5绕过拐角的通信</span><br><span class="line">6电报机与继电器</span><br><span class="line">7我们的十个数字</span><br><span class="line">8十的替代品</span><br><span class="line">9二进制数</span><br><span class="line">10逻辑与开关</span><br><span class="line">11门</span><br><span class="line">12二进制加法器</span><br><span class="line">13如何实现减法</span><br><span class="line">14反馈与触发器</span><br><span class="line">15字节与十六进制</span><br><span class="line">16存储器组织</span><br><span class="line">17自动操作</span><br><span class="line">18从算盘到芯片</span><br><span class="line">19两种典型的微处理器</span><br><span class="line">20ASCII码和字符转换</span><br><span class="line">21总线</span><br><span class="line">22操作系统</span><br><span class="line">23定点数和浮点数</span><br><span class="line">24高级语言与低级语言</span><br><span class="line">25图形化革命</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B009RSXIB4/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B009RSXIB4&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41mBhBIxUSL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>it文化</tag>
      </tags>
  </entry>
  <entry>
    <title>别逗了,费曼先生</title>
    <url>/2020/04/19/B009QVEA8M/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 别逗了,费曼先生<br>作者信息： 作者: R•P•费曼 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《别逗了,费曼先生》是一本很棒的读物：挥霍无忌、惊世骇俗，却仍然温馨，很有人情味儿。R·P·费曼，他因盘子电动力学方面的研究荣获诺贝尔物理学奖。除了作为一个物理学家外，费曼在不同时期还曾是故事大王、艺术家、鼓手和密码破泽专家。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">导言</span><br><span class="line">第1部分从法洛克维到麻省理工学院</span><br><span class="line">他动动脑袋瓜子就能修好收音机！</span><br><span class="line">菜豆</span><br><span class="line">谁偷了门？</span><br><span class="line">拉丁语还是意大利语？</span><br><span class="line">总想逃避</span><br><span class="line">米特普拉斯特公司的首席化学家</span><br><span class="line">第2部分在普林斯顿大学的岁月</span><br><span class="line">“别逗了，费曼先生！”</span><br><span class="line">我——！</span><br><span class="line">猫地图？</span><br><span class="line">魔鬼头脑</span><br><span class="line">搅和油漆</span><br><span class="line">别具一格的工具箱</span><br><span class="line">测心术</span><br><span class="line">业余科学家</span><br><span class="line">第3部分费曼，炸弹和军队</span><br><span class="line">嘶嘶的信管</span><br><span class="line">考验猎犬</span><br><span class="line">从低处看洛斯阿拉莫斯</span><br><span class="line">撬锁贼碰到了撬锁贼</span><br><span class="line">山姆大叔不要你了！</span><br><span class="line">第4部分从康奈尔大学到加州工学院，接触巴西</span><br><span class="line">讲派头的教授</span><br><span class="line">有问题吗？</span><br><span class="line">我要我的一块钱！</span><br><span class="line">你就这样问她们？</span><br><span class="line">幸运数字</span><br><span class="line">又是这个美国人！</span><br><span class="line">什么话都会说</span><br><span class="line">照您吩咐的，老大！</span><br><span class="line">盛情难承</span><br><span class="line">第5部分一个物理学家的世界</span><br><span class="line">你解狄拉克方程吗？</span><br><span class="line">百分之七的答案</span><br><span class="line">十三次</span><br><span class="line">“鸡母牛，鸡母牛！”</span><br><span class="line">但那是艺术吗？</span><br><span class="line">电是火吗？</span><br><span class="line">书好书坏，看看封面</span><br><span class="line">诺贝尔的另一个错误</span><br><span class="line">把文化带给物理学家</span><br><span class="line">巴黎见分晓</span><br><span class="line">另类状态</span><br><span class="line">野狐禅科学</span><br><span class="line">索引</span><br><span class="line">译后记</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B009QVEA8M/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B009QVEA8M&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41XsxJMgiVL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>it文化</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵的秘密 他的生平、思想及论文解读</title>
    <url>/2020/04/19/B00AAQXKXS/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 图灵的秘密 他的生平、思想及论文解读<br>作者信息： 作者: Charles Petzold [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>佩措尔德编著的《图灵的秘密》涉及数学中几个大的研究领域，包括可计算性和数理逻辑。《图灵的秘密：他的生平、思想及论文解读》仅把与理解图灵论文最相关的那些主题和概念挑出来加以解释，省去了很多细节，因此《图灵的秘密：他的生平、思想及论文解读》从深度和严格性上都无法取代那些可计算性和逻辑方面的专业书籍。想深入研究这些领域的读者可以查阅参考文献。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分 基础</span><br><span class="line">第1章这个墓穴埋葬着丢番图</span><br><span class="line">第2章无理数和超越数</span><br><span class="line">第3章几个世纪以来的发展</span><br><span class="line">第二部分可计算数</span><br><span class="line">第4章图灵的学业</span><br><span class="line">第5章运作的机器</span><br><span class="line">第6章加与乘</span><br><span class="line">第7章子程序</span><br><span class="line">第8章万物皆数字</span><br><span class="line">第9章通用机</span><br><span class="line">第10章计算机与可计算性</span><br><span class="line">第11章机器与人</span><br><span class="line">第三部分判定性问题</span><br><span class="line">第12章逻辑与可计算性</span><br><span class="line">第13章可计算函数</span><br><span class="line">第14章主要证明</span><br><span class="line">第15章λ演算</span><br><span class="line">第16章对连续统的设想</span><br><span class="line">第四部分题外话</span><br><span class="line">第17章万物皆是图灵机？</span><br><span class="line">第18章长眠的丢番图</span><br><span class="line">参考文献</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00AAQXKXS/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00AAQXKXS&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51ZPJFdUkdL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>it文化</tag>
      </tags>
  </entry>
  <entry>
    <title>淘宝技术这十年</title>
    <url>/2020/04/19/B00CK2H13K/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 淘宝技术这十年<br>作者信息： 作者: 子柳 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《淘宝技术这十年》编辑推荐：淘宝技术大学校长解密淘宝十年，有熠熠生辉的技术变迁，有饱含智慧的产品演进，有叱咤风云的牛人生涯，有令人捧腹的圈内趣事。无论你是程序员、架构师、产品经理还是运维人员，甚至只要你身处IT圈，《淘宝技术这十年》都有无穷无尽的看点，让你大呼过瘾之余，深受启发，进而陷入沉思，不由开始细数自己所在公司的技术发展历程……</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第0章引言：光棍节的狂欢1</span><br><span class="line">第1章个人网站13</span><br><span class="line">LAMP架构的网站14</span><br><span class="line">武侠和倒立文化的起源20</span><br><span class="line">第2章个人网站的升级23</span><br><span class="line">数据库从mySQL到Oracle25</span><br><span class="line">支付手段的创新——支付宝28</span><br><span class="line">交流方式的创新——淘宝旺旺29</span><br><span class="line">第3章企业级Java网站33</span><br><span class="line">脱胎换骨的升级——更换开发语言34</span><br><span class="line">坚若磐石——围绕性能、容量和成本的进化41</span><br><span class="line">第4章创造技术33</span><br><span class="line">淘宝文件系统——TFS53</span><br><span class="line">淘宝KV缓存系统——Tair64</span><br><span class="line">第5章分布式电子商务操作系统77</span><br><span class="line">服务化78</span><br><span class="line">中间件88</span><br><span class="line">高性能服务框架HSF91</span><br><span class="line">消息中间件Notify95</span><br><span class="line">分布式数据访问层TDDL99</span><br><span class="line">Session框架107</span><br><span class="line">开放平台111</span><br><span class="line">第6章我在淘宝这八年129</span><br><span class="line">第7章牛P列传167</span><br><span class="line">正明——集团核心系统高级研究员168</span><br><span class="line">正祥——淘宝高级研究员，Ocean Base项目负责人180</span><br><span class="line">毕玄——集团核心系统资深技术专家191</span><br><span class="line">放翁——淘宝开放平台项目负责人198</span><br><span class="line">吴翰清——阿里云集团信息安全中心高级安全专家210</span><br><span class="line">云铮——数据平台与产品部资深技术专家218</span><br><span class="line">小马——淘宝UED前端通用平台高级技术专家225</span><br><span class="line">淘宝传奇工程师多隆的程序世界236</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00CK2H13K/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00CK2H13K&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41Hrr9YNS6L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>it文化</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring实战(第3版)</title>
    <url>/2020/04/19/B00CY6UD2I/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Spring实战(第3版)<br>作者信息： 作者: 沃尔斯 (Craig Walls) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Spring实战(第3版)》编辑推荐：In Action系列中最畅销的Spring图书，有近10万读者选择《Spring实战(第3版)》来学习Spring，也是国内读者最熟悉的Spring经典图书之一！Spring框架已经成为Java开发人员的必备知识，而且Spring 3引入了强大的新特性，例如SpEL、Spring表达式语言、IoC容器的新注解以及用户急需的对REST的支持。无论你是刚刚接触Spring还是被Spring 3.0的新特性所吸引，《Spring实战(第3版)》都是掌握Spring的最佳选择。《Spring实战(第3版)》继承了前两个畅销版本面向实战、实用的写作风格，介绍了Spring 3.0最重要的几个方面，包括REST、远程服务、消息、安全、MVC、Web Flow等。作者Craig Walls将读者真正需要的技术通过丰富且非常有趣的示例予以呈现，精彩纷呈，一定让你大呼过瘾。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分Spring的核心</span><br><span class="line">第1章Spring之旅2</span><br><span class="line">1.1简化Java开发3</span><br><span class="line">1.1.1激发POJO的潜能4</span><br><span class="line">1.1.2依赖注入5</span><br><span class="line">1.1.3应用切面9</span><br><span class="line">1.1.4使用模板消除样板式代码13</span><br><span class="line">1.2容纳你的Bean15</span><br><span class="line">1.2.1与应用上下文共事16</span><br><span class="line">1.2.2Bean的生命周期17</span><br><span class="line">1.3俯瞰Spring风景线19</span><br><span class="line">1.3.1Spring模块19</span><br><span class="line">1.3.2SpringPortfolio22</span><br><span class="line">1.4Spring新功能25</span><br><span class="line">1.4.1Spring2.5新特性26</span><br><span class="line">1.4.2Spring3.0新特性26</span><br><span class="line">1.4.3SpringPortfollo新特性27</span><br><span class="line">1.5小结28</span><br><span class="line">第2章装配Bean29</span><br><span class="line">2.1声明Bean30</span><br><span class="line">2.1.1创建Spring配置30</span><br><span class="line">2.1.2声明一个简单Bean31</span><br><span class="line">2.1.3通过构造器注入33</span><br><span class="line">2.1.4Bean的作用域37</span><br><span class="line">2.1.5初始化和销毁Bean38</span><br><span class="line">2.2注入Bean属性40</span><br><span class="line">2.2.1注入简单值41</span><br><span class="line">2.2.2引用其他Bean42</span><br><span class="line">2.2.3使用Spring的命名空间p装配属性45</span><br><span class="line">2.2.4装配集合46</span><br><span class="line">2.2.5装配空值50</span><br><span class="line">2.3使用表达式装配51</span><br><span class="line">2.3.1SpEL的基本原理51</span><br><span class="line">2.3.2在SpEL值上执行操作54</span><br><span class="line">2.3.3在SpEL中筛选集合58</span><br><span class="line">2.4小结62</span><br><span class="line">第3章最小化Spring XML配置63</span><br><span class="line">3.1自动装配Bean属性64</span><br><span class="line">3.1.14种类型的自动装配64</span><br><span class="line">3.1.2默认自动装配68</span><br><span class="line">3.1.3混合使用自动装配和显式装配68</span><br><span class="line">3.2使用注解装配69</span><br><span class="line">3.2.1使用@Autowired70</span><br><span class="line">3.2.2借助@Inject实现基于标准的自动装配74</span><br><span class="line">3.2.3在注解注入中使用表达式76</span><br><span class="line">3.3自动检测Bean77</span><br><span class="line">3.3.1为自动检测标注Bean78</span><br><span class="line">3.3.2过滤组件扫描79</span><br><span class="line">3.4使用Spring基于Java的配置80</span><br><span class="line">3.4.1创建基于Java的配置80</span><br><span class="line">3.4.2定义一个配置类81</span><br><span class="line">3.4.3声明一个简单的Bean81</span><br><span class="line">3.4.4使用Spring的基于Java的配置进行注入82</span><br><span class="line">3.5小结83</span><br><span class="line">第4章面向切面的Spring84</span><br><span class="line">4.1什么是面向切面编程85</span><br><span class="line">4.1.1定义AOP术语86</span><br><span class="line">4.1.2Spring对AOP的支持88</span><br><span class="line">4.2使用切点选择连接点90</span><br><span class="line">4.2.1编写切点91</span><br><span class="line">4.2.2使用Spring的bean（）指示器92</span><br><span class="line">4.3在XML中声明切面93</span><br><span class="line">4.3.1声明前置和后置通知94</span><br><span class="line">4.3.2声明环绕通知96</span><br><span class="line">4.3.3为通知传递参数98</span><br><span class="line">4.3.4通过切面引入新功能100</span><br><span class="line">4.4注解切面102</span><br><span class="line">4.4.1注解环绕通知104</span><br><span class="line">4.4.2传递参数给所标注的通知105</span><br><span class="line">4.4.3标注引入105</span><br><span class="line">4.5注入AspectJ切面107</span><br><span class="line">4.6小结109</span><br><span class="line">第二部分Spring应用程序的核心组件</span><br><span class="line">第5章征服数据库112</span><br><span class="line">5.1Spring的数据访问哲学113</span><br><span class="line">5.1.1了解Spring的数据访问异常体系114</span><br><span class="line">5.1.2数据访问模板化116</span><br><span class="line">5.1.3使用DAO支持类118</span><br><span class="line">5.2配置数据源119</span><br><span class="line">5.2.1使用JNDI数据源119</span><br><span class="line">5.2.2使用数据源连接池120</span><br><span class="line">5.2.3基于JDBC驱动的数据源121</span><br><span class="line">5.3在Spring中使用JDBC122</span><br><span class="line">5.3.1应对失控的JDBC代码122</span><br><span class="line">5.3.2使用JDBC模板125</span><br><span class="line">5.4在Spring中集成Hibernate130</span><br><span class="line">5.4.1Hibernate概览131</span><br><span class="line">5.4.2声明Hibernate的Session工厂132</span><br><span class="line">5.4.3构建不依赖于Spring的Hibernate代码134</span><br><span class="line">5.5Spring与Java持久化API136</span><br><span class="line">5.5.1配置实体管理器工厂136</span><br><span class="line">5.5.2编写基于JPA的DAO140</span><br><span class="line">5.6小结142</span><br><span class="line">第6章事务管理144</span><br><span class="line">6.1理解事务145</span><br><span class="line">6.1.1用4个词来表示事务146</span><br><span class="line">6.1.2理解Spring对事务管理的支持147</span><br><span class="line">6.2选择事务管理器147</span><br><span class="line">6.2.1JDBC事务149</span><br><span class="line">6.2.2Hibernate事务149</span><br><span class="line">6.2.3Java持久化API事务150</span><br><span class="line">6.2.4JTA（Java Transaction API）事务151</span><br><span class="line">6.3在Spring中的编码事务151</span><br><span class="line">6.4声明式事务153</span><br><span class="line">6.4.1定义事务属性154</span><br><span class="line">6.4.2在XML中定义事务157</span><br><span class="line">6.4.3定义注解驱动的事务159</span><br><span class="line">6.5小结160</span><br><span class="line">第7章使用Spring MVC构建Web应用程序162</span><br><span class="line">7.1Spring MVC起步163</span><br><span class="line">7.1.1跟踪Spring MVC的请求163</span><br><span class="line">7.1.2搭建Spring MVC165</span><br><span class="line">7.2编写基本的控制器166</span><br><span class="line">7.2.1配置注解驱动的SpringMVC167</span><br><span class="line">7.2.2定义首页的控制器168</span><br><span class="line">7.2.3解析视图171</span><br><span class="line">7.2.4定义首页的视图175</span><br><span class="line">7.2.5完成Spring应用上下文177</span><br><span class="line">7.3处理控制器的输入178</span><br><span class="line">7.3.1编写处理输入的控制器179</span><br><span class="line">7.3.2渲染视图181</span><br><span class="line">7.4处理表单183</span><br><span class="line">7.4.1展现注册表单183</span><br><span class="line">7.4.2处理表单输入185</span><br><span class="line">7.4.3校验输入187</span><br><span class="line">7.5处理文件上传191</span><br><span class="line">7.5.1在表单上添加文件上传域191</span><br><span class="line">7.5.2接收上传的文件192</span><br><span class="line">7.5.3配置Spring支持文件上传195</span><br><span class="line">7.6小结196</span><br><span class="line">第8章使用Spring Web Flow197</span><br><span class="line">8.1安装Spring Web Flow198</span><br><span class="line">8.1.1在Spring中使用Web Flow198</span><br><span class="line">8.2流程的组件201</span><br><span class="line">8.2.1状态201</span><br><span class="line">8.2.2转移204</span><br><span class="line">8.2.3流程数据205</span><br><span class="line">8.3组合起来：披萨流程207</span><br><span class="line">8.3.1定义基本流程207</span><br><span class="line">8.3.2收集顾客信息211</span><br><span class="line">8.3.3构建订单216</span><br><span class="line">8.3.4支付219</span><br><span class="line">8.4保护Web流程211</span><br><span class="line">8.5小结221</span><br><span class="line">第9章保护Spring应用223</span><br><span class="line">9.1Spring Security介绍224</span><br><span class="line">9.1.1Spring Security起步224</span><br><span class="line">9.1.2使用Spring Security配置命名空间225</span><br><span class="line">9.2保护Web请求226</span><br><span class="line">9.2.1代理Servlet过滤器226</span><br><span class="line">9.2.2配置最小化的Web安全性227</span><br><span class="line">9.2.3拦截请求231</span><br><span class="line">9.3保护视图级别的元素234</span><br><span class="line">9.3.1访问认证信息的细节234</span><br><span class="line">9.3.2根据权限渲染235</span><br><span class="line">9.4认证用户237</span><br><span class="line">9.4.1配置内存用户存储库238</span><br><span class="line">9.4.2基于数据库进行认证239</span><br><span class="line">9.4.3基于LDAP进行认证240</span><br><span class="line">9.4.4启用remember—me功能244</span><br><span class="line">9.5保护方法调用245</span><br><span class="line">9.5.1使用@Secured注解保护方法调用245</span><br><span class="line">9.5.2使用JSR—250的@Roles Allowed注解246</span><br><span class="line">9.5.3使用SpEL实现调用前后的安全性246</span><br><span class="line">9.5.4声明方法级别的安全性切点250</span><br><span class="line">9.6小结251</span><br><span class="line">第三部分Spring集成</span><br><span class="line">第10章使用远程服务254</span><br><span class="line">10.1Spring远程调用概览255</span><br><span class="line">10.2使用RMI257</span><br><span class="line">10.2.1发布一个RMI服务257</span><br><span class="line">10.2.2装配RMI服务260</span><br><span class="line">10.3使用Hessian和Burlap发布远程服务262</span><br><span class="line">10.3.1使用Hessian和Burlap发布Bean的功能263</span><br><span class="line">10.3.2访问Hessian&#x2F;Burlap服务266</span><br><span class="line">10.4使用Spring的HttpInvoker267</span><br><span class="line">10.4.1将把Bean发布为HTTP服务267</span><br><span class="line">10.4.2通过HTTP访问服务269</span><br><span class="line">10.5发布和使用Web服务270</span><br><span class="line">10.5.1创建JAX—WS端点271</span><br><span class="line">10.5.2在客户端代理JAX—WS服务275</span><br><span class="line">10.6小结276</span><br><span class="line">第11章为Spring添加REST功能277</span><br><span class="line">11.1了解REST278</span><br><span class="line">11.1.1REST的基本原理278</span><br><span class="line">11.1.2Spring是如何支持REST的279</span><br><span class="line">11.2编写面向资源的控制器279</span><br><span class="line">11.2.1剖析RESTless的控制器280</span><br><span class="line">11.2.2处理RESTfulURL281</span><br><span class="line">11.2.3执行REST动作284</span><br><span class="line">11.3表述资源287</span><br><span class="line">11.3.1协商资源表述287</span><br><span class="line">11.3.2使用HTTP信息转换器290</span><br><span class="line">11.4编写REST客户端293</span><br><span class="line">11.4.1了解RestTemplate的操作295</span><br><span class="line">11.4.2GET资源296</span><br><span class="line">11.4.3PUT资源298</span><br><span class="line">11.4.4DELETE资源300</span><br><span class="line">11.4.5POST资源数据301</span><br><span class="line">11.4.6交换资源303</span><br><span class="line">11.5提交RESTful表单305</span><br><span class="line">11.5.1在JSP中渲染隐藏的方法域306</span><br><span class="line">11.5.2发布真正的请求307</span><br><span class="line">11.6小结308</span><br><span class="line">第12章Spring消息310</span><br><span class="line">12.1JMS简介311</span><br><span class="line">12.1.1构建JMS312</span><br><span class="line">12.1.2评估JMS的优点314</span><br><span class="line">12.2在Spring中搭建消息代理316</span><br><span class="line">12.2.1创建连接工厂316</span><br><span class="line">12.2.2声明ActiveMQ消息目的地317</span><br><span class="line">12.3使用Spring的JMS模板318</span><br><span class="line">12.3.1处理失控的JMS代码318</span><br><span class="line">12.3.2使用JMS模板319</span><br><span class="line">12.4创建消息驱动的POJO324</span><br><span class="line">12.4.1创建消息监听器325</span><br><span class="line">12.4.2配置消息监听器326</span><br><span class="line">12.5使用基于消息的RPC327</span><br><span class="line">12.5.1使用Spring基于消息的RPC328</span><br><span class="line">12.5.2使用Lingo实现异步RPC330</span><br><span class="line">12.6小结332</span><br><span class="line">第13章使用JMX管理SpringBean333</span><br><span class="line">13.1将SpringBean导出为MBean334</span><br><span class="line">13.1.1通过名称发布方法337</span><br><span class="line">13.1.2使用接口定义MBean的操作和属性339</span><br><span class="line">13.1.3使用注解驱动的MBean340</span><br><span class="line">13.1.4处理MBean冲突342</span><br><span class="line">13.2远程MBean343</span><br><span class="line">13.2.1发布远程MBean343</span><br><span class="line">13.2.2访问远程MBean344</span><br><span class="line">13.2.3代理MBean346</span><br><span class="line">13.3处理通知347</span><br><span class="line">13.3.1监听通知348</span><br><span class="line">13.4小结349</span><br><span class="line">第14章其他Spring技巧350</span><br><span class="line">14.1外部化配置351</span><br><span class="line">14.1.1替换属性占位符351</span><br><span class="line">14.1.2重写属性354</span><br><span class="line">14.1.3加密外部属性355</span><br><span class="line">14.2装配JNDI对象357</span><br><span class="line">14.2.1JNDI的传统用法357</span><br><span class="line">14.2.2装配JNDI对象359</span><br><span class="line">14.2.3将EJB装配到Spring中362</span><br><span class="line">14.3发送邮件363</span><br><span class="line">14.3.1配置邮件发送器363</span><br><span class="line">14.3.2构建邮件365</span><br><span class="line">14.4调度和后台任务370</span><br><span class="line">14.4.1声明调度方法371</span><br><span class="line">14.4.2声明异步方法372</span><br><span class="line">14.5小结373</span><br><span class="line">14.6结束语374</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00CY6UD2I/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00CY6UD2I&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51J%2BCSGyQ%2BL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵程序设计丛书 代码的未来</title>
    <url>/2020/04/19/B00D1HUYVE/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 图灵程序设计丛书 代码的未来<br>作者信息： 作者: 松本行弘 (Yukihiro Matsumoto) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《代码的未来》编辑推荐：20年后、100年后的编程语言会是什么样？《代码的未来》中Ruby之父松本行弘剖析云计算、大数据时代下的技术：Lisp会是未来的发展趋势吗？ Go和Dart能取代C和JavaScript吗？关系型数据库已经走到穷途末路了吗？Go、VoltDB、node.js、CoffeeScript、Dart、MongoDB…… 云计算、大数据时代下谁主沉浮？作者在《代码的未来》中一一剖析。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一章 编程的时间和空间</span><br><span class="line">1.1 编程的本质 3</span><br><span class="line">编程的本质是思考 4</span><br><span class="line">创造世界的乐趣 4</span><br><span class="line">快速提高的性能改变了社会 5</span><br><span class="line">以不变应万变 8</span><br><span class="line">摩尔定律的局限 9</span><br><span class="line">社会变化与编程 10</span><br><span class="line">1.2 未来预测 13</span><br><span class="line">科学的未来预测 14</span><br><span class="line">IT未来预测 14</span><br><span class="line">极限未来预测 16</span><br><span class="line">从价格看未来 16</span><br><span class="line">从性能看未来 17</span><br><span class="line">从容量看未来 18</span><br><span class="line">从带宽看未来 19</span><br><span class="line">小结 20</span><br><span class="line">第二章 编程语言的过去、现在和未来</span><br><span class="line">2.1 编程语言的世界 23</span><br><span class="line">被历史埋没的先驱 25</span><br><span class="line">编程语言的历史 26</span><br><span class="line">编程语言的进化方向 30</span><br><span class="line">未来的编程语言 32</span><br><span class="line">20年后的编程语言 34</span><br><span class="line">学生们的想象 34</span><br><span class="line">2.2 DSL（特定领域语言） 36</span><br><span class="line">外部DSL 37</span><br><span class="line">内部DSL 38</span><br><span class="line">DSL的优势 39</span><br><span class="line">DSL的定义 39</span><br><span class="line">适合内部DSL的语言 40</span><br><span class="line">外部DSL实例 42</span><br><span class="line">DSL设计的构成要素 43</span><br><span class="line">Sinatra 46</span><br><span class="line">小结 47</span><br><span class="line">2.3 元编程 48</span><br><span class="line">Meta，Reflection 48</span><br><span class="line">类对象 51</span><br><span class="line">类的操作 52</span><br><span class="line">Lisp 53</span><br><span class="line">数据和程序 54</span><br><span class="line">Lisp程序 56</span><br><span class="line">宏 56</span><br><span class="line">宏的功与过 57</span><br><span class="line">元编程的可能性与危险性 59</span><br><span class="line">小结 60</span><br><span class="line">2.4 内存管理 61</span><br><span class="line">看似无限的内存 61</span><br><span class="line">GC的三种基本方式 62</span><br><span class="line">术语定义 62</span><br><span class="line">标记清除方式 63</span><br><span class="line">复制收集方式 64</span><br><span class="line">引用计数方式 65</span><br><span class="line">引用计数方式的缺点 65</span><br><span class="line">进一步改良的应用方式 66</span><br><span class="line">分代回收 66</span><br><span class="line">对来自老生代的引用进行记录 67</span><br><span class="line">增量回收 68</span><br><span class="line">并行回收 69</span><br><span class="line">GC大统一理论 69</span><br><span class="line">2.5 异常处理 71</span><br><span class="line">“一定没问题的” 71</span><br><span class="line">用特殊返回值表示错误 72</span><br><span class="line">容易忽略错误处理 72</span><br><span class="line">Ruby中的异常处理 73</span><br><span class="line">产生异常 74</span><br><span class="line">更高级的异常处理 75</span><br><span class="line">Ruby中的后处理保证 76</span><br><span class="line">其他语言中的异常处理 77</span><br><span class="line">Java的检查型异常 77</span><br><span class="line">Icon的异常和真假值 78</span><br><span class="line">Eiffel的DesignbyContract 80</span><br><span class="line">异常与错误值 80</span><br><span class="line">小结 81</span><br><span class="line">2.6 闭包 82</span><br><span class="line">函数对象 82</span><br><span class="line">高阶函数 83</span><br><span class="line">用函数参数提高通用性 84</span><br><span class="line">函数指针的局限 85</span><br><span class="line">作用域：变量可见范围 87</span><br><span class="line">生存周期：变量的存在范围 88</span><br><span class="line">闭包与面向对象 89</span><br><span class="line">Ruby的函数对象 89</span><br><span class="line">Ruby与JavaScript的区别 90</span><br><span class="line">Lisp—1与Lisp—2 91</span><br><span class="line">第三章 编程语言的新潮流</span><br><span class="line">3.1 语言的设计 97</span><br><span class="line">客户端与服务器端 97</span><br><span class="line">向服务器端华丽转身 98</span><br><span class="line">在服务器端获得成功的四大理由 99</span><br><span class="line">客户端的JavaScript 100</span><br><span class="line">性能显著提升 101</span><br><span class="line">服务器端的Ruby 102</span><br><span class="line">RubyonRails带来的飞跃 102</span><br><span class="line">服务器端的Go 103</span><br><span class="line">静态与动态 104</span><br><span class="line">动态运行模式 105</span><br><span class="line">何谓类型 105</span><br><span class="line">静态类型的优点 106</span><br><span class="line">动态类型的优点 106</span><br><span class="line">有鸭子样的就是鸭子 107</span><br><span class="line">StructuralSubtyping 108</span><br><span class="line">小结 108</span><br><span class="line">3.2 Go 109</span><br><span class="line">New（新的） 109</span><br><span class="line">Experimental（实验性的） 109</span><br><span class="line">Concurrent（并发的） 110</span><br><span class="line">Garbage—collected（带垃圾回收的） 110</span><br><span class="line">Systems（系统） 111</span><br><span class="line">Go的创造者们 111</span><br><span class="line">HelloWorld 112</span><br><span class="line">Go的控制结构 113</span><br><span class="line">类型声明 116</span><br><span class="line">无继承式面向对象 118</span><br><span class="line">多值与多重赋值 120</span><br><span class="line">并发编程 122</span><br><span class="line">小结 124</span><br><span class="line">3.3 Dart 126</span><br><span class="line">为什么要推出Dart？ 126</span><br><span class="line">Dart的设计目标 129</span><br><span class="line">代码示例 130</span><br><span class="line">Dart的特征 132</span><br><span class="line">基于类的对象系统 132</span><br><span class="line">非强制性静态类型 133</span><br><span class="line">Dart的未来 134</span><br><span class="line">3.4 CoffeeScript 135</span><br><span class="line">最普及的语言 135</span><br><span class="line">被误解最多的语言 135</span><br><span class="line">显著高速化的语言 136</span><br><span class="line">对JavaScript的不满 138</span><br><span class="line">CoffeeScript 138</span><br><span class="line">安装方法 139</span><br><span class="line">声明和作用域 139</span><br><span class="line">分号和代码块 141</span><br><span class="line">省略记法 142</span><br><span class="line">字符串 143</span><br><span class="line">数组和循环 143</span><br><span class="line">类 145</span><br><span class="line">小结 146</span><br><span class="line">3.5 Lua 148</span><br><span class="line">示例程序 149</span><br><span class="line">数据类型 149</span><br><span class="line">函数 150</span><br><span class="line">表 150</span><br><span class="line">元表 151</span><br><span class="line">方法调用的实现 153</span><br><span class="line">基于原型编程 155</span><br><span class="line">和Ruby的比较（语言篇） 157</span><br><span class="line">嵌入式语言Lua 157</span><br><span class="line">和Ruby的比较（实现篇） 158</span><br><span class="line">嵌入式Ruby 159</span><br><span class="line">第四章 云计算时代的编程</span><br><span class="line">4.1 可扩展性 163</span><br><span class="line">信息的尺度感 163</span><br><span class="line">大量数据的查找 164</span><br><span class="line">二分法查找 165</span><br><span class="line">散列表 167</span><br><span class="line">布隆过滤器 169</span><br><span class="line">一台计算机的极限 170</span><br><span class="line">DHT（分布式散列表） 171</span><br><span class="line">Roma 172</span><br><span class="line">MapReduce 173</span><br><span class="line">小结 174</span><br><span class="line">4.2 C10K问题 175</span><br><span class="line">何为C10K问题 175</span><br><span class="line">C10K问题所引发的“想当然” 177</span><br><span class="line">使用epoll功能 180</span><br><span class="line">使用libev框架 181</span><br><span class="line">使用EventMachine 183</span><br><span class="line">小结 185</span><br><span class="line">4.3 HashFold 186</span><br><span class="line">HashFold库的实现（Level1） 187</span><br><span class="line">运用多核的必要性 190</span><br><span class="line">目前的Ruby实现所存在的问题 191</span><br><span class="line">通过进程来实现HashFold（Level2） 191</span><br><span class="line">抖动 193</span><br><span class="line">运用进程池的HashFold（Level3） 194</span><br><span class="line">小结 197</span><br><span class="line">4.4 进程间通信 198</span><br><span class="line">进程与线程 198</span><br><span class="line">同一台计算机上的进程间通信 199</span><br><span class="line">TCP&#x2F;IP协议 201</span><br><span class="line">用C语言进行套接字编程 202</span><br><span class="line">用Ruby进行套接字编程 204</span><br><span class="line">Ruby的套接字功能 205</span><br><span class="line">用Ruby实现网络服务器 208</span><br><span class="line">小结 209</span><br><span class="line">4.5 Rack与Unicorn 210</span><br><span class="line">Rack中间件 211</span><br><span class="line">应用程序服务器的问题 212</span><br><span class="line">Unicorn的架构 215</span><br><span class="line">Unicorn的解决方案 215</span><br><span class="line">性能 219</span><br><span class="line">策略 220</span><br><span class="line">小结 221</span><br><span class="line">第五章 支撑大数据的数据存储技术</span><br><span class="line">5.1 键—值存储 225</span><br><span class="line">Hash类 225</span><br><span class="line">DBM类 226</span><br><span class="line">数据库的ACID特性 226</span><br><span class="line">CAP原理 227</span><br><span class="line">CAP解决方案——BASE 228</span><br><span class="line">不能舍弃可用性 229</span><br><span class="line">大规模环境下的键—值存储 230</span><br><span class="line">访问键—值存储 230</span><br><span class="line">键—值存储的节点处理 231</span><br><span class="line">存储器 232</span><br><span class="line">写入和读取 233</span><br><span class="line">节点追加 233</span><br><span class="line">故障应对 233</span><br><span class="line">终止处理 235</span><br><span class="line">其他机制 235</span><br><span class="line">性能与应用实例 236</span><br><span class="line">小结 236</span><br><span class="line">5.2 NoSQL 237</span><br><span class="line">RDB的极限 237</span><br><span class="line">NoSQL数据库的解决方案 238</span><br><span class="line">形形色色的NoSQL数据库 239</span><br><span class="line">面向文档数据库 240</span><br><span class="line">MongoDB的安装 241</span><br><span class="line">启动数据库服务器 243</span><br><span class="line">MongoDB的数据库结构 244</span><br><span class="line">数据的插入和查询 244</span><br><span class="line">用JavaScript进行查询 245</span><br><span class="line">高级查询 246</span><br><span class="line">数据的更新和删除 249</span><br><span class="line">乐观并发控制 250</span><br><span class="line">5.3 用Ruby来操作MongoDB 251</span><br><span class="line">使用Ruby驱动 251</span><br><span class="line">对数据库进行操作 253</span><br><span class="line">数据的插入 253</span><br><span class="line">数据的查询 253</span><br><span class="line">高级查询 254</span><br><span class="line">find方法的选项 256</span><br><span class="line">原子操作 257</span><br><span class="line">ActiveRecord 259</span><br><span class="line">ODMapper 260</span><br><span class="line">5.4 SQL数据库的反击 264</span><br><span class="line">“云”的定义 264</span><br><span class="line">SQL数据库的极限 264</span><br><span class="line">存储引擎Spider 265</span><br><span class="line">SQL数据库之父的反驳 265</span><br><span class="line">SQL数据库VoltDB 268</span><br><span class="line">VoltDB的架构 269</span><br><span class="line">VoltDB中的编程 270</span><br><span class="line">HelloVoltDB！ 271</span><br><span class="line">性能测试 273</span><br><span class="line">小结 275</span><br><span class="line">5.5 memcached和它的伙伴们 276</span><br><span class="line">用于高速访问的缓存 276</span><br><span class="line">memcached 277</span><br><span class="line">示例程序 278</span><br><span class="line">对memcached的不满 279</span><br><span class="line">memcached替代服务器 280</span><br><span class="line">另一种键—值存储Redis 282</span><br><span class="line">Redis的数据类型 284</span><br><span class="line">Redis的命令与示例 285</span><br><span class="line">小结 289</span><br><span class="line">第六章 多核时代的编程</span><br><span class="line">6.1 摩尔定律 293</span><br><span class="line">呈几何级数增长 293</span><br><span class="line">摩尔定律的内涵 294</span><br><span class="line">摩尔定律的结果 295</span><br><span class="line">摩尔定律所带来的可能性 296</span><br><span class="line">为了提高性能 297</span><br><span class="line">摩尔定律的极限 302</span><br><span class="line">超越极限 303</span><br><span class="line">不再有免费的午餐 304</span><br><span class="line">6.2 UNIX管道 305</span><br><span class="line">管道编程 306</span><br><span class="line">多核时代的管道 308</span><br><span class="line">xargs——另一种运用核心的方式 309</span><br><span class="line">注意瓶颈 311</span><br><span class="line">阿姆达尔定律 311</span><br><span class="line">多核编译 312</span><br><span class="line">ccache 313</span><br><span class="line">distcc 313</span><br><span class="line">编译性能测试 314</span><br><span class="line">小结 315</span><br><span class="line">6.3 非阻塞I&#x2F;O 316</span><br><span class="line">何为非阻塞I&#x2F;O 316</span><br><span class="line">使用read（2）的方法 317</span><br><span class="line">边沿触发与电平触发 319</span><br><span class="line">使用read（2）+select的方法 319</span><br><span class="line">使用read+O_NONBLOCK标志 321</span><br><span class="line">Ruby的非阻塞I&#x2F;O 322</span><br><span class="line">使用aio_read的方法 323</span><br><span class="line">6.4 node.js 330</span><br><span class="line">减负 330</span><br><span class="line">拖延 331</span><br><span class="line">委派 332</span><br><span class="line">非阻塞编程 333</span><br><span class="line">node.js框架 333</span><br><span class="line">事件驱动编程 334</span><br><span class="line">事件循环的利弊 335</span><br><span class="line">node.js编程 335</span><br><span class="line">node.js网络编程 337</span><br><span class="line">node.js回调风格 339</span><br><span class="line">node.js的优越性 340</span><br><span class="line">EventMachine与Rev 341</span><br><span class="line">6.5 ZeroMQ 342</span><br><span class="line">多CPU的必要性 342</span><br><span class="line">阿姆达尔定律 343</span><br><span class="line">多CPU的运用方法 343</span><br><span class="line">进程间通信 345</span><br><span class="line">管道 345</span><br><span class="line">SysVIPC 346</span><br><span class="line">套接字 347</span><br><span class="line">UNIX套接字 349</span><br><span class="line">ZeroMQ 349</span><br><span class="line">ZeroMQ的连接模型 350</span><br><span class="line">ZeroMQ的安装 352</span><br><span class="line">ZeroMQ示例程序 352</span><br><span class="line">小结 354</span><br><span class="line">版权声明 356</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00D1HUYVE/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00D1HUYVE&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51kDl298FvL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>it文化</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript设计模式</title>
    <url>/2020/04/19/B00D6MT3LG/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： JavaScript设计模式<br>作者信息： 作者: 奥斯马尼 (Addy Osmani) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>通过阅读奥斯马尼的《JavaScript设计模式》，你将学会如何把经典和现代设计模式应用到JavaScript语言中，来编写优美、结构化和可维护的代码。如果想让代码保持高效、更易于管理，并且能同步最新的最佳实践，那么本书正是为你打造的。    本书介绍了很多流行的设计模式，包括Module(模块)模式、Observer(观察者)模式、：Facade(外观)模式和Mediator(中介者)模式；帮助你从现代Web应用程序开发者的角度来了解MVC、MVP、MVVM等现代架构模式的实用性。本书将带领你了解现代模块格式、有效为代码定义名称空间的方法和其他重要主题。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 介绍 1</span><br><span class="line">第2章 什么是模式 3</span><br><span class="line">我们每天都在使用模式 4</span><br><span class="line">第3章 模式状态测试、Proto模式及三法则 6</span><br><span class="line">第4章 设计模式的结构 8</span><br><span class="line">第5章 编写设计模式 11</span><br><span class="line">第6章 反模式 13</span><br><span class="line">第7章 设计模式类别 15</span><br><span class="line">第8章 设计模式分类 17</span><br><span class="line">有关类（Class）的要点 17</span><br><span class="line">第9章JavaScript设计模式 20</span><br><span class="line">9.1Constructor（构造器）模式 21</span><br><span class="line">9.1.1对象创建 21</span><br><span class="line">9.1.2基本Constructor（构造器） 23</span><br><span class="line">9.1.3带原型的Constructor（构造器） 24</span><br><span class="line">9.2Module（模块）模式 25</span><br><span class="line">9.2.1对象字面量 25</span><br><span class="line">9.2.2Module（模块）模式 27</span><br><span class="line">9.2.3Module模式变化 31</span><br><span class="line">9.3RevealingModule（揭示模块）模式 36</span><br><span class="line">9.3.1优点 38</span><br><span class="line">9.3.2缺点 38</span><br><span class="line">9.4Singleton（单例）模式 38</span><br><span class="line">9.5Observer（观察者）模式 42</span><br><span class="line">9.5.1Observer（观察者）模式和Publish&#x2F;Subscribe（发布／订阅）模式的区别 47</span><br><span class="line">9.5.2优点 49</span><br><span class="line">9.5.3缺点 49</span><br><span class="line">9.5.4Publish&#x2F;Subscribe实现 49</span><br><span class="line">9.6Mediator（中介者）模式 59</span><br><span class="line">9.6.1基本实现 60</span><br><span class="line">9.6.2高级实现 61</span><br><span class="line">9.6.3示例 67</span><br><span class="line">9.6.4优点和缺点 68</span><br><span class="line">9.6.5中介者（Mediator）与观察者（Observer） 69</span><br><span class="line">9.6.6中介者（Mediator）与外观（Facade） 69</span><br><span class="line">9.7Prototype（原型）模式 70</span><br><span class="line">9.8Command（命令）模式 73</span><br><span class="line">9.9Facade（外观）模式 75</span><br><span class="line">有关抽象的要点 78</span><br><span class="line">9.10Factory（工厂）模式 78</span><br><span class="line">9.10.1何时使用Factory模式 81</span><br><span class="line">9.10.2何时不应使用Factory模式 81</span><br><span class="line">9.10.3AbstractFactory（抽象工厂） 81</span><br><span class="line">9.11Mixin模式 82</span><br><span class="line">9.11.1子类化 83</span><br><span class="line">9.11.2Mixin（混入） 84</span><br><span class="line">9.12Decorator（装饰者）模式 88</span><br><span class="line">9.12.1伪经典Decorator（装饰者） 91</span><br><span class="line">9.12.2使用jQuery的装饰者 96</span><br><span class="line">9.12.3优点和缺点 97</span><br><span class="line">9.13Flyweight（享元）模式 98</span><br><span class="line">9.13.1使用Flyweight模式 98</span><br><span class="line">9.13.2Flyweight和共享数据 99</span><br><span class="line">9.13.3实现经典Flyweight（享元） 99</span><br><span class="line">9.13.4转换代码以使用Flyweight（享元）模式 103</span><br><span class="line">9.13.5基本工厂 105</span><br><span class="line">9.13.6管理外部状态 106</span><br><span class="line">9.13.7Flyweight（享元）模式和DOM 107</span><br><span class="line">第10章 JavaScriptMV*模式 112</span><br><span class="line">10.1MVC 112</span><br><span class="line">Smalltalk—80MVC 113</span><br><span class="line">10.2为JavaScript开发人员提供的MVC 114</span><br><span class="line">10.2.1Model（模型） 114</span><br><span class="line">10.2.2View（视图） 116</span><br><span class="line">10.2.3Controller（控制器） 119</span><br><span class="line">10.2.4Spine.js与Backbone.js 120</span><br><span class="line">10.3MVC为我们提供了什么 122</span><br><span class="line">10.4JavaScript中的Smalltalk—80MVC 122</span><br><span class="line">10.4.1深入挖掘 123</span><br><span class="line">10.4.2总结 123</span><br><span class="line">10.5MVP 124</span><br><span class="line">10.5.1Model、View和Presenter 124</span><br><span class="line">10.5.2MVP或MVC？ 125</span><br><span class="line">10.5.3MVC、MVP和Backbone.js 126</span><br><span class="line">10.6MVVM 128</span><br><span class="line">10.6.1历史 129</span><br><span class="line">10.6.2Model 129</span><br><span class="line">10.6.3View 130</span><br><span class="line">10.6.4ViewModel 133</span><br><span class="line">10.6.5小结：View和ViewModel 135</span><br><span class="line">10.6.6小结：ViewModel和Model 135</span><br><span class="line">10.7利与弊 135</span><br><span class="line">10.7.1优点 135</span><br><span class="line">10.7.2缺点 136</span><br><span class="line">10.8使用更松散数据绑定的MVVM 136</span><br><span class="line">10.9MVC、MVP与MVVM 141</span><br><span class="line">10.10Backbone.js与KnockoutJS 142</span><br><span class="line">第11章模块化的JavaScript设计模式 144</span><br><span class="line">11.1脚本加载器要点 145</span><br><span class="line">11.2AMD 145</span><br><span class="line">11.2.1模块入门 146</span><br><span class="line">11.2.2使用Dojo的AMD模块 150</span><br><span class="line">11.2.3AMD模块设计模式（Dojo） 151</span><br><span class="line">11.2.4使用jQuery的AMD模块 152</span><br><span class="line">11.2.5AMD总结 155</span><br><span class="line">11.3CommonJS 155</span><br><span class="line">11.3.1入门指南 156</span><br><span class="line">11.3.2使用多个依赖 157</span><br><span class="line">11.3.3支持CommonJS的加载器和框架 158</span><br><span class="line">11.3.4CommonJS适用于浏览器吗？ 158</span><br><span class="line">11.3.5延伸阅读 159</span><br><span class="line">11.4AMD和CommonJS：互相竞争，标准同效 159</span><br><span class="line">UMD：用于插件的AMD和CommonJS兼容模块 160</span><br><span class="line">11.5ESHarmony 165</span><br><span class="line">11.5.1具有Imports和Exports的模块 166</span><br><span class="line">11.5.2从远程数据源加载的模块 167</span><br><span class="line">11.5.3模块加载器API 167</span><br><span class="line">11.5.4用于服务器的类CommonJS模块 168</span><br><span class="line">11.5.5具有构造函数、getter和setter的类 168</span><br><span class="line">11.5.6ESHarmony总结 169</span><br><span class="line">11.5.7延伸阅读 170</span><br><span class="line">11.6总结 170</span><br><span class="line">第12章jQuery中的设计模式 171</span><br><span class="line">12.1Composite（组合）模式 171</span><br><span class="line">12.2Adapter（适配器）模式 173</span><br><span class="line">12.3Facade（外观）模式 174</span><br><span class="line">12.4Observer（观察者）模式 177</span><br><span class="line">12.5Iterator（迭代器）模式 180</span><br><span class="line">12.6延迟初始化 181</span><br><span class="line">12.7Proxy（代理）模式 183</span><br><span class="line">12.8Builder（生成器）模式 184</span><br><span class="line">第13章jQuery插件设计模式 187</span><br><span class="line">13.1模式 188</span><br><span class="line">13.2LightweightStart模式 189</span><br><span class="line">延伸阅读 191</span><br><span class="line">13.3完整的WidgetFactory模式 191</span><br><span class="line">延伸阅读 194</span><br><span class="line">13.4嵌套命名空间插件模式 194</span><br><span class="line">延伸阅读 196</span><br><span class="line">13.5自定义事件插件模式（使用WidgetFactory） 196</span><br><span class="line">延伸阅读 198</span><br><span class="line">13.6使用DOM—to—ObjectBridge模式的原型继承 198</span><br><span class="line">延伸阅读 200</span><br><span class="line">13.7jQuery UI Widget Factory Bridge模式 200</span><br><span class="line">延伸阅读 203</span><br><span class="line">13.8使用WidgetFactory的jQuery Mobile Widget 203</span><br><span class="line">13.9RequireJS和jQuery UI Widget Factory 206</span><br><span class="line">13.9.1用法 208</span><br><span class="line">13.9.2延伸阅读 209</span><br><span class="line">13.10全局选项和单次调用可重写选项（最佳选项模式） 209</span><br><span class="line">延伸阅读 211</span><br><span class="line">13.11高可配和高可变的插件模式 211</span><br><span class="line">延伸阅读 213</span><br><span class="line">13.12是什么使插件超越模式 213</span><br><span class="line">13.12.1质量 214</span><br><span class="line">13.12.2代码风格 214</span><br><span class="line">13.12.3兼容性 214</span><br><span class="line">13.12.4可靠性 214</span><br><span class="line">13.12.5性能 214</span><br><span class="line">13.12.6文档 215</span><br><span class="line">13.12.7维护的可能性 215</span><br><span class="line">13.13总结 215</span><br><span class="line">13.14命名空间模式 215</span><br><span class="line">13.15命名空间基础 216</span><br><span class="line">13.15.1单一全局变量 216</span><br><span class="line">13.15.2命名空间前缀 217</span><br><span class="line">13.15.3对象字面量表示法 217</span><br><span class="line">13.15.4嵌套命名空间 221</span><br><span class="line">13.15.5立即调用的函数表达式（IIFE） 222</span><br><span class="line">13.15.6命名空间注入 224</span><br><span class="line">13.16高级命名空间模式 226</span><br><span class="line">13.16.1自动嵌套的命名空间 227</span><br><span class="line">13.16.2依赖声明模式 229</span><br><span class="line">13.16.3深度对象扩展 229</span><br><span class="line">13.16.4推荐 232</span><br><span class="line">第14章 总结 233</span><br><span class="line">附录 参考文献 235</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00D6MT3LG/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00D6MT3LG&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51B7jy4UMOL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java虚拟机 JVM高级特性与最佳实践(第2版)</title>
    <url>/2020/04/19/B00D2ID4PK/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 深入理解Java虚拟机 JVM高级特性与最佳实践(第2版)<br>作者信息： 作者: 周志明 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)》编辑推荐：超级畅销书全新升级，第1版两年内印刷近10次，Java图书领域公认的经典著作，繁体版台湾发行。基于最新JDK1.7，围绕内存管理、执行子系统、程序编译与优化、高效并发等核心主题对JVM进行全面而深入的分析，深刻揭示JVM的工作原理。以实践为导向，通过大量与实际生产环境相结合的案例展示了解决各种常见JVM问题的技巧和最佳实践。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">第一部分走近Java</span><br><span class="line">第1章走近Java2</span><br><span class="line">1.1概述2</span><br><span class="line">1.2Java技术体系3</span><br><span class="line">1.3Java发展史5</span><br><span class="line">1.4Java虚拟机发展史9</span><br><span class="line">1.4.1SunClassicExactVM9</span><br><span class="line">1.4.2SunHotSpotVM11</span><br><span class="line">1.4.3SunMobile—EmbeddedVMMeta—CircularVM12</span><br><span class="line">1.4.4BEAJRockitIBMJ9VM13</span><br><span class="line">1.4.5AzulVMBEALiquidVM14</span><br><span class="line">1.4.6ApacheHarmonyGoogleAndroidDalvikVM14</span><br><span class="line">1.4.7MicrosoftJVM及其他15</span><br><span class="line">1.5展望Java技术的未来16</span><br><span class="line">1.5.1模块化17</span><br><span class="line">1.5.2混合语言17</span><br><span class="line">1.5.3多核并行19</span><br><span class="line">1.5.4进一步丰富语法20</span><br><span class="line">1.5.564位虚拟机21</span><br><span class="line">1.6实战：自己编译JDK22</span><br><span class="line">1.6.1获取JDK源码22</span><br><span class="line">1.6.2系统需求24</span><br><span class="line">1.6.3构建编译环境25</span><br><span class="line">1.6.4进行编译26</span><br><span class="line">1.6.5在IDE工具中进行源码调试31</span><br><span class="line">1.7本章小结35</span><br><span class="line">第二部分自动内存管理机制</span><br><span class="line">第2章Java内存区域与内存溢出异常38</span><br><span class="line">2.1概述38</span><br><span class="line">2.2运行时数据区域38</span><br><span class="line">2.2.1程序计数器39</span><br><span class="line">2.2.2Java虚拟机栈39</span><br><span class="line">2.2.3本地方法栈40</span><br><span class="line">2.2.4Java堆41</span><br><span class="line">2.2.5方法区41</span><br><span class="line">2.2.6运行时常量池42</span><br><span class="line">2.2.7直接内存43</span><br><span class="line">2.3HotSpot虚拟机对象探秘43</span><br><span class="line">2.3.1对象的创建44</span><br><span class="line">2.3.2对象的内存布局47</span><br><span class="line">2.3.3对象的访问定位48</span><br><span class="line">2.4实战：OutOfMemoryError异常50</span><br><span class="line">2.4.1Java堆溢出51</span><br><span class="line">2.4.2虚拟机栈和本地方法栈溢出53</span><br><span class="line">2.4.3方法区和运行时常量池溢出56</span><br><span class="line">2.4.4本机直接内存溢出59</span><br><span class="line">2.5本章小结60</span><br><span class="line">第3章垃圾收集器与内存分配策略61</span><br><span class="line">3.1概述61</span><br><span class="line">3.2对象已死吗62</span><br><span class="line">3.2.1引用计数算法62</span><br><span class="line">3.2.2可达性分析算法64</span><br><span class="line">3.2.3再谈引用65</span><br><span class="line">3.2.4生存还是死亡66</span><br><span class="line">3.2.5回收方法区68</span><br><span class="line">3.3垃圾收集算法69</span><br><span class="line">3.3.1标记—清除算法69</span><br><span class="line">3.3.2复制算法70</span><br><span class="line">3.3.3标记—整理算法71</span><br><span class="line">3.3.4分代收集算法72</span><br><span class="line">3.4HotSpot的算法实现72</span><br><span class="line">3.4.1枚举根节点72</span><br><span class="line">3.4.2安全点73</span><br><span class="line">3.4.3安全区域74</span><br><span class="line">3.5垃圾收集器75</span><br><span class="line">3.5.1Serial收集器76</span><br><span class="line">3.5.2ParNew收集器77</span><br><span class="line">3.5.3ParallelScavenge收集器79</span><br><span class="line">3.5.4SerialOld收集器80</span><br><span class="line">3.5.5ParallelOld收集器80</span><br><span class="line">3.5.6CMS收集器81</span><br><span class="line">3.5.7G1收集器84</span><br><span class="line">3.5.8理解GC日志89</span><br><span class="line">3.5.9垃圾收集器参数总结90</span><br><span class="line">3.6内存分配与回收策略91</span><br><span class="line">3.6.1对象优先在Eden分配91</span><br><span class="line">3.6.2大对象直接进入老年代93</span><br><span class="line">3.6.3长期存活的对象将进入老年代95</span><br><span class="line">3.6.4动态对象年龄判定97</span><br><span class="line">3.6.5空间分配担保98</span><br><span class="line">3.7本章小结100</span><br><span class="line">第4章虚拟机性能监控与故障处理工具101</span><br><span class="line">4.1概述101</span><br><span class="line">4.2JDK的命令行工具101</span><br><span class="line">4.2.1jps：虚拟机进程状况工具104</span><br><span class="line">4.2.2jstat：虚拟机统计信息监视工具105</span><br><span class="line">4.2.3jinfo：Java配置信息工具106</span><br><span class="line">4.2.4jmap：Java内存映像工具107</span><br><span class="line">4.2.5jhat：虚拟机堆转储快照分析工具108</span><br><span class="line">4.2.6jstack：Java堆栈跟踪工具109</span><br><span class="line">4.2.7HSDIS：JIT生成代码反汇编111</span><br><span class="line">4.3JDK的可视化工具114</span><br><span class="line">4.3.1JConsole：Java监视与管理控制台115</span><br><span class="line">4.3.2VisualVM：多合一故障处理工具122</span><br><span class="line">4.4本章小结131</span><br><span class="line">第5章调优案例分析与实战132</span><br><span class="line">5.1概述132</span><br><span class="line">5.2案例分析132</span><br><span class="line">5.2.1高性能硬件上的程序部署策略132</span><br><span class="line">5.2.2集群间同步导致的内存溢出135</span><br><span class="line">5.2.3堆外内存导致的溢出错误136</span><br><span class="line">5.2.4外部命令导致系统缓慢137</span><br><span class="line">5.2.5服务器JVM进程崩溃138</span><br><span class="line">5.2.6不恰当数据结构导致内存占用过大139</span><br><span class="line">5.2.7由Windows虚拟内存导致的长时间停顿141</span><br><span class="line">5.3实战：Eclipse运行速度调优142</span><br><span class="line">5.3.1调优前的程序运行状态142</span><br><span class="line">5.3.2升级JDK1.6的性能变化及兼容问题145</span><br><span class="line">5.3.3编译时间和类加载时间的优化150</span><br><span class="line">5.3.4调整内存设置控制垃圾收集频率153</span><br><span class="line">5.3.5选择收集器降低延迟157</span><br><span class="line">5.4本章小结160</span><br><span class="line">第三部分虚拟机执行子系统</span><br><span class="line">第6章类文件结构162</span><br><span class="line">6.1概述162</span><br><span class="line">6.2无关性的基石162</span><br><span class="line">6.3Class类文件的结构164</span><br><span class="line">6.3.1魔数与Class文件的版本166</span><br><span class="line">6.3.2常量池167</span><br><span class="line">6.3.3访问标志173</span><br><span class="line">6.3.4类索引、父类索引与接口索引集合174</span><br><span class="line">6.3.5字段表集合175</span><br><span class="line">6.3.6方法表集合178</span><br><span class="line">6.3.7属性表集合180</span><br><span class="line">6.4字节码指令简介196</span><br><span class="line">6.4.1字节码与数据类型197</span><br><span class="line">6.4.2加载和存储指令199</span><br><span class="line">6.4.3运算指令200</span><br><span class="line">6.4.4类型转换指令202</span><br><span class="line">6.4.5对象创建与访问指令203</span><br><span class="line">6.4.6操作数栈管理指令203</span><br><span class="line">6.4.7控制转移指令204</span><br><span class="line">6.4.8方法调用和返回指令204</span><br><span class="line">6.4.9异常处理指令205</span><br><span class="line">6.4.10同步指令205</span><br><span class="line">6.5公有设计和私有实现206</span><br><span class="line">6.6Class文件结构的发展207</span><br><span class="line">6.7本章小结208</span><br><span class="line">第7章虚拟机类加载机制209</span><br><span class="line">7.1概述209</span><br><span class="line">7.2类加载的时机210</span><br><span class="line">7.3类加载的过程214</span><br><span class="line">7.3.1加载214</span><br><span class="line">7.3.2验证216</span><br><span class="line">7.3.3准备219</span><br><span class="line">7.3.4解析220</span><br><span class="line">7.3.5初始化225</span><br><span class="line">7.4类加载器227</span><br><span class="line">7.4.1类与类加载器228</span><br><span class="line">7.4.2双亲委派模型229</span><br><span class="line">7.4.3破坏双亲委派模型233</span><br><span class="line">7.5本章小结235</span><br><span class="line">第8章虚拟机字节码执行引擎236</span><br><span class="line">8.1概述236</span><br><span class="line">8.2运行时栈帧结构236</span><br><span class="line">8.2.1局部变量表238</span><br><span class="line">8.2.2操作数栈242</span><br><span class="line">8.2.3动态连接243</span><br><span class="line">8.2.4方法返回地址243</span><br><span class="line">8.2.5附加信息244</span><br><span class="line">8.3方法调用244</span><br><span class="line">8.3.1解析244</span><br><span class="line">8.3.2分派246</span><br><span class="line">8.3.3动态类型语言支持258</span><br><span class="line">8.4基于栈的字节码解释执行引擎269</span><br><span class="line">8.4.1解释执行269</span><br><span class="line">8.4.2基于栈的指令集与基于寄存器的指令集270</span><br><span class="line">8.4.3基于栈的解释器执行过程272</span><br><span class="line">8.5本章小结275</span><br><span class="line">第9章类加载及执行子系统的案例与实战276</span><br><span class="line">9.1概述276</span><br><span class="line">9.2案例分析276</span><br><span class="line">9.2.1Tomcat：正统的类加载器架构276</span><br><span class="line">9.2.2OSGi：灵活的类加载器架构279</span><br><span class="line">9.2.3字节码生成技术与动态代理的实现282</span><br><span class="line">9.2.4Retrotranslator：跨越JDK版本286</span><br><span class="line">9.3实战：自己动手实现远程执行功能289</span><br><span class="line">9.3.1目标290</span><br><span class="line">9.3.2思路290</span><br><span class="line">9.3.3实现291</span><br><span class="line">9.3.4验证298</span><br><span class="line">9.4本章小结299</span><br><span class="line">第四部分程序编译与代码优化</span><br><span class="line">第10章早期（编译期）优化302</span><br><span class="line">10.1概述302</span><br><span class="line">10.2Javac编译器303</span><br><span class="line">10.2.1Javac的源码与调试303</span><br><span class="line">10.2.2解析与填充符号表305</span><br><span class="line">10.2.3注解处理器307</span><br><span class="line">10.2.4语义分析与字节码生成307</span><br><span class="line">10.3Java语法糖的味道311</span><br><span class="line">10.3.1泛型与类型擦除311</span><br><span class="line">10.3.2自动装箱、拆箱与遍历循环315</span><br><span class="line">10.3.3条件编译317</span><br><span class="line">10.4实战：插入式注解处理器318</span><br><span class="line">10.4.1实战目标318</span><br><span class="line">10.4.2代码实现319</span><br><span class="line">10.4.3运行与测试326</span><br><span class="line">10.4.4其他应用案例327</span><br><span class="line">10.5本章小结328</span><br><span class="line">第11章晚期（运行期）优化329</span><br><span class="line">11.1概述329</span><br><span class="line">11.2HotSpot虚拟机内的即时编译器329</span><br><span class="line">11.2.1解释器与编译器330</span><br><span class="line">11.2.2编译对象与触发条件332</span><br><span class="line">11.2.3编译过程337</span><br><span class="line">11.2.4查看及分析即时编译结果339</span><br><span class="line">11.3编译优化技术345</span><br><span class="line">11.3.1优化技术概览346</span><br><span class="line">11.3.2公共子表达式消除350</span><br><span class="line">11.3.3数组边界检查消除351</span><br><span class="line">11.3.4方法内联352</span><br><span class="line">11.3.5逃逸分析354</span><br><span class="line">11.4Java与C&#x2F;C++的编译器对比356</span><br><span class="line">11.5本章小结358</span><br><span class="line">第五部分高效并发</span><br><span class="line">第12章Java内存模型与线程360</span><br><span class="line">12.1概述360</span><br><span class="line">12.2硬件的效率与一致性361</span><br><span class="line">12.3Java内存模型362</span><br><span class="line">12.3.1主内存与工作内存363</span><br><span class="line">12.3.2内存间交互操作364</span><br><span class="line">12.3.3对于volatile型变量的特殊规则366</span><br><span class="line">12.3.4对于long和double型变量的特殊规则372</span><br><span class="line">12.3.5原子性、可见性与有序性373</span><br><span class="line">12.3.6先行发生原则375</span><br><span class="line">12.4Java与线程378</span><br><span class="line">12.4.1线程的实现378</span><br><span class="line">12.4.2Java线程调度381</span><br><span class="line">12.4.3状态转换383</span><br><span class="line">12.5本章小结384</span><br><span class="line">第13章线程安全与锁优化385</span><br><span class="line">13.1概述385</span><br><span class="line">13.2线程安全385</span><br><span class="line">13.2.1Java语言中的线程安全386</span><br><span class="line">13.2.2线程安全的实现方法390</span><br><span class="line">13.3锁优化397</span><br><span class="line">13.3.1自旋锁与自适应自旋398</span><br><span class="line">13.3.2锁消除398</span><br><span class="line">13.3.3锁粗化400</span><br><span class="line">13.3.4轻量级锁400</span><br><span class="line">13.3.5偏向锁402</span><br><span class="line">13.4本章小结403</span><br><span class="line">附录</span><br><span class="line">附录A编译Windows版的OpenJDK406</span><br><span class="line">附录B虚拟机字节码指令表414</span><br><span class="line">附录CHotSpot虚拟机主要参数表420</span><br><span class="line">附录D对象查询语言（OQL）简介424</span><br><span class="line">附录EJDK历史版本轨迹430</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00D2ID4PK/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00D2ID4PK&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41WduDiHOWL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>精通iOS开发(第5版)</title>
    <url>/2020/04/19/B00EXGR1DG/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 精通iOS开发(第5版)<br>作者信息： 作者: 马克 (David Mark) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《精通iOS开发(第5版)》编辑推荐：iOS是如今最炙手可热的移动平台，苹果公司为其推出了强大的软件开发工具包iOS SDK。自2009年《精通iOS开发(第1版)》面世以来，累计销量超过5万册；全球iOS开发者交口称赞的iOS开发圣经，新版本经过重新翻译审校；资深技术专家担纲撰写，iOS开发必备。　　《精通iOS开发(第5版)》具有较强的通用性，iOS开发新手可通过学习本书快速入门进阶，经验丰富的iOS开发人员也能从中找到令人耳目一新的内容。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 欢迎来到iOS世界 1</span><br><span class="line">1.1 关于本书 1</span><br><span class="line">1.2 必要条件 1</span><br><span class="line">1.2.1 开发者选项 3</span><br><span class="line">1.2.2 必备知识 3</span><br><span class="line">1.3 编写iOS应用程序有何不同 4</span><br><span class="line">1.3.1 只能激活一个应用 4</span><br><span class="line">1.3.2 只有一个窗口 5</span><br><span class="line">1.3.3 有限的访问权限 5</span><br><span class="line">1.3.4 有限的响应时间 5</span><br><span class="line">1.3.5 有限的屏幕大小 5</span><br><span class="line">1.3.6 有限的系统资源 6</span><br><span class="line">1.3.7 不支持垃圾回收 6</span><br><span class="line">1.3.8 新功能 6</span><br><span class="line">1.3.9 与众不同的交互方法 7</span><br><span class="line">1.4 本书内容 7</span><br><span class="line">1.5 这一版的新内容 8</span><br><span class="line">1.6 准备开始吧 9</span><br><span class="line">第2章 创建项目 10</span><br><span class="line">2.1 在Xcode中创建项目 10</span><br><span class="line">2.1.1 Xcode工作区窗口 14</span><br><span class="line">2.1.2 深入研究项目 21</span><br><span class="line">2.2 InterfaceBuilder简介 23</span><br><span class="line">2.2.1 nib文件的构成 24</span><br><span class="line">2.2.2 库 25</span><br><span class="line">2.2.3 在视图中添加标签 26</span><br><span class="line">2.2.4 属性修改 29</span><br><span class="line">2.3 画龙点睛——美化iPhone应用 30</span><br><span class="line">2.4 小结 34</span><br><span class="line">第3章 实现基本交互 35</span><br><span class="line">3.1 MVC方法 36</span><br><span class="line">3.2 创建项目 36</span><br><span class="line">3.3 视图控制器 37</span><br><span class="line">3.3.1 输出口和动作 38</span><br><span class="line">3.3.2 清理视图控制器 41</span><br><span class="line">3.3.3 设计用户界面 41</span><br><span class="line">3.3.4 运行应用 50</span><br><span class="line">3.3.5 样式文本 50</span><br><span class="line">3.4 应用程序委托 52</span><br><span class="line">3.5 小结 55</span><br><span class="line">第4章 更丰富的用户界面 56</span><br><span class="line">4.1 满是控件的屏幕 56</span><br><span class="line">4.2 活动控件、静态控件和被动控件 58</span><br><span class="line">4.3 创建应用程序 59</span><br><span class="line">4.4 实现图像视图和文本字段 59</span><br><span class="line">4.4.1 添加图像视图 59</span><br><span class="line">4.4.2 调整图像视图的大小 62</span><br><span class="line">4.4.3 设置视图属性 63</span><br><span class="line">4.4.4 添加文本字段 65</span><br><span class="line">4.4.5 创建和关联输出口 70</span><br><span class="line">4.5 关闭键盘 72</span><br><span class="line">4.5.1 输入完成后关闭键盘 73</span><br><span class="line">4.5.2 通过触摸背景关闭键盘 74</span><br><span class="line">4.5.3 添加滑块和标签 76</span><br><span class="line">4.5.4 添加顶部约束 78</span><br><span class="line">4.5.5 创建并关联动作方法和输出口 78</span><br><span class="line">4.5.6 实现动作方法 79</span><br><span class="line">4.6 实现开关、按钮和分段控件 80</span><br><span class="line">4.7 实现分段控件的动作方法 84</span><br><span class="line">4.8 实现操作表单和警告视图 85</span><br><span class="line">4.8.1 遵从操作表单委托方法 85</span><br><span class="line">4.8.2 显示操作表单 85</span><br><span class="line">4.9 美化按钮 88</span><br><span class="line">4.9.1 viewDidLoad方法 89</span><br><span class="line">4.9.2 控件状态 90</span><br><span class="line">4.9.3 可拉伸图像 90</span><br><span class="line">4.10 小结 91</span><br><span class="line">第5章 自动旋转和自动调整大小 92</span><br><span class="line">5.1 自动旋转机制 93</span><br><span class="line">5.1.1 点、像素和Retina显示屏 93</span><br><span class="line">5.1.2 自动旋转的实现方式 94</span><br><span class="line">5.2 选择视图支持的方向 95</span><br><span class="line">5.2.1 应用级支持的方向 95</span><br><span class="line">5.2.2 单个控制器的旋转支持 96</span><br><span class="line">5.3 使用约束设计界面 98</span><br><span class="line">5.3.1 覆盖默认的约束 100</span><br><span class="line">5.3.2 与屏幕等宽的按钮 101</span><br><span class="line">5.4 旋转时重构视图 103</span><br><span class="line">5.4.1 创建并关联输出口 104</span><br><span class="line">5.4.2 旋转时移动按钮 105</span><br><span class="line">5.5 切换视图 106</span><br><span class="line">5.5.1 设计两个视图 108</span><br><span class="line">5.5.2 实现视图切换 109</span><br><span class="line">5.5.3 修改输出口集合 111</span><br><span class="line">5.6 小结 112</span><br><span class="line">第6章 多视图应用程序 113</span><br><span class="line">6.1 多视图应用程序的常见类型 113</span><br><span class="line">6.2 多视图应用程序的体系结构 117</span><br><span class="line">6.2.1 根控制器 119</span><br><span class="line">6.2.2 内容视图剖析 119</span><br><span class="line">6.3 UINavigationController 120</span><br><span class="line">6.3.1 创建视图控制器和nib文件 121</span><br><span class="line">6.3.2 修改应用程序委托 123</span><br><span class="line">6.3.3 修改BIDSwitchView—Controller.h 124</span><br><span class="line">6.3.4 添加视图控制器 124</span><br><span class="line">6.3.5 构建带有工具栏的视图 126</span><br><span class="line">6.3.6 编写根视图控制器 128</span><br><span class="line">6.3.7 实现内容视图 131</span><br><span class="line">6.3.8 转换过程的动画效果 134</span><br><span class="line">6.4 小结 136</span><br><span class="line">第7章 标签栏与选取器 137</span><br><span class="line">7.1 Pickers应用程序 138</span><br><span class="line">7.2 委托和数据源 140</span><br><span class="line">7.3 建立标签栏框架 141</span><br><span class="line">7.3.1 创建文件 141</span><br><span class="line">7.3.2 添加根视图控制器 142</span><br><span class="line">7.3.3 创建TabBarController.xib 143</span><br><span class="line">7.3.4 初次运行 149</span><br><span class="line">7.4 实现日期选取器 150</span><br><span class="line">7.5 实现单组件选取器 153</span><br><span class="line">7.5.1 声明输出口和动作方法 153</span><br><span class="line">7.5.2 构建视图 153</span><br><span class="line">7.5.3 将控制器实现为数据源和委托 155</span><br><span class="line">7.6 实现多组件选取器 158</span><br><span class="line">7.6.1 声明输出口和动作方法 158</span><br><span class="line">7.6.2 构建视图 159</span><br><span class="line">7.6.3 实现控制器 159</span><br><span class="line">7.7 实现依赖组件 162</span><br><span class="line">7.8 使用自定义选取器创建一个简单游戏 168</span><br><span class="line">7.8.1 编写控制器头文件 168</span><br><span class="line">7.8.2 构建视图 169</span><br><span class="line">7.8.3 添加图像资源 170</span><br><span class="line">7.8.4 实现控制器 170</span><br><span class="line">7.8.5 最后的细节 173</span><br><span class="line">7.8.6 链接AudioToolbox框架 177</span><br><span class="line">7.9 小结 178</span><br><span class="line">第8章 表视图简介 179</span><br><span class="line">8.1 表视图基础 179</span><br><span class="line">8.1.1 表视图和表视图单元 180</span><br><span class="line">8.1.2 分组表和无格式表 180</span><br><span class="line">8.2 实现一个简单表 181</span><br><span class="line">8.2.1 设计视图 182</span><br><span class="line">8.2.2 编写控制器 182</span><br><span class="line">8.2.3 添加一个图像 186</span><br><span class="line">8.2.4 表视图单元样式 187</span><br><span class="line">8.2.5 设置缩进级别 189</span><br><span class="line">8.2.6 处理行的选择 190</span><br><span class="line">8.2.7 更改字体大小和行高 192</span><br><span class="line">8.3 定制表视图单元 193</span><br><span class="line">8.3.1 向表视图单元添加子视图 193</span><br><span class="line">8.3.2 创建UITableViewCell子类 194</span><br><span class="line">8.3.3 从nib文件加载UITableViewCell 199</span><br><span class="line">8.4 分组分区和索引分区 202</span><br><span class="line">8.4.1 构建视图 202</span><br><span class="line">8.4.2 导入数据 203</span><br><span class="line">8.4.3 实现控制器 204</span><br><span class="line">8.4.4 添加索引 207</span><br><span class="line">8.5 实现搜索栏 208</span><br><span class="line">8.6 小结 215</span><br><span class="line">第9章 导航控制器和表视图 216</span><br><span class="line">9.1 导航控制器 216</span><br><span class="line">9.1.1 栈的性质 216</span><br><span class="line">9.1.2 控制器栈 217</span><br><span class="line">9.2 由6个部分组成的分层应用程序：Nav 218</span><br><span class="line">9.2.1 子控制器 219</span><br><span class="line">9.2.2 Nav应用程序骨架 223</span><br><span class="line">9.2.3 向项目中添加图像 229</span><br><span class="line">9.2.4 第一个子控制器：展开按钮视图 229</span><br><span class="line">9.2.5 第二个子控制器：检查表 237</span><br><span class="line">9.2.6 第三个子控制器：表行上的控件 242</span><br><span class="line">9.2.7 第四个子控制器：可移动的行 248</span><br><span class="line">9.2.8 第五个子控制器：可删除的行 252</span><br><span class="line">9.2.9 第六个子控制器：可编辑的详细面板 257</span><br><span class="line">9.2.10 其他内容 272</span><br><span class="line">9.3 小结 273</span><br><span class="line">第10章 故事板 274</span><br><span class="line">10.1 创建一个简单的故事板 274</span><br><span class="line">10.2 动态原型单元 277</span><br><span class="line">10.2.1 使用故事板的动态表内容 277</span><br><span class="line">10.2.2 编辑原型单元 278</span><br><span class="line">10.2.3 实现表视图数据源 279</span><br><span class="line">10.2.4 它会加载吗 281</span><br><span class="line">10.3 静态单元 282</span><br><span class="line">10.3.1 实现静态单元 282</span><br><span class="line">10.3.2 实现表视图数据源 283</span><br><span class="line">10.4 联线 285</span><br><span class="line">10.4.1 创建联线导航 285</span><br><span class="line">10.4.2 设计故事板 286</span><br><span class="line">10.4.3 第一个视图转换 287</span><br><span class="line">10.4.4 更为实用的任务列表 288</span><br><span class="line">10.4.5 查看任务详情 289</span><br><span class="line">10.4.6 设置更多联线 290</span><br><span class="line">10.4.7 从列表中传递任务 291</span><br><span class="line">10.4.8 处理任务细节 292</span><br><span class="line">10.4.9 回传详细信息 293</span><br><span class="line">10.4.10 让列表获取详细信息 294</span><br><span class="line">10.4.11 小结 295</span><br><span class="line">第11章 iPad开发注意事项 296</span><br><span class="line">11.1 分割视图和浮动窗口 296</span><br><span class="line">11.1.1 创建SplitView项目 298</span><br><span class="line">11.1.2 在故事板中定义结构 300</span><br><span class="line">11.1.3 使用代码定义功能 301</span><br><span class="line">11.2 显示总统信息 307</span><br><span class="line">11.3 创建浮动窗口 313</span><br><span class="line">11.4 小结 319</span><br><span class="line">第12章 应用程序设置及用户默认设置 320</span><br><span class="line">12.1 设置捆绑包入门 320</span><br><span class="line">12.2 AppSettings应用程序 321</span><br><span class="line">12.2.1 创建项目 324</span><br><span class="line">12.2.2 使用设置捆绑包 325</span><br><span class="line">12.2.3 读取应用程序中的设置 338</span><br><span class="line">12.2.4 在应用程序中修改默认设置 342</span><br><span class="line">12.2.5 注册默认值 344</span><br><span class="line">12.2.6 保证设置有效 345</span><br><span class="line">12.3 小结 348</span><br><span class="line">第13章 数据持久化基础知识 349</span><br><span class="line">13.1 应用程序的沙盒 349</span><br><span class="line">13.1.1 获取Documents目录 350</span><br><span class="line">13.1.2 获取tmp目录 351</span><br><span class="line">13.2 文件保存策略 351</span><br><span class="line">13.2.1 单文件持久化 352</span><br><span class="line">13.2.2 多文件持久化 352</span><br><span class="line">13.3 属性列表 352</span><br><span class="line">13.3.1 属性列表序列化 352</span><br><span class="line">13.3.2 Persistence应用程序的第一个版本 353</span><br><span class="line">13.4 对模型对象进行归档 358</span><br><span class="line">13.4.1 遵循NSCoding协议 358</span><br><span class="line">13.4.2 实现NSCopying协议 360</span><br><span class="line">13.4.3 对数据对象进行归档和取消归档 360</span><br><span class="line">13.4.4 归档应用程序 361</span><br><span class="line">13.5 使用iOS内嵌的SQLite3 364</span><br><span class="line">13.5.1 创建或打开数据库 365</span><br><span class="line">13.5.2 绑定变量 366</span><br><span class="line">13.5.3 SQLite3应用程序 367</span><br><span class="line">13.6 使用CoreData 373</span><br><span class="line">13.6.1 实体和托管对象 374</span><br><span class="line">13.6.2 CoreData应用程序 378</span><br><span class="line">13.7 小结 386</span><br><span class="line">第14章 iCloud之旅 387</span><br><span class="line">14.1 使用UIDocument管理文档存储 387</span><br><span class="line">14.1.1 构建TinyPix 388</span><br><span class="line">14.1.2 创建BIDTinyPix—Document类 388</span><br><span class="line">14.1.3 主代码 391</span><br><span class="line">14.1.4 初始故事板 397</span><br><span class="line">14.1.5 创建BIDTinyPixView类 400</span><br><span class="line">14.1.6 设计详细视图 403</span><br><span class="line">14.2 添加iCloud支持 407</span><br><span class="line">14.2.1 创建provisioningprofile 408</span><br><span class="line">14.2.2 启用iCloud授权 409</span><br><span class="line">14.2.3 如何查询 409</span><br><span class="line">14.2.4 保存在哪里 411</span><br><span class="line">14.2.5 将首选项保存到iCloud 411</span><br><span class="line">14.3 小结 412</span><br><span class="line">第15章 GrandCentralDispatch和后台处理 414</span><br><span class="line">15.1 GrandCentralDispatch 414</span><br><span class="line">15.2 SlowWorker简介 415</span><br><span class="line">15.3 线程基础知识 418</span><br><span class="line">15.4 工作单元 419</span><br><span class="line">15.5 GCD：低级队列 419</span><br><span class="line">15.5.1 傻瓜式操作 420</span><br><span class="line">15.5.2 改进SlowWorker 421</span><br><span class="line">15.6 后台处理 426</span><br><span class="line">15.6.1 应用程序生命周期 427</span><br><span class="line">15.6.2 状态更改通知 427</span><br><span class="line">15.6.3 创建StateLab项目 428</span><br><span class="line">15.6.4 执行状态的变化 430</span><br><span class="line">15.6.5 利用执行状态更改 431</span><br><span class="line">15.6.6 处理不活动状态 432</span><br><span class="line">15.6.7 处理后台状态 436</span><br><span class="line">15.7 小结 443</span><br><span class="line">第16章 使用Quartz和OpenGL绘图 444</span><br><span class="line">16.1 图形世界的两个视图 444</span><br><span class="line">16.2 Quartz2D绘图方法 445</span><br><span class="line">16.2.1 Quartz2D的图形上下文 445</span><br><span class="line">16.2.2 坐标系 446</span><br><span class="line">16.2.3 指定颜色 447</span><br><span class="line">16.2.4 在上下文中绘制图像 449</span><br><span class="line">16.2.5 绘制形状：多边形、直线和曲线 449</span><br><span class="line">16.2.6 Quartz2D工具采样器：模式、梯度、虚线模式 450</span><br><span class="line">16.3 QuartzFun应用程序 451</span><br><span class="line">16.3.1 建立QuartzFun应用程序 451</span><br><span class="line">16.3.2 添加Quartz2D的绘图代码 460</span><br><span class="line">16.3.3 优化QuartzFun应用程序 465</span><br><span class="line">16.4 GLFun应用程序 468</span><br><span class="line">16.4.1 建立GLFun应用程序 468</span><br><span class="line">16.4.2 创建BIDGLFunView类 469</span><br><span class="line">16.4.3 更新BIDView—Controller类 475</span><br><span class="line">16.4.4 更新nib文件 476</span><br><span class="line">16.4.5 完成GLFun应用程序 476</span><br><span class="line">16.5 小结 476</span><br><span class="line">第17章 轻击、触摸和手势 477</span><br><span class="line">17.1 多点触控术语 477</span><br><span class="line">17.2 响应者链 478</span><br><span class="line">17.2.1 响应事件 478</span><br><span class="line">17.2.2 转发事件：保持响应者链的活动状态 479</span><br><span class="line">17.3 多点触控体系结构 480</span><br><span class="line">17.4 4个手势通知方法 480</span><br><span class="line">17.5 TouchExplorer应用程序 481</span><br><span class="line">17.6 Swipes应用程序 485</span><br><span class="line">17.6.1 自动手势识别 488</span><br><span class="line">17.6.2 实现多指滑动 489</span><br><span class="line">17.7 检测多次轻击 491</span><br><span class="line">17.8 检测捏合和旋转 496</span><br><span class="line">17.9 自定义手势 500</span><br><span class="line">17.9.1 CheckPlease应用程序 501</span><br><span class="line">17.9.2 CheckPlease的触摸方法 503</span><br><span class="line">17.10 小结 505</span><br><span class="line">第18章 CoreLocation和MapKit 506</span><br><span class="line">18.1 位置管理器 506</span><br><span class="line">18.1.1 设置精度 507</span><br><span class="line">18.1.2 设置距离筛选器 507</span><br><span class="line">18.1.3 启动位置管理器 508</span><br><span class="line">18.1.4 合理使用位置管理器 508</span><br><span class="line">18.2 位置管理器委托 508</span><br><span class="line">18.2.1 获取位置更新 508</span><br><span class="line">18.2.2 使用CLLocation获取纬度和经度 508</span><br><span class="line">18.2.3 错误通知 510</span><br><span class="line">18.3 试用CoreLocation 511</span><br><span class="line">18.4 将移动路线展现在地图上 516</span><br><span class="line">18.5 小结 519</span><br><span class="line">第19章 陀螺仪和加速计 520</span><br><span class="line">19.1 加速计物理学 520</span><br><span class="line">19.2 不要忘记旋转 521</span><br><span class="line">19.3 CoreMotion和动作管理器 521</span><br><span class="line">19.3.1 基于事件的动作 522</span><br><span class="line">19.3.2 主动动作访问 527</span><br><span class="line">19.3.3 加速计结果 529</span><br><span class="line">19.4 检测摇动 530</span><br><span class="line">19.4.1 内嵌的摇动检测 531</span><br><span class="line">19.4.2 摇动与击碎 531</span><br><span class="line">19.5 将加速计用做方向控制器 536</span><br><span class="line">19.5.1 滚弹珠程序 537</span><br><span class="line">19.5.2 实现BIDBallView类 539</span><br><span class="line">19.5.3 计算弹珠运动 542</span><br><span class="line">19.6 小结 544</span><br><span class="line">第20章 照相机和照片库 545</span><br><span class="line">20.1 图像选取器和UIImagePicker—Controller 545</span><br><span class="line">20.2 实现图像选取器控制器委托 547</span><br><span class="line">20.3 实际测试照相机和照片库 548</span><br><span class="line">20.3.1 设计界面 549</span><br><span class="line">20.3.2 实现照相机视图控制器 550</span><br><span class="line">20.4 小结 553</span><br><span class="line">第21章 集合视图 554</span><br><span class="line">21.1 创建DialogViewer项目 554</span><br><span class="line">21.2 视图控制器类 555</span><br><span class="line">21.3 自定义单元 555</span><br><span class="line">21.4 配置视图控制器 558</span><br><span class="line">21.5 内容单元 559</span><br><span class="line">21.6 实现流式布局 560</span><br><span class="line">21.7 分区标题视图 562</span><br><span class="line">21.8 小结 563</span><br><span class="line">第22章 应用程序本地化 564</span><br><span class="line">22.1 本地化体系结构 564</span><br><span class="line">22.2 字符串文件 565</span><br><span class="line">22.2.1 字符串文件 566</span><br><span class="line">22.2.2 本地化的字符串宏 566</span><br><span class="line">22.3 现实中的iOS：本地化应用程序 567</span><br><span class="line">22.3.1 创建LocalizeMe 568</span><br><span class="line">22.3.2 测试LocalizeMe 570</span><br><span class="line">22.3.3 本地化nib文件 571</span><br><span class="line">22.3.4 本地化图像 575</span><br><span class="line">22.3.5 生成并本地化字符串文件 577</span><br><span class="line">22.3.6 BaseInternationalization 579</span><br><span class="line">22.3.7 应用显示名称的本地化 582</span><br><span class="line">22.4 小结 583</span><br><span class="line">附录A 未来之路 584</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00EXGR1DG/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00EXGR1DG&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51tvt-TCT7L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>高流量网站CSS开发技术</title>
    <url>/2020/04/19/B00FIIM9JO/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 高流量网站CSS开发技术<br>作者信息： 作者: 肯尼迪 (Antony Kennedy) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>构建和维护高流量网站有诸多需要注意的事项和需要克服的障碍，其中有关于技术的，也有关于团队和人员的，肯尼迪、利昂编著的《高流量网站CSS开发技术》正是要把这些内容恰到好处地展现给读者。如何构建快速、高效的高流量网站，并尽可能降低成本，《高流量网站CSS开发技术》会告诉你技巧，也会讲解最佳实践。读完本书，读者便可掌握开发高流量网站的专业技术，最重要的是明白如何充分发挥整个开发团队的力量。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 流程的价值</span><br><span class="line">1.1 团队</span><br><span class="line">1.2 成长的烦恼</span><br><span class="line">1.3 人员流失</span><br><span class="line">1.4 一致比优秀更重要</span><br><span class="line">1.5 工具</span><br><span class="line">1.5.1 Wiki</span><br><span class="line">1.5.2 错误报告</span><br><span class="line">1.5.3 任务管理</span><br><span class="line">1.5.4 错误跟踪和任务管理</span><br><span class="line">1.5.5 版本控制</span><br><span class="line">1.5.6 Diff工具</span><br><span class="line">1.5.7 解决冲突</span><br><span class="line">1.6 备份</span><br><span class="line">1.6.1 在线备份</span><br><span class="line">1.6.2 桌面备份</span><br><span class="line">1.7 原型设计</span><br><span class="line">1.8 开发方法</span><br><span class="line">1.8.1 瀑布开发</span><br><span class="line">1.8.2 敏捷开发</span><br><span class="line">1.9 小结</span><br><span class="line">第2章 CSS格式指导标准</span><br><span class="line">2.1 CSS格式指导标准</span><br><span class="line">2.2 CSS编写格式</span><br><span class="line">2.2.1 单行与多行</span><br><span class="line">2.2.2 缩进</span><br><span class="line">2.2.3 制表符和空格</span><br><span class="line">2.2.4 冒号和分号</span><br><span class="line">2.3 注释和CSS元数据</span><br><span class="line">2.3.1 现成的标准：CSSDOC</span><br><span class="line">2.3.2 文件信息</span><br><span class="line">2.3.3 内容目录</span><br><span class="line">2.3.4 区块</span><br><span class="line">2.3.5 配色方案</span><br><span class="line">2.3.6 文件夹路径</span><br><span class="line">2.3.7 尺寸单位</span><br><span class="line">2.3.8 文档补丁和错误修正</span><br><span class="line">2.3.9 使用模板</span><br><span class="line">2.4 class和id命名</span><br><span class="line">2.4.1 语义化</span><br><span class="line">2.4.2 可接受的字符</span><br><span class="line">2.4.3 惯例</span><br><span class="line">2.4.4 大小写</span><br><span class="line">2.5 命名空间</span><br><span class="line">2.5.1 可重用的class</span><br><span class="line">2.5.2 CSS命名空间模块</span><br><span class="line">2.6 小结</span><br><span class="line">第3章 基本原理</span><br><span class="line">3.1 层叠：来源、重要性和继承</span><br><span class="line">3.1.1 来源和重要性</span><br><span class="line">3.1.2 继承</span><br><span class="line">3.1.3 继承和通用选择器</span><br><span class="line">3.2 特殊性</span><br><span class="line">3.2.1 特殊性计算</span><br><span class="line">3.2.2 ！important声明</span><br><span class="line">3.2.3 命名空间和特殊性</span><br><span class="line">3.2.4 使用工具</span><br><span class="line">3.3 编码</span><br><span class="line">3.4 本地化</span><br><span class="line">3.5 浏览器特定CSS</span><br><span class="line">3.5.1 补丁和滤镜</span><br><span class="line">3.5.2 CSS表达式</span><br><span class="line">3.5.3 厂商特定扩展</span><br><span class="line">3.5.4 媒体查询</span><br><span class="line">3.5.5 条件注释</span><br><span class="line">3.6 何时以及如何使用补丁</span><br><span class="line">3.6.1 “安全”补丁</span><br><span class="line">3.6.2 真实的世界</span><br><span class="line">3.7 服务器端用户代理检测</span><br><span class="line">3.8 一些浏览器渲染差异的例子</span><br><span class="line">3.8.1 怪异模式</span><br><span class="line">3.8.2 IE盒模型</span><br><span class="line">3.8.3 hasLayout</span><br><span class="line">3.8.4 实验性CSS</span><br><span class="line">3.9 小结</span><br><span class="line">第4章 框架和整合</span><br><span class="line">4.1 框架</span><br><span class="line">4.1.1 Blueprint CSS</span><br><span class="line">4.1.2960 Grid System</span><br><span class="line">4.1.3 YUI 3 Grids</span><br><span class="line">4.1.4 其他用途</span><br><span class="line">4.1.5 重置样式表</span><br><span class="line">4.1.6 为什么要建立自己的框架</span><br><span class="line">4.2 面向对象的CSS</span><br><span class="line">4.2.1 面向对象编程</span><br><span class="line">4.2.2 OOCSS</span><br><span class="line">4.3 覆盖CSS</span><br><span class="line">4.4 与第三方代码相处</span><br><span class="line">4.5 防御式CSS</span><br><span class="line">4.6 脆弱的CSS</span><br><span class="line">4.7 CSS中的元数据</span><br><span class="line">4.8 小结</span><br><span class="line">第5章 品牌实施</span><br><span class="line">5.1 什么是品牌</span><br><span class="line">5.2 品牌指导标准</span><br><span class="line">5.2.1 指导标准的进化</span><br><span class="line">5.2.2 设计库</span><br><span class="line">5.3 字体排版</span><br><span class="line">5.3.1 图像替换与灵活性</span><br><span class="line">5.3.2 font—face</span><br><span class="line">5.3.3 后备字体</span><br><span class="line">5.3.4 尺寸单位</span><br><span class="line">5.4 颜色</span><br><span class="line">5.4.1 多种配色方案</span><br><span class="line">5.4.2 颜色参考</span><br><span class="line">5.4.3 动态颜色</span><br><span class="line">5.4.4 后备颜色</span><br><span class="line">5.5 布局</span><br><span class="line">5.5.1 栅格</span><br><span class="line">5.5.2 模板</span><br><span class="line">5.6 主题</span><br><span class="line">5.7 灵活的CSS和品牌进化</span><br><span class="line">5.8 小结</span><br><span class="line">第6章 CSS与无障碍访问</span><br><span class="line">6.1 缺陷问题概览</span><br><span class="line">6.1.1 弱视</span><br><span class="line">6.1.2 盲人</span><br><span class="line">6.1.3 色盲</span><br><span class="line">6.1.4 运动障碍</span><br><span class="line">6.1.5 听力障碍</span><br><span class="line">6.1.6 认知障碍</span><br><span class="line">6.1.7 年幼</span><br><span class="line">6.1.8 年老</span><br><span class="line">6.1.9 癫痫</span><br><span class="line">6.2 无障碍访问的指导标准</span><br><span class="line">6.3 辅助技术</span><br><span class="line">6.3.1 屏幕阅读器</span><br><span class="line">6.3.2 用CSS隐藏内容</span><br><span class="line">6.3.3 只有键盘的用户</span><br><span class="line">6.3.4 其他辅助设备</span><br><span class="line">6.4 设计和布局</span><br><span class="line">6.4.1 颜色</span><br><span class="line">6.4.2 字体和单位</span><br><span class="line">6.4.3 Web字体和失读症</span><br><span class="line">6.4.4 用户自定义</span><br><span class="line">6.4.5 样式切换</span><br><span class="line">6.5 WAI—ARIA</span><br><span class="line">6.6 设备和环境缺陷</span><br><span class="line">6.7 渐进增强还是优雅降级</span><br><span class="line">6.8 分级浏览器支持</span><br><span class="line">6.9 小结</span><br><span class="line">第7章 设备</span><br><span class="line">7.1 媒体类型</span><br><span class="line">7.1.1 all</span><br><span class="line">7.1.2 braille</span><br><span class="line">7.1.3 embossed</span><br><span class="line">7.1.4 handheld</span><br><span class="line">7.1.5 print</span><br><span class="line">7.1.6 projection</span><br><span class="line">7.1.7 screen</span><br><span class="line">7.1.8 speech</span><br><span class="line">7.1.9 tty</span><br><span class="line">7.1.10 tv</span><br><span class="line">7.2 媒体查询</span><br><span class="line">7.2.1 width</span><br><span class="line">7.2.2 height</span><br><span class="line">7.2.3 device—width</span><br><span class="line">7.2.4 device—height</span><br><span class="line">7.2.5 orientation</span><br><span class="line">7.2.6 aspect—ratio</span><br><span class="line">7.2.7 device—aspect—ratio</span><br><span class="line">7.2.8 color</span><br><span class="line">7.2.9 color—index</span><br><span class="line">7.2.10 monochrome</span><br><span class="line">7.2.11 resolution</span><br><span class="line">7.2.12 scan</span><br><span class="line">7.2.13 grid</span><br><span class="line">7.2.14 transform—2d</span><br><span class="line">7.2.15 transform—3d</span><br><span class="line">7.2.16 transition</span><br><span class="line">7.2.17 animation</span><br><span class="line">7.3 Modernizr</span><br><span class="line">7.4 打印样式表</span><br><span class="line">7.5 移动设备</span><br><span class="line">7.5.1 另一个网站</span><br><span class="line">7.5.2 使用媒体查询指定移动设备</span><br><span class="line">7.5.3 做一个应用程序代替</span><br><span class="line">7.6 其他设备</span><br><span class="line">7.7 搜索引擎优化</span><br><span class="line">7.8 小结</span><br><span class="line">第8章 性能</span><br><span class="line">8.1 净荷：注意文件大小</span><br><span class="line">8.1.1 命名规范</span><br><span class="line">8.1.2 文件命名</span><br><span class="line">8.1.3 文件夹结构</span><br><span class="line">8.1.4 语法</span><br><span class="line">8.1.5 精简</span><br><span class="line">8.1.6 压缩</span><br><span class="line">8.1.7 Apache</span><br><span class="line">8.1.8 Microsoft IIS</span><br><span class="line">8.1.9 内容分发网络和域名</span><br><span class="line">8.1.10 减少HTTP请求数远比文件大小重要</span><br><span class="line">8.1.11 域名查询</span><br><span class="line">8.1.12 连接</span><br><span class="line">8.1.13 发送</span><br><span class="line">8.1.14 等待</span><br><span class="line">8.1.15 接收</span><br><span class="line">8.1.16 合并</span><br><span class="line">8.1.17 CSS图片合并</span><br><span class="line">8.2 data URI</span><br><span class="line">8.3 缓存</span><br><span class="line">8.4 应该缓存哪些内容</span><br><span class="line">8.5 版本</span><br><span class="line">8.6 试试离线存储</span><br><span class="line">8.7 渲染和解析</span><br><span class="line">8.8 使用JavaScript修改属性</span><br><span class="line">8.9 动画</span><br><span class="line">8.10 硬件加速</span><br><span class="line">8.11 小结</span><br><span class="line">第9章 动态CSS</span><br><span class="line">9.1 CSS扩展和预处理器</span><br><span class="line">9.2 LESS</span><br><span class="line">9.2.1 变量</span><br><span class="line">9.2.2 混合</span><br><span class="line">9.2.3 嵌套规则</span><br><span class="line">9.2.4 运算</span><br><span class="line">9.2.5 颜色函数</span><br><span class="line">9.2.6 命名空间</span><br><span class="line">9.2.7 注释</span><br><span class="line">9.2.8 导入</span><br><span class="line">9.2.9 小结</span><br><span class="line">9.3 Sass</span><br><span class="line">9.3.1 变量</span><br><span class="line">9.3.2 嵌套选择器</span><br><span class="line">9.3.3 条件逻辑</span><br><span class="line">9.3.4 循环</span><br><span class="line">9.3.5 注释</span><br><span class="line">9.3.6 继承</span><br><span class="line">9.3.7 混合</span><br><span class="line">9.3.8 颜色</span><br><span class="line">9.3.9 导入</span><br><span class="line">9.3.10 小结</span><br><span class="line">9.4 评估第三方技术</span><br><span class="line">9.5 使用服务器端技术生成CSS</span><br><span class="line">9.6 持续集成</span><br><span class="line">9.7 巧妙地构建脚本</span><br><span class="line">9.8 缓存注意事项</span><br><span class="line">9.9 小结</span><br><span class="line">第10章 测试与调试</span><br><span class="line">10.1 快速开发</span><br><span class="line">10.1.1 合并CSS文件的构建脚本</span><br><span class="line">10.1.2 压缩CSS的构建脚本</span><br><span class="line">10.1.3 无刷新重载CSS</span><br><span class="line">10.1.4 缓存文件</span><br><span class="line">10.1.5 IE的bug</span><br><span class="line">10.2 调试</span><br><span class="line">10.2.1 Firebug（Firefox）</span><br><span class="line">10.2.2 Web Developer（用于Firefox或Chrome）</span><br><span class="line">10.2.3 Developer Tools（IE8+）</span><br><span class="line">10.2.4 Web Inspector（Safari）</span><br><span class="line">10.2.5 Developer Tools（Chrome）</span><br><span class="line">10.2.6 IE Developer Toolbar</span><br><span class="line">10.2.7 Opera蜻蜓</span><br><span class="line">10.3 代理工具</span><br><span class="line">10.3.1 Fiddler</span><br><span class="line">10.3.2 Charles</span><br><span class="line">10.4 测试</span><br><span class="line">10.4.1 分级浏览器支持</span><br><span class="line">10.4.2 运行多个版本的IE</span><br><span class="line">10.4.3 模拟其他设备</span><br><span class="line">10.4.4 自动生成网页截图</span><br><span class="line">10.5 小结</span><br><span class="line">第11章 创建你自己的CSS框架</span><br><span class="line">11.1 为Igloo冰箱配件公司制作网站</span><br><span class="line">11.2 分析设计图</span><br><span class="line">11.2.1 栅格系统</span><br><span class="line">11.2.2 可重用组件</span><br><span class="line">11.2.3 配色方案</span><br><span class="line">11.2.4 无障碍访问问题</span><br><span class="line">11.2.5 沟通很重要</span><br><span class="line">11.3 编写CSS</span><br><span class="line">11.3.1 注释</span><br><span class="line">11.3.2 单位</span><br><span class="line">11.3.3 基准样式</span><br><span class="line">11.3.4 结构</span><br><span class="line">11.3.5 默认字体排版</span><br><span class="line">11.3.6 全局元素</span><br><span class="line">11.3.7 组件和可重用类</span><br><span class="line">11.3.8 一次性样式</span><br><span class="line">11.3.9 取舍之道</span><br><span class="line">11.3.10 跨浏览器一致性</span><br><span class="line">11.3.11 无障碍访问及超链接</span><br><span class="line">11.4 文档和设计模式库</span><br><span class="line">11.5 小结</span><br><span class="line">附录1 CSS指导标准</span><br><span class="line">附录2 无障碍访问指导标准</span><br><span class="line">附录3 浏览器支持指南</span><br><span class="line">附录4 开发流程</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00FIIM9JO/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00FIIM9JO&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51gZ4nSjwQL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Java虚拟机规范(Java SE 7版)</title>
    <url>/2020/04/19/B00H1FXTNM/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Java虚拟机规范(Java SE 7版)<br>作者信息： 作者: Tim Lindholm [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Java虚拟机规范(Java SE7版)》由林德霍尔姆著，本书完整而准确地阐释了Java虚拟机各方面的细节，围绕．Java虚拟机整体架构、编译器、class文件格式、加载、链接与初始化、指令集等核心主题对Java虚拟机进行全面而深入的分析，深刻揭示Java虚拟机的工作原理。同时，基于最新Java SE 7平台，它详细介绍了Java SE 7中新加入的lnvokeDynamic指令和方法句柄机制，给出了在Java SE 6期间引入的类型检查检验器的原理证明。本书还介绍了Java SE 5中对class文件格式的扩展变动，例如泛型和注解等。另外还介绍了Java内存模型的指令操作和初始化规则。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目　录</span><br><span class="line">译者序</span><br><span class="line">前言</span><br><span class="line">第2版前言</span><br><span class="line">第1版前言</span><br><span class="line">第1章　引言1</span><br><span class="line">1.1　简史1</span><br><span class="line">1.2　Java虚拟机2</span><br><span class="line">1.3　各章节摘要2</span><br><span class="line">1.4　说明3</span><br><span class="line">第2章　Java虚拟机结构4</span><br><span class="line">2.1　class文件格式4</span><br><span class="line">2.2　数据类型5</span><br><span class="line">2.3　原始类型与值5</span><br><span class="line">2.3.1　整数类型与整型值6</span><br><span class="line">2.3.2　浮点类型、取值集合及浮点值6</span><br><span class="line">2.3.3　returnAddress类型和值8</span><br><span class="line">2.3.4　boolean类型8</span><br><span class="line">2.4　引用类型与值9</span><br><span class="line">2.5　运行时数据区9</span><br><span class="line">2.5.1　pc寄存器9</span><br><span class="line">2.5.2　Java虚拟机栈9</span><br><span class="line">2.5.3　Java堆10</span><br><span class="line">2.5.4　方法区11</span><br><span class="line">2.5.5　运行时常量池11</span><br><span class="line">2.5.6　本地方法栈11</span><br><span class="line">2.6　栈帧12</span><br><span class="line">2.6.1　局部变量表13</span><br><span class="line">2.6.2　操作数栈13</span><br><span class="line">2.6.3　动态链接14</span><br><span class="line">2.6.4　方法正常调用完成14</span><br><span class="line">2.6.5　方法异常调用完成15</span><br><span class="line">2.7　对象的表示15</span><br><span class="line">2.8　浮点算法15</span><br><span class="line">2.8.1　Java虚拟机和IEEE 754中的浮点算法15</span><br><span class="line">2.8.2　浮点模式16</span><br><span class="line">2.8.3　数值集合转换16</span><br><span class="line">2.9　特殊方法17</span><br><span class="line">2.10　异常18</span><br><span class="line">2.11　字节码指令集简介20</span><br><span class="line">2.11.1　数据类型与Java虚拟机21</span><br><span class="line">2.11.2　加载和存储指令23</span><br><span class="line">2.11.3　算术指令23</span><br><span class="line">2.11.4　类型转换指令24</span><br><span class="line">2.11.5　对象创建与操作26</span><br><span class="line">2.11.6　操作数栈管理指令26</span><br><span class="line">2.11.7　控制转移指令27</span><br><span class="line">2.11.8　方法调用和返回指令27</span><br><span class="line">2.11.9　抛出异常28</span><br><span class="line">2.11.10　同步28</span><br><span class="line">2.12　类库28</span><br><span class="line">2.13　公有设计，私有实现29</span><br><span class="line">第3章　Java虚拟机编译器30</span><br><span class="line">3.1　示例的格式说明30</span><br><span class="line">3.2　常量、局部变量和控制结构的使用31</span><br><span class="line">3.3　算术运算35</span><br><span class="line">3.4　访问运行时常量池35</span><br><span class="line">3.5　更多控制结构示例36</span><br><span class="line">3.6　接收参数39</span><br><span class="line">3.7　方法调用39</span><br><span class="line">3.8　使用类实例42</span><br><span class="line">3.9　数组43</span><br><span class="line">3.10　编译switch语句45</span><br><span class="line">3.11　使用操作数栈46</span><br><span class="line">3.12　抛出异常和处理异常47</span><br><span class="line">3.13　编译finally语句块50</span><br><span class="line">3.14　同步53</span><br><span class="line">3.15　注解54</span><br><span class="line">第4章　class文件格式55</span><br><span class="line">4.1　ClassFile结构56</span><br><span class="line">4.2　各种内部表示名称60</span><br><span class="line">4.2.1　类和接口的二进制名称60</span><br><span class="line">4.2.2　非全限定名60</span><br><span class="line">4.3　描述符和签名61</span><br><span class="line">4.3.1　语法符号61</span><br><span class="line">4.3.2　字段描述符61</span><br><span class="line">4.3.3　方法描述符63</span><br><span class="line">4.3.4　签名63</span><br><span class="line">4.4　常量池66</span><br><span class="line">4.4.1　CONSTANT_Class_info结构67</span><br><span class="line">4.4.2　CONSTANT_Fieldref_info、CONSTANT_Methodref_info和CONSTANT_Interface Methodref_info结构67</span><br><span class="line">4.4.3　CONSTANT_String_info结构69</span><br><span class="line">4.4.4　CONSTANT_Integer_info和CONSTANT_Float_info结构69</span><br><span class="line">4.4.5　CONSTANT_Long_info和CONSTANT_Double_info结构70</span><br><span class="line">4.4.6　CONSTANT_NameAndType_info结构71</span><br><span class="line">4.4.7　CONSTANT_Utf8_info结构72</span><br><span class="line">4.4.8　CONSTANT_MethodHandle_info结构74</span><br><span class="line">4.4.9　CONSTANT_MethodType_info结构74</span><br><span class="line">4.4.10　CONSTANT_InvokeDynamic_info结构75</span><br><span class="line">4.5　字段75</span><br><span class="line">4.6　方法77</span><br><span class="line">4.7　属性80</span><br><span class="line">4.7.1　自定义和命名新的属性81</span><br><span class="line">4.7.2　ConstantValue属性81</span><br><span class="line">4.7.3　Code属性82</span><br><span class="line">4.7.4　StackMapTable属性85</span><br><span class="line">4.7.5　Exceptions属性91</span><br><span class="line">4.7.6　InnerClasses属性92</span><br><span class="line">4.7.7　EnclosingMethod属性94</span><br><span class="line">4.7.8　Synthetic属性94</span><br><span class="line">4.7.9　Signature属性95</span><br><span class="line">4.7.10　SourceFile属性96</span><br><span class="line">4.7.11　SourceDebugExtension属性96</span><br><span class="line">4.7.12　LineNumberTable属性97</span><br><span class="line">4.7.13　LocalVariableTable属性98</span><br><span class="line">4.7.14　LocalVariableTypeTable属性99</span><br><span class="line">4.7.15　Deprecated属性101</span><br><span class="line">4.7.16　RuntimeVisibleAnnotations属性101</span><br><span class="line">4.7.17　RuntimeInvisible Annotations属性105</span><br><span class="line">4.7.18　RuntimeVisibleParameter Annotations属性106</span><br><span class="line">4.7.19　RuntimeInvisibleParameter Annotations属性107</span><br><span class="line">4.7.20　AnnotationDefault属性108</span><br><span class="line">4.7.21　BootstrapMethods属性108</span><br><span class="line">4.8　格式检查110</span><br><span class="line">4.9　Java虚拟机代码约束110</span><br><span class="line">4.9.1　静态约束110</span><br><span class="line">4.9.2　结构化约束113</span><br><span class="line">4.10　class文件校验115</span><br><span class="line">4.10.1　类型检查验证116</span><br><span class="line">4.10.2　类型推导验证178</span><br><span class="line">4.11　Java虚拟机限制184</span><br><span class="line">第5章　加载、链接与初始化186</span><br><span class="line">5.1　运行时常量池186</span><br><span class="line">5.2　虚拟机启动188</span><br><span class="line">5.3　创建和加载188</span><br><span class="line">5.3.1　使用引导类加载器来加载类型190</span><br><span class="line">5.3.2　使用用户自定义类加载器来加载类型190</span><br><span class="line">5.3.3　创建数组类191</span><br><span class="line">5.3.4　加载限制191</span><br><span class="line">5.3.5　从class文件表示得到类192</span><br><span class="line">5.4　链接193</span><br><span class="line">5.4.1　验证194</span><br><span class="line">5.4.2　准备194</span><br><span class="line">5.4.3　解析195</span><br><span class="line">5.4.4　访问控制201</span><br><span class="line">5.4.5　方法覆盖201</span><br><span class="line">5.5　初始化202</span><br><span class="line">5.6　绑定本地方法实现203</span><br><span class="line">5.7　Java虚拟机退出203</span><br><span class="line">第6章　Java虚拟机指令集204</span><br><span class="line">6.1　设定：“必须”的含义204</span><br><span class="line">6.2　保留操作码204</span><br><span class="line">6.3　虚拟机错误205</span><br><span class="line">6.4　指令描述格式205</span><br><span class="line">6.5　指令集描述207</span><br><span class="line">第7章　操作码助记符293</span><br><span class="line">附录A　Limited License Grant300</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00H1FXTNM/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00H1FXTNM&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41FPgKGImEL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心技术(卷1) 基础知识(原书第9版)</title>
    <url>/2020/04/19/B00G9KF4JC/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Java核心技术(卷1) 基础知识(原书第9版)<br>作者信息： 作者: 霍斯特曼 (Cay S. Horstmann) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Java领域最有影响力和价值的著作之一，与《Java编程思想》齐名，10余年全球畅销不衰，广受好评；2）根据Java SE 7全面更新，系统全面讲解Java语言的核心概念、语法、重要特性和开发方法，包含大量案例，实践性强</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">译者序</span><br><span class="line">前言</span><br><span class="line">致谢</span><br><span class="line">第1章 Java程序设计概述</span><br><span class="line">1.1 Java程序设计平台</span><br><span class="line">1.2 Java“白皮书”的关键术语</span><br><span class="line">1.2.1 简单性</span><br><span class="line">1.2.2 面向对象</span><br><span class="line">1.2.3 网络技能</span><br><span class="line">1.2.4 健壮性</span><br><span class="line">1.2.5 安全性</span><br><span class="line">1.2.6 体系结构中立</span><br><span class="line">1.2.7 可移植性</span><br><span class="line">1.2.8 解释型</span><br><span class="line">1.2.9 高性能</span><br><span class="line">1.2.10 多线程</span><br><span class="line">1.2.11 动态性</span><br><span class="line">1.3 Java applet与Internet</span><br><span class="line">1.4 Java发展简史</span><br><span class="line">1.5 关于Java的常见误解</span><br><span class="line">第2章 Java程序设计环境</span><br><span class="line">2.1 安装Java开发工具箱</span><br><span class="line">2.1.1 下载JDK</span><br><span class="line">2.1.2 设置执行路径</span><br><span class="line">2.1.3 安装库源文件和文档</span><br><span class="line">2.1.4 安装本书中的示例</span><br><span class="line">2.1.5 导航Java目录</span><br><span class="line">2.2 选择开发环境</span><br><span class="line">2.3 使用命令行工具</span><br><span class="line">2.4 使用集成开发环境</span><br><span class="line">2.5 运行图形化应用程序</span><br><span class="line">2.6 建立并运行applet</span><br><span class="line">第3章 Java的基本程序设计结构</span><br><span class="line">3.1 一个简单的Java应用程序</span><br><span class="line">3.2 注释</span><br><span class="line">3.3 数据类型</span><br><span class="line">3.3.1 整型</span><br><span class="line">3.3.2 浮点类型</span><br><span class="line">3.3.3 char类型</span><br><span class="line">3.3.4 boolean类型</span><br><span class="line">3.4 变量</span><br><span class="line">3.4.1 变量初始化</span><br><span class="line">3.4.2 常量</span><br><span class="line">3.5 运算符</span><br><span class="line">3.5.1 自增运算符与自减运算符</span><br><span class="line">3.5.2 关系运算符与boolean运算符</span><br><span class="line">3.5.3 位运算符</span><br><span class="line">3.5.4 数学函数与常量</span><br><span class="line">3.5.5 数值类型之间的转换</span><br><span class="line">3.5.6 强制类型转换</span><br><span class="line">3.5.7 括号与运算符级别</span><br><span class="line">3.5.8 枚举类型</span><br><span class="line">3.6 字符串</span><br><span class="line">3.6.1 子串</span><br><span class="line">3.6.2 拼接</span><br><span class="line">3.6.3 不可变字符串</span><br><span class="line">3.6.4 检测字符串是否相等</span><br><span class="line">3.6.5 空串与Null串</span><br><span class="line">3.6.6 代码点与代码单元</span><br><span class="line">3.6.7 字符串API</span><br><span class="line">3.6.8 阅读联机API文档</span><br><span class="line">3.6.9 构建字符串</span><br><span class="line">3.7 输入输出</span><br><span class="line">3.7.1 读取输入</span><br><span class="line">3.7.2 格式化输出</span><br><span class="line">3.7.3 文件输入与输出</span><br><span class="line">3.8 控制流程</span><br><span class="line">3.8.1 块作用域</span><br><span class="line">3.8.2 条件语句</span><br><span class="line">3.8.3 循环</span><br><span class="line">3.8.4 确定循环</span><br><span class="line">3.8.5 多重选择：switch语句</span><br><span class="line">3.8.6 中断控制流程语句</span><br><span class="line">3.9 大数值</span><br><span class="line">3.10 数组</span><br><span class="line">3.10.1 for each循环</span><br><span class="line">3.10.2 数组初始化以及匿名数组</span><br><span class="line">3.10.3 数组拷贝</span><br><span class="line">3.10.4 命令行参数</span><br><span class="line">3.10.5 数组排序</span><br><span class="line">3.10.6 多维数组</span><br><span class="line">3.10.7 不规则数组</span><br><span class="line">第4章 对象与类</span><br><span class="line">4.1 面向对象程序设计概述</span><br><span class="line">4.1.1 类</span><br><span class="line">4.1.2 对象</span><br><span class="line">4.1.3 识别类</span><br><span class="line">4.1.4 类之间的关系</span><br><span class="line">4.2 使用预定义类</span><br><span class="line">4.2.1 对象与对象变量</span><br><span class="line">4.2.2 Java类库中的Gregorian—Calendar类</span><br><span class="line">4.2.3 更改器方法与访问器方法</span><br><span class="line">4.3 用户自定义类</span><br><span class="line">4.3.1 Employee类</span><br><span class="line">4.3.2 多个源文件的使用</span><br><span class="line">4.3.3 剖析Employee类</span><br><span class="line">4.3.4 从构造器开始</span><br><span class="line">4.3.5 隐式参数与显式参数</span><br><span class="line">4.3.6 封装的优点</span><br><span class="line">4.3.7 基于类的访问权限</span><br><span class="line">4.3.8 私有方法</span><br><span class="line">4.3.9 final实例域</span><br><span class="line">4.4 静态域与静态方法</span><br><span class="line">4.4.1 静态域</span><br><span class="line">4.4.2 静态常量</span><br><span class="line">4.4.3 静态方法</span><br><span class="line">4.4.4 工厂方法</span><br><span class="line">4.4.5 main方法</span><br><span class="line">4.5 方法参数</span><br><span class="line">4.6 对象构造</span><br><span class="line">4.6.1 重载</span><br><span class="line">4.6.2 默认域初始化</span><br><span class="line">4.6.3 无参数的构造器</span><br><span class="line">4.6.4 显式域初始化</span><br><span class="line">4.6.5 参数名</span><br><span class="line">4.6.6 调用另一个构造器</span><br><span class="line">4.6.7 初始化块</span><br><span class="line">4.6.8 对象析构与finalize方法</span><br><span class="line">4.7 包</span><br><span class="line">4.7.1 类的导入</span><br><span class="line">4.7.2 静态导入</span><br><span class="line">4.7.3 将类放入包中</span><br><span class="line">4.7.4 包作用域</span><br><span class="line">4.8 类路径</span><br><span class="line">4.9 文档注释</span><br><span class="line">4.9.1 注释的插入</span><br><span class="line">4.9.2 类注释</span><br><span class="line">4.9.3 方法注释</span><br><span class="line">4.9.4 域注释</span><br><span class="line">4.9.5 通用注释</span><br><span class="line">4.9.6 包与概述注释</span><br><span class="line">4.9.7 注释的抽取</span><br><span class="line">4.10 类设计技巧</span><br><span class="line">第5章 继承</span><br><span class="line">5.1 类、超类和子类</span><br><span class="line">5.1.1 继承层次</span><br><span class="line">5.1.2 多态</span><br><span class="line">5.1.3 动态绑定</span><br><span class="line">5.1.4 阻止继承：final类和方法</span><br><span class="line">5.1.5 强制类型转换</span><br><span class="line">5.1.6 抽象类</span><br><span class="line">5.1.7 受保护访问</span><br><span class="line">5.2 Object：所有类的超类</span><br><span class="line">5.2.1 equals方法</span><br><span class="line">5.2.2 相等测试与继承</span><br><span class="line">5.2.3 hashCode方法</span><br><span class="line">5.2.4 toString方法</span><br><span class="line">5.3 泛型数组列表</span><br><span class="line">5.3.1 访问数组列表元素</span><br><span class="line">5.3.2 类型化与原始数组列表的兼容性</span><br><span class="line">5.4 对象包装器与自动装箱</span><br><span class="line">5.5 参数数量可变的方法</span><br><span class="line">5.6 枚举类</span><br><span class="line">5.7 反射</span><br><span class="line">5.7.1 Class类</span><br><span class="line">5.7.2 捕获异常</span><br><span class="line">5.7.3 利用反射分析类的能力</span><br><span class="line">5.7.4 在运行时使用反射分析对象</span><br><span class="line">5.7.5 使用反射编写泛型数组代码</span><br><span class="line">5.7.6 调用任意方法</span><br><span class="line">5.8 继承设计的技巧</span><br><span class="line">第6章 接口与内部类</span><br><span class="line">6.1 接口</span><br><span class="line">6.1.1 接口的特性</span><br><span class="line">6.1.2 接口与抽象类</span><br><span class="line">6.2 对象克隆</span><br><span class="line">6.3 接口与回调</span><br><span class="line">6.4 内部类</span><br><span class="line">6.4.1 使用内部类访问对象状态</span><br><span class="line">6.4.2 内部类的特殊语法规则</span><br><span class="line">6.4.3 内部类是否有用、必要和安全</span><br><span class="line">6.4.4 局部内部类</span><br><span class="line">6.4.5 由外部方法访问final变量</span><br><span class="line">6.4.6 匿名内部类</span><br><span class="line">6.4.7 静态内部类</span><br><span class="line">6.5 代理</span><br><span class="line">第7章 图形程序设计</span><br><span class="line">7.1 Swing概述</span><br><span class="line">7.2 创建框架</span><br><span class="line">7.3 框架定位</span><br><span class="line">7.3.1 框架属性</span><br><span class="line">7.3.2 确定合适的框架大小</span><br><span class="line">7.4 在组件中显示信息</span><br><span class="line">7.5 处理2D图形</span><br><span class="line">7.6 使用颜色</span><br><span class="line">7.7 文本使用特殊字体</span><br><span class="line">7.8 显示图像</span><br><span class="line">第8章 事件处理</span><br><span class="line">8.1 事件处理基础</span><br><span class="line">8.1.1 实例：处理按钮点击事件</span><br><span class="line">8.1.2 建议使用内部类</span><br><span class="line">8.1.3 创建包含一个方法调用的监听器</span><br><span class="line">8.1.4 实例：改变观感</span><br><span class="line">8.1.5 适配器类</span><br><span class="line">8.2 动作</span><br><span class="line">8.3 鼠标事件</span><br><span class="line">8.4 AWT事件继承层次</span><br><span class="line">第9章 Swing用户界面组件</span><br><span class="line">9.1 Swing和模型—视图—控制器设计模式</span><br><span class="line">9.1.1 设计模式</span><br><span class="line">9.1.2 模型—视图—控制器模式</span><br><span class="line">9.1.3 Swing按钮的模型—视图—控制器分析</span><br><span class="line">9.2 布局管理概述</span><br><span class="line">9.2.1 边框布局</span><br><span class="line">9.2.2 网格布局</span><br><span class="line">9.3 文本输入</span><br><span class="line">9.3.1 文本域</span><br><span class="line">9.3.2 标签和标签组件</span><br><span class="line">9.3.3 密码域</span><br><span class="line">9.3.4 文本区</span><br><span class="line">9.3.5 滚动窗格</span><br><span class="line">9.4 选择组件</span><br><span class="line">9.4.1 复选框</span><br><span class="line">9.4.2 单选按钮</span><br><span class="line">9.4.3 边框</span><br><span class="line">9.4.4 组合框</span><br><span class="line">9.4.5 滑动条</span><br><span class="line">9.5 菜单</span><br><span class="line">9.5.1 菜单创建</span><br><span class="line">9.5.2 菜单项中的图标</span><br><span class="line">9.5.3 复选框和单选按钮菜单项</span><br><span class="line">9.5.4 弹出菜单</span><br><span class="line">9.5.5 快捷键和加速器</span><br><span class="line">9.5.6 启用和禁用菜单项</span><br><span class="line">9.5.7 工具栏</span><br><span class="line">9.5.8 工具提示</span><br><span class="line">9.6 复杂的布局管理</span><br><span class="line">9.6.1 网格组布局</span><br><span class="line">9.6.2 组布局</span><br><span class="line">9.6.3 不使用布局管理器</span><br><span class="line">9.6.4 定制布局管理器</span><br><span class="line">9.6.5 遍历顺序</span><br><span class="line">9.7 对话框</span><br><span class="line">9.7.1 选项对话框</span><br><span class="line">9.7.2 创建对话框</span><br><span class="line">9.7.3 数据交换</span><br><span class="line">9.7.4 文件对话框</span><br><span class="line">9.7.5 颜色选择器</span><br><span class="line">第10章 部署应用程序和applet</span><br><span class="line">10.1 JAR文件</span><br><span class="line">10.1.1 清单文件</span><br><span class="line">10.1.2 可运行JAR文件</span><br><span class="line">10.1.3 资源</span><br><span class="line">10.1.4 密封</span><br><span class="line">10.2 Java Web Start</span><br><span class="line">10.2.1 沙箱</span><br><span class="line">10.2.2 签名代码</span><br><span class="line">10.2.3 JNLP API</span><br><span class="line">10.3 applet</span><br><span class="line">10.3.1 一个简单的applet</span><br><span class="line">10.3.2 applet的HTML标记和属性</span><br><span class="line">10.3.3 object标记</span><br><span class="line">10.3.4 使用参数向applet传递信息</span><br><span class="line">10.3.5 访问图像和音频文件</span><br><span class="line">10.3.6 applet上下文</span><br><span class="line">10.4 应用程序首选项存储</span><br><span class="line">10.4.1 属性映射</span><br><span class="line">10.4.2 Preferences API</span><br><span class="line">第11章 异常、断言、日志和调试</span><br><span class="line">11.1 处理错误</span><br><span class="line">11.1.1 异常分类</span><br><span class="line">11.1.2 声明已检查异常</span><br><span class="line">11.1.3 如何抛出异常</span><br><span class="line">11.1.4 创建异常类</span><br><span class="line">11.2 捕获异常</span><br><span class="line">11.2.1 捕获多个异常</span><br><span class="line">11.2.2 再次抛出异常与异常链</span><br><span class="line">11.2.3 finally子句</span><br><span class="line">11.2.4 带资源的try语句</span><br><span class="line">11.2.5 分析堆栈跟踪元素</span><br><span class="line">11.3 使用异常机制的技巧</span><br><span class="line">11.4 使用断言</span><br><span class="line">11.4.1 启用和禁用断言</span><br><span class="line">11.4.2 使用断言完成参数检查</span><br><span class="line">11.4.3 为文档假设使用断言</span><br><span class="line">11.5 记录日志</span><br><span class="line">11.5.1 基本日志</span><br><span class="line">11.5.2 高级日志</span><br><span class="line">11.5.3 修改日志管理器配置</span><br><span class="line">11.5.4 本地化</span><br><span class="line">11.5.5 处理器</span><br><span class="line">11.5.6 过滤器</span><br><span class="line">11.5.7 格式化器</span><br><span class="line">11.5.8 日志记录说明</span><br><span class="line">11.6 调试技巧</span><br><span class="line">11.7 GUI程序排错技巧</span><br><span class="line">11.8 使用调试器</span><br><span class="line">……</span><br><span class="line">第12章 泛型程序设计</span><br><span class="line">第13章 集合</span><br><span class="line">第14章 多线程</span><br><span class="line">附录 Java关键字</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00G9KF4JC/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00G9KF4JC&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41%2BkAL9YJsL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java性能优化权威指南</title>
    <url>/2020/04/19/B00IOB0K1Q/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Java性能优化权威指南<br>作者信息： 作者: Charlie Hunt [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Java性能优化权威指南》由曾任职于Oracle/Sun的性能优化专家编写，系统而详细地讲解了性能优化的各个方面，帮助你学习Java虚拟机的基本原理、掌握一些监控Java程序性能的工具，从而快速找到程序中的性能瓶颈，并有效改善程序的运行性能。 Java性能优化的任何问题，都可以从本书中找到答案！</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目 　录 </span><br><span class="line"></span><br><span class="line"> 第1章　策略、方法和方法论　　1 1.1 　性能问题的现状　　1 1.2 　性能分析的两种方法：自顶向下和自底向上　　4 1.2.1 　自顶向下　　4 1.2.2 　自底向上　　5 1.3 　选择正确的平台并评估系统性能　　5 1.3.1 　选择正确的CPU架构　　6 1.3.2 　评估系统性能　　7 1.4 　参考资料　　7 第2章　操作系统性能监控　　8 2.1 　定义　　8 2.2 　CPU使用率　　9 2.2.1 　监控CPU使用率：Windows　　9 2.2.2 　监控CPU使用率：Windows typeperf　　12 2.2.3 　监控CPU使用率：Linux　　13 2.2.4 　监控CPU使用率：Solaris　　14 2.2.5 　命令行监控CPU使用率：Linux和Solaris　　16 2.3 　CPU调度程序运行队列　　19 2.3.1 　监控CPU调度程序运行队列：Windows　　19 2.3.2 　监控CPU调度程序运行队列：Solaris　　21 2.3.3 　监控CPU调度程序运行队列：Linux　　21 2.4 　内存使用率　　22 2.4.1 　监控内存利用率：Windows　　22 2.4.2 　监控内存使用率：Solaris　　23 2.4.3 　监控内存使用率：Linux　　24 2.4.4 　监控锁竞争：Solaris　　25 2.4.5 　监控锁竞争：Linux　　26 2.4.6 　监控锁竞争：Windows　　27 2.4.7 　隔离竞争锁　　27 2.4.8 　监控抢占式上下文切换　　27 2.4.9 　监控线程迁移　　28 2.5 　网络I&#x2F;O使用率　　28 2.5.1 　监控网络I&#x2F;O使用率：Solaris　　29 2.5.2 　监控网络I&#x2F;O使用率：Linux　　30 2.5.3 　监控网络I&#x2F;O使用率：Windows　　30 2.5.4 　应用性能改进的考虑　　31 2.6 　磁盘I&#x2F;O使用率　　31 2.7 　其他命令行工具　　34 2.8 　监控CPU使用率：SPARC T系列系统　　35 2.9 　参考资料　　36 第3章　JVM概览　　38 3.1 　HotSpot VM的基本架构　　38 3.2 　HotSpot VM运行时　　40 3.2.1 　命令行选项　　40 3.2.2 　VM生命周期　　41 3.2.3 　VM类加载　　44 3.2.4 　字节码验证　　46 3.2.5 　类数据共享　　47 3.2.6 　解释器　　48 3.2.7 　异常处理　　49 3.2.8 　同步　　50 3.2.9 　线程管理　　51 3.2.10 　C++堆管理　　53 3.2.11 　Java本地接口　　54 3.2.12 　VM致命错误处理　　55 3.3 　HotSpot VM垃圾收集器　　56 3.3.1 　分代垃圾收集　　56 3.3.2 　新生代　　58 3.3.3 　快速内存分配　　60 3.3.4 　垃圾收集器　　60 3.3.5 　Serial收集器　　61 3.3.6 　Parallel收集器：吞吐量为先！　　62 3.3.7　　Mostly-Concurrent收集器：低延迟为先！　　62 3.3.8　　Garbage-First收集器：CMS替代者　　64 3.3.9 　垃圾收集器比较　　64 3.3.10 　应用程序对垃圾收集器的影响　　65 3.3.11 　简单回顾收集器历史　　65 3.4 　HotSpot VM JIT编译器　　65 3.4.1 　类型继承关系分析　　67 3.4.2 　编译策略　　67 3.4.3 　逆优化　　68 3.4.4 　Client JIT编译器概览　　69 3.4.5 　Server JIT编译器概览　　69 3.4.6 　静态单赋值——程序依赖图　　69 3.4.7 　未来增强展望　　71 3.5 　HotSpot VM自适应调优　　71 3.5.1 　Java 1.4.2的默认值　　71 3.5.2 　Java 5自动优化的默认值　　71 3.5.3 　Java 6 Update 18更新后的默认优化值　　73 3.5.4 　自适应Java堆调整　　74 3.5.5 　超越自动优化　　75 3.6 　参考资料　　75 第4章　JVM性能监控　　77 4.1 　定义　　77 4.2 　垃圾收集　　78 4.2.1 　重要的垃圾收集数据　　78 4.2.2 　垃圾收集报告　　78 4.2.3 　垃圾收集数据的离线分析　　86 4.2.4 　图形化工具　　89 4.3 　JIT编译器　　103 4.4 　类加载　　104 4.5 　Java应用监控　　106 4.6 　参考资料　　109 第5章　Java应用性能分析　　110 5.1 　术语　　111 5.1.1 　通用性能分析术语　　111 5.1.2 　Oracle Solaris Studio Performance Analyzer术语　　112 5.1.3 　NetBeans Profiler术语　　112 5.2 　Oracle Solaris Studio Performance Analyzer　　112 5.2.1 　支持平台　　113 5.2.2 　下载&#x2F;安装Oracle Solaris Studio Performance Analyzer　　114 5.2.3 　使用Oracle Solaris Studio Performance Analyzer 抓取性能数据　　114 5.2.4 　查看性能数据　　118 5.2.5 　数据表示　　125 5.2.6 　过滤性能数据　　128 5.2.7 　命令行工具er_print　　129 5.3 　NetBeans Profiler　　135 5.3.1 　支持平台　　136 5.3.2 　下载安装NetBeans Profiler　　136 5.3.3 　开始方法分析会话　　137 5.3.4 　Controls子面板　　143 5.3.5 　Status子面板　　143 5.3.6 　Profiling Results子面板　　143 5.3.7 　Saved Snapshots子面板　　144 5.3.8 　View子面板　　144 5.3.9 　Basic Telemetry子面板　　144 5.3.10 　查看动态结果　　145 5.3.11 　对结果进行快照　　145 5.3.12 　启动内存分析会话　　146 5.3.13 　查看实时结果　　148 5.3.14 　对结果进行快照　　150 5.3.15 　定位内存泄漏　　150 5.3.16 　分析堆转储　　151 5.4 　参考资料　　152 第6章　Java应用性能分析技巧　　153 6.1 　性能优化机会　　153 6.2 　系统或内核态CPU使用　　154 6.3 　锁竞争　　161 6.4 　Volatile的使用　　171 6.5 　调整数据结构的大小　　172 6.5.1 　StringBuilder或StringBuffer大小的调整　　172 6.5.2 　Java Collection类大小调整　　175 6.6 　增加并行性　　179 6.7 　过高的CPU使用率　　181 6.8 　其他有用的分析提示　　182 6.9 　参考资料　　184 第7章　JVM性能调优入门　　185 7.1 　方法　　185 7.1.1 　假设条件　　187 7.1.2 　测试基础设施需求　　188 7.2 　应用程序的系统需求　　188 7.2.1 　可用性　　188 7.2.2 　可管理性　　188 7.2.3 　吞吐量　　189 7.2.4 　延迟及响应性　　189 7.2.5 　内存占用　　189 7.2.6 　启动时间　　189 7.3 　对系统需求分级　　190 7.4 　选择JVM部署模式　　190 7.4.1 　单JVM部署模式　　190 7.4.2 　多JVM部署模式　　190 7.4.3 　通用建议　　191 7.5 　选择JVM运行模式　　191 7.5.1 　Client模式或Server模式　　191 7.5.2 　32位&#x2F;64位 JVM　　192 7.5.3 　垃圾收集器　　192 7.6 　垃圾收集调优基础　　193 7.6.1 　性能属性　　193 7.6.2 　原则　　193 7.6.3 　命令行选项及GC日志　　194 7.7 　确定内存占用　　197 7.7.1 　约束　　197 7.7.2 　HotSpot VM堆的布局　　197 7.7.3 　堆大小调优着眼点　　200 7.7.4 　计算活跃数据大小　　201 7.7.5 　初始堆空间大小配置　　202 7.7.6 　其他考量因素　　203 7.8 　调优延迟&#x2F;响应性　　204 7.8.1 　输入　　205 7.8.2 　优化新生代的大小　　205 7.8.3 　优化老年代的大小　　207 7.8.4 　为CMS调优延迟　　210 7.8.5 　Survivor空间介绍　　212 7.8.6 　解析晋升阈值　　214 7.8.7 　监控晋升阈值　　215 7.8.8 　调整Survivor空间的容量　　216 7.8.9 　显式的垃圾收集　　222 7.8.10 　并发永久代垃圾收集　　223 7.8.11 　调优CMS停顿时间　　224 7.8.12 　下一步　　225 7.9 　应用程序吞吐量调优　　225 7.9.1 　CMS吞吐量调优　　225 7.9.2 　Throughput收集器调优　　226 7.9.3 　Survivor空间调优　　228 7.9.4 　调优并行垃圾收集线程　　231 7.9.5 　在NUMA系统上部署　　231 7.9.6 　下一步　　232 7.10 　极端示例　　232 7.11 　其他性能命令行选项　　232 7.11.1 　实验性（最近最大）优化　　232 7.11.2 　逃逸分析　　233 7.11.3 　偏向锁　　233 7.11.4 　大页面支持　　234 7.12 　参考资料　　236 第8章　Java应用的基准测试　　237 8.1 　基准测试所面临的挑战　　237 8.1.1 　基准测试的预热阶段　　238 8.1.2 　垃圾收集　　240 8.1.3 　使用Java Time接口　　240 8.1.4 　剔除无效代码　　241 8.1.5 　内联　　247 8.1.6 　逆优化　　251 8.1.7 　创建微基准测试的注意事项　　256 8.2 　实验设计　　257 8.3 　使用统计方法　　258 8.3.1 　计算均值　　258 8.3.2 　计算标准差　　258 8.3.3 　计算置信区间　　259 8.3.4 　使用假设测试　　260 8.3.5 　使用统计方法的注意事项　　262 8.4 　参考文献　　263 8.5 　参考资料　　263 第9章　多层应用的基准测试　　264 9.1 　基准测试难题　　264 9.2 　企业级应用基准测试的考量　　266 9.2.1 　定义被测系统　　266 9.2.2 　制定微基准测试　　266 9.2.3 　定义用户交互模型　　267 9.2.4 　定义性能指标　　270 9.2.5 　扩展基准测试　　273 9.2.6 　用利特尔法则验证　　274 9.2.7 　思考时间　　275 9.2.8 　扩展性分析　　278 9.2.9 　运行基准测试　　278 9.3 　应用服务器监控　　281 9.3.1 　GlassFish监控　　281 9.3.2 　监控子系统　　286 9.3.3 　Solaris　　287 9.3.4 　Linux　　288 9.3.5 　Windows　　288 9.3.6 　外部系统的性能　　289 9.3.7 　磁盘I&#x2F;O　　292 9.3.8 　监控和调优资源池　　293 9.4 　企业级应用性能分析　　294 9.5 　参考资料　　295 第10章　Web应用的性能调优　　297 10.1 　Web应用的基准测试　　298 10.2 　Web容器的组件　　298 10.2.1 　HTTP连接器　　299 10.2.2 　Servlet引擎　　300 10.3 　Web容器的监控和性能调优　　300 10.3.1 　容器的开发和生产模式　　300 10.3.2 　安全管理器　　301 10.3.3 　JVM调优　　301 10.3.4 　HTTP服务和Web容器　　303 10.3.5 　HTTP监听器　　303 10.4 　最佳实践　　315 10.4.1 　Servlet和JSP最佳实践　　315 10.4.2 　内容缓存　　324 10.4.3 　会话持久化　　328 10.4.4 　HTTP服务器文件缓存　　329 10.5 　参考资料　　333 第11章　Web Service的性能　　334 11.1 　XML的性能　　334 11.1.1 　XML处理的生命周期　　335 11.1.2 　解析&#x2F;解编组　　335 11.1.3 　访问　　338 11.1.4 　修改　　338 11.1.5 　序列化&#x2F;编组　　339 11.2 　验证　　339 11.3 　解析外部实体　　341 11.4 　XML文档的局部处理　　343 11.5 　选择合适的API　　346 11.6 　JAX-WS参考实现栈　　349 11.7 　Web Service基准测试　　350 11.8 　影响Web Service性能的因素　　353 11.8.1 　消息大小的影响　　353 11.8.2 　不同Schema类型的性能特征　　355 11.8.3 　终端服务器的实现　　358 11.8.4 　处理程序的性能　　359 11.9 　最佳性能实践　　361 11.9.1 　二进制负载的处理　　361 11.9.2 　处理XML文档　　365 11.9.3 　使用MTOM发送XML文档　　365 11.9.4 　使用Provider接口　　368 11.9.5 　快速信息集　　370 11.9.6 　HTTP压缩　　372 11.9.7 　Web Service客户端的性能　　373 11.10 　参考资料　　374 第12章　Java持久化及Enterprise Java Bean的性能　　375 12.1 　EJB编程模型　　376 12.2 　Java持久化API及其参考实现　　376 12.3 　监控及调优EJB容器　　379 12.3.1 　线程池　　380 12.3.2 　Bean池和缓存　　382 12.3.3 　EclipseLink会话缓存　　385 12.4 　事务隔离级　　386 12.5 　Enterprise Java Bean的最佳实践　　387 12.5.1 　简要说明使用的EJB基准测试　　387 12.5.2 　EJB 2.1　　388 12.5.3 　EJB 3.0　　400 12.6 　Java持久化最佳实践　　403 12.6.1 　JPA查询语言中的查询　　403 12.6.2 　查询结果缓存　　405 12.6.3 　FetchType　　406 12.6.4 　连接池　　408 12.6.5 　批量更新　　409 12.6.6 　选择正确的数据库锁策略　　411 12.6.7 　不带事务的读取　　411 12.6.8 　继承　　411 12.7 　参考资料　　412 附录A 　重要的HotSpot VM选项　　413 附录B 　性能分析技巧示例源代码　　429 B.1 　锁竞争实现1　　429 B.2 　锁竞争实现2　　439 B.3 　锁竞争实现3　　449 B.4 　锁竞争实现4　　459 B.5 　锁竞争实现5　　469 B.6 　调整容量变化1　　481 B.7 　调整容量变化2　　492 B.8 　增加并发性的单线程实现　　504 B.9 　增加并发性的多线程实现　　514</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00IOB0K1Q/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00IOB0K1Q&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51IUUwmNkVL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript启示录</title>
    <url>/2020/04/19/B00IR39PNU/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： JavaScript启示录<br>作者信息： 作者: Cody Lindley [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《JavaScript启示录》无关于JavaScript设计模式，也无关于JavaScript面向对象代码实现。《JavaScript启示录》意图通过考察原生JavaScript对象和不同环境对原生对象的支持和细微差别。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目　录 </span><br><span class="line"></span><br><span class="line"> 第1章　JavaScript对象　1 1.1　创建对象　1 1.2　JavaScript构造函数构建并返回对象实例　6 1.3　JavaScript原生&#x2F;内置对象构造函数　7 1.4　用户自定义&#x2F;非原生对象构造函数　8 1.5　使用new　操作符实例化构造函数　10 1.6　从构造函数创建字面量值　11 1.7　原始值(或简单值)　13 1.8　null、undefined、“string”、10、true和false等原始值不是对象　14 1.9　如何存储和复制原始值　15 1.10　原始值比较采用值比较　16 1.11　原始值(String、Number、Boolean)在被用做对象时就像对象　17 1.12　复杂值(或组合值)　18 1.13　如何存储或复制复杂值　19 1.14　复杂对象比较采用引用比较　20 1.15　复杂对象具有动态属性　21 1.16　typeof操作符　21 1.17　动态属性支持易变对象　23 1.18　构造函数实例都拥有指向其构造函数的Constructor属性　24 1.19　验证对象是否是特定构造函数的实例　26 1.20　构造函数创建的实例可拥有自己独立的属性(实例属性)　27 1.21　JavaScript对象和Object()对象　28</span><br><span class="line"></span><br><span class="line"> 第2章　对象与属性　29 2.1　复杂对象可以将大多数JavaScript值作为属性　29 2.2　封装复杂对象　30 2.3　用点表示法或中括号表示法获取&#x2F;设置&#x2F;更新对象属性　31 2.4　删除对象属性　34 2.5　如何解决对象属性的引用　34 2.6　使用hasOwnProperty验证对象属性不是来自原型链　37 2.7　使用in操作符检查一个对象是否包含给定属性　37 2.8　使用for in循环枚举(循环遍历)对象的属性　38 2.9　宿主对象与原生对象　39 2.10　使用Underscore.js增强及扩展对象　40</span><br><span class="line"></span><br><span class="line"> 第3章　Object()　43 3.1　Object()对象概要　43 3.2　Object()参数　44 3.3　Object()属性和方法　45 3.4　Object()对象实例属性和方法　45 3.5　使用对象字面量创建Object()对象　46 3.6　所有对象都继承自Object.prototype　47</span><br><span class="line"></span><br><span class="line"> 第4章　Function()　49 4.1　Function()对象概要　49 4.2　Function()参数　50 4.3　Function()属性和方法　50 4.4　Function对象实例属性和方法　51 4.5　函数总有返回值　51 4.6　函数是“一等公民”(不仅语法，还有值)　52 4.7　函数的参数传递　53 4.8　this和arguments适用于所有函数　53 4.9　arguments.callee属性　54 4.10　函数实例的length属性和arguments.length　55 4.11　重定义函数参数　55 4.12　代码执行完成前取消函数执行　56 4.13　定义函数(语句、表达式或构造函数)　57 4.14　调用函数[函数、方法、构造函数或call()和apply()]　57 4.15　匿名函数　59 4.16　自调用的函数表达式　59 4.17　自调用的匿名函数语句　59 4.18　函数可以嵌套　60 4.19　给函数传递函数，从函数返回函数　61 4.20　函数定义之前调用(函数提升)　61 4.21　函数可以调用自身(递归)　62</span><br><span class="line"></span><br><span class="line"> 第5章　head&#x2F;全局对象　64 5.1　head&#x2F;全局对象概要　64 5.2　head对象内的全局函数　65 5.3　head对象与全局属性、全局变量　65 5.4　引用head对象　67 5.5　head对象是隐式的，通常不显式引用　67</span><br><span class="line"></span><br><span class="line"> 第6章　this关键字　69 6.1　this概要及this如何引用对象　69 6.2　如何确定this值　70 6.3　在嵌套函数中用this关键字引用head对象　71 6.4　充分利用作用域链研究嵌套函数问题　73 6.5　使用call()或apply()控制this值　73 6.6　在用户自定义构造函数内部使用this关键字　75 6.7　原型方法内的this关键字引用构造函数实例　75</span><br><span class="line"></span><br><span class="line"> 第7章　作用域和闭包　77 7.1　JavaScript作用域概要　77 7.2　JavaScript没有块作用域　78 7.3　在函数中用var声明变量，避免作用域陷阱　78 7.4　作用域链(词法作用域)　79 7.5　作用域链查找返回第一轮值　81 7.6　函数定义时确定作用域，而非调用时确定　81 7.7　闭包是由作用域链引起的　82</span><br><span class="line"></span><br><span class="line"> 第8章　函数原型属性　84 8.1　原型链概要　84 8.2　为何要关注prototype属性　85 8.3　原型在所有function()实例上都是标准的　85 8.4　默认的prototype属性是Object()对象　86 8.5　将构造函数创建的实例链接至构造函数的prototype属性　87 8.6　原型链的最后是Object.prototype　88 8.7　原型链返回在链中找到的第一个匹配结果　88 8.8　用新对象替换prototype属性会删除默认构造函数属性　89 8.9　继承原型属性的实例总是能够获得最新值　90 8.10　用新对象替换prototype属性不会更新以前的实例　91 8.11　用户自定义构造函数像原生构造函数一样原型继承　92 8.12　创建继承链　94</span><br><span class="line"></span><br><span class="line"> 第9章　Array()　95 9.1　Array()对象概要　95 9.2　Array()参数　96 9.3　Array()属性和方法　96 9.4　数组对象实例属性和方法　96 9.5　创建数组　97 9.6　数组添加及更新　98 9.7　长度与索引　99 9.8　定义预定义长度的数组　100 9.9　可以通过设置数组长度添加或删除值　100 9.10　数组包含数组(多维数组)　101 9.11　遍历数组　101</span><br><span class="line"></span><br><span class="line"> 第10章　String()　103 10.1　String()对象概要　103 10.2　String()参数　104 10.3　String()属性和方法　104 10.4　字符串对象实例属性和方法　104</span><br><span class="line"></span><br><span class="line"> 第11章　Number()　106 11.1　Number()对象概要　106 11.2　整数和浮点数　106 11.3　Number()参数　107 11.4　Number()属性　108 11.5　数字对象实例属性和方法　108</span><br><span class="line"></span><br><span class="line"> 第12章　Boolean()　109 12.1　Boolean()对象概要　109 12.2　Boolean()参数　109 12.3　Boolean()属性和方法　110 12.4　布尔对象实例属性和方法　110 12.5　非原始false布尔对象转换为true　111 12.6　某些值是false，其他都是true　111</span><br><span class="line"></span><br><span class="line"> 第13章　使用原始值：字符串、数字和布尔值　113 13.1　访问属性时原始值&#x2F;字面量值被转换为对象　113 13.2　通常应使用原始字符串、数字和布尔值　115</span><br><span class="line"></span><br><span class="line"> 第14章　null　116 14.1　null值概要　116 14.2　typeof(null)的返回值为“object”　116</span><br><span class="line"></span><br><span class="line"> 第15章　undefined　118 15.1　undefined值概要　118 15.2　在全局作用域中定义undefined变量　119</span><br><span class="line"></span><br><span class="line"> 第16章　Math函数　120 16.1　内置Math对象概要　120 16.2　Math属性和方法　120 16.3　Math不是构造函数　122 16.4　Math常数无法增大&#x2F;改变　122</span><br><span class="line"></span><br><span class="line"> 附录A　回顾　123 附录B　总结　126</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00IR39PNU/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00IR39PNU&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41SuaSVGqaL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>精通Ext JS</title>
    <url>/2020/04/19/B00IY9F2CA/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 精通Ext JS<br>作者信息： 作者: Loiane Groner [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>花旗银行软件开发经理、IBM系统分析师8年工作经验总结汇聚Java用户组领导者的精粹技巧每章一个任务，分模块细析应用开发</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目　录 </span><br><span class="line"></span><br><span class="line"> 第1章　启程　1 1.1　安装所需软件　1 1.2　展示应用及其功能　3 1.2.1　启动界面　3 1.2.2　登录界面　4 1.2.3　主界面　4 1.2.4　用户控制管理　5 1.2.5　MySQL数据库表管理　5 1.2.6　内容管理控制　6 1.2.7　电子邮件客户端模块　7 1.3　用MVC创建应用框架　8 1.3.1　MVC简介　8 1.3.2　创建应用　9 1.4　创建加载页面　14 1.5　小结　19</span><br><span class="line"></span><br><span class="line"> 第2章　登录界面　20 2.1　登录界面　20 2.2　创建登录界面　21 2.2.1　客户端验证　24 2.2.2　添加带有按钮的工具栏　26 2.2.3　运行代码　27 2.2.4　itemId还是id：Ext.Cmp的问题　28 2.3　创建登录控制器　28 2.3.1　在app.js中添加控制器　29 2.3.2　监听按钮点击事件　30 2.4　创建用户和用户组表　38 2.5　服务器端的登录界面处理　39 2.5.1　连接数据库　39 2.5.2　login.php　40 2.5.3　处理服务器端的返回结果——登录与否　42 2.6　优化登录界面　45 2.6.1　进行认证时为表单提供一个加载遮罩　45 2.6.2　回车提交表单　46 2.6.3　大写键提醒信息　46 2.7　小结　50</span><br><span class="line"></span><br><span class="line"> 第3章　注销与多语言支持　51 3.1　基本应用界面　51 3.2　注销功能　54 3.2.1　重构登录和注销代码　56 3.2.2　服务器端注销功能　58 3.2.3　客户端行为监控　58 3.3　多语言支持　59 3.3.1　创建语言转换组件　60 3.3.2　创建转换文件　62 3.3.3　使用转换信息　63 3.3.4　HTML5本地存储　63 3.3.5　实时的语言切换　64 3.3.6　本地化：Ext JS语言转换　67 3.4　小结　67</span><br><span class="line"></span><br><span class="line"> 第4章　动态菜单高级应用　68 4.1　创建动态菜单　68 4.1.1　数据库模型：用户组、菜单及权限　69 4.1.2　创建菜单模型：hasMany绑定　70 4.1.3　创建数据存储器：通过服务器端加载菜单　73 4.1.4　在服务器端处理动态菜单　73 4.1.5　用折叠面板和树形面板创建菜单　76 4.1.6　在视见区替换中央区域容器　76 4.1.7　创建菜单控制器　77 4.1.8　改动app.js　80 4.2　小结　81</span><br><span class="line"></span><br><span class="line"> 第5章　用户鉴权与安全　82 5.1　用户管理　82 5.2　列出所有用户：简单的网格面板　83 5.2.1　用户模型　83 5.2.2　用户存储器　84 5.2.3　用户网格面板　85 5.2.4　用户控制器　88 5.3　添加和编辑用户　89 5.3.1　创建编辑视图：窗体里的表单　89 5.3.2　用户组模型　93 5.3.3　用户组集模型　93 5.3.4　控制器：监听Add按钮事件　94 5.3.5　控制器：监听Edit按钮事件　95 5.3.6　控制器：保存用户信息　96 5.3.7　控制器：监听Cancel按钮　97 5.3.8　在上传之前预览文件　98 5.4　删除用户　99 5.5　小结　101</span><br><span class="line"></span><br><span class="line"> 第6章　MySQL数据库表管理　102 6.1　呈现数据库表　102 6.2　创建模型　104 6.2.1　抽象模型　104 6.2.2　特定模型　105 6.3　创建存储器　106 6.3.1　抽象存储器　107 6.3.2　抽象代理类　107 6.3.3　特定存储器　111 6.4　创建菜单项　112 6.5　创建重用的抽象网格面板　113 6.5.1　用MVC架构模式处理操作列　118 6.5.2　在操作列用iconCls属性取代icon属性　118 6.5.3　比较即席搜索插件与过滤插件　119 6.5.4　对应每张数据库表的特定网格面板　120 6.6　通用控制器　121 6.6.1　在网格渲染时加载网格面板　122 6.6.2　在网格面板上添加记录　123 6.6.3　编辑存在记录　124 6.6.4　删除：在控制器中处理操作列　125 6.6.5　保存变更　125 6.6.6　取消变更　127 6.6.7　清除过滤器　127 6.6.8　在控制器中监听存储器事件　128 6.7　小结　128</span><br><span class="line"></span><br><span class="line"> 第7章　内容管理　129 7.1　管理影片、客户和租借信息　129 7.2　呈现影片数据网格　133 7.2.1　影片模型　133 7.2.2　影片存储器　133 7.2.3　带分页功能的影片数据网格　135 7.2.4　创建控制器　141 7.3　影片网格面板编辑功能　142 7.3.1　Packt.view.sakila.WindowForm　147 7.3.2　影片类别　149 7.3.3　演员信息　154 7.4　影片控制器　159 7.4.1　在编辑表单中加载已有影片信息　159 7.4.2　获取MultiSelect组件值　160 7.4.3　通过即席搜索获取所选演员　161 7.5　小结　162</span><br><span class="line"></span><br><span class="line"> 第8章　添加额外功能　163 8.1　将网格面板信息导出成PDF和Excel格式　163 8.1.1　导出成PDF格式　164 8.1.2　导出成Excel格式　166 8.2　通过网格打印插件打印网格面板内容　166 8.3　创建影片类别销售图　168 8.3.1　饼图　169 8.3.2　柱状图　170 8.3.3　图表面板　172 8.3.4　更改图表类型　175 8.3.5　图表导出成图片格式(PNG和SVG)　176 8.3.6　图表导出成PDF格式　177 8.4　小结　179</span><br><span class="line"></span><br><span class="line"> 第9章　电子邮件客户端模块　180 9.1　创建收件箱：邮件列表　180 9.1.1　邮件信息模型　181 9.1.2　邮件信息存储器　181 9.1.3　邮件列表视图　182 9.1.4　邮件预览面板　186 9.2　邮件菜单(树形菜单)　187 9.2.1　树形邮件菜单存储器　187 9.2.2　创建邮件菜单视图　188 9.3　邮件容器：组织电子邮件客户端　189 9.4　控制器　191 9.5　组织电子邮件：拖放　193 9.6　创建新邮件　195 9.6.1　动态呈现Cc和Bcc字段　197 9.6.2　动态添加文件上传字段　198 9.7　小结　199</span><br><span class="line"></span><br><span class="line"> 第10章　产品化准备　200 10.1　开始之前　200 10.2　自定义主题　201 10.3　为产品发布打包应用　206 10.3.1　发布成产品的内容　208 10.3.2　产品化的优点　209 10.4　从Web到桌面：Sencha Desktop Packager　210 10.4.1　安装Sencha Desktop Packager　210 10.4.2　应用打包　214 10.4.3　服务器端代码调整　216 10.5　小结　219</span><br><span class="line"></span><br><span class="line"> 第11章　创建WordPress主题　220 11.1　安装WordPress　220 11.2　WordPress主题简介　222 11.3　组织主题结构　223 11.4　构建头部　225 11.5　构建页脚　229 11.6　构建主页面　230 11.7　构建侧边栏　232 11.8　构建单一文章页面　237 11.9　构建单一页面　238 11.10　小结　238</span><br><span class="line"></span><br><span class="line"> 第12章　调试与测试　239 12.1　调试Ext JS应用程序　239 12.2　测试Ext JS应用程序　241 12.2.1　使用Sencha command生成“测试”构造　242 12.2.2　安装Siesta并创建测试用例　243 12.3　有用的工具箱　247 12.4　从Ext JS应用到移动应用　249 12.5　第三方组件和插件　250 12.6　小结　250</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00IY9F2CA/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00IY9F2CA&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="/images/posts/Mastering_Ext_JS.jpg"/></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Node学习指南</title>
    <url>/2020/04/19/B00IR39QMK/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Node学习指南<br>作者信息： 作者: Shelley Powers [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>■ 探索Node独特的异步开发的实现方式；■ 使用Express架构和Connect中间件构建Node应用示例；■ 使用NoSQL解决方案，比如Redis和MongoDB，探索Node的关系数据库模块；■ 使用PDF文件，提供HTML5媒体，使用Canvas创建图形；■ 使用WebSockets创建浏览器和服务器的双向通信；■ 深入学习如何调试和测试程序；■ 在云服务器或者自己的系统上部署Node应用程序。    精彩的内容将帮助你将Web开发技能从浏览器端转向Node服务器，并且学习如何使用Node这种基于JavaScript的平台编写出快速和高可扩展性的网络应用。你可以快速掌握Node的核心技能，获得使用内建和扩展模块的经验，并了解客户端编程和服务器端编程的不同和相同之处。如果你喜欢使用JavaScript，书中提供了很多代码和开发的示例来帮助你学习Node服务器端的开发。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目　录 </span><br><span class="line"></span><br><span class="line"> 第1章　Node.js：启动与运行　1 1.1　搭建Node开发环境　2 1.1.1　Linux(Ubuntu)下安装Node　2 1.1.2　Windows 7平台下Node+WebMatrix　4 1.1.3　升级Node　8 1.2　开始Node开发　9 1.2.1　Hello, World in Node　9 1.2.2　分析“Hello,World”　11 1.3　异步函数及Node事件循环　13 1.3.1　使用异步方式读取文件　14 1.3.2　观察异步程序流程　15 1.4　Node的优势　19</span><br><span class="line"></span><br><span class="line"> 第2章　Node与REPL　20 2.1　REPL：先睹为快和未定义的表达式　20 2.2　REPL的优势：更好地理解表层之下的JavaScript　22 2.3　多行以及更复杂的JavaScript　23 2.3.1　REPL命令　26 2.3.2　REPL和rlwrap　27 2.3.3　定制REPL　28 2.4　不可预计的意外——记得经常保存　32</span><br><span class="line"></span><br><span class="line"> 第3章　Node核心库　33 3.1　全局对象：global、process和Buffer　34 3.1.1　global　34 3.1.2　process　36 3.1.3　Buffer　38 3.2　定时器：setTimeout、clearTimeout、setInterval 和clearInterval　39 3.3　Servers、Streams和Sockets　40 3.3.1　TCP Sockets和Servers　41 3.3.2　HTTP　43 3.3.3　UDP数据报套接字　45 3.3.4　流、管道和Readline　47 3.4　子进程　49 3.4.1　child_process.spawn　50 3.4.2　child_process.exec和child_process.execFile　52 3.4.3　child_process.fork　52 3.4.4　在Windows系统中使用子进程　53 3.5　域名解析和URL处理　54 3.6　Utilities模块和对象继承　55 3.7　Events和EventEmitter　59</span><br><span class="line"></span><br><span class="line"> 第4章　Node模块系统　63 4.1　使用require和默认路径加载模块　63 4.2　外部模块和Node包管理工具　65 4.3　如何找到你需要的模块　69 4.3.1　Colors：简单至上　71 4.3.2　Optimist：另一个简单的小模块　73 4.3.3　Underscore　74 4.4　创建自定义模块　75 4.4.1　打包整个目录　76 4.4.2　为你的模块发布做准备　76 4.4.3　发布模块　80</span><br><span class="line"></span><br><span class="line"> 第5章　控制流、异步模式和异常处理　82 5.1　使用Callback而不使用Promises　82 5.2　顺序调用、嵌套回调、异常捕获　85 5.3　异步模式和控制流模块　92 5.3.1　Step　93 5.3.2　Async　96 5.4　Node编码风格　101</span><br><span class="line"></span><br><span class="line"> 第6章　路由寻址、服务文件和中间件　103 6.1　从头开始：创建一个简单的静态文件服务器　103 6.2　中间件　110 6.2.1　Connect基本知识　111 6.2.2　Connect中间件　113 6.2.3　定制Connect中间件　118 6.3　Routers　121 6.4　Proxies　124</span><br><span class="line"></span><br><span class="line"> 第7章　Express框架　128 7.1　Express：启动和运行　129 7.2　app.js文件　130 7.3　错误处理　133 7.4　Express与Connect的关系　134 7.5　路由　135 7.5.1　路由路径　137 7.5.2　路由和HTTP动词　140 7.6　关于MVC　147 7.7　使用cURL测试Express应用程序　152</span><br><span class="line"></span><br><span class="line"> 第8章　Express、模板系统和CSS　154 8.1　EJS模板系统(Embedded JavaScript Template System)　154 8.1.1　基本语法　155 8.1.2　Node与EJS　156 8.1.3　EJS与Node Filters　158 8.2　在Express中使用EJS　159 8.2.1　多对象环境的改造　161 8.2.2　静态文件路由　162 8.2.3　处理一个新对象的Post请求　164 8.2.4　Widget索引和生成picklist　166 8.2.5　显示单个对象并确认对象的删除操作　168 8.2.6　提供更新信息的表达以及处理PUT请求　170 8.3　Jade模板系统　173 8.3.1　Jade语法简介　173 8.3.2　使用block和extends模块化视图模板　176 8.3.3　Widget View转换为Jade模板　178 8.3.4　转换edit和delete表单　179 8.4　使用Stylus完成简单的CSS样式　182</span><br><span class="line"></span><br><span class="line"> 第9章　结构化数据、Noe和Redis　187 9.1　Node和Redis　188 9.2　构建游戏得分排行榜　190 9.3　创建消息队列　197 9.4　为Express应用程序添加统计中间件　201</span><br><span class="line"></span><br><span class="line"> 第10章　Node和MongoDB：文档中心数据　206 10.1　MongoDB Native Node.js Driver(MongoDB原生Node.js驱动)　207 10.1.1　MongoDB入门　207 10.1.2　定义、创建以及销毁MongoDB Collection　208 10.1.3　为Collection添加数据　209 10.1.4　查询数据　212 10.1.5　使用Updates、Upserts、Find和Remove　216 10.2　使用Mongoose实现Widget模块　221 10.3 重构Widget工厂　222 10.4　添加MongoDB后台　223</span><br><span class="line"></span><br><span class="line"> 第11章　Node与关系型数据库　228 11.1　db-mysql入门　229 11.1.1　查询字符串和方法链　229 11.1.2　使用查询字符串更新数据库　233 11.1.3　使用方法链更新数据库　235 11.2　使用node-mysql实现本地MySQL访问　237 11.2.1　使用node-mysql做基本的CRUD操作　237 11.2.2　MySQL事务与mysql-queues　239 11.3　ORM与Sequelize　241 11.3.1　定义模型　241 11.3.2　ORM风格的CRUD实现　243 11.3.3　添加多个对象　246 11.3.4　从关系型到ORM　247</span><br><span class="line"></span><br><span class="line"> 第12章　图形和HTML5 Video　248 12.1　创建和使用PDF　248 12.1.1　使用子进程访问PDF工具　249 12.1.2　使用PDFKit创建PDF　257 12.2　从子进程访问ImageMagick　258 12.3　通过HTTP提供HTML5 Video服务　263 12.4　创建和流化画布内容(Canvas Content)　267</span><br><span class="line"></span><br><span class="line"> 第13章　WebSockets和Socket.IO　271 13.1　WebSockets　271 13.2　Socket.IO简介　272 13.2.1　一个简单的通信范例　273 13.2.2　异步世界里的WebSockets　276 13.2.3　关于客户端代码　277 13.3　配置Socket.IO　278 13.4　Chat：WebSockets版本的“Hello, World”　279 13.5　在Express中使用Socket.IO　282</span><br><span class="line"></span><br><span class="line"> 第14章　Node应用程序的测试和调试　284 14.1　调试　284 14.1.1　Node.js Debugger　284 14.1.2　使用Node Inspector的客户端调试　287 14.2　单元测试(Unit Testing)　289 14.2.1　Assert与单元测试　289 14.2.2　Nodeunit与单元测试　293 14.2.3　其他测试框架　295 14.3　验收测试　299 14.3.1　Soda和Selenium测试　299 14.3.2　通过Tobi和Zombie模拟浏览器　303 14.4　性能测试：基准问题和负载测试　304 14.4.1　ApacheBench基准测试　305 14.4.2　Nodeload与负载测试　309 14.5　Nodemon更新代码　312</span><br><span class="line"></span><br><span class="line"> 第15章　安全及防护　313 15.1　数据加密　314 15.1.1　TSL&#x2F;SSL配置　314 15.1.2　使用HTTPS　315 15.1.3　如何安全的保存密码　317 15.2　认证&#x2F;授权及Passport　320 15.2.1　授权&#x2F;认证策略：Oauth、OpenID、用户名&#x2F;密码验证　321 15.2.2　Local Passport Strategy　323 15.2.3　Twitter Passport Strategy(OAuth)　330 15.3　保护应用程序，防止攻击　336 15.3.1　不要使用eval　336 15.3.2　尽量使用复选框、单选按钮和下拉式选项　337 15.3.3　使用node-validator　337 15.4　在沙箱中执行代码　339</span><br><span class="line"></span><br><span class="line"> 第16章　扩展和部署Node应用　343 16.1　把你的节点部署到服务器上　343 16.1.1　编写package.json文件　344 16.1.2　使用Forever让你的应用“永不掉线”　347 16.1.3　使用Node和Apache　350 16.1.4　改善性能　352 16.2　部署到云服务　352 16.2.1　通过Cloud9 IDE部署到Windows Azure　353 16.2.2　Joyent Development SmartMachine　355 16.2.3　Heroku　355 16.2.4　Amazon EC2　356 16.2.5　Nodejitsu　356</span><br><span class="line"></span><br><span class="line"> 附录　Node、Git和GitHub　357</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00IR39QMK/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00IR39QMK&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/417xoGMvZVL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员的职业素养</title>
    <url>/2020/04/19/cheng-xu-yuan-de-zhi-ye-su-yang/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 程序员的职业素养<br>作者信息： 作者: Robert C.Martin [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《程序员的职业素养》是编程大师 Robert C. Martin40余年编程生涯的心得体会, 讲解成为真正专业的程序员需要什么样的态度、原则，需要采取什么样的行动。Robert C. Martin以自己以及身边的同事走过的弯路、犯过的错误为例，意在为后来人引路，助其职业生涯迈上更高台阶。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 专业主义</span><br><span class="line">1.1 清楚你要什么</span><br><span class="line">1.2 担当责任</span><br><span class="line">1.3 首先，不行损害之事</span><br><span class="line">1.3.1 不要破坏软件功能</span><br><span class="line">1.3.2 不要破坏结构</span><br><span class="line">1.4 职业道德</span><br><span class="line">1.4.1 了解你的领域</span><br><span class="line">1.4.2 坚持学习</span><br><span class="line">1.4.3 练习</span><br><span class="line">1.4.4 合作</span><br><span class="line">1.4.5 辅导</span><br><span class="line">1.4.6 了解业务领域</span><br><span class="line">1.4.7 与雇主&#x2F;客户保持一致</span><br><span class="line">1.4.8 谦逊</span><br><span class="line">1.5 参考文献</span><br><span class="line">第2章 说“不”</span><br><span class="line">2.1对抗角色</span><br><span class="line">2.2高风险时刻</span><br><span class="line">2.3要有团队精神</span><br><span class="line">2.3.1试试看</span><br><span class="line">2.3.2消极对抗</span><br><span class="line">2.4说“是”的成本</span><br><span class="line">2.5如何写出好代码</span><br><span class="line">第3章说“是”</span><br><span class="line">3.1承诺用语</span><br><span class="line">3.1.1识别“缺乏承诺”的征兆</span><br><span class="line">3.1.2真正的承诺听起来是怎样的</span><br><span class="line">3.1.3 总结</span><br><span class="line">3.2学习如何说“是”</span><br><span class="line">3.2.1 “试试”的另一面</span><br><span class="line">3.2.2 坚守原则</span><br><span class="line">3.3结论</span><br><span class="line">第4章编码</span><br><span class="line">4.1做好准备</span><br><span class="line">4.1.1 凌晨3点写出的代码</span><br><span class="line">4.1.2焦虑时写下的代码</span><br><span class="line">4.2流态区</span><br><span class="line">4.2.1 音乐</span><br><span class="line">4.2.2 中断</span><br><span class="line">4.3 阻塞</span><br><span class="line">4.4调试</span><br><span class="line">4.5保持节奏</span><br><span class="line">4.5.1知道何时应该离开一会</span><br><span class="line">4.5.2开车回家路上</span><br><span class="line">4.5.3 洗澡</span><br><span class="line">4.6进度延迟</span><br><span class="line">4.6.1期望</span><br><span class="line">4.6.2盲目冲刺</span><br><span class="line">4.6.3加班加点</span><br><span class="line">4.6.4交付失误</span><br><span class="line">4.6.5定义“完成”</span><br><span class="line">4.7帮助</span><br><span class="line">4.7.1帮助他人</span><br><span class="line">4.7.2接受他人的帮助</span><br><span class="line">4.7.3 辅导</span><br><span class="line">4.8参考文献</span><br><span class="line">第5章测试驱动开发</span><br><span class="line">5.1此事已有定论</span><br><span class="line">5.2 TDD的三项法则</span><br><span class="line">5.3 TDD的优势</span><br><span class="line">5.3.1 确定性</span><br><span class="line">5.3.2缺陷注入率</span><br><span class="line">5.3.3 勇气</span><br><span class="line">5.3.4 文档</span><br><span class="line">5.3.5设计</span><br><span class="line">5.3.6、专业人士的选择</span><br><span class="line">5.4 TDD的局限</span><br><span class="line">5.5参考文献</span><br><span class="line">第6章练习</span><br><span class="line">6.1 引子</span><br><span class="line">6.1.1 10的22次方</span><br><span class="line">6.1.2转变</span><br><span class="line">6.2编程柔道场</span><br><span class="line">6.2.1 卡塔</span><br><span class="line">6.2.2瓦萨</span><br><span class="line">6.2.3 自由练习</span><br><span class="line">6.3 自身经验的拓展</span><br><span class="line">6.3.1 开源</span><br><span class="line">6.3.2 关于练习的职业道德</span><br><span class="line">6.4结论</span><br><span class="line">6.5参考文献</span><br><span class="line">第7章验收测试</span><br><span class="line">7.1需求的沟通</span><br><span class="line">7.1.1过早精细化</span><br><span class="line">7.1.2迟来的模糊性</span><br><span class="line">7.2验收测试</span><br><span class="line">7.2.1 “完成”的定义</span><br><span class="line">7.2.2 沟通</span><br><span class="line">7.2.3 自动化</span><br><span class="line">7.2.4额外工作</span><br><span class="line">7.2.5验收测试什么时候写，由谁来写</span><br><span class="line">7.2.6开发人员的角色</span><br><span class="line">7.2.7测试的协商与被动推进</span><br><span class="line">7.2.8验收测试和单元测试</span><br><span class="line">7.2.9 图形界面及其他复杂因素</span><br><span class="line">7.2.10持续集成</span><br><span class="line">7.3结论</span><br><span class="line">第8章测试策略</span><br><span class="line">8.1 QA应该找不到任何错误</span><br><span class="line">8.1.1 QA也是团队的一部分</span><br><span class="line">8.1.2需求规约定义者</span><br><span class="line">8.1.3特性描述者</span><br><span class="line">8.2自动化测试金字塔</span><br><span class="line">8.2.1 单元测试</span><br><span class="line">8.2.2组件测试</span><br><span class="line">8.2.3集成测试</span><br><span class="line">8.2.4 系统溺4试</span><br><span class="line">8.2.5人工探索式测试</span><br><span class="line">8.3结论</span><br><span class="line">8.4参考文献</span><br><span class="line">第9章时间管理</span><br><span class="line">9.1 会议</span><br><span class="line">9.1.1拒绝</span><br><span class="line">9.1.2 离席</span><br><span class="line">9.1.3确定议程与目标</span><br><span class="line">9.1.4立会</span><br><span class="line">9.1.5迭代计划会议</span><br><span class="line">9.1.6迭代回顾和DEM0展示</span><br><span class="line">9.1.7争论&#x2F;反对</span><br><span class="line">9.2注意力点数</span><br><span class="line">9.2.1 睡眠</span><br><span class="line">9.2.2咖啡因</span><br><span class="line">9.2.3恢复</span><br><span class="line">9.2.4肌肉注意力</span><br><span class="line">……</span><br><span class="line">第10章 预估</span><br><span class="line">第11章 压力</span><br><span class="line">第12章 协作</span><br><span class="line">第13章 团队与项目</span><br><span class="line">第14章 辅导、学徒期与技艺</span><br><span class="line">附录 工具</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0098NRHHY/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0098NRHHY&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51S1GaiY0DL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>it文化</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS权威指南 第3版</title>
    <url>/2020/04/19/cssquan-wei-zhi-nan-di-3ban/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： CSS权威指南 第3版<br>作者信息： 作者: 迈耶 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《CSS权威指南(第3版)》编辑推荐：想要快速省力地做到让Web风格整齐划一吗？《CSS权威指南(第3版)》告诉你怎样将最新的CSS2以CSS2.1里面所定义的各种CSS元素应用到实际工作当中。通过书中的例子，你将学会怎样使用CSS创建或修改网站的外观，并且达到普通HTML无法实现的效果。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">第1章 CS S和文档</span><br><span class="line">web的衰落</span><br><span class="line">CSS作救星</span><br><span class="line">元素</span><br><span class="line">结合CSS和xHTML</span><br><span class="line">小结</span><br><span class="line">第2章 选择器</span><br><span class="line">基本规则</span><br><span class="line">分组</span><br><span class="line">类选择器和ID选择器</span><br><span class="line">属性选择器</span><br><span class="line">使用文档结构</span><br><span class="line">伪类和伪元素</span><br><span class="line">小结</span><br><span class="line">第3章 结构和层叠</span><br><span class="line">特殊性</span><br><span class="line">继承</span><br><span class="line">层叠</span><br><span class="line">小结</span><br><span class="line">第4章 值和单位</span><br><span class="line">数字</span><br><span class="line">百分数</span><br><span class="line">颜色</span><br><span class="line">长度单位</span><br><span class="line">URL</span><br><span class="line">css2单位</span><br><span class="line">小结</span><br><span class="line">第5章 字体</span><br><span class="line">字体系列</span><br><span class="line">字体加粗</span><br><span class="line">字体大小</span><br><span class="line">风格和变形</span><br><span class="line">拉伸和调整字体</span><br><span class="line">font属性</span><br><span class="line">字体匹配</span><br><span class="line">小结</span><br><span class="line">第6章 文本属性</span><br><span class="line">缩进和水平对齐</span><br><span class="line">垂直对齐</span><br><span class="line">字间隔和字母间隔</span><br><span class="line">文本转换</span><br><span class="line">文本装饰</span><br><span class="line">文本阴影</span><br><span class="line">小结</span><br><span class="line">第7章 基本视觉格式化</span><br><span class="line">第8章 内边距、边框和外边距</span><br><span class="line">第9章 颜色和背景</span><br><span class="line">第10章 浮动和定位</span><br><span class="line">第11章 表布局</span><br><span class="line">第12章 列表与生成内容</span><br><span class="line">第13章 用户界面样式</span><br><span class="line">第14章 非屏幕媒体</span><br><span class="line">附录A 属性参考</span><br><span class="line">附录B 选择器、伪类和伪元素参考</span><br><span class="line">附录C 示例HTML 4样式表</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0011F5SIC/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0011F5SIC&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51P-xHTkLYL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>黑客与画家</title>
    <url>/2020/04/19/hacker-and-painter/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 黑客与画家<br>作者信息： 作者: Paul Graham [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《黑客与画家:硅谷创业之父Paul Graham文集》是硅谷创业之父Paul Graham的文集，主要介绍黑客即优秀程序员的爱好和动机，讨论黑客成长、黑客对世界的贡献以及编程语言和黑客工作方法等所有对计算机时代感兴趣的人的一些话题。书中的内容不但有助于了解计算机编程的本质、互联网行业的规则，还会帮助读者了解我们这个时代，迫使读者独立思考。 　　<br>《黑客与画家:硅谷创业之父Paul Graham文集》适合所有程序员和互联网创业者，也适合一切对计算机行业感兴趣的读者。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 为什么书呆子不受欢迎　1</span><br><span class="line">他们的心思在别的地方。</span><br><span class="line">2. 黑客与画家　18</span><br><span class="line">黑客也是创造者，与画家、建筑师、作家一样。</span><br><span class="line">3. 不能说的话　34</span><br><span class="line">如果你的想法是社会无法容忍的，你怎么办？</span><br><span class="line">4. 良好的坏习惯　52</span><br><span class="line">与其他美国人一样，黑客的成功秘诀就是打破常规。</span><br><span class="line">5. 另一条路　59</span><br><span class="line">互联网软件是微机诞生后的最大机会。</span><br><span class="line">6. 如何创造财富　90</span><br><span class="line">致富的最好方法就是为社会创造财富。创造财富的最好方法就是创业。</span><br><span class="line">7. 关注贫富分化　111</span><br><span class="line">“收入分配不平等”的危害，会不会没有我们想的那样严重？</span><br><span class="line">8. 防止垃圾邮件的一种方法　124</span><br><span class="line">不久前，许多专家还认为无法有效地过滤垃圾邮件。本文改变了他们的想法 </span><br><span class="line"></span><br><span class="line"> 。 9. 设计者的品味　133 如何做出优秀的东西？ 10. 编程语言解析　148 什么是编程语言？为什么它们现在很热门？ 11. 一百年后的编程语言　156 一百年后，人类怎样编程？为什么不从现在开始就这样编程呢？ 12. 拒绝平庸　169 别忘了你的对手与你一样，能用任何想用的语言编写互联网软件。 13. 书呆子的复仇　180 在高科技行业，只有失败者采用“业界最佳实践”。 14. 梦寐以求的编程语言　198 一种好的编程语言，是让黑客可以随心所欲使用的语言。 15. 设计与研究　213 研究必须是“新”的，而设计必须是“好”的。 志谢　219 术语解释　221 图片授权说明　236</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B004WHZGZQ/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B004WHZGZQ&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51MF61YgbOL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>it文化</tag>
      </tags>
  </entry>
  <entry>
    <title>Head First Servlets and JSP(第2版) (英）</title>
    <url>/2020/04/19/head-first-servlets-and-jsp-di-2ban/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Head First Servlets and JSP(第2版) (英）<br>作者信息： 作者: 巴萨姆 [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>是不是要学最新版本j2ee 1.5参加sun认证web组件开发人员（scwcd）考试？《head first servlets&amp;jsp（第二版）》并没有给你一大堆需要死记硬背的条条框框；它能将知识直接送入你的大脑。你会通过不寻常的方式同servlet和jsp打交道，可以学得更深入、更快捷。读完全书后，你会看到一个全新的模拟测验，这是模拟实际考试而专门设计的。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">引子</span><br><span class="line">1 为什么使用Servlets&amp;JSP：前言与概述</span><br><span class="line">2 Web应用体系结构：高层概述</span><br><span class="line">3 MVC迷你教程：MVC实战</span><br><span class="line">4 作为Servlet：请求和响应</span><br><span class="line">5 作为Web应用：属性和监听者</span><br><span class="line">6 会话状态：会话管理</span><br><span class="line">7 作为JSP：使用JSP</span><br><span class="line">8 没有脚本的页面：无脚本的JSP</span><br><span class="line">9 强大的定制标记：使用JSTL</span><br><span class="line">10 JSTL也有力不能及的时候：定制标记开发</span><br><span class="line">11 部署Web应用：Web应用部署</span><br><span class="line">12 要保密，要安全：Web应用安全</span><br><span class="line">13 过滤器的威力：过滤器和包装器</span><br><span class="line">14 企业设计模式：模式和struts</span><br><span class="line">A 附录A：最终模拟测验</span><br><span class="line">i 索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0042WNHGG/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0042WNHGG&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51nKK0ba55L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5揭秘</title>
    <url>/2020/04/19/html5jie-mi/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： HTML5揭秘<br>作者信息： 作者: 马克•皮尔格雷姆 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>本书全面而深入地对HTML5相关的技术进行详细介绍和剖析。“从开始到现在”道出HTML5的坎坷发展史；“HTML5特性检测”介绍了多种针对不同特性的检测方法；“本地存储”揭开了如何把“数据库”搬到客户端的神秘面纱；“离线应用”展示了脱机状态下依然能让Web应用完好无损的神奇技艺；“疯狂的表单”大秀了一把炫酷无比的下一代Web表单……它几乎涵盖了HTML5标准中描述的所有新特性。本书在以诙谐的文字结合生动的实例介绍HTML5特性的同时，还深入剖析其内部原理。让读者不仅知其然，而且知其所以然。无论是刚接触Web前端技术的新人，还是经验丰富的老手，只要是HTML5技术爱好者，都会从本书中受益。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言  I</span><br><span class="line">第1章 从开始到现在  1</span><br><span class="line">1.1 引言  1</span><br><span class="line">1.2 MIME类型  1</span><br><span class="line">1.3 很长的题外话：一份标准是如何诞生的？  2</span><br><span class="line">1.4 未曾间断的路线   7</span><br><span class="line">1.5 HTML发展史：从1997到2004年   9</span><br><span class="line">1.6 你所知道的关于XHTML的一切都是错误的  10</span><br><span class="line">1.7 一个竞争愿景  11</span><br><span class="line">1.8 WHAT工作小组？ 12</span><br><span class="line">1.9 回到W3C   13</span><br><span class="line">1.10 后记 14</span><br><span class="line">1.11 扩展阅读   14</span><br><span class="line">第2章 HTML5特性检测   15</span><br><span class="line">2.1 引言  15</span><br><span class="line">2.2 检测技术    15</span><br><span class="line">2.3 Modernizr：一个HTML5特性检测库  16</span><br><span class="line">2.4 画布  16</span><br><span class="line">2.5 画布文本    17</span><br><span class="line">2.6 视频  18</span><br><span class="line">2.7 视频格式    19</span><br><span class="line">2.8 本地存储    21</span><br><span class="line">2.9 Web Workers 23</span><br><span class="line">2.10 离线Web应用    23</span><br><span class="line">2.11 地理位置   24</span><br><span class="line">2.12 输入框类型    25</span><br><span class="line">2.13 占位文本   27</span><br><span class="line">2.14 表单自动聚焦 27</span><br><span class="line">2.15 微数据  28 </span><br><span class="line"></span><br><span class="line"> 2.16 扩展阅读 29 第3章 从这一切的含义 31 3.1 引言 31 3.2 文档类型 31 3.3 根元素 33 3.4 head元素 34 3.4.1 字符编码 35 3.4.2 朋友和（链接）关系 36 3.5 HTML5中新增的语义元素 41 3.6 题外话：浏览器如何处理未知元素 42 3.7 页头 45 3.8 文章 47 3.9 日期和时间 49 3.10 导航 51 3.11 页脚 52 3.12 扩展阅读 55 第4章 Canvas绘图 57 4.1 引言 57 4.2 简单的图形 58 4.3 Canvas坐标系 60 4.4 路径 61 4.5 文本 63 4.6 颜色渐变 67 4.7 图片 70 4.8 IE怎么办？ 73 4.9 一个完整的例子 75 4.10 扩展阅读 79 第5章 网络上的视频 81 5.1 前言 81 5.2 视频容器 81 5.3 视频编解码器 83 5.3.1 H.264 84 5.3.2 Theora 84 5.3.3 VP8 85 5.4 音频编解码器 85 5.4.1 MPEG-1 音频层 3 86 5.4.2 高级音频编码 87 5.4.3 Vorbis 87 5.5 在网页中怎么工作 88 5.6 H.264视频的授权问题 90 5.7 使用Firefogg编码Ogg视频 91 5.8 使用ffmpegtheora批量编码Ogg视频 98 5.9 使用HandBrake编码H.264视频 100 5.10 使用HandBrake批量编码H.264视频 107 5.11 使用ffmpeg编码WebM视频 108 5.12 最后，标记 110 5.12.1 MIME类型很重要 113 5.13 IE怎么办？ 114 5.14 完整的例子 114 5.14 扩展阅读 115 第6章 地理位置 117 6.1 引言 117 6.2 地理位置API 117 6.3 代码展示 118 6.4 容错处理 120 6.5 方案！我要方案！ 121 6.6 那IE怎么办？ 123 6.7 geo.js来拯救 123 6.8 一个完整的例子 125 6.9 扩展阅读 126 第7章 Web应用本地存储的过去、现在和未来 127 7.1 引言 127 7.2 HTML5之前的伪本地存储简史 128 7.3 HTML5存储介绍 129 7.4 使用HTML5存储 130 7.4.1 跟踪HTML5存储区的改动 131 7.4.2 现有浏览器的局限性 132 7.5 HTML5存储实践 132 7.6 超越键值对的存储形式 134 7.7 扩展阅读 135 第8章 离线Web应用 137 8.1 引言 137 8.2 缓存清单 138 8.2.1 “网络”段 139 8.2.2 “默认”部分 140 8.3 事件流 141 8.4 调试的艺术——杀了我！现在就杀了我！ 142 8.5 让我们来构建一个离线Web应用！ 145 8.6 扩展阅读 146</span><br><span class="line"></span><br><span class="line"> 第9章 疯狂的表单 147 9.1 引言 147 9.2 占位文本 147 9.3 自动聚焦 148 9.4 Email地址 150 9.5 Web地址 151 9.6 数字类型输入框：数字选择器 153 9.7 数字类型输入框：滑块 155 9.8 日期选择器 156 9.9 搜索框 158 9.10 颜色选择器 160 9.11 还有一点…… 160 9.12 扩展阅读 161 第10章 “分布式”、“可扩展性”及其他华丽词藻 163 10.1 引言 163 10.2 什么是微数据？ 164 10.3 微数据的数据模型 165 10.4 标注“人” 168 10.4.1 Google Rich Snippets介绍 174 10.5 标注“组织” 176 10.6 标注“事件” 180 10.6.1 Google Rich Snippets的回归 184 10.7 标注“点评” 186 10.8 扩展阅读 190 附录A 全方位特性检测指南 191 元素列表 191 扩展阅读 199 索引 201</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/0596806027/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=0596806027&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51-5qLoIu9L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5敏捷实践</title>
    <url>/2020/04/19/html5min-jie-shi-jian/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： HTML5敏捷实践<br>作者信息： 作者: Jesse Cravens [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>HTML5 is already transforming web development, though it’s still under construction in some areas. HTML5 Hacks shows you how to use the latest tools to make your sites and applications more interactive, more functional, and more capable of competing with desktop applications. Each hack shows you how to make a concrete improvement, applying the latest in JavaScript, HTML, and CSS power to common web development issues. Learn the latest techniques with HTML, CSS, and JavaScript Discover new markup and multimedia features Take off with new graphics features in Canvas and SVG Use new presentation models and tools in CSS3 Apply CSS transformation and animation to reduce the amount of JavaScript you need for exciting sites Implement local storage with hash tables and databases Improve client-server communication with web sockets and XmlHttpRequest</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/1449334997/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=1449334997&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51XBZ%2BglHqL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>黑客攻防技术宝典. iOS实战篇(英文版)</title>
    <url>/2020/04/19/ios-hackers-handbook/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 黑客攻防技术宝典. iOS实战篇(英文版)<br>作者信息： 作者: Charlie Miller [ 英文 epub ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Discover all the security risks and exploits that can threaten iOS-based mobile devices iOS is Apple’s mobile operating system for the iPhone and iPad. With the introduction of iOS5, many security issues have come to light. This book explains and discusses them all. The award-winning author team, experts in Mac and iOS security, examines the vulnerabilities and the internals of iOS to show how attacks can be mitigated. The book explains how the operating system works, its overall security architecture, and the security risks associated with it, as well as exploits, rootkits, and other payloads developed for it. Covers iOS security architecture, vulnerability hunting, exploit writing, and how iOS jailbreaks work Explores iOS enterprise and encryption, code signing and memory protection, sandboxing, iPhone fuzzing, exploitation, ROP payloads, and baseband attacks Also examines kernel debugging and exploitation Companion website includes source code and tools to facilitate your efforts iOS Hacker’s Handbook arms you with the tools needed to identify, understand, and foil iOS attacks.</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Introduction xv </span><br><span class="line"></span><br><span class="line"> Chapter 1 iOS Security Basics 1</span><br><span class="line"></span><br><span class="line"> Chapter 2 iOS in the Enterprise 15</span><br><span class="line"></span><br><span class="line"> Chapter 3 Encryption 47</span><br><span class="line"></span><br><span class="line"> Chapter 4 Code Signing and Memory Protections 69</span><br><span class="line"></span><br><span class="line"> Chapter 5 Sandboxing 107</span><br><span class="line"></span><br><span class="line"> Chapter 6 Fuzzing iOS Applications 139</span><br><span class="line"></span><br><span class="line"> Chapter 7 Exploitation 185</span><br><span class="line"></span><br><span class="line"> Chapter 8 Return-Oriented Programming 219</span><br><span class="line"></span><br><span class="line"> Chapter 9 Kernel Debugging and Exploitation 249</span><br><span class="line"></span><br><span class="line"> Chapter 10 Jailbreaking 297</span><br><span class="line"></span><br><span class="line"> Chapter 11 Baseband Attacks 327</span><br><span class="line"></span><br><span class="line"> Appendix References 365</span><br><span class="line"></span><br><span class="line"> Index 369</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/1118204123/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=1118204123&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51g8wVgRKmL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>Java How to Program (9th Edition)</title>
    <url>/2020/04/19/java-how-to-program-9th-edition/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Java How to Program (9th Edition)<br>作者信息： 作者: Paul Deitel [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>The Deitels’ groundbreaking How to Program series offers unparalleled breadth and depth of object-oriented programming concepts and intermediate-level topics for further study. Their Live Code Approach features thousands of lines of code in hundreds of complete working programs. This enables readers  to confirm that programs run as expected. Java How to Program (Early Objects) 9e contains an optional extensive OOD/UML 2 case study on developing and implementing the software for an automated teller machine.This edition covers both Java SE7 and SE6.</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Preface xxiii</span><br><span class="line">Before You Begin xxxiii</span><br><span class="line">1 Introduction to Computers and Java 1</span><br><span class="line">1.1 Introduction 2</span><br><span class="line">1.2 Computers: Hardware and Software 5</span><br><span class="line">1.3 Data Hierarchy 6</span><br><span class="line">1.4 Computer Organization 8</span><br><span class="line">1.5 Machine Languages, Assembly Languages and High-Level Languages 10</span><br><span class="line">1.6 Introduction to Object Technology 11</span><br><span class="line">1.7 Operating Systems 13</span><br><span class="line">1.8 Programming Languages 16</span><br><span class="line">1.9 Java and a Typical Java Development Environment 18</span><br><span class="line">1.10 Test-Driving a Java Application 22</span><br><span class="line">1.11 Web 2.0: Going Social 26</span><br><span class="line">1.12 Software Technologies 29</span><br><span class="line">1.13 Keeping Up-to-Date with Information Technologies 31</span><br><span class="line">1.14 Wrap-Up 32 </span><br><span class="line"></span><br><span class="line"> 2 Introduction to Java Applications 37 2.1 Introduction 38 2.2 Your First Program in Java: Printing a Line of Text 38 2.3 Modifying Your First Java Program 44 2.4 Displaying Text with printf 46 2.5 Another Application: Adding Integers 47 2.6 Memory Concepts 52 2.7 Arithmetic 53 2.8 Decision Making: Equality and Relational Operators 56 2.9 Wrap-Up 60</span><br><span class="line"></span><br><span class="line"> 3 Introduction to Classes, Objects, Methods and Strings 71 3.1 Introduction 72 3.2 Declaring a Class with a Method and Instantiating an Object of a Class 72 3.3 Declaring a Method with a Parameter 76 3.4 Instance Variables, set Methods and get Methods 79 3.5 Primitive Types vs. Reference Types 84 3.6 Initializing Objects with Constructors 85 3.7 Floating-Point Numbers and Type double 88 3.8 (Optional) GUI and Graphics Case Study: Using Dialog Boxes 92 3.9 Wrap-Up 95</span><br><span class="line"></span><br><span class="line"> 4 Control Statements: Part 1 102 4.1 Introduction 103 4.2 Algorithms 103 4.3 Pseudocode 104 4.4 Control Structures 104 4.5 if Single-Selection Statement 107 4.6 if…else Double-Selection Statement 107 4.7 while Repetition Statement 112 4.8 Formulating Algorithms: Counter-Controlled Repetition 113 4.9 Formulating Algorithms: Sentinel-Controlled Repetition 118 4.10 Formulating Algorithms: Nested Control Statements 125 4.11 Compound Assignment Operators 130 4.12 Increment and Decrement Operators 130 4.13 Primitive Types 134 4.14 (Optional) GUI and Graphics Case Study: Creating Simple Drawings 134 4.15 Wrap-Up 138</span><br><span class="line"></span><br><span class="line"> 5 Control Statements: Part 2 151 5.1 Introduction 152 5.2 Essentials of Counter-Controlled Repetition 152 5.3 for Repetition Statement 154 5.4 Examples Using the for Statement 158 5.5 do…while Repetition Statement 162 5.6 switch Multiple-Selection Statement 164 5.7 break and continue Statements 172 5.8 Logical Operators 173 5.9 Structured Programming Summary 179 5.10 (Optional) GUI and Graphics Case Study: Drawing Rectangles and Ovals 184 5.11 Wrap-Up 187</span><br><span class="line"></span><br><span class="line"> 6 Methods: A Deeper Look 197 6.1 Introduction 198 6.2 Program Modules in Java 198 6.3 static Methods, static Fields and Class Math 200 6.4 Declaring Methods with Multiple Parameters 202 6.5 Notes on Declaring and Using Methods 205 6.6 Method-Call Stack and Activation Records 206 6.7 Argument Promotion and Casting 207 6.8 Java API Packages 208 6.9 Case Study: Random-Number Generation 210 6.9.1 Generalized Scaling and Shifting of Random Numbers 214 6.9.2 Random-Number Repeatability for Testing and Debugging 214 6.10 Case Study: A Game of Chance; Introducing Enumerations 215 6.11 Scope of Declarations 219 6.12 Method Overloading 222 6.13 (Optional) GUI and Graphics Case Study: Colors and Filled Shapes 224 6.14 Wrap-Up 227</span><br><span class="line"></span><br><span class="line"> 7 Arrays and ArrayLists 240 7.1 Introduction 241 7.2 Arrays 242 7.3 Declaring and Creating Arrays 243 7.4 Examples Using Arrays 244 7.5 Case Study: Card Shuffling and Dealing Simulation 254 7.6 Enhanced for Statement 258 7.7 Passing Arrays to Methods 259 7.8 Case Study: Class GradeBook Using an Array to Store Grades 262 7.9 Multidimensional Arrays 268 7.10 Case Study: Class GradeBook Using a Two-Dimensional Array 271 7.11 Variable-Length Argument Lists 278 7.12 Using Command-Line Arguments 279 7.13 Class Arrays 281 7.14 Introduction to Collections and Class ArrayList 284 7.15 (Optional) GUI and Graphics Case Study: Drawing Arcs 286 7.16 Wrap-Up 289</span><br><span class="line"></span><br><span class="line"> 8 Classes and Objects: A Deeper Look 311 8.1 Introduction 312 8.2 Time Class Case Study 312 8.3 Controlling Access to Members 316 8.4 Referring to the Current Object’s Members with the this Reference 317 8.5 Time Class Case Study: Overloaded Constructors 320 8.6 Default and No-Argument Constructors 326 8.7 Notes on Set and Get Methods 326 8.8 Composition 328 8.9 Enumerations 331 8.10 Garbage Collection and Method finalize 333 8.11 static Class Members 334 8.12 static Import 338 8.13 final Instance Variables 339 8.14 Time Class Case Study: Creating Packages 340 8.15 Package Access 345 8.16 (Optional) GUI and Graphics Case Study: Using Objects with Graphics 347 8.17 Wrap-Up 351</span><br><span class="line"></span><br><span class="line"> 9 Object-Oriented Programming: Inheritance 359 9.1 Introduction 360 9.2 Superclasses and Subclasses 361 9.3 protected Members 363 9.4 Relationship between Superclasses and Subclasses 364 9.4.1 Creating and Using a CommissionEmployee Class 364 9.4.2 Creating and Using a BasePlusCommissionEmployee Class 370 9.4.3 Creating a CommissionEmployee—BasePlusCommissionEmployee Inheritance Hierarchy 375 9.4.4 CommissionEmployee—BasePlusCommissionEmployee Inheritance Hierarchy Using protected Instance Variables 377 9.4.5 CommissionEmployee—BasePlusCommissionEmployee Inheritance Hierarchy Using private Instance Variables 380 9.5 Constructors in Subclasses 385 9.6 Software Engineering with Inheritance 386 9.7 Class Object 387 9.8 (Optional) GUI and Graphics Case Study: Displaying Text and Images Using Labels 388 9.9 Wrap-Up 391</span><br><span class="line"></span><br><span class="line"> 10 Object-Oriented Programming: Polymorphism 394 10.1 Introduction 395 10.2 Polymorphism Examples 397 10.3 Demonstrating Polymorphic Behavior 398 10.4 Abstract Classes and Methods 400 10.5 Case Study: Payroll System Using Polymorphism 403 10.5.1 Abstract Superclass Employee 404 10.5.2 Concrete Subclass SalariedEmployee 407 10.5.3 Concrete Subclass HourlyEmployee 408 10.5.4 Concrete Subclass CommissionEmployee 410 10.5.5 Indirect Concrete Subclass BasePlusCommissionEmployee 412 10.5.6 Polymorphic Processing, Operator instanceof and Downcasting 413 10.5.7 Summary of the Allowed Assignments Between Superclass and Subclass Variables 418 10.6 final Methods and Classes 418 10.7 Case Study: Creating and Using Interfaces 419 10.7.1 Developing a Payable Hierarchy 421 10.7.2 Interface Payable 422 10.7.3 Class Invoice 422 10.7.4 Modifying Class Employee to Implement Interface Payable 425 10.7.5 Modifying Class SalariedEmployee for Use in the Payable Hierarchy 427 10.7.6 Using Interface Payable to Process Invoices and Employees Polymorphically 428 10.7.7 Common Interfaces of the Java API 430 10.8 (Optional) GUI and Graphics Case Study: Drawing with Polymorphism 431 10.9 Wrap-Up 433</span><br><span class="line"></span><br><span class="line"> 11 Exception Handling: A Deeper Look 438 11.1 Introduction 439 11.2 Example: Divide by Zero without Exception Handling 439 11.3 Example: Handling ArithmeticExceptions and InputMismatchExceptions 442 11.4 When to Use Exception Handling 447 11.5 Java Exception Hierarchy 447 11.6 finally Block 450 11.7 Stack Unwinding and Obtaining Information from an Exception Object 454 11.8 Chained Exceptions 457 11.9 Declaring New Exception Types 459 11.10 Preconditions and Postconditions 460 11.11 Assertions 461 11.12 (New in Java SE 7) Multi-catch: Handling Multiple Exceptions in One catch 462 11.13 (New in Java SE 7) try-with-Resources: Automatic Resource Deallocation 463 11.14 Wrap-Up 463</span><br><span class="line"></span><br><span class="line"> 12 ATM Case Study, Part 1: Object-Oriented Design with the UML 469 12.1 Case Study Introduction 470 12.2 Examining the Requirements Document 470 12.3 Identifying the Classes in a Requirements Document 478 12.4 Identifying Class Attributes 484 12.5 Identifying Objects’ States and Activities 489 12.6 Identifying Class Operations 493 12.7 Indicating Collaboration Among Objects 499 12.8 Wrap-Up 506</span><br><span class="line"></span><br><span class="line"> 13 ATM Case Study Part 2: Implementing an Object-Oriented Design 510 13.1 Introduction 511 13.2 Starting to Program the Classes of the ATM System 511 13.3 Incorporating Inheritance and Polymorphism into the ATM System 516 13.4 ATM Case Study Implementation 522 13.4.1 Class ATM 523 13.4.2 Class Screen 528 13.4.3 Class Keypad 529 13.4.4 Class CashDispenser 530 13.4.5 Class DepositSlot 531 13.4.6 Class Account 532 13.4.7 Class BankDatabase 534 13.4.8 Class Transaction 537 13.4.9 Class BalanceInquiry 53…</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/0132575663/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=0132575663&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51JBGwgt4AL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>浪潮之巅</title>
    <url>/2020/04/19/lang-chao-zhi-dian/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 浪潮之巅<br>作者信息： 作者: 吴军 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《浪潮之巅》梳理了IT产业发展的历史脉络，叙述了美国硅谷明星公司的兴衰沉浮。通过对各大公司从技术轨迹到经营理念的剖析，作者吴军想向读者展现的并不仅仅是一幅有关科技产业更迭和大公司成长规律的历史景观，而是为了让中国的读者能更真实地了解美国、了解科技产业，以此理解科技创新和商业公平在美国文化生活中的深刻意义</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">序言</span><br><span class="line">前言　有幸见证历史</span><br><span class="line">第 1 章　帝国的余辉—AT＆T</span><br><span class="line">第 2 章　蓝色巨人—IBM 公司</span><br><span class="line">第 3 章　“水果”公司的复兴—乔布斯和苹果公司</span><br><span class="line">第 4 章　计算机工业的生态链</span><br><span class="line">第 5 章　奔腾的芯 — 英特尔公司</span><br><span class="line">第 6 章　IT 领域的罗马帝国—微软公司</span><br><span class="line">第 7 章　互联网的金门大桥—思科公司</span><br><span class="line">第 8 章　英名不朽—杨致远、菲洛和雅虎公司</span><br><span class="line">第 9 章　硅谷的见证人—惠普公司</span><br><span class="line">第 10 章　没落的贵族—摩托罗拉公司</span><br><span class="line">第 11 章　硅谷的另一面</span><br><span class="line">第 12 章　短暂的春秋—与机会失之交臂的公司</span><br><span class="line">第 13 章　幕后的英雄—风险投资</span><br><span class="line">第 14 章　信息产业的规律性</span><br><span class="line">第 15 章　硅谷的摇篮—斯坦福大学</span><br><span class="line">第 16 章　科技公司的吹鼓手—投资银行</span><br><span class="line">第 17 章　挑战者—Google 公司</span><br><span class="line">第 18 章　成功的转基因—诺基亚、3M、GE 公司</span><br><span class="line">第 19 章　印钞机—最佳的商业模式</span><br><span class="line">第 20 章　互联网 2.0</span><br><span class="line">第 21 章　金融风暴的冲击</span><br><span class="line">第 22 章 　云计算</span><br><span class="line">第 23 章　下一个 Google</span><br><span class="line">后记</span><br><span class="line">索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B005DSK504/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B005DSK504&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51DtisU6DGL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>it文化</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C程序设计 第4版</title>
    <url>/2020/04/19/objective-ccheng-xu-she-ji-di-4ban/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Objective-C程序设计 第4版<br>作者信息： 作者: Stephen G. Kochan [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>这是一本Objective-C编程领域最畅销的书籍，内容涵盖Xcode 4.2和自动引用计数（ARC）。<br>本书详细介绍了Objective-C和苹果iOS、Mac平台面向对象程序编程的知识。<br>本书结合独特的学习方法，在每章都编写有大量的小程序例子和练习，使Objective-C程序设计适合于课堂教学和自学。<br>本书已经为iOS 5和Xcode 4.2中的重大变更做了全面更新，最大的改动是引入了自动引用计数（ARC），并详细说明了如何在Objective-C编程过程中使用ARC提升和简化内存管理。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1引言</span><br><span class="line">1.1本书内容</span><br><span class="line">1.2本书组织方式</span><br><span class="line">1.3支持</span><br><span class="line">1.4致谢</span><br><span class="line">1.5第4版前言</span><br><span class="line">2Objective—C编程</span><br><span class="line">2.1编译并运行程序</span><br><span class="line">2.1.1使用Xcode</span><br><span class="line">2.1.2使用Terminal</span><br><span class="line">2.2解释第一个程序</span><br><span class="line">2.3显示变量的值</span><br><span class="line">2.4小结</span><br><span class="line">2.5练习</span><br><span class="line">3类、对象和方法</span><br><span class="line">3.1到底什么是对象</span><br><span class="line">3.2实例和方法</span><br><span class="line">3.3用于处理分数的Objective—C类</span><br><span class="line">3.4@interface部分</span><br><span class="line">3.4.1选择名称</span><br><span class="line">3.4.2类方法和实例方法</span><br><span class="line">3.5@implementation部分</span><br><span class="line">3.6program部分</span><br><span class="line">3.7实例变量的访问及数据封装</span><br><span class="line">3.8小结</span><br><span class="line">3.9练习</span><br><span class="line">4数据类型和表达式</span><br><span class="line">4.1数据类型和常量</span><br><span class="line">4.1.1int类型</span><br><span class="line">4.1.2float类型</span><br><span class="line">4.1.3char类型</span><br><span class="line">4.1.4限定词：long、long long、short、unsigned及signed</span><br><span class="line">4.1.5id类型</span><br><span class="line">4.2算术表达式</span><br><span class="line">4.2.1运算符的优先级</span><br><span class="line">4.2.2整数运算和一元负号运算符</span><br><span class="line">4.2.3模运算符</span><br><span class="line">4.2.4整型值和浮点值的相互转换</span><br><span class="line">4.2.5类型转换运算符</span><br><span class="line">4.3赋值运算符</span><br><span class="line">4.4Calculator类</span><br><span class="line">4.5练习</span><br><span class="line">5循环结构</span><br><span class="line">5.1for语句</span><br><span class="line">5.1.1键盘输入</span><br><span class="line">5.1.2嵌套的for循环</span><br><span class="line">5.1.3for循环的变体</span><br><span class="line">5.2while语句</span><br><span class="line">5.3do语句</span><br><span class="line">5.4break语句</span><br><span class="line">5.5continue语句</span><br><span class="line">5.6小结</span><br><span class="line">5.7练习</span><br><span class="line">6选择结构</span><br><span class="line">6.1if语句</span><br><span class="line">6.1.1if—else结构</span><br><span class="line">6.1.2复合条件测试</span><br><span class="line">6.1.3嵌套的if语句</span><br><span class="line">6.1.4else if结构</span><br><span class="line">6.2switch语句</span><br><span class="line">6.3Boolean变量</span><br><span class="line">6.4条件运算符</span><br><span class="line">6.5练习</span><br><span class="line">7类</span><br><span class="line">7.1分离接口和实现文件</span><br><span class="line">7.2合成存取方法</span><br><span class="line">7.3使用点运算符访问属性</span><br><span class="line">7.4具有多个参数的方法</span><br><span class="line">7.4.1不带参数名的方法</span><br><span class="line">7.4.2关于分数的操作</span><br><span class="line">7.5局部变量</span><br><span class="line">7.5.1方法的参数</span><br><span class="line">7.5.2static关键字</span><br><span class="line">7.6self关键字</span><br><span class="line">7.7在方法中分配和返回对象</span><br><span class="line">7.8练习</span><br><span class="line">8继承</span><br><span class="line">8.1一切从根类开始</span><br><span class="line">8.2通过继承来扩展：添加新方法</span><br><span class="line">8.2.1Point类和对象创建</span><br><span class="line">8.2.2@class指令</span><br><span class="line">8.2.3具有对象的类</span><br><span class="line">8.3覆写方法</span><br><span class="line">8.4抽象类</span><br><span class="line">8.5练习</span><br><span class="line">9多态、动态类型和动态绑定</span><br><span class="line">9.1多态：相同的名称，不同的类</span><br><span class="line">9.2动态绑定和id类型</span><br><span class="line">9.3编译时和运行时检查</span><br><span class="line">9.4id数据类型与静态类型</span><br><span class="line">9.5有关类的问题</span><br><span class="line">9.6使用@try处理异常</span><br><span class="line">9.7练习</span><br><span class="line">10变量和数据类型</span><br><span class="line">10.1对象的初始化</span><br><span class="line">10.2作用域回顾</span><br><span class="line">10.2.1控制实例变量作用域的指令</span><br><span class="line">10.2.2全局变量</span><br><span class="line">10.2.3静态变量</span><br><span class="line">10.3枚举数据类型</span><br><span class="line">10.4typedef语句</span><br><span class="line">10.5数据类型转换</span><br><span class="line">10.6位运算符</span><br><span class="line">10.6.1按位与运算符</span><br><span class="line">10.6.2按位或运算符</span><br><span class="line">10.6.3按位异或运算符</span><br><span class="line">10.6.4一次求反运算符</span><br><span class="line">10.6.5向左移位运算符</span><br><span class="line">10.6.6向右移位运算符</span><br><span class="line">10.7练习</span><br><span class="line">……</span><br><span class="line">11分类和协议</span><br><span class="line">12预处理程序</span><br><span class="line">13基本的C语言特性</span><br><span class="line">14Foundation框架简介</span><br><span class="line">15数字、字符串和集合</span><br><span class="line">16使用文件</span><br><span class="line">17内存管理和自动引用计数</span><br><span class="line">18复制对象</span><br><span class="line">19归档</span><br><span class="line">20Cocoa和Cocoa Touch简介</span><br><span class="line">21编写iOS应用程序</span><br><span class="line">附录A术语表</span><br><span class="line">附录B地址簿示例源代码</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B009EBOK98/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B009EBOK98&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51ifh7pe1ZL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>七周七语言</title>
    <url>/2020/04/19/qi-zhou-qi-yu-yan/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 七周七语言<br>作者信息： 作者: 泰特 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《7周7语言:理解多种编程范型》适合从事程序设计工作的人员阅读。<br>Bruce A. Tate是软件行业的一名老兵，他有一个宏伟目标：用一本书的篇幅切中要害地探索七种不同的语言。《七周七语言：理解多种编程范型》就是他的成果。书中介绍了Ruby、Io、Prolog、Scala、Erlang、Cloiure和Haskell这七种语言。关注每一门语言的精髓和特性，重点解决如下问题：这门语言的类型模型是什么。编程范型是什么。如何与其交互。有哪些决策构造和核心数据结构，有哪些独特的核心特性。<br>在这个飞速发展的信息时代。程序员仅仅掌握甚至精通一门语言是远远不够的。了解多门语言蕴涵的思维方式。在编码中互相借鉴。再挑出一两门对自己口味的语言深入学习，这些已经成为在软件行业中安身立命之本。从这个意义上说。每个程序员都应该看看这本《七周七语言》。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章　简介　1</span><br><span class="line">1.1　不走寻常路　1</span><br><span class="line">1.2　语言　2</span><br><span class="line">1.3　谁应该买这本书　4</span><br><span class="line">1.3.1　学会如何学习　4</span><br><span class="line">1.3.2　乱世英雄　4</span><br><span class="line">1.4　谁不应该买这本书　5</span><br><span class="line">1.4.1　超越语法　5</span><br><span class="line">1.4.2　不是安装指南　6</span><br><span class="line">1.4.3　不是编程参考　6</span><br><span class="line">1.4.4　严格督促　6</span><br><span class="line">1.5　最后一击　7 </span><br><span class="line"></span><br><span class="line"> 第2章　Ruby　8 2.1　Ruby简史　9 2.2　第一天：找个保姆　10 2.2.1　快速起步　10 2.2.2　从命令行执行Ruby　10 2.2.3　Ruby的编程模型　11 2.2.4　判断　12 2.2.5　鸭子类型　15 2.2.6　第一天我们学到了什么　16 2.2.7　第一天自习　16 2.3　第二天：从天而降　17 2.3.1　定义函数　17 2.3.2　数组　17 2.3.3　散列表　19 2.3.4　代码块和yield　20 2.3.5　定义类　22 2.3.6　编写Mixin　25 2.3.7　模块、可枚举和集合　26 2.3.8　第二天我们学到了什么　27 2.3.9　第二天自习　28 2.4　第三天：重大改变　28 2.4.1　打开类　29 2.4.2　使用method_missing　30 2.4.3　模块　31 2.4.4　第三天我们学到了什么　35 2.4.5　第三天自习　35 2.5　趁热打铁　35 2.5.1　核心优势　35 2.5.2　不足之处　37 2.5.3　最后思考　37</span><br><span class="line"></span><br><span class="line"> 第3章　Io　38 3.1　Io简介　38 3.2　第一天：逃学吧，轻松一下　39 3.2.1　开场白　39 3.2.2　对象、原型和继承　40 3.2.3　方法　43 3.2.4　列表和映射　44 3.2.5　true、false、nil以及单例　46 3.2.6　Steve Dekorte访谈录　48 3.2.7　第一天我们学到了什么　49 3.2.8　第一天自习　50 3.3　第二天：香肠大王　50 3.3.1　条件和循环　51 3.3.2　运算符　52 3.3.3　消息　54 3.3.4　反射　56 3.3.5　第二天我们学到了什么　57 3.3.6　第二天自习　57 3.4　第三天：花车游行和各种奇妙经历　58 3.4.1　领域特定语言　58 3.4.2　Io的method_missing　60 3.4.3　并发　62 3.4.4　第三天我们学到了什么　64 3.4.5　第三天自习　64 3.5　趁热打铁　65 3.5.1　核心优势　65 3.5.2　不足之处　66 3.5.3　最后思考　66</span><br><span class="line"></span><br><span class="line"> 第4章　Prolog　67 4.1　关于Prolog　68 4.2　第一天：一名优秀的司机　68 4.2.1　基本概况　68 4.2.2　基本推论和变量　69 4.2.3　填空　70 4.2.4　合一，第一部分　73 4.2.5　实际应用中的Prolog　75 4.2.6　第一天我们学到了什么　77 4.2.7　第一天自习　77 4.3　第二天：离瓦普纳法官开演还有15分钟　78 4.3.1　递归　78 4.3.2　列表和元组　79 4.3.3　列表与数学运算　82 4.3.4　在两个方向上使用规则　83 4.3.5　第二天我们学到了什么　86 4.3.6　第二天自习　87 4.4　第三天：维加斯的爆发　87 4.4.1　解决数独问题　87 4.4.2　八皇后问题　91 4.4.3　第三天我们学到了什么　96 4.4.4　第三天自习　96 4.5　趁热打铁　96 4.5.1　核心优势　97 4.5.2　不足之处　97 4.5.3　最后思考　98</span><br><span class="line"></span><br><span class="line"> 第5章　Scala　99 5.1　关于Scala　99 5.1.1　与Java的密切关系　100 5.1.2　没有盲目崇拜　100 5.1.3　Martin Odersky访谈录　100 5.1.4　函数式编程与并发　101 5.2　第一天：山丘上的城堡　102 5.2.1　Scala 类型　102 5.2.2　表达式与条件　103 5.2.3　循环　105 5.2.4　范围与元组　107 5.2.5　Scala中的类　109 5.2.6　扩展类　111 5.2.7　第一天我们学到了什么　113 5.2.8　第一天自习　114 5.3　第二天：修剪灌木丛和其他新把戏　114 5.3.1　对比var和val　115 5.3.2　集合　115 5.3.3　集合与函数　119 5.3.4　第二天我们都学到了什么　124 5.3.5　第二天自习　124 5.4　第三天：剪断绒毛　125 5.4.1　XML　125 5.4.2　模式匹配　126 5.4.3　并发　128 5.4.4　实际中的并发　129 5.4.5　第三天我们学到了什么　132 5.4.6　第三天自习　132 5.5　趁热打铁　133 5.5.1　核心优势　133 5.5.2　不足之处　134 5.5.3　最后思考　135</span><br><span class="line"></span><br><span class="line"> 第6章　Erlang　136 6.1　Erlang简介　136 6.1.1　为并发量身打造　137 6.1.2　Joe Armstrong博士访谈录　138 6.2　第一天：以常人面目出现　139 6.2.1　新手上路　140 6.2.2　注释、变量和表达式　140 6.2.3　原子、列表和元组　141 6.2.4　模式匹配　142 6.2.5　函数　144 6.2.6　第一天我们学到了什么　147 6.2.7　第一天自习　147 6.3　第二天：改变结构　148 6.3.1　控制结构　148 6.3.2　匿名函数　150 6.3.3　列表和高阶函数　150 6.3.4　列表的一些高级概念　153 6.3.5　第二天我们学到了什么　156 6.3.6　第二天自习　157 6.4　第三天： 红药丸　157 6.4.1　基本并发原语　157 6.4.2　同步消息　160 6.4.3　链接进程以获得可靠性　162 6.4.4　第三天我们学到了什么　167 6.4.5　第三天自习　167 6.5　趁热打铁　167 6.5.1　核心优势　168 6.5.2　不足之处　169 6.5.3　最后思考　169</span><br><span class="line"></span><br><span class="line"> 第7章　Clojure　170 7.1　Clojure入门　170 7.1.1　一切皆Lisp　170 7.1.2　JVM　171 7.1.3　为并发更新　171 7.2　第一天：训练Luke　172 7.2.1　调用基本函数　172 7.2.2　字符串和字符　174 7.2.3　布尔值和表达式　175 7.2.4　列表、映射表、集合以及向量　176 7.2.5　定义函数　179 7.2.6　绑定　180 7.2.7　匿名函数　182 7.2.8　Rich Hickey访谈录　183 7.2.9　第一天我们学到了什么　184 7.2.10　第一天自习　185 7.3　第二天：Yoda与原力　185 7.3.1　用loop和recur递归　185 7.3.2　序列　186 7.3.3　延迟计算　189 7.3.4　defrecord和protocol　191 7.3.5　宏　193 7.3.6　第二天我们学到了什么　194 7.3.7　第二天自习　195 7.4　第三天：一瞥魔鬼　195 7.4.1　引用和事务内存　196 7.4.2　使用原子　197 7.4.3　使用代理　198 7.4.4　future　200 7.4.5　还差什么　200 7.4.6　第三天我们学到了什么　201 7.4.7　第三天自习　201 7.5　趁热打铁　201 7.5.1　Lisp悖论　202 7.5.2　核心优势　202 7.5.3　不足之处　203 7.5.4　最后思考　204</span><br><span class="line"></span><br><span class="line"> 第8章　Haskell　205 8.1　Haskell简介　205 8.2　第一天：逻辑　206 8.2.1　表达式和基本类型　206 8.2.2　函数　208 8.2.3　元组和列表　211 8.2.4　生成列表　214 8.2.5　Philip Wadler访谈录　217 8.2.6　第一天我们学到了什么　218 8.2.7　第一天自习　218 8.3　第二天：Spock的超凡力量　218 8.3.1　高阶函数　219 8.3.2　偏应用函数和柯里化　220 8.3.3　惰性求值　221 8.3.4　Simon Peyton-Jones访谈录　223 8.3.5　第二天我们学到了什么　224 8.3.6　第二天自习　225 8.4　第三天：心灵融合　226 8.4.1　类与类型　226 8.4.2　monad　231 8.4.3　第三天我们学到了什么　236 8.4.4　第三天自习　237 8.5　趁热打铁　237 8.5.1　核心优势　237 8.5.2　不足之处　238 8.5.3　最后思考　239</span><br><span class="line"></span><br><span class="line"> 第9章　落幕时分　240 9.1　编程模型　240 9.1.1　面向对象(Ruby、Scala)　241 9.1.2　原型编程(Io)　241 9.1.3　约束-逻辑编程(Prolog)　241 9.1.4　函数式编程(Scala、Erlang、Clojure、Haskell)　241 9.1.5　范型演进之路　242 9.2　并发　242 9.2.1　控制可变状态　243 9.2.2　Io、Erlang和Scala中的actor　243 9.2.3　future　243 9.2.4　事务型内存　243 9.3　编程结构　244 9.3.1　列表解析　244 9.3.2　monad　244 9.3.3　匹配　245 9.3.4　合一　246 9.4　发现自己的旋律　246</span><br><span class="line"></span><br><span class="line"> 附录　参考书目　247</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B008041DUY/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B008041DUY&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51Z9LSX5auL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>it文化</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统</title>
    <url>/2020/04/19/shen-ru-li-jie-ji-suan-ji-xi-tong/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 深入理解计算机系统<br>作者信息： 作者: 布莱恩特 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>“2005年，我开始采用Bryant和O’Hallaron的这本书作为本科生计算机系统课程的教材。现今，这本书仍然是我的计算机系统课程教科书的首选。”<br>　　——Mirela Damian，维拉诺瓦大学<br>“本书表述清晰、恰到好处——举重若轻地呈现了那些非常复杂的内容。”<br>　　——Ibrahim Matta，波士顿大学<br>“这是一本学习计算机硬件和软件如何‘真正’协同工作的好书，还教会你为什么了解这些知识会使你成为一个更有价值的程序员。本书还帮你为学习像操作系统和编译器这样的高级课程做好准备。在本书中，我最喜欢的章节是关于缓存的，当我第一次发现缓存有多重要时，真是难以置信！”<br>　　——Vishal Shah，Ask.com总架构师</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">出版者的话</span><br><span class="line">译者序</span><br><span class="line">前言</span><br><span class="line">第1章 计算机系统漫游 1</span><br><span class="line">1.1 信息就是位+上下文 1</span><br><span class="line">1.2 程序被其他程序翻译成不同的格式 3</span><br><span class="line">1.3 了解编译系统如何工作是大有益处的 4</span><br><span class="line">1.4 处理器读并解释存储在存储器中的指令 5</span><br><span class="line">1.4.1 系统的硬件组成 5</span><br><span class="line">1.4.2 运行hello程序 7</span><br><span class="line">1.5 高速缓存至关重要 7</span><br><span class="line">1.6 存储设备形成层次结构 9</span><br><span class="line">1.7 操作系统管理硬件 10</span><br><span class="line">1.7.1 进程 11</span><br><span class="line">1.7.2 线程 12</span><br><span class="line">1.7.3 虚拟存储器 12</span><br><span class="line">1.7.4 文件 13</span><br><span class="line">1.8 系统之间利用网络通信 13</span><br><span class="line">1.9 重要主题 15</span><br><span class="line">1.9.1 并发和并行 15</span><br><span class="line">1.9.2 计算机系统中抽象的重要性 17</span><br><span class="line">1.10 小结 17</span><br><span class="line">参考文献说明 18 </span><br><span class="line"></span><br><span class="line"> 第一部分 程序结构和执行 第2章 信息的表示和处理 20 2.1 信息存储 22 2.1.1 十六进制表示法 22 2.1.2 字 25 2.1.3 数据大小 25 2.1.4 寻址和字节顺序 26 2.1.5 表示字符串 31 2.1.6 表示代码 31 2.1.7 布尔代数简介 32 2.1.8 C语言中的位级运算 34 2.1.9 C语言中的逻辑运算 36 2.1.10 V语言中的移位运算 36 2.2 整数表示 38 2.2.1 整型数据类型 38 2.2.2 无符号数的编码 39 2.2.3 补码编码 40 2.2.4 有符号数和无符号数之间的转换 44 2.2.5 C语言中的有符号数与无符号数 47 2.2.6 扩展一个数字的位表示 49 2.2.7 截断数字 51 2.2.8 关于有符号数与无符号数的建议 52 2.3 整数运算 54 2.3.1 无符号加法 54 2.3.2 补码加法 57 2.3.3 补码的非 59 2.3.4 无符号乘法 60 2.3.5 补码乘法 60 2.3.6 乘以常数 63 2.3.7 除以2的幂 64 2.3.8 关于整数运算的最后思考 67 2.4 浮点数 67 2.4.1 二进制小数 68 2.4.2 IEEE浮点表示 70 2.4.3 数字示例 71 2.4.4 舍入 74 2.4.5 浮点运算 76 2.4.6 C语言中的浮点数 77 2.5 小结 79 参考文献说明 80 家庭作业 80 练习题答案 90</span><br><span class="line"></span><br><span class="line"> 第3章 程序的机器级表示 102 3.1 历史观点 103 3.2 程序编码 105 3.2.1 机器级代码 106 3.2.2 代码示例 107 3.2.3 关于格式的注解 109 3.3 数据格式 111 3.4 访问信息 112 3.4.1 操作数指示符 112 3.4.2 数据传送指令 114 3.4.3 数据传送示例 116 3.5 算术和逻辑操作 118 3.5.1 加载有效地址 118 3.5.2 一元操作和二元操作 119 3.5.3 移位操作 120 3.5.4 讨论 120 3.5.5 特殊的算术操作 122 3.6 控制 123 3.6.1 条件码 124 3.6.2 访问条件码 125 3.6.3 跳转指令及其编码 127 3.6.4 翻译条件分支 129 3.6.5 循环 132 3.6.6 条件传送指令 139 3.6.7 switch语句 144 3.7 过程 149 3.7.1 栈帧结构 149 3.7.2 转移控制 150 3.7.3 寄存器使用惯例 151 3.7.4 过程示例 152 3.7.5 递归过程 156 3.8 数组分配和访问 158 3.8.1 基本原则 158 3.8.2 指针运算 159 3.8.3 嵌套的数组 159 3.8.4 定长数组 161 3.8.5 变长数组 163 3.9 异质的数据结构 164 3.9.1 结构 164 3.9.2 联合 167 3.9.3 数据对齐 170 3.10 综合：理解指针 172 3.11 应用：使用GDB调试器 174 3.12 存储器的越界引用和缓冲区溢出 175 3.13 x86-64：将ia32扩展到64位 183 3.13.1 x86-64的历史和动因 184 3.13.2 x86-64简介 185 3.13.3 访问信息 187 3.13.4 控制 192 3.13.5 数据结构 200 3.13.6 关于x86-64的总结性评论 200 3.14 浮点程序的机器级表示 201 3.15 小结 201 参考文献说明 202 家庭作业 202 练习题答案 212</span><br><span class="line"></span><br><span class="line"> 第4章 处理器体系结构2 30 4.1 Y86指令集体系结构 231 4.1.1 程序员可见的状态 231 4.1.2 Y86指令 232 4.1.3 指令编码 233 4.1.4 Y86异常 237 4.1.5 Y86程序 237 4.1.6 一些Y86指令的详情 241 4.2 逻辑设计和硬件控制语言HCL 242 4.2.1 逻辑门 243 4.2.2 组合电路和HCL布尔表达式 243 4.2.3 字级的组合电路和HCL整数表达式 245 4.2.4 集合关系 248 4.2.5 存储器和时钟 248 4.3 y86的顺序实现 250 4.3.1 将处理组织成阶段 250 4.3.2 SEQ硬件结构 258 4.3.3 SEQ的时序 259 4.3.4 SEQ阶段的实现 262 4.4 流水线的通用原理 267 4.4.1 计算流水线 268 4.4.2 流水线操作的详细说明 269 4.4.3 流水线的局限性 271 4.4.4 带反馈的流水线系统272 4.5 Y86的流水线实现273 4.5.1 SEQ+：重新安排计算阶段 273 4.5.2 插入流水线寄存器 276 4.5.3 对信号进行重新排列和标号 277 4.5.4 预测下一个PC 279 4.5.5 流水线冒险 280 4.5.6 用暂停来避免数据冒险 283 4.5.7 用转发来避免数据冒险 285 4.5.8 加载&#x2F;使用数据冒险 288 4.5.9 异常处理 289 4.5.10 pipe各阶段的实现 291 4.5.11 流水线控制逻辑 297 4.5.12 性能分析 305 4.5.13 未完成的工作 306 4.6 小结 308 参考文献说明309 家庭作业309 练习题答案 314</span><br><span class="line"></span><br><span class="line"> 第5章 优化程序性能 324 5.1 优化编译器的能力和局限性 325 5.2 表示程序性能 328 5.3 程序示例 330 5.4 消除循环的低效率 332 5.5 减少过程调用 336 5.6 消除不必要的存储器引用 336 5.7 理解现代处理器 340 5.7.1 整体操作 340 5.7.2 功能单元的性能 343 5.7.3 处理器操作的抽象模型 344 5.8 循环展开 348 5.9 提高并行性 351 5.9.1 多个累积变量 351 5.9.2 重新结合变换 354 5.10 优化合并代码的结果小结 358 5.11 一些限制因素 359 5.11.1 寄存器溢出359 5.11.2 分支预测和预测错误处罚 360 5.12 理解存储器性能 363 5.12.1 加载的性能 363 5.12.2 存储的性能 364 5.13 应用：性能提高技术 369 5.14 确认和消除性能瓶颈 369 5.14.1 程序剖析 370 5.14.2 使用剖析程序来指导优化 371 5.14.3 Amdahl定律 374 5.15 小结 375 参考文献说明 375 家庭作业 376 练习题答案 378</span><br><span class="line"></span><br><span class="line"> 第6章 存储器层次结构 382 6.1 存储技术 382 6.1.1 随机访问存储器 383 6.1.2 磁盘存储 389 6.1.3 固态硬盘 398 6.1.4 存储技术趋势 399 6.2 局部性 401 6.2.1 对程序数据引用的局部性 402 6.2.2 取指令的局部性 403 6.2.3 局部性小结 403 6.3 存储器层次结构 405 6.3.1 存储器层次结构中的缓存 406 6.3.2 存储器层次结构概念小结 408 6.4 高速缓存存储器 408 6.4.1 通用的高速缓存存储器结构 409 6.4.2 直接映射高速缓存 410 6.4.3 组相联高速缓存 416 6.4.4 全相联高速缓存 418 6.4.5 有关写的问题 420 6.4.6 一个真实的高速缓存层次结构的解剖 421 6.4.7 高速缓存参数的性能影响 422 6.5 编写高速缓存友好的代码 423 6.6 综合：高速缓存对程序性能的影响 426 6.6.1 存储器山 426 6.6.2 重新排列循环以提高空间局部性 430 6.6.3 在程序中利用局部性 433 6.7 小结 433 参考文献说明 434 家庭作业 434 练习题答案 442</span><br><span class="line"></span><br><span class="line"> 第二部分 在系统上运行程序 第7章 链接 448 7.1 编译器驱动程序 449 7.2 静态链接 450 7.3 目标文件 450 7.4 可重定位目标文件 451 7.5 符号和符号表 452 7.6 符号解析 454 7.6.1 链接器如何解析多重定义的全局符号 455 7.6.2 与静态库链接 457 7.6.3 链接器如何使用静态库来解析引用 460 7.7 重定位 461 7.7.1 重定位条目 461 7.7.2 重定位符号引用 462 7.8 可执行目标文件 465 7.9 加载可执行目标文件 466 7.10 动态链接共享库 467 7.11 从应用程序中加载和链接共享库 468 7.12 与位置无关的代码（PIC） 471 7.13 处理目标文件的工具 473 7.14 小结 473 参考文献说明 474 家庭作业 474 练习题答案 479</span><br><span class="line"></span><br><span class="line"> 第8章 异常控制流 480 8.1 异常 481 8.1.1 异常处理 481 8.1.2 异常的类别 482 8.1.3 Linux&#x2F;IA32系统中的异常 484 8.2 进程 487 8.2.1 逻辑控制流 487 8.2.2 并发流 487 8.2.3 私有地址空间488 8.2.4 用户模式和内核模式 488 8.2.5 上下文切换 489 8.3 系统调用错误处理 491 8.4 进程控制 492 8.4.1 获取进程ID 492 8.4.2 创建和终止进程 492 8.4.3 回收子进程 495 8.4.4 让进程休眠 499 8.4.5 加载并运行程序500 8.4.6 利用fork和execve运行程序502 8.5 信号 504 8.5.1 信号术语 505 8.5.2 发送信号 506 8.5.3 接收信号 509 8.5.4 信号处理问题 511</span><br><span class="line"></span><br><span class="line"> …… 第9章 虚拟存储器 534 第10章 系统级I&#x2F;O 596 第11章 网络编程 614 第12章 并发编程 648 附录A 错误处理 694</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B004BJ18KM/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B004BJ18KM&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51XrO5U3a-L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>it文化</tag>
      </tags>
  </entry>
  <entry>
    <title>松本行弘的程序世界</title>
    <url>/2020/04/19/song-ben-xing-hong-de-cheng-xu-shi-jie/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 松本行弘的程序世界<br>作者信息： 作者: 松本行弘 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《松本行弘的程序世界》为“Ruby之父”经典力作，展现了大师级的程序思考方式。作者凭借对编程本质的深刻认识和对各种技术优缺点的掌握，阐述了Ruby的设计理念，并由此延伸，带领读者了解编程的本质，一窥程序设计的奥秘。<br>《松本行弘的程序世界》不是为了介绍某种特定的技术，而是从宏观的角度讨论与编程相关的各种技术。书中第1章介绍了作者对编程问题的新思考和新看法，剩下的内容出自《日经Linux》杂志于2005年5月到2009年4月连载的“松本编程模式讲坛”，其中真正涉及“模式”的内容并不多，大量篇幅都用于介绍技术内幕和背景分析等内容，使读者真正了解相关技术的立足点。另外，书中还包含许多以Ruby、Lisp、Smalltalk、ErIang、JavaScrlpl等动态语言所写成的范例。<br>Ruby之父佳作，进入不同凡响的程序世界，深入剖析程序设计的道与术，举一反三，触类旁通。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 我为什么开发Ruby 1</span><br><span class="line">1.1 我为什么开发Ruby 2</span><br><span class="line">1.1.1 编程语言的重要性 2</span><br><span class="line">1.1.2 Ruby的原则 3</span><br><span class="line">1.1.3 简洁性 4</span><br><span class="line">1.1.4 扩展性 5</span><br><span class="line">1.1.5 稳定性 6</span><br><span class="line">1.1.6 一切皆因兴趣 7 </span><br><span class="line"></span><br><span class="line"> 第2章 面向对象 9 2.1 编程和面向对象的关系 10 2.1.1 颠倒的构造 10 2.1.2 主宰计算机的武器 11 2.1.3 怎样写程序 12 2.1.4 面向对象的编程方法 12 2.1.5 面向对象的难点 13 2.1.6 多态性 13 2.1.7 具体的程序 14 2.1.8 多态性的优点 15 2.2 数据抽象和继承 16 2.2.1 面向对象的历史 16 2.2.2 复杂性是面向对象的敌人 18 2.2.3 结构化编程 18 2.2.4 数据抽象化 19 2.2.5 雏形 21 2.2.6 找出相似的部分来继承 22 2.3 多重继承的缺点 23 2.3.1 为什么需要多重继承 23 2.3.2 多重继承和单一继承不可分离 24 2.3.3 goto语句和多重继承比较相似 25 2.3.4 解决多重继承的问题 25 2.3.5 静态语言和动态语言的区别 26 2.3.6 静态语言的特点 26 2.3.7 动态语言的特点 27 2.3.8 静态语言和动态语言的比较 27 2.3.9 继承的两种含义 28 2.3.10 接口的缺点 28 2.3.11 继承实现的方法 29 2.3.12 从多重继承变形而来的Mix-in 29 2.3.13 积极支持Mix-in的Ruby 30 2.4 两个误解 31 2.4.1 面向对象的编程 31 2.4.2 对象的模板&#x3D;类 33 2.4.3 利用模块的手段&#x3D;继承 33 2.4.4 多重继承不好吗 34 2.4.5 动态编程语言也需要多重继承 35 2.4.6 驯服多重继承的方法 35 2.4.7 Ruby中多重继承的实现方法 37 2.4.8 Java实现多重继承的方法 38 2.5 Duck Typing诞生之前 39 2.5.1 为什么需要类型 39 2.5.2 动态的类型是从Lisp中诞生的 40 2.5.3 动态类型在面向对象中发展起来了 41 2.5.4 动态类型和静态类型的邂逅 42 2.5.5 静态类型的优点 42 2.5.6 动态类型的优点 43 2.5.7 只关心行为的Duck Typing 44 2.5.8 避免明确的类型检查 45 2.5.9 克服动态类型的缺点 46 2.5.10 动态编程语言 46 2.6 元编程 46 2.6.1 元编程 46 2.6.2 反射 47 2.6.3 元编程的例子 48 2.6.4 使用反射功能 48 2.6.5 分布式Ruby的实现 49 2.6.6 数据库的应用 50 2.6.7 输出XML 51 2.6.8 元编程和小编程语言 51 2.6.9 声明的实现 52 2.6.10 上下文相关的实现 52 2.6.11 单位的实现 53 2.6.12 词汇的实现 53 2.6.13 层次数据的实现 54 2.6.14 适合DSL的语言，不适合DSL的语言 54</span><br><span class="line"></span><br><span class="line"> 第3章 程序块 57 3.1 程序块的威力 58 3.1.1 把函数作为参数的高阶函数 58 3.1.2 C语言高阶函数的局限 59 3.1.3 可以保存外部环境的闭包 60 3.1.4 块的两种使用方法 60 3.1.5 最终来看，块到底是什么 61 3.1.6 块在循环处理中的应用 62 3.1.7 内部迭代器和外部迭代器 62 3.1.8 在排序和比较大小中的应用 63 3.1.9 用块保证程序的后处理 63 3.1.10 用块实现新的控制结构 64 3.1.11 在回调中使用块 65 3.1.12 块处理的特别理由 65 3.2 用块作循环 66 3.2.1 块是处理的集合 67 3.2.2 块应用范围的扩展 68 3.2.3 高阶函数和块的本质一样 69 3.2.4 用Enumerable来利用块 69 3.2.5 Enumerable的局限 74 3.3 精通集合的使用 77 3.3.1 使用Ruby的数组 77 3.3.2 修改指定范围的元素内容 78 3.3.3 Ruby中的哈希处理 78 3.3.4 支持循环的Enumerable 79 3.3.5 用于循环的each方法 81 3.3.6 使用inject、zip和grep 81 3.3.7 用来指定条件的select方法 82 3.3.8 排序与比较大小的方法 83 3.3.9 在类中包含(include)Enumerable模块 84 3.3.10 List的内部包和块的区别 85</span><br><span class="line"></span><br><span class="line"> 第4章 设计模式 89 4.1 设计模式(1) 90 4.1.1 设计模式的价值和意义 91 4.1.2 设计模式是程序抽象化的延伸 92 4.1.3 Ruby中的设计模式 92 4.1.4 Singleton模式 92 4.1.5 Proxy模式 94 4.1.6 Iterator模式 95 4.1.7 外部与内部，哪一个更好 96 4.1.8 内部迭代器的缺陷 97 4.1.9 外部迭代器的缺陷 98 4.2 设计模式(2) 98 4.2.1 模式与动态语言的关系 99 4.2.2 重复使用既存对象的Prototype模式 99 4.2.3 亲身体验Io语言 100 4.2.4 Ruby中的原型 101 4.2.5 编写抽象算法的Template Method模式 101 4.2.6 用Ruby来尝试TemplateMethod 102 4.2.7 动态语言与Template Method模式 104 4.2.8 避免高度依赖性的Observer模式 104 4.2.9 Observable模块 105 4.2.10 Observer模式与动态语言 107 4.3 设计模式(3) 107 4.3.1 软件开发的悲剧 108 4.3.2 开放-封闭原则 108 4.3.3 面向对象的情况 109 4.3.4 非面向对象的情况 110 4.3.5 OCP与Template Method模式 111 4.3.6 Observer模式 113 4.3.7 使用Strategy模式 114 4.3.8 Strategy模式与OCP 116</span><br><span class="line"></span><br><span class="line"> 第5章 Ajax 119 5.1 Ajax和JavaScript(前篇) 120 5.1.1 通信及异步页面更新 120 5.1.2 技术要素之一：JavaScript 122 5.1.3 技术要素之二：XML 122 5.1.4 XML以外的数据表现形式 123 5.1.5 技术要素之三：DHTML 124 5.1.6 JavaScript技术基础 124 5.1.7 原型模式的面向对象编程语言 126 5.1.8 使用prototype.js库 127 5.1.9 prototype.js的功能 127 5.2 Ajax和JavaScript(后篇) 130 5.2.1 巧妙使用DHTML 131 5.2.2 获取document节点 132 5.2.3 获取和更新标签数据 133 5.2.4 设定事件处理程序 133 5.2.5 追加标签节点 135 5.2.6 本地HTML应用 135 5.2.7 和服务器间的通信 137 5.2.8 使用Prototype.js的优点 138 5.2.9 在服务器上保存数据 138 5.2.10 Web应用的脆弱性 140 5.2.11 使用JavaScript的感觉 141</span><br><span class="line"></span><br><span class="line"> 第6章 Ruby on Rails 143 6.1 MVC和Ruby on Rails 144 6.1.1 模型、视图和控制的作用 144 6.1.2 用秒表的例子来学习MVC模式 145 6.1.3 生成视图和控制部分 147 6.1.4 GUI工具箱与MVC 148 6.1.5 同时使用工具箱和MVC 149 6.1.6 MVC的优缺点 151 6.1.7 Web应用中的MVC 152 6.2 开放类和猴子补丁 153 6.2.1 开放类 154 6.2.2 猴子补丁的目的 154 6.2.3 猴子补丁的技巧 155 6.2.4 灵活使用开放类的库 159 6.2.5 猴子补丁的几点问题 161 6.2.6 其他办法 162 6.2.7 Ruby on Rails和开放类 165 6.2.8 ActiveSupport带来的扩展 166 6.2.9 字节单位系列 168 6.2.10 复数形和序数 168 6.2.11 大规模开发和Ruby 169 6.2.12 信赖性模型 170 6.2.13 猴子补丁的未来 170</span><br><span class="line"></span><br><span class="line"> 第7章 文字编码 173 7.1 文字编码的种类 174 7.1.1 早期的文字编码 174 7.1.2 纸带与文字表现 175 7.1.3 文字是什么 176 7.1.4 走向英语以外的语言(欧洲篇) 177 7.1.5 英语以外的语言(亚洲篇) 177 7.1.6 Unicode的问世 180 7.1.7 统一编码成16位的汉字统合 181 7.1.8 Unicode的两个问题 181 7.1.9 Unicode的文字集 182 7.1.10 文字表示的不确定性 183 7.1.11 Unicode的字符编码方式 183 7.2 程序中的文字处理 185 7.2.1 文字编码有多个意思 185 7.2.2 只能处理文字集中包含的文字 185 7.2.3 纷繁复杂的文字编码方式 186 7.2.4 影响力渐微的Shift_JIS与EUC-JP 186 7.2.5 Unicode有多种字符编码方式 186 7.2.6 为什么会发生乱码 188 7.2.7 字符编码方式错误 188 7.2.8 没有字体 189 7.2.9 变换为内部码时出错 189 7.2.10 发生不完全变换 189 7.2.11 文字集的不同 190 7.2.12 字节顺序错误 191 7.2.13 从编程语言的角度处理文字 191 7.2.14 以变换为前提的UCS方式 191 7.2.15 原封不动处理的CSI方式 192 7.2.16 使用UTF-16的Java 192 7.2.17 使用UTF-8的Perl 193 7.2.18 用UTF-16的Python 194 7.2.19 采用CSI方式的Ruby 1.8 194 7.2.20 强化了功能的Ruby 1.9 195 7.2.21 是UCS还是CSI 196</span><br><span class="line"></span><br><span class="line"> 第8章 正则表达式 199 8.1 正则表达式基础 200 8.1.1 检索“像那样的东西” 200 8.1.2 正则表达式的语法 200 8.1.3 3个陷阱 203 8.1.4 正则表达式对象 204 8.1.5 选项 205 8.1.6 正则表达式匹配的方法 206 8.1.7 特殊变量 207 8.1.8 字符串与正则表达式 207 8.1.9 split的本质 207 8.1.10 字符串的扫描 208 8.1.11 置换 208 8.2 正则表达式的应用实例与“鬼车” 210 8.2.1 解析日志文件的方法 211 8.2.2 避免使用$的方法 213 8.2.3 从邮件中取出日期的方法 215 8.2.4 典型拼写错误的检索方法 216 8.2.5 Ruby 1.9的新功能“鬼车” 216</span><br><span class="line"></span><br><span class="line"> 第9章 整数和浮点小数 219 9.1 深奥的整数世界 220 9.1.1 整数是有范围的 221 9.1.2 尝试位运算 222 9.1.3 操作特定的位 223 9.1.4 表示负数的办法 225 9.1.5 Ruby的整数 226 9.1.6 挑战公开密钥方式 227 9.2 扑朔迷离的浮点小数世界 228 9.2.1 计算机对小数的处理 229 9.2.2 固定小数点数不易使用 229 9.2.3 科学计数法也有问题 229 9.2.4 小数不能完全表示 230 9.2.5 有不能比较的时候 231 9.2.6 误差积累 232 9.2.7 不是数的特别“数” 232 9.2.8 计算误差有多种 233 9.2.9 误差导致的严重问题 235 9.2.10 BigDecimal是什么 236 9.2.11 能够表示分数的Rational类 236</span><br><span class="line"></span><br><span class="line"> 第10章 高速执行和并行处理 239 10.1 让程序高速执行(前篇) 240 10.1.1 是不是越快越好 240 10.1.2 高速执行的乐趣与效率 240 10.1.3 以数据为基础作出判断 241 10.1.4 改善系统调用 241 10.1.5 数据可靠吗 243 10.1.6 只需改善瓶颈 243 10.1.7 profiler本身成了累赘 245 10.1.8 算法与数据结构 245 10.1.9 理解O记法 245 10.1.10 选择算法 246 10.1.11 调查算法的性能 246 10.1.12 高速执行的悲哀 247 10.1.13 性能优化的格言 248 10.2 让程序高速执行(后篇) 248 10.2.1 确认程序概要 249 10.2.2 发现瓶颈 250 10.2.3 使用更好的profiler 251 10.2.4 高速优化之一：削减对象 252 10.2.5 高速优化之二：利用立即值 254 10.2.6 高速优化之三：利用C语言 255 10.2.7 高速优化之四：采用合适的数据结构 256 10.2.8 全部以C语言计算 257 10.2.9 还存在其他技巧 257 10.3 并行编程 258 10.3.1 使用线程的理由 258 10.3.2 生成线程 259 10.3.3 线程的执行状态 260 10.3.4 传递值给线程的方法 261 10.3.5 信息共有所产生的问题 262 10.3.6 数据完整性的丧失 262 10.3.7 死锁 263 10.3.8 用锁来实现对资源的独占 264 10.3.9 二级互斥 265 10.3.10 用队列协调线程 265 10.3.11 锁模型与队列模型的比较 267 10.4 前景可期的并行编程技术，Actor 268 10.4.1 何谓Actor 268 10.4.2 操作Actor的3种处理系统 269 10.4.3 Erlang的程序 270 10.4.4 Pingpong处理的开始 270 10.4.5 启动pingpong程序 271 10.4.6 Erlang的错误处理 272 10.4.7 Erlang的使用场所 273 10.4.8 面向Ruby的库“Revactor” 273 10.4.9 Revactor的应用场合 274 10.4.10 另一个库Dramatis 275</span><br><span class="line"></span><br><span class="line"> 第11章 程序安全性 279 11.1 程序的漏洞与攻击方法 280 11.1.1 4种软件漏洞 280 11.1.2 因权限被窃取而成为重大问题 281 11.1.3 安全问题的根源 281 11.1.4 “守护神”引起的问题 282 11.1.5 多 样化的攻击手段 282 11.1.6 缓冲区溢出 283 11.1.7 整数溢出 284 11.1.8 SQL注入 285 11.1.9 Shell注入 286 11.1.10 跨站点脚本攻击 287 11.1.11 跨站点伪造请求 288 11.1.12 社会工程 289 11.2 用异常进行错误处理 290 11.2.1 异常的历史 292 11.2.2 Java的受控异常 292 11.2.3 Icon的面向目标判断 293 11.2.4 Ruby的异常 294 11.2.5 异常发生 295 11.2.6 异常类 296 11.2.7 异常处理的设计方针 297 11.2.8 异常发生的设计原则 298</span><br><span class="line"></span><br><span class="line"> 第12章 关于时间的处理 301 12.1 用程序处理时刻与时间 302 12.1.1 时差与时区 302 12.1.2 世界协调时间 302 12.1.3 夏令时(DST) 303 12.1.4 改历 304 12.1.5 日期与时间的类 305 12.1.6 2038年问题 308 12.1.7 DateTime类 309 12.1.8 Time与DateTime的相互变换 310</span><br><span class="line"></span><br><span class="line"> 第13章 关于数据的持久化 313 13.1 持久化数据的方法 314 13.1.1 保存文本 314 13.1.2 变换成文本的Marshal 314 13.1.3 使用Marshal模块 315 13.1.4 复制有两种方式 316 13.1.5 仔细看Marshal的格式 316 13.1.6 不能保存的3类对象 317 13.1.7 制作面向对象数据库 318 13.1.8 试用PStore 318 13.1.9 变换为文本的YAML 320 13.1.10 用YAML制作数据库 321 13.2 对象的保存 322 13.2.1 高速的Object Prevalence 322 13.2.2 Object Prevalence的问题点 323 13.2.3 使用Madeleine 323 13.2.4 访问时刻信息 325 13.2.5 让Madeleine更容易使用 326 13.2.6 Madeleine的实用例Instiki 328 13.3 关于XML的考察 328 13.3.1 XML的祖先是SGML 329 13.3.2 XML是树结构的数据表现 329 13.3.3 优点在于纯文本 330 13.3.4 缺点在于冗长 331 13.3.5 不适合重视效率的处理 331 13.3.6 适合于信息交换的格式 332 13.3.7 XML的解析 332 13.3.8 XML处理库REXML 333 13.3.9 XML的代替 336</span><br><span class="line"></span><br><span class="line"> 第14章 函数式编程 339 14.1 新范型——函数式编程 340 14.1.1 具有多种函数式性质的Lisp 341 14.1.2 彻底的函数式编程语言Haskell 342 14.1.3 延迟计算：不必要的处理就不做 343 14.1.4 灵活的“静态多态性”类型系统 344 14.1.5 近代函数式语言之父OCaml 345 14.1.6 强于并行计算的Erlang 345 14.1.7 用Ruby进行函数式编程 346 14.1.8 用枚举器来实现延迟计算 347 14.2 自动生成代码 348 14.2.1 在商业中利用Ruby 349 14.2.2 使用Ruby自动生成代码 350 14.2.3 消除重复代码 350 14.2.4 代码生成的应用 351 14.2.5 代码生成的效果 352 14.2.6 编写代码生成器 353 14.2.7 也可以使用XML 354 14.2.8 在EJB中使用代码生成 355 14.3 内存管理与垃圾收集 356 14.3.1 内存管理的困难 357 14.3.2 垃圾收集亮相之前 358 14.3.3 评价垃圾收集的两个指标 359 14.3.4 垃圾收集算法 360 14.3.5 引用计数方式 360 14.3.6 标记和扫除方式 361 14.3.7 标记和紧缩方式 362 14.3.8 复制方式 363 14.3.9 多种多样的垃圾收集算法 364 14.3.10 分代垃圾收集 364 14.3.11 保守垃圾收集 366 14.3.12 增量垃圾收集 366 14.3.13 并行垃圾收集 367 14.3.14 位图标记 367 14.4 用C语言来扩展Ruby 368 14.4.1 开发与执行速度的取舍 368 14.4.2 扩展库 369 14.4.3 看例题学习扩展模块 370 14.4.4 QDBM函数 372 14.4.5 初始化对象 373 14.4.6 实现方法 374 14.4.7 关于垃圾收集的注意事项 376 14.4.8 其他的Ruby API 376 14.4.9 扩展库的编译 376 14.4.10 扩展库以外的工具 377 14.5 为什么要开源 380 14.5.1 自由软件的思想 380 14.5.2 自由软件的历史 381 14.5.3 Emacs事件的发生 381 14.5.4 开源的诞生 382 14.5.5 OSS许可证 383 14.5.6 开源的背景 385 14.5.7 企业关注开源的理由 386 14.5.8 Ruby与开源 386 14.5.9 选择许可证的方法 387</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B005KGBTQ8/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B005KGBTQ8&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41hbSw%2Br-UL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>ruby</tag>
      </tags>
  </entry>
  <entry>
    <title>信息简史（英文版）</title>
    <url>/2020/04/19/the-information-a-history-a-theory-a-flood/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 信息简史（英文版）<br>作者信息： 作者: James Gleick [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>The story of information begins in a time profoundly unlike our own, when every thought and utterance vanished as soon as it was born. From the invention of scripts and alphabets to the long misunderstood “talk­ing drums” of Africa, James Gleick tells the story of information technologies that changed the very nature of human consciousness. He provides portraits of the key figures contributing to the inexorable develop­ment of our modern understanding of information: Charles Babbage, the idiosyncratic inventor of the first great mechanical computer; Ada Byron, the po­et’s brilliant and doomed daughter, who became the first true programmer; pivotal figures like Samuel Morse and Alan Turing; and Claude Shannon, the cre­ator of information theory itself. Chapter 1. Drums That Talk<br>Chapter 2. The Persistence of the Word<br>Chapter 3. Two Wordbooks<br>Chapter 4. To Throw the Powers of Thought into Wheel-Work<br>Chapter 5. A Nervous System for the Earth<br>Chapter 6. New Wires, New Logic<br>Chapter 7. Information Theory<br>Chapter 8. The Informational Turn<br>Chapter 9. Entropy and Its Demons<br>Chapter 10. Life’s Own Code<br>Chapter 11. Into the Meme Pool<br>Chapter 12. The Sense of Randomness<br>Chapter 13. Information Is Physical<br>Chapter 14. After the Flood<br>Chapter 15. New News Every Day</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/0375423729/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=0375423729&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51abKuKivNL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>it文化</tag>
      </tags>
  </entry>
  <entry>
    <title>响应式Web设计 HTML5和CSS3实战</title>
    <url>/2020/04/19/xiang-ying-shi-webshe-ji-html5he-css3shi-zhan/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 响应式Web设计 HTML5和CSS3实战<br>作者信息： 作者: Ben Frain [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《响应式Web设计：HTML5和CSS3实战》作者Ben Frain将当前Web设计中热门的响应式设计技术与HTML和CSS3完美结合，帮助读者全面掌握最新的Web设计技术，一步跨入最前沿；《响应式Web设计：HTML5和CSS3实战》是前端设计人员必备教程。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 　HTML5、CSS3及响应式设计入门　1</span><br><span class="line">1.1 　为什么智能手机很重要（而老版的IE不再重要）　2</span><br><span class="line">1.2 　响应式设计一定是最佳选择吗　3</span><br><span class="line">1.3 　响应式网页设计的定义　3</span><br><span class="line">1.4 　为什么要在响应式设计上停滞不前　4</span><br><span class="line">1.5 　响应式网页设计示例　4</span><br><span class="line">1.5.1 　下载视口调试工具　4</span><br><span class="line">1.5.2 　在线创意源泉　11</span><br><span class="line">1.6 　为什么HTML5很优秀　12</span><br><span class="line">1.6.1 　省时省力　12</span><br><span class="line">1.6.2 　新增了语义化标签元素　13</span><br><span class="line">1.7 　CSS3为响应式设计和更多创新奠定了基础　13</span><br><span class="line">1.7.1 　底线：CSS3不破坏任何东西　14</span><br><span class="line">1.7.2 　CSS3如何解决日常设计问题　14</span><br><span class="line">1.8 　看呐，不用图片　17</span><br><span class="line">1.9 　HTML5和CSS3现在就能用吗　20</span><br><span class="line">1.10 　响应式网页设计不是灵丹妙药　20</span><br><span class="line">1.11 　引导客户：网站不必在所有浏览器中表现一致　21</span><br><span class="line">1.12 　小结　22</span><br><span class="line">第2章 　媒体查询：支持不同的视口　23</span><br><span class="line">2.1 　现在就能使用媒体查询　23</span><br><span class="line">2.2 　为什么响应式设计需要媒体查询　24</span><br><span class="line">2.2.1 　媒体查询语法　24</span><br><span class="line">2.2.2 　 媒体查询能检测那些特性　26</span><br><span class="line">2.2.3 　用媒体查询改造我们的设计　27</span><br><span class="line">2.2.4 　加载媒体查询的最佳方法　27</span><br><span class="line">2.3 　我们的第一个响应式设计　27</span><br><span class="line">2.3.1 　我们的设计是固定宽度的，不要惊讶　28</span><br><span class="line">2.3.2 　响应式设计中要保证图片尽可能精简　32</span><br><span class="line">2.3.3 　小视口下的内容剪切　33</span><br><span class="line">2.4 　阻止移动浏览器自动调整页面大小　34</span><br><span class="line">2.5 　针对不同视口宽度修正设计　37</span><br><span class="line">2.6 　响应式设计中内容始终优先　38</span><br><span class="line">2.7 　媒体查询只是必要条件之一　42</span><br><span class="line">2.8 　小结　42</span><br><span class="line">第3章 　拥抱流式布局　43</span><br><span class="line">3.1 　固定布局经不起未来考验　43</span><br><span class="line">3.2 　为什么响应式设计需要百分比布局　44</span><br><span class="line">3.3 　将网页从固定布局修改为百分比布局　44</span><br><span class="line">3.3.1 　需要牢记的公式　45</span><br><span class="line">3.3.2 　设置百分比元素的上下文　47</span><br><span class="line">3.3.3 　必须时刻牢记上下文　52</span><br><span class="line">3.4 　用em替换px　54</span><br><span class="line">3.5 　弹性图片　56</span><br><span class="line">3.5.1 　让图片随视口缩放　56</span><br><span class="line">3.5.2 　为特定图片指定特定规则　58</span><br><span class="line">3.5.3 　给弹性图片设置阈值　59</span><br><span class="line">3.5.4 　超级全能的max-width属性　61</span><br><span class="line">3.6 　为不同的屏幕尺寸提供不同的图片　61</span><br><span class="line">3.7 　流动网格布局和媒体查询的默契配合　66</span><br><span class="line">3.8 　CSS网格系统　66</span><br><span class="line">3.9 　小结　72</span><br><span class="line">第4章 　响应式设计中的HTML5　73</span><br><span class="line">4.1 　HTML5的哪些部分现在就能用　73</span><br><span class="line">4.1.1 　大多数网站可以用HTML5编写　74</span><br><span class="line">4.1.2 　腻子脚本和Modernizr　74</span><br><span class="line">4.2 　如何编写HTML5网页　75</span><br><span class="line">4.2.1 　HTML5的精简之道　76</span><br><span class="line">4.2.2 　HTML5标签的合理写法　76</span><br><span class="line">4.2.3 　伟大的标签万岁　77 4.2.4 　HTML的废弃零件　77 4.3 　HTML5的全新语义化元素　78 4.3.1 　 　78 4.3.2 　 　79 4.3.3 　 　79 4.3.4 　 　79 4.3.5 　 　79 4.3.6 　 　81 4.3.7 　 　81 4.3.8 　 　81 4.4 　HTML5结构元素的实际用法　81 4.5 　HTML5的文本级语义元素　87 4.5.1 　　88 4.5.2 　　88 4.5.3 　　88 4.5.4 　在页面中应用文本层语义元素　88 4.6 　遵循WAI-ARIA实现无障碍站点　90 4.7 　在HTML5中嵌入媒体　93 4.8 　用HTML5的方法为页面添加视频或音频　93 4.8.1 　提供备用的媒体源文件　95 4.8.2 　针对老版本浏览器的备用方案　95 4.8.3 　和标签的用法基本一致　96 4.9 　响应式视频　96 4.10 　离线Web应用　99 4.10.1 　离线Web应用概述　99 4.10.2 　让网页可离线使用　99 4.10.3 　理解manifest文件　100 4.10.4 　页面被自动加载到离线缓存　101 4.10.5 　版本注释的用途　101 4.10.6 　离线访问网站　101 4.10.7 　离线Web应用的故障诊断　102 4.11 　小结　103 第5章 　CSS3：选择器、字体和颜色模式　104 5.1 　CSS3给前端开发人员带来了什么　104 5.1.1 　Internet Explorer 6到8对CSS3的支持　105 5.1.2 　使用CSS3设计和开发页面　105 5.2 　CSS规则解析　105 5.3 　私有前缀及其用法　106 5.4 　快速而有效的CSS技巧　108 5.4.1 　CSS3多栏布局　108 5.4.2 　文字换行　110 5.5 　CSS3的新增选择器及其用法　111 5.5.1 　CSS3属性选择器　111 5.5.2 　CSS3结构伪类　113 5.5.3 　对伪元素的修正　122 5.6 　自定义网页字体　123 5.6.1 　@font-face规则　124 5.6.2 　使用@font-face嵌入网页字体　124 5.7 　帮帮我，标题模糊怎么办　127 5.8 　新的CSS3颜色格式和透明度　129 5.8.1 　RGB颜色　130 5.8.2 　HSL颜色　131 5.8.3 　针对IE6、IE7和IE8提供备用颜色值　132 5.8.4 　透明通道　132 5.9 　小结　134 第6章 　用CSS3创造令人惊艳的美　135 6.1 　文字阴影　136 6.1.1 　HEX、HSL或RGB颜色都可以　136 6.1.2 　px、em或rem都行　136 6.1.3 　取消文字阴影　138 6.1.4 　制作浮雕文字阴影效果　139 6.1.5 　多重文字阴影　140 6.2 　盒阴影　140 6.2.1 　内阴影　141 6.2.2 　多重阴影　142 6.3 　背景渐变　143 6.3.1 　线性背景渐变　144 6.3.2 　径向背景渐变　147 6.3.3 　重复渐变　149 6.4 　背景渐变图案　151 6.5 　CSS3的响应性　153 6.6 　组合使用CSS3属性　155 6.7 　多重背景图片　159 6.7.1 　背景图片大小　161 6.7.2 　背景图片位置　161 6.7.3 　背景属性的缩写语法　161 6.8 　更多CSS特性　162 6.9 　可缩放图标：响应式设计中的完美选择　162 6.10 　小结　163 第7章 　CSS3过渡、变形和动画　164 7.1 　什么是CSS3过渡以及如何使用它　164 7.1.1 　过渡相关的属性　166 7.1.2 　响应式网站中的有趣过渡　168 7.2 　CSS3的2D变形　169 7.3 　尝试CSS3的3D变形　174 7.3.1 　分析3D变形效果　176 7.3.2 　3D变形尚未成熟　178 7.4 　CSS3动画效果　179 7.5 　小结　185 第8章 　用HTML5和CSS3征服表单　186 8.1 　HTML5表单　186 8.1.1 　理解HTML5表单中的元素　188 8.1.2 　placeholder　189 8.1.3 　required　189 8.1.4 　autofocus　190 8.1.5 　autocomplete　191 8.1.6 　list（及对应的datalist元素）　191 8.1.7 　HTML5的新输入类型　192 8.1.8 　日期和时间输入类型　198 8.2 　如何给不支持新特性的浏览器打补丁　203 8.3 　使用CSS3美化HTML5表单　204 8.4 　小结　210 第9章 　解决跨浏览器问题　211 9.1 　渐进增强与优雅降级　215 9.2 　该不该修复老版本IE　216 9.2.1 　统计数据（再看看世界的变化）　216 9.2.2 　个人选择　216 9.3 　前端的瑞士军刀：Modernizr　217 9.3.1 　使用Modernizr辅助修正样式问题　219 9.3.2 　使用Modernizr让老版本IE支持HTML5元素　221 9.3.3 　给IE6、7、8追加min&#x2F;max媒体查询功能　222 9.3.4 　使用Modernizr按需加载资源　223 9.4 　必要时将导航链接转换为下拉菜单　225 9.5 　高分辨率设备（未来趋势）　228 9.6 　小结　231</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00AH83HUK/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00AH83HUK&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51olk4jWxVL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>用AngularJS开发下一代Web应用（英文）</title>
    <url>/2020/04/19/angularjs-2013-4/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 用AngularJS开发下一代Web应用（英文）<br>作者信息： 作者: Brad Green [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Develop smaller, lighter web apps that are simple to create and easy to test, extend, and maintain as they grow. This hands-on guide introduces you to AngularJS, the open source JavaScript framework that uses Model - view - controller (MVC) architecture, data binding, client-side templates, and dependency injection to create a much-needed structure for building web apps. Guided by two engineers who worked on AngularJS at Google, you’ll walk through the framework’s key features, and then build a working AngularJS app - from layout to testing, compiling, and debugging. You’ll learn how AngularJS helps reduce the complexity of your web app. Dive deep into Angular’s building blocks and learn how they work together Gain maximum flexibility by separating logic, data, and presentation responsibilities with MVC Assemble your full app in the browser, using client-side templates Use AngularJS directives to extend HTML with declarative syntax Communicate with the server and implement simple caching with the $http service Use dependency injection to improve refactoring, testability, and multiple environment design Get code samples for common problems you face in most web apps</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Chapter 1 Introduction to AngularJS</span><br><span class="line">Concepts</span><br><span class="line">An Example: Shopping Cart</span><br><span class="line">Up Next</span><br><span class="line">Chapter 2 Anatomy of an AngularJS Application</span><br><span class="line">Invoking Angular</span><br><span class="line">Model View Controller</span><br><span class="line">Templates and Data Binding</span><br><span class="line">Organizing Dependencies with Modules</span><br><span class="line">Formatting Data with Filters</span><br><span class="line">Changing Views with Routes and $location</span><br><span class="line">Talking to Servers</span><br><span class="line">Changing the DOM with Directives</span><br><span class="line">Validating User Input</span><br><span class="line">Moving On</span><br><span class="line">Chapter 3 Developing in AngularJS</span><br><span class="line">Project Organization</span><br><span class="line">Tools</span><br><span class="line">Running Your Application</span><br><span class="line">Testing with AngularJS</span><br><span class="line">Unit Tests</span><br><span class="line">End-to-End&#x2F;Integration Tests</span><br><span class="line">Compilation</span><br><span class="line">Other Awesome Tools</span><br><span class="line">Yeoman: Optimizing Your Workflow</span><br><span class="line">Integrating AngularJS with RequireJS</span><br><span class="line">Chapter 4 Analyzing an AngularJS App</span><br><span class="line">The Application</span><br><span class="line">Relationship Between Model, Controller, and Template</span><br><span class="line">The Model</span><br><span class="line">Controllers, Directives, and Services, Oh My!</span><br><span class="line">The Templates</span><br><span class="line">The Tests</span><br><span class="line">Chapter 5 Communicating with Servers</span><br><span class="line">Communicating Over $http</span><br><span class="line">Unit Testing</span><br><span class="line">Working with RESTful Resources</span><br><span class="line">The $q and the Promise</span><br><span class="line">Response Interception</span><br><span class="line">Security Considerations</span><br><span class="line">Chapter 6 Directives</span><br><span class="line">Directives and HTML Validation</span><br><span class="line">API Overview</span><br><span class="line">Moving On</span><br><span class="line">Chapter 7 Other Concerns</span><br><span class="line">$location</span><br><span class="line">AngularJS Module Methods</span><br><span class="line">Communicating Between Scopes with $on, $emit, and $broadcast</span><br><span class="line">Cookies</span><br><span class="line">Internationalization and Localization</span><br><span class="line">Sanitizing HTML &amp; the Sanitize Module</span><br><span class="line">Chapter 8 Cheatsheet and Recipes</span><br><span class="line">Wrapping a jQuery Datepicker</span><br><span class="line">The Teams List App: Filtering and Controller Communication</span><br><span class="line">File Upload in AngularJS</span><br><span class="line">Using Socket.IO</span><br><span class="line">A Simple Pagination Service</span><br><span class="line">Working with Servers and Login</span><br><span class="line">Conclusion</span><br><span class="line">Index</span><br><span class="line">Colophon</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/1449344852/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=1449344852&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51gijh9XW6L._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>LINUX设备驱动程序(第3版)</title>
    <url>/2020/04/19/B001147E76/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： LINUX设备驱动程序(第3版)<br>作者信息： 作者: 科波特 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《LINUX设备驱动程序(第3版)》详细介绍了Linux。如果您希望在Linux操作系统上支持计算机外部设备，或者在Linux上运行新的硬件，或者只是希望一般性地了解Linux内核的编程，就一定要阅读本书。本书描述了如何针对各种设备编写驱动程序，而在过去，这些内容仅仅以口头形式交流，或者零星出现在神秘的代码注释中。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">第一章 设备驱动程序简介</span><br><span class="line">  设备驱动程序的作用</span><br><span class="line">  内核功能划分</span><br><span class="line">  设备和模块的分类</span><br><span class="line">  安全问题</span><br><span class="line">  版本编号</span><br><span class="line">  许可证条款</span><br><span class="line">  加入内核开发社团</span><br><span class="line">  本书概要</span><br><span class="line">第二章 构造和运行模块</span><br><span class="line">  设置测试系统</span><br><span class="line">  Hello world模块</span><br><span class="line">  核心模块与应用程序的对比</span><br><span class="line">  编译和装载</span><br><span class="line">  内核符号表</span><br><span class="line">  预备知识</span><br><span class="line">  初始化和关闭</span><br><span class="line">  模块参数</span><br><span class="line">  在用户空间编写驱动程序</span><br><span class="line">  快速参考</span><br><span class="line">第三章 字符设备驱动程序</span><br><span class="line">  scull的设计</span><br><span class="line">  主设备号和次设备号</span><br><span class="line">  一些重要的数据结构</span><br><span class="line">  字符设备的注册</span><br><span class="line">  open和release</span><br><span class="line">  scull的内存使用</span><br><span class="line">  read和write</span><br><span class="line">  试试新设备</span><br><span class="line">  快速参考</span><br><span class="line">第四章 调试技术</span><br><span class="line">  内核中的调试支持</span><br><span class="line">  通过打印调试</span><br><span class="line">  通过查询调试</span><br><span class="line">  通过监视调试</span><br><span class="line">  调试系统故障</span><br><span class="line">  调试器和相关工具</span><br><span class="line">第五章 并发和竞态</span><br><span class="line">  scull的缺陷</span><br><span class="line">  并发及其管理</span><br><span class="line">  信号量和互斥体</span><br><span class="line">  completiOn</span><br><span class="line">  自旋锁</span><br><span class="line">  锁陷阱</span><br><span class="line">  除了锁之外的办法</span><br><span class="line">  快速参考</span><br><span class="line">第六章 高级字符驱动程序操作</span><br><span class="line">    ioctl</span><br><span class="line">    阻塞型I／O</span><br><span class="line">    poll和select</span><br><span class="line">    异步通知</span><br><span class="line">    定位设备</span><br><span class="line">    设备文件的访问控制</span><br><span class="line">    快速参考</span><br><span class="line">第七章 时间、延迟及延缓操作</span><br><span class="line">  度量时间差</span><br><span class="line">  获取当前时间</span><br><span class="line">  延迟执行</span><br><span class="line">  内核定时器</span><br><span class="line">  tasklet</span><br><span class="line">  工作队列</span><br><span class="line">  快速参考</span><br><span class="line">第八章 分配内存</span><br><span class="line">  kmalloc函数的内幕</span><br><span class="line">  后备高速缓存</span><br><span class="line">  get—free—page和相关函数</span><br><span class="line">  vmalloc及其辅助函数</span><br><span class="line">  per-CPU变量</span><br><span class="line">  获取大的缓冲区</span><br><span class="line">  快速参考</span><br><span class="line">……………………………………</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001147E76/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001147E76&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec8.images-amazon.com/images/I/51TK5a5V3AL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>点石成金 访客至上的网页设计秘笈(原书第2版)</title>
    <url>/2020/04/19/B0011BTJV8/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 点石成金 访客至上的网页设计秘笈(原书第2版)<br>作者信息： 作者: Steve Krug [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《点石成金:访客至上的网页设计秘笈(原书第2版)》编辑推荐：可用性设计是Web设计中最重要也是难度最大的一项任务。作者根据多年从业的经验，剖析用户的心理，在用户使用的模式、为扫描进行设计、导航设计、主页布局、可用性测试等方面提出了许多独特的观点，并给出了大量简单、易行的可用性设计的建议。《点石成金:访客至上的网页设计秘笈(原书第2版)》短小精炼，语言轻松诙谐，书中穿插大量色彩丰富的屏幕截图、趣味丛生的卡通插图以及包含大量信息的图表，使枯燥的设计原理变得平易近人。《点石成金:访客至上的网页设计秘笈(原书第2版)》适合从事Web设计和Web开发的技术人员阅读，特别适合为如何留住访问者而苦恼的网站/网页设计人员阅读。这是一本关于Web设计原则而不是Web设计技术的书。《点石成金:访客至上的网页设计秘笈(原书第2版)》作者是Web设计专家，具有丰富的实践经验。他用幽默的语言为你揭示Web设计中重要但却容易被忽视的问题，只需几个小时，你便能对照书中讲授的设计原则找到网站设计的症结所在，令你的网站焕然一新。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">译者序</span><br><span class="line">第2版前言</span><br><span class="line">序言</span><br><span class="line">导读  </span><br><span class="line">指导原则</span><br><span class="line">第1章   别让我思考  </span><br><span class="line">Krug可用性第一定律</span><br><span class="line">第2章   我们实际上是如何使用Web的  </span><br><span class="line">扫描，满意即可，勉强应付</span><br><span class="line">第3章   广告牌设计101法则  </span><br><span class="line">为扫描设计，不为阅读设计</span><br><span class="line">第4章   动物、植物、无机物  </span><br><span class="line">为什么用户喜欢无须思考的选择</span><br><span class="line">第5章   省略不必要的文字  </span><br><span class="line">不要在Web上写作的艺术</span><br><span class="line">必须正确处理的几个方面</span><br><span class="line">第6章   街头指示牌和面包屑  </span><br><span class="line">设计导航</span><br><span class="line">第7章   首先要承认，主页不由你控制  </span><br><span class="line">设计主页</span><br><span class="line">确定你做对的几件事</span><br><span class="line">第8章   农场主和牧牛人应该是朋友  </span><br><span class="line">为什么Web设计团队讨论可用性是在浪费时间，如何避免这种情况</span><br><span class="line">第9章   一天10美分的可用性测试   </span><br><span class="line">让测试简单—这样你能进行充分的测试</span><br><span class="line">大的方面和外界影响</span><br><span class="line">第10章   可用性是基本礼貌   </span><br><span class="line">为什么你的网站应该让人尊敬</span><br><span class="line">第11章   可访问性、级联样式表和你  </span><br><span class="line">正当你觉得已经完成了的时候，一只猫掉了下来，背上捆着涂了奶油的面包</span><br><span class="line">第12章   救命！老板想要我……  </span><br><span class="line">当好人遇到不好的设计决策</span><br><span class="line">推荐读物  </span><br><span class="line">致谢</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0011BTJV8/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0011BTJV8&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41I53XkKrjL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>A Practical Guide to Linux Commands Editors and Shell Programming</title>
    <url>/2020/04/19/a-practical-guide-to-linux-commands-editors-and-shell-programming/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： A Practical Guide to Linux Commands Editors and Shell Programming<br>作者信息： 作者: Mark G. Sobell [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>“This book is a very useful tool for anyone who wants to ‘look under the hood’ so to speak, and really start putting the power of Linux to work. What I find particularly frustrating about man pages is that they never include examples. Sobell, on the other hand, outlines very clearly what the command does and then gives several common, easy-to-understand examples that make it a breeze to start shell programming on one’s own. As with Sobell’s other works, this is simple, straight-forward, and easy to read. It’s a great book and will stay on the shelf at easy arm’s reach for a long time.”<br>–Ray Bartlett, Travel Writer</p>
<p>“Overall I found this book to be quite excellent, and it has earned a spot on the very front of my bookshelf. It covers the real ‘guts’ of Linux– the command line and its utilities–and does so very well. Its strongest points are the outstanding use of examples, and the Command Reference section. Highly recommended for Linux users of all skill levels. Well done to Mark Sobell and Prentice Hall for this outstanding book!”<br>–Dan Clough, Electronics Engineer and Slackware Linux User</p>
<p>“Totally unlike most Linux books, this book avoids discussing everything via GUI and jumps right into making the power of the command line your friend.”<br>–Bjorn Tipling, Software Engineer, ask.com</p>
<p>“This book is the best distro-agnostic, foundational Linux reference I’ve ever seen, out of dozens of Linux-related books I’ve read. Finding this book was a real stroke of luck. If you want to really understand how to get things done at the command line, where the power and flexibility of free UNIX-like OSes really live, this book is among the best tools you’ll find toward that end.”<br>–Chad Perrin, Writer, TechRepublic</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href=""><img src="http://ecx.images-amazon.com/images/I/51aoOQgTcUL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU01_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS商业网站布局之道</title>
    <url>/2020/04/19/B0011C4RU0/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： CSS商业网站布局之道<br>作者信息： 作者: 浏览全部评论  [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>解密网站布局，畅销书作者朱宏印为您细述，一起参悟CSS布局之道。超值赠送：最新版CSS中文完全参考手册。最新的CSS技巧、诀窍和研究;针对浏览器存在的Bug，深入剖析Hack和Filter之技;学习经典的盒模型、布局模型、网页定位技术与CSS编码规范;通过五个有代表性的综合实例体会实战开发的智慧，将超链接、导航菜单、滑动门、圆角、阴影、换肤、Tab等技术融入其中。《CSS商业网站布局之道》注重基础、讲究实用、选材精当、深入浅出，适合初中级读者学习使用，也适合具有(X)HTML和CSS基本知识的任何网页设计和开发人员阅读和参考。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 Web标准布局概述</span><br><span class="line">1.1 从闪客帝国网站改版说起</span><br><span class="line">1.2 表格布局的神话与没落</span><br><span class="line">　1.3 从Table到CSS——坎坷的历程</span><br><span class="line">　1.4 认识Web标准</span><br><span class="line">　1.5 CSS布局的基本思路</span><br><span class="line">　1.6 我能学好CSS布局吗</span><br><span class="line">　1.7 制作你的第一个XHTML+CSS页面</span><br><span class="line">第2章 CSS布局基础</span><br><span class="line">　2.1 标准网页结构</span><br><span class="line">　2.2 CSS基本语法</span><br><span class="line">　2.3 CSS选择符</span><br><span class="line">　2.4 CSS属性</span><br><span class="line">　2.5 CSS属性值</span><br><span class="line">　2.6 在网页中应用CSS</span><br><span class="line">　2.7 CSS的继承、层叠和特殊性</span><br><span class="line">　2.8 div和span深入研究</span><br><span class="line">　2.9 id和class深入研究</span><br><span class="line">第3章 CSS布局工具</span><br><span class="line">　3.1 TopStyle</span><br><span class="line">　3.2 Dreamweaver</span><br><span class="line">第4章 CSS盒模型</span><br><span class="line">　4.1 盒模型基础</span><br><span class="line">　4.2 边框</span><br><span class="line">　4.3 边界</span><br><span class="line">　4.4 补白</span><br><span class="line">　4.5 盒模型兼容性应用</span><br><span class="line">第5章 CSS格式化排版</span><br><span class="line">　5.1 排版是个细活</span><br><span class="line">　5.2 文字排版</span><br><span class="line">　5.3 段落排版</span><br><span class="line">　5.4 图文混排</span><br><span class="line">第6章 CSS布局模型</span><br><span class="line">　6.1 关于CSS布局</span><br><span class="line">　6.2 流动布局模型</span><br><span class="line">　6.3 浮动布局模型</span><br><span class="line">　6.4 层布局模型</span><br><span class="line">　6.5 层叠等级</span><br><span class="line">　6.6 高度自适应</span><br><span class="line">　6.7 CSS基本布局类型</span><br><span class="line">第7章 CSS浏览器兼容解决方案</span><br><span class="line">　7.1 关于网页浏览器</span><br><span class="line">　7.2 CSS Bug、Hack和Filter简介</span><br><span class="line">　7.3 过滤样式表文件</span><br><span class="line">　7.4 过滤规则和声明</span><br><span class="line">　7.5 在IE&#x2F;Windows中隐藏规则和声明</span><br><span class="line">　7.6 网页Bug解决方案</span><br><span class="line">　7.7 常见Bug及其修复</span><br><span class="line">　7.8 HTML默认样式与浏览器解析差异</span><br><span class="line">　7.9 IE 7浏览器兼容解决方案</span><br><span class="line">　8.1 CSS文档统筹</span><br><span class="line">　8.2 规则的组织</span><br><span class="line">　8.3 属性的组织</span><br><span class="line">　8.4 CSS命名艺术</span><br><span class="line">　8.5 CSS代码缩写规则</span><br><span class="line">　8.6 CSS代码书写格式</span><br><span class="line">　8.7 CSS代码注释艺术</span><br><span class="line">　8.8 CSS代码优化技巧</span><br><span class="line">第9章 个人Blog网站布局</span><br><span class="line">　9.1 关于Veerle’s blog的研究</span><br><span class="line">　9.2 网站配色</span><br><span class="line">　9.3 全局属性设置</span><br><span class="line">　9.4 控制模块显示宽度</span><br><span class="line">　9.5 关于兼容性的解决方案</span><br><span class="line">　9.6 滑动门技术研究</span><br><span class="line">　9.7 欣赏与研究背景图像的应用</span><br><span class="line">　9.8 圆角研究</span><br><span class="line">　9.9 阴影研究</span><br><span class="line">第10章 公司宣传网站的布局</span><br><span class="line">　10.1 关于Layout的研究</span><br><span class="line">　10.2 全局属性设置</span><br><span class="line">　10.3 页面框架控制</span><br><span class="line">　10.4 关于列表布局的深入研究</span><br><span class="line">　10.5 导航菜单研究</span><br><span class="line">第11章 技术门户网站布局</span><br><span class="line">　11.1 关于CSS Beauty的研究</span><br><span class="line">　11.2 全局属性设置</span><br><span class="line">　11.3 页面框架控制</span><br><span class="line">　11.4 关于CSS Beauty导航条的研究</span><br><span class="line">　11.5 关于CSS Beauty数据表格的研究</span><br><span class="line">　11.6 数据表格深入研究</span><br><span class="line">　11.7 数据表格的CSS布局研究</span><br><span class="line">第12章 Web 2.0网站布局</span><br><span class="line">　12.1 关于Web 2.0的技术探析</span><br><span class="line">　12.2 关于读客网的研究</span><br><span class="line">　12.3 全局属性设置</span><br><span class="line">　12.4 页面框架控制</span><br><span class="line">第13章 网上商城网站布局</span><br><span class="line">　13.1 关于阿里巴巴</span><br><span class="line">　13.2 关于阿里巴巴中国网站的研究</span><br><span class="line">　13.3 全局属性设置</span><br><span class="line">　13.4 页面框架控制</span><br><span class="line">　13.5 网页换肤技术研究</span><br><span class="line">　13.6 Tab切换技术</span><br><span class="line">　13.7 表单研究</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0011C4RU0/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0011C4RU0&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/513V5wF3v-L._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>Programming Ruby(中文版)(第2版)</title>
    <url>/2020/04/19/B0011EQNUK/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Programming Ruby(中文版)(第2版)<br>作者信息： 作者: 孙勇 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Programming Rudy》(中文版)(第2版)适合各种程度的Ruby程序员，无论新手还是老兵，都会从中得到巨大的帮助。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1版序</span><br><span class="line">第2版序</span><br><span class="line">前言</span><br><span class="line">路线图</span><br><span class="line">第1部分　Ruby面面观</span><br><span class="line">　第1章　入门</span><br><span class="line">　　1.1　安装Ruby</span><br><span class="line">　　1.2　运行Ruby</span><br><span class="line">　　1.3　Ruby文档：RDoc和ri</span><br><span class="line">　第2章　Ruby.new</span><br><span class="line">　　2.1　Ruby是一门面向对象语言</span><br><span class="line">　　2.2　Ruby的一些基本知识</span><br><span class="line">　　2.3　数组和散列表</span><br><span class="line">　　2.4　控制结构</span><br><span class="line">　　2.5　正则表达式</span><br><span class="line">　　2.6　Block和迭代器</span><br><span class="line">　　2.7　读&#x2F;写文件</span><br><span class="line">　　2.8　更高更远</span><br><span class="line">　第3章　类、对象和变量</span><br><span class="line">　　3.1　继承和消息</span><br><span class="line">　　3.2　对象和属性</span><br><span class="line">　　3.3　类变量和类方法</span><br><span class="line">　　3.4　访问控制</span><br><span class="line">　　3.5　变量</span><br><span class="line">　第4章　容器、Blocks和迭代器</span><br><span class="line">　　4.1　容器</span><br><span class="line">　　4.2　Blocks和迭代器</span><br><span class="line">　　4.3　处处皆是容器</span><br><span class="line">　第5章　标准类型</span><br><span class="line">　　5.1　数字</span><br><span class="line">　　5.2　字符串</span><br><span class="line">　　5.3　区间</span><br><span class="line">　　5.4　正则表达式</span><br><span class="line">　第6章　关于方法的更多细节</span><br><span class="line">　　6.1　定义一个方法</span><br><span class="line">　　6.2　调用方法</span><br><span class="line">　第7章　表达式</span><br><span class="line">　　7.1　运算符表达式</span><br><span class="line">　　7.2　表达式之杂项</span><br><span class="line">　　7.3　赋值</span><br><span class="line">　　7.4　条件执行</span><br><span class="line">　　7.5　Case表达式</span><br><span class="line">　　7.6　循环</span><br><span class="line">　　7.7　变量作用域、循环和Blocks</span><br><span class="line">　第8章　异常，捕获和抛出</span><br><span class="line">　　8.1　异常类</span><br><span class="line">　　8.2　处理异常</span><br><span class="line">　　8.3　引发异常</span><br><span class="line">　　8.4　捕获和抛出</span><br><span class="line">　第9章　模块</span><br><span class="line">　　9.1　命名空间</span><br><span class="line">　　9.2　Mixin</span><br><span class="line">　　9.3　迭代器与可枚举模块</span><br><span class="line">　　9.4　组合模块</span><br><span class="line">　　9.5　包含其他文件</span><br><span class="line">　第10章　基本输入和输出</span><br><span class="line">　　10.1　什么是 IO 对象</span><br><span class="line">　　10.2　文件打开和关闭</span><br><span class="line">　　10.3　文件读写</span><br><span class="line">　　10.4　谈谈网络</span><br><span class="line">　第11章　线程和进程</span><br><span class="line">　　11.1　多线程</span><br><span class="line">　　11.2　控制线程调度器</span><br><span class="line">　　11.3　互斥</span><br><span class="line">　　11.4　运行多个进程</span><br><span class="line">　第12章　单元测试</span><br><span class="line">　　12.1　Test::Unit框架</span><br><span class="line">　　12.2　组织测试</span><br><span class="line">　　12.3　组织和运行测试</span><br><span class="line">　第13章　当遇到麻烦时</span><br><span class="line">　　13.1　Ruby调试器</span><br><span class="line">　　13.2　交互式Ruby</span><br><span class="line">　　13.3　编辑器支持</span><br><span class="line">　　13.4　但是它不运作</span><br><span class="line">　　13.5　然而它太慢了</span><br><span class="line">第2部分　Ruby与其环境</span><br><span class="line">　第14章　Ruby和Ruby世界</span><br><span class="line">　　14.1　命令行参数</span><br><span class="line">　　14.2　程序终止</span><br><span class="line">　　14.3　环境变量</span><br><span class="line">　　14.4　从何处查找它的模块</span><br><span class="line">　　14.5　编译环境</span><br><span class="line">　第15章　交互式Ruby Shell</span><br><span class="line">　　15.1　命令行</span><br><span class="line">　　15.2　配置</span><br><span class="line">　　15.3　命令</span><br><span class="line">　　15.4　限制</span><br><span class="line">　　15.5　rtags与xmp</span><br><span class="line">　第16章　文档化Ruby</span><br><span class="line">　　16.1　向Ruby代码中添加RDoc</span><br><span class="line">　　16.2　向C扩展中添加RDoc</span><br><span class="line">　　16.3　运行RDoc</span><br><span class="line">　　16.4　显示程序用法信息</span><br><span class="line">　第17章　用RubyGems进行包的管理</span><br><span class="line">　　17.1　安装RubyGems</span><br><span class="line">　　17.2　安装程序Gems</span><br><span class="line">　　17.3　安装和使用Gem库</span><br><span class="line">　　17.4　创建自己的Gems</span><br><span class="line">　第18章　Ruby与Web</span><br><span class="line">　　18.1　编写CGI脚本</span><br><span class="line">　　18.2　Cookies</span><br><span class="line">　　18.3　提升性能</span><br><span class="line">　　18.4　Web服务器的选择</span><br><span class="line">　　18.5　SOAP及Web Services</span><br><span class="line">　　18.6　更多信息</span><br><span class="line">　第19章　Ruby Tk</span><br><span class="line">　　19.1　简单的Tk应用程序</span><br><span class="line">　　19.2　部件</span><br><span class="line">　　19.3　绑定事件</span><br><span class="line">　　19.4　画布</span><br><span class="line">　　19.5　滚动</span><br><span class="line">　　19.6　从Perl&#x2F;Tk文档转译</span><br><span class="line">　第20章　Ruby和微软Windows系统</span><br><span class="line">　　20.1　得到Ruby for Windows</span><br><span class="line">　　20.2　在Windows下运行Ruby</span><br><span class="line">　　20.3　Win32API</span><br><span class="line">　　20.4　Windows 自动化</span><br><span class="line">　第21章　扩展Ruby</span><br><span class="line">　　21.1　你的第一个扩展</span><br><span class="line">　　21.2　C中的Ruby对象</span><br><span class="line">　　21.3　Jukebox扩展</span><br><span class="line">　　21.4　内存分配</span><br><span class="line">　　21.5　Ruby的类型系统</span><br><span class="line">　　21.6　创建一个扩展</span><br><span class="line">　　21.7　内嵌Ruby解释器</span><br><span class="line">　　21.8　将Ruby连接到其他语言</span><br><span class="line">　　21.9　Ruby C语言API</span><br><span class="line">第3部分　Ruby的核心</span><br><span class="line">　第22章　Ruby语言</span><br><span class="line">　　22.1　源代码编排</span><br><span class="line">　　22.2　基本类型</span><br><span class="line">　　22.3　名字</span><br><span class="line">　　22.4　变量和常量</span><br><span class="line">　　22.5　表达式</span><br><span class="line">　　22.6　方法定义</span><br><span class="line">　　22.7　调用方法</span><br><span class="line">　　22.8　别名</span><br><span class="line">　　22.9　类定义</span><br><span class="line">　　22.10　模块定义</span><br><span class="line">　　22.11　访问控制</span><br><span class="line">　　22.12　Blocks，Closures和Proc对象</span><br><span class="line">　　22.13　异常</span><br><span class="line">　　22.14　Catch 和 Throw</span><br><span class="line">　第23章　Duck Typing</span><br><span class="line">　　23.1　类不是类型</span><br><span class="line">　　23.2　像鸭子那样编码</span><br><span class="line">　　23.3　标准协议和强制转换</span><br><span class="line">　　23.4　该做的做，该说的说</span><br><span class="line">　第24章　类与对象</span><br><span class="line">　　24.1　类和对象是如何交互的</span><br><span class="line">　　24.2　类和模块的定义</span><br><span class="line">　　24.3　顶层的执行环境</span><br><span class="line">　　24.4　继承与可见性</span><br><span class="line">　　24.5　冻结对象</span><br><span class="line">　第25章　Ruby安全</span><br><span class="line">　　25.1　安全级别</span><br><span class="line">　　25.2　受污染的对象</span><br><span class="line">　第26章　反射,ObjectSpace和分布式Ruby</span><br><span class="line">　　26.1　看看对象</span><br><span class="line">　　26.2　考察类</span><br><span class="line">　　26.3　动态地调用方法</span><br><span class="line">　　26.4　系统钩子</span><br><span class="line">　　26.5　跟踪程序的执行</span><br><span class="line">　　26.6　列集和分布式Ruby</span><br><span class="line">　　26.7　编译时？运行时？任何时</span><br><span class="line">第4部分　Ruby库的参考</span><br><span class="line">　第27章　内置的类和模块</span><br><span class="line">　第28章　标准库</span><br><span class="line">第5部分　附录</span><br><span class="line">　附录A　Socket库</span><br><span class="line">　附录B　MKMF参考</span><br><span class="line">　附录C　支持</span><br><span class="line">　附录D　书目</span><br><span class="line">　索引（Index）</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0011EQNUK/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0011EQNUK&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51TGRQaCqnL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>ruby</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解LINUX内核(第3版)(涵盖2.6版)</title>
    <url>/2020/04/19/B0011F5RYM/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 深入理解LINUX内核(第3版)(涵盖2.6版)<br>作者信息： 作者: 博韦 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《深入理解LINUX内核(第3版)(涵盖2.6版)》编辑推荐：为了彻底理解是什么使得Linux能正常运行以及其为何能在各种不同的系统中运行良好，你需要深入研究内核最本质的部分。内核处理CPU与外界间的所有交互，并且决定哪些程序将以什么顺序共享处理器时间。它如此有效地管理有限的内存，以至成百上千的进程能高效地共享系统。它熟练地统筹数据传输，这样CPU 不用为等待速度相对较慢的硬盘而消耗比正常耗时更长的时间。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">第一章  绪论</span><br><span class="line">  Linux与其他类Unix内核的比较</span><br><span class="line">  硬件的依赖性</span><br><span class="line">  Linux版本</span><br><span class="line">  操作系统基本概念</span><br><span class="line">  Unix文件系统概述</span><br><span class="line">  Unix内核概述</span><br><span class="line">第二章  内存寻址</span><br><span class="line">  内存地址</span><br><span class="line">  硬件中的分段</span><br><span class="line">  Linux中的分段</span><br><span class="line">  硬件中的分页</span><br><span class="line">  Linux中的分页</span><br><span class="line">第三章  进程</span><br><span class="line">  进程、轻量级进程和线程</span><br><span class="line">  进程描述符</span><br><span class="line">  进程切换</span><br><span class="line">  创建进程</span><br><span class="line">  撤消进程</span><br><span class="line">第四章  中断和异常</span><br><span class="line">  中断信号的作用</span><br><span class="line">  中断和异常</span><br><span class="line">  中断和异常处理程序的嵌套执行</span><br><span class="line">  初始化中断描述符表</span><br><span class="line">  异常处理</span><br><span class="line">  中断处理</span><br><span class="line">  软中断及tasklet</span><br><span class="line">  工作队列</span><br><span class="line">  从中断和异常返回</span><br><span class="line">第五章  内核同步</span><br><span class="line">  内核如何为不同的请求提供服务</span><br><span class="line">  同步原语</span><br><span class="line">  对内核数据结构的同步访问</span><br><span class="line">  避免竞争条件的实例</span><br><span class="line">第六章  定时测量</span><br><span class="line">  时钟和定时器电路</span><br><span class="line">  Linux计时体系结构</span><br><span class="line">  更新时间和日期</span><br><span class="line">  更新系统统计数</span><br><span class="line">  软定时器和延迟函数</span><br><span class="line">  与定时测量相关的系统调用</span><br><span class="line">第七章  进程调度</span><br><span class="line">  调度策略</span><br><span class="line">  调度算法</span><br><span class="line">  调度程序所使用的数据结构</span><br><span class="line">  调度程序所使用的函数</span><br><span class="line">  多处理器系统中运行队列的平衡</span><br><span class="line">  与调度相关的系统调用</span><br><span class="line">第八章  内存管理</span><br><span class="line">  页框管理</span><br><span class="line">  内存区管理</span><br><span class="line">  非连续内存区管理</span><br><span class="line">第九章  进程地址空间</span><br><span class="line">  进程的地址空间</span><br><span class="line">  内存描述符</span><br><span class="line">  线性区</span><br><span class="line">  缺页异常处理程序</span><br><span class="line">  创建和删除进程的地址空间</span><br><span class="line">  堆的管理</span><br><span class="line">第十章  系统调用</span><br><span class="line">  POSIX API和系统调用</span><br><span class="line">  系统调用处理程序及服务例程</span><br><span class="line">  进入和退出系统调用</span><br><span class="line">  参数传递</span><br><span class="line">  内核封装例程</span><br><span class="line">第十一章  信号</span><br><span class="line">  信号的作用</span><br><span class="line">  产生信号</span><br><span class="line">  传递信号</span><br><span class="line">  与信号处理相关的系统调用</span><br><span class="line">第十二章  虚拟文件系统</span><br><span class="line">  虚拟文件系统(VFS)的作用</span><br><span class="line">  VFS的数据结构</span><br><span class="line">  文件系统类型</span><br><span class="line">  文件系统处理</span><br><span class="line">  路径名查找</span><br><span class="line">  VFS系统调用的实现</span><br><span class="line">  文件加锁</span><br><span class="line">第十三章  I&#x2F;O体系结构和设备驱动程序</span><br><span class="line">  I&#x2F;O体系结构</span><br><span class="line">  设备驱动程序模型</span><br><span class="line">  设备文件</span><br><span class="line">  设备驱动程序</span><br><span class="line">  字符设备驱动程序</span><br><span class="line">第十四章  块设备驱动程序</span><br><span class="line">  块设备的处理</span><br><span class="line">  通用块层</span><br><span class="line">  I&#x2F;O调度程序</span><br><span class="line">  块设备驱动程序</span><br><span class="line">  打开块设备文件</span><br><span class="line">第十五章  页高速缓存</span><br><span class="line">  页高速缓存</span><br><span class="line">  把块存放在页高速缓存中</span><br><span class="line">  把脏页写入磁盘</span><br><span class="line">  sync()、fsync()和fdatasync()系统调用</span><br><span class="line">第十六章  访问文件</span><br><span class="line">  读写文件</span><br><span class="line">  内存映射</span><br><span class="line">  直接I&#x2F;O传送</span><br><span class="line">  异步I&#x2F;O</span><br><span class="line">第十七章  回收页框</span><br><span class="line">  页框回收算法</span><br><span class="line">  反向映射</span><br><span class="line">  PFRA实现</span><br><span class="line">  交换</span><br><span class="line">第十八章  Ext2和Ext3文件系统</span><br><span class="line">  Ext2的一般特征</span><br><span class="line">  Ext2磁盘数据结构</span><br><span class="line">  Ext2的内存数据结构</span><br><span class="line">  创建Ext2文件系统</span><br><span class="line">  Ext2的方法</span><br><span class="line">  管理Ext2磁盘空间</span><br><span class="line">  Ext3文件系统</span><br><span class="line">第十九章  进程通信</span><br><span class="line">  管道</span><br><span class="line">  FIFO</span><br><span class="line">  System V IPC</span><br><span class="line">  POSIX消息队列</span><br><span class="line">第二十章  程序的执行</span><br><span class="line">  可执行文件</span><br><span class="line">  可执行格式</span><br><span class="line">  执行域</span><br><span class="line">  exec函数</span><br><span class="line">附录一  系统启动</span><br><span class="line">附录二  模块</span><br><span class="line">参考文献</span><br><span class="line">源代码索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0011F5RYM/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0011F5RYM&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51ztv3-OjrL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP5权威编程</title>
    <url>/2020/04/19/B0012L2YY6/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： PHP5权威编程<br>作者信息： 作者: D) 瑞桑斯 (Rethans [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《PHP5权威编程》适合PHP程序员及具备其他高级语言编程经验的Web开发人员阅读。三大牛人合力之作！</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">序</span><br><span class="line">前言</span><br><span class="line">第1章　PHP 5新特性</span><br><span class="line">1.1 介绍</span><br><span class="line">1.2　语言特性</span><br><span class="line">1.3　PHP改进概述</span><br><span class="line">1.4　其他的PHF　5新特性</span><br><span class="line">1.5　总结 </span><br><span class="line"></span><br><span class="line"> 第2章　PHP 5基础语言 2.1 介绍 2.2　嵌入HTMI 2.3　注释 2.4　变量 2.5　基础数据类型 2.6　运算符 2.7　控制结构 2.8　函数 2.9　总结</span><br><span class="line"></span><br><span class="line"> 第3章　PHP 5面向对象语言 3.1　介绍 3.2　对象 3.3　声明一个类 3.4　new关键字和构造函数 3.5　析构函数 3.6　使用$this变量访问方法和属性 3.7　类的常量 3.8　克隆对象 3.9 多态 3.10　parent和self 3.11　instanceof运算符 3.12　Abstract方法和类 3.13　接口 3.14　接口的继承 3.15　final方法 3.16　final类 3.17　toString（）方法 3.18　异常处理 3.19　_autoloadO 3.20　在函数参数中提示类的类别 3.21 总结</span><br><span class="line"></span><br><span class="line"> 第4章　PHP 5高级面向对象编程和设计模式 4.1　介绍 4.2　重载性能 4.3　迭代器 4.4　设计模式 4.5 映射 4.6 总结</span><br><span class="line"></span><br><span class="line"> 第5章　如何用PHP写一个Web应用 5.1 介绍 5.2　嵌入HTML当中 5.3　获取用户数据 5.4　对用户输入的数据进行安全验证 5.5　一些让脚本运行“安全”的技术 5.6　Cookies 5.7 Sessions 5.8　文件上传 5.9　架构 5.10　总结 第2章　PHP　5基础语言 第3章　PHP　5面向对象语言 第4章　PHP　5高级面向对象编程和设计模式 第5章　如何用PHP写一个Web应用 第6章　使用PHP　5访问数据库 第7章　错误处理 第8章　PHP　5中处理XML 第9章　主流扩展 第10章　使用PEAR 第11章　重要的PEAR包 第12章　创建PEAR的组件 第13章　迁移 第14章　性能 第15章　一个编写PHP扩展的介绍 第16章　PHP　Shell　脚本编程</span><br><span class="line"></span><br><span class="line"> 附录A　PEAR和PECL包索引 附录B　phpDocumentor格式参考 附录C　Zend Studio快速使用说明 索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0012L2YY6/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0012L2YY6&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/515ijY2wRvL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>精通JavaScript</title>
    <url>/2020/04/19/B0015KTCBW/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 精通JavaScript<br>作者信息： 作者: 平均4.1 星  [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《精通JavaScript》适合各层次Web开发人员阅读。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分 认识现代JavaScript</span><br><span class="line">第1章 现代JavaScript程序设计 2</span><br><span class="line">1.1 面向对象的JavaScript 2</span><br><span class="line">1.2 测试代码 3</span><br><span class="line">1.3 打包分发 4</span><br><span class="line">1.4 分离式DOM脚本编程 5</span><br><span class="line">1.4.1 DOM 6</span><br><span class="line">1.4.2 事件 7</span><br><span class="line">1.4.3 JavaScript与CSS 8</span><br><span class="line">1.5 Ajax 8</span><br><span class="line">1.6 浏览器支持 11</span><br><span class="line">1.7 小结 12 </span><br><span class="line"></span><br><span class="line"> 第二部分 专业JavaScript开发 第2章 面向对象的JavaScript 14 2.1 语言特性 14 2.1.1 引用 14 2.1.2 函数重载和类型检查 16 2.1.3 作用域 19 2.1.4 闭包 20 2.1.5 上下文对象 23</span><br><span class="line"></span><br><span class="line"> 2.2 面向对象基础 24 2.2.1 对象 25 2.2.2 对象的创建 25 2.3 小结 30</span><br><span class="line"></span><br><span class="line"> 第3章 创建可重用代码 31 3.1 标准化面向对象的代码 31 3.1.1 原型式继承 31 3.1.2 类式继承 32 3.1.3 Base库 35 3.1.4 Prototype库 36</span><br><span class="line"></span><br><span class="line"> 3.2 打包 39 3.2.1 命名空间 40 3.2.2 清理代码 42 3.2.3 压缩 43 3.3 分发 45 3.4 小结 47</span><br><span class="line"></span><br><span class="line"> 第4章 调试与测试的工具 48 4.1 调试 48 4.1.1 错误控制台 48 4.1.2 DOM查看器 52 4.1.3 Firebug 54 4.1.4 Venkman 55</span><br><span class="line"></span><br><span class="line"> 4.2 测试 56 4.2.1 JSUnit 56 4.2.2 J3Unit 57 4.2.3 Test.Simple 58 4.3 小结 59 第三部分 分离式JavaScript 第四部分 Ajax 第五部分 JavaScript的未来 第六部分 附录 附录A DOM参考手册 242 附录B 事件参考手册 257 附录C 浏览器 273 索引 275</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0015KTCBW/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0015KTCBW&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51HTlhmx1YL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Python核心编程(第2版)</title>
    <url>/2020/04/19/B001BKVXOA/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Python核心编程(第2版)<br>作者信息： 作者: 丘恩 (Wesley J.Chun) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Python核心编程(第2版)》提供了对Python核心特性系统的专家级讲解；开发复杂的应用程序和软件所需的强大深入的视角：易用的图表，详细描述了Pyffion模块、操作符、函数和方法：大量的专业级实例代码，从小的代码片段到功能齐全的应用程序一应俱全。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1部分  Python核心</span><br><span class="line">第1章  欢迎来到Python世界  3</span><br><span class="line">1.1  什么是Python  4</span><br><span class="line">1.2  起源  4</span><br><span class="line">1.3  特点  4</span><br><span class="line">1.3.1  高级  4</span><br><span class="line">1.3.2  面向对象  5</span><br><span class="line">1.3.3  可升级  5</span><br><span class="line">1.3.4  可扩展  5</span><br><span class="line">1.3.5  可移植性  5</span><br><span class="line">1.3.6  易学  6</span><br><span class="line">1.3.7  易读  6</span><br><span class="line">1.3.8  易维护  6</span><br><span class="line">1.3.9  健壮性  6</span><br><span class="line">1.3.10  高效的快速原型开发工具  6</span><br><span class="line">1.3.11  内存管理器  7</span><br><span class="line">1.3.12  解释性和(字节)编译性  7</span><br><span class="line">1.4  下载和安装Python  7</span><br><span class="line">1.5  运行Python  8</span><br><span class="line">1.5.1  命令行上的交互式解释器  9</span><br><span class="line">1.5.2  从命令行启动脚本  10</span><br><span class="line">1.5.3  集成开发环境  11</span><br><span class="line">1.5.4  其他的集成开发环境和执行环境  14</span><br><span class="line">1.6  Python文档  15</span><br><span class="line">1.7  比较Python(Python与其他语言的比较)  15</span><br><span class="line">1.8  其他实现  17</span><br><span class="line">1.9  练习  18 </span><br><span class="line"></span><br><span class="line"> 第2章 快速入门 19 2.1 程序输出，print语句及“Hello World!” 20 2.2 程序输入和raw_input()内建函数 21 2.3 注释 22 2.4 操作符 22 2.5 变量和赋值 24 2.6 数字 24 2.7 字符串 25 2.8 列表和元组 26 2.9 字典 26 2.10 代码块及缩进对齐 27 2.11 if语句 27 2.12 while循环 28 2.13 for循环和range()内建函数 28 2.14 列表解析 30 2.15 文件和内建函数open()、file() 30 2.16 错误和异常 31 2.17 函数 32 2.17.1 如何定义函数 32 2.17.2 如何调用函数 32 2.17.3 默认参数 33 2.18 类 33 2.19 模块 35 2.19.1 如何导入模块 35 2.19.2 如何访问一个模块函数或访问一个模块变量 35 2.20 实用的函数 36 2.21 练习 36</span><br><span class="line"></span><br><span class="line"> 第3章 Python基础 39 3.1 语句和语法 40 3.1.1 注释(#) 40 3.1.2 继续() 40 3.1.3 多个语句构成代码组(:) 41 3.1.4 代码组由不同的缩进分隔 41 3.1.5 同一行书写多个语句(;) 41 3.1.6 模块 41 3.2 变量赋值 42 3.2.1 赋值操作符 42 3.2.2 增量赋值 42 3.2.3 多重赋值 43 3.2.4 “多元”赋值 43 3.3 标识符 44 3.3.1 合法的Python标识符 44 3.3.2 关键字 44 3.3.3 内建 45 3.3.4 专用下划线标识符 45 3.4 基本风格指南 45 3.4.1 模块结构和布局 46 3.4.2 在主程序中书写测试代码 48 3.5 内存管理 49 3.5.1 变量定义 49 3.5.2 动态类型 49 3.5.3 内存分配 49 3.5.4 引用计数 50 3.5.5 垃圾收集 51 3.6 第一个Python程序 51 3.7 相关模块和开发工具 54 3.8 练习 55</span><br><span class="line"></span><br><span class="line"> 第4章 Python对象 56 4.1 Python 对象 57 4.2 标准类型 57 4.3 其他内建类型 58 4.3.1 类型对象和type类型对象 58 4.3.2 None——Python的Null对象 58 4.4 内部类型 59 4.4.1 代码对象 59 4.4.2 帧对象 60 4.4.3 跟踪记录对象 60 4.4.4 切片对象 60 4.4.5 省略对象 60 4.4.6 XRange 对象 60 4.5 标准类型操作符 61 4.5.1 对象值的比较 61 4.5.2 对象身份比较 61 4.5.3 布尔类型 64 4.6 标准类型内建函数 64 4.6.1 type() 64 4.6.2 cmp() 65 4.6.3 str()和repr()(及&#96;&#96;操作符) 66 4.6.4 type()和isinstance() 67 4.6.5 Python类型操作符和内建函数总结 70 4.7 类型工厂函数 70 4.8 标准类型的分类 71 4.8.1 存储模型 71 4.8.2 更新模型 72 4.8.3 访问模型 73 4.9 不支持的类型 74 4.10 练习 75</span><br><span class="line"></span><br><span class="line"> 第5章 数字 76 5.1 数字简介 77 5.1.1 如何创建数值对象并用其赋值(数字对象) 77 5.1.2 如何更新数字对象 77 5.1.3 如何删除数字对象 77 5.2 整型 77 5.2.1 布尔型 78 5.2.2 标准整型 78 5.2.3 长整型 78 5.2.4 整型和长整型的统一 79 5.3 双精度浮点型 79 5.4 复数 80 5.5 操作符 81 5.5.1 混合模式操作符 81 5.5.2 标准类型操作符 82 5.5.3 算术操作符 82 5.5.4 *位操作符(只适用于整型) 86 5.6 内建函数与工厂函数 87 5.6.1 标准类型函数 87 5.6.2 数字类型函数 87 5.6.3 仅用于整型的函数 92 5.7 其他数字类型 93 5.7.1 布尔“数” 93 5.7.2 十进制浮点型 94 5.8 相关模块 95 5.9 练习 97</span><br><span class="line"></span><br><span class="line"> 第6章 序列：字符串、列表和元组 100 6.1 序列 101 6.1.1 标准类型操作符 101 6.1.2 序列类型操作符 101 6.1.3 内建函数(BIF) 106 6.2 字符串 107 6.3 字符串和操作符 109 6.3.1 标准类型操作符 109 6.3.2 序列操作符切片([]和[:]) 109 6.4 只适用于字符串的操作符 114 6.4.1 格式化操作符(％) 114 6.4.2 字符串模板: 更简单的替代品 117 6.4.3 原始字符串操作符(r&#x2F;R) 118 6.4.4 Unicode字符串操作符(u&#x2F;U) 119 6.5 内建函数 119 6.5.1 标准类型函数 119 6.5.2 序列类型函数 119 6.5.3 字符串类型函数 120 6.6 字符串内建函数 121 6.7 字符串的独特特性 124 6.7.1 特殊字符串和控制字符 124 6.7.2 三引号 125 6.7.3 字符串不变性 126 6.8 Unicode 127 6.8.1 术语 127 6.8.2 什么是Unicode 128 6.8.3 怎样使用Unicode 128 6.8.4 Codec是什么 129 6.8.5 编码解码 129 6.8.6 把Unicode应用到实际应用中 130 6.8.7 从现实中得来的教训 131 6.8.8 Python的Unicode支持 131 6.9 相关模块 133 6.10 字符串关键点总结 134 6.11 列表 134 6.12 操作符 136 6.12.1 标准类型操作符 136 6.12.2 序列类型操作符 136 6.12.3 列表类型操作符和列表解析 139 6.13 内建函数 139 6.13.1 标准类型函数 139 6.13.2 序列类型函数 140 6.13.3 列表类型内建函数 142 6.14 列表类型的内建函数 142 6.15 列表的特殊特性 145 6.16 元组 151 6.17 元组操作符和内建函数 152 6.17.1 标准类型操作符、序列类型操作符和内建函数 152 6.17.2 元组类型操作符和内建函数、内建方法 153 6.18 元组的特殊特性 153 6.18.1 不可变性给元组带来了什么影响 153 6.18.2 元组也不是那么“不可变” 153 6.18.3 默认集合类型 154 6.18.4 单元素元组 155 6.18.5 字典的关键字 155 6.19 相关模块 156 6.20 *拷贝Python对象、浅拷贝和深拷贝 156 6.21 序列类型小结 158 6.22 练习 160</span><br><span class="line"></span><br><span class="line"> 第7章 映像和集合类型 163 7.1 映射类型：字典 164 7.1.1 如何创建字典和给字典赋值 164 7.1.2 如何访问字典中的值 165 7.1.3 如何更新字典 166 7.1.4 如何删除字典元素和字典 167 7.2 映射类型操作符 167 7.2.1 标准类型操作符 167 7.2.2 映射类型操作符 168 7.3 映射类型的内建函数和工厂函数 168 7.3.1 标准类型函数[type()、str()和cmp()] 168 7.3.2 映射类型相关的函数 170 7.4 映射类型内建方法 172 7.5 字典的键 174 7.5.1 不允许一个键对应多个值 174 7.5.2 键必须是可哈希的 175 7.6 集合类型 178 7.6.1 如何创建集合类型和给集合赋值 179 7.6.2 如何访问集合中的值 179 7.6.3 如何更新集合 179 7.6.4 如何删除集合中的成员和集合 180 7.7 集合类型操作符 180 7.7.1 标准类型操作符(所有的集合类型) 180 7.7.2 集合类型操作符(所有的集合类型) 181 7.7.3 集合类型操作符(仅适用于可变集合) 182 7.8 内建函数 183 7.8.1 标准类型函数 183 7.8.2 集合类型工厂函数 183 7.9 集合类型内建方法 184 7.9.1 方法(所有的集合方法) 184 7.9.2 方法(仅适用于可变集合) 184 7.9.3 操作符和内建方法比较 185 7.10 集合类型总结表 185 7.11 相关模块 186 7.12 练习 186</span><br><span class="line"></span><br><span class="line"> 第8章 条件和循环 189 8.1 if语句 190 8.1.1 多重条件表达式 190 8.1.2 单一语句的代码块 190 8.2 else语句 190 8.3 elif(即else-if)语句 191 8.4 条件表达式(即“三元操作符”) 192 8.5 while语句 193 8.5.1 一般语法 193 8.5.2 计数循环 193 8.5.3 无限循环 194 8.6 for语句 194 8.6.1 一般语法 194 8.6.2 用于序列类型 195 8.6.3 用于迭代器类型 196 8.6.4 range()内建函数 196 8.6.5 xrange() 内建函数 198 8.6.6 与序列相关的内建函数 198 8.7 break语句 199 8.8 continue语句 199 8.9 pass语句 200 8.10 再谈else语句 200 8.11 迭代器和iter()函数 202 8.11.1 什么是迭代器 202 8.11.2 为什么要迭代器 202 8.11.3 如何迭代 202 8.11.4 使用迭代器 203 8.11.5 可变对象和迭代器 204 8.11.6 如何创建迭代器 204 8.12 列表解析 205 8.13 生成器表达式 206 8.14 相关模块 209 8.15 练习 209</span><br><span class="line"></span><br><span class="line"> 第9章 文件和输入输出 212 9.1 文件对象 213 9.2 文件内建函数(open()和file()) 213 9.2.1 工厂函数file() 214 9.2.2 通用换行符支持(UNS) 214 9.3 文件内建方法 215 9.3.1 输入 215 9.3.2 输出 215 9.3.3 文件内移动 216 9.3.4 文件迭代 216 9.3.5 其他 216 9.3.6 文件方法杂项 217 9.4 文件内建属性 219 9.5 标准文件 220 9.6 命令行参数 220 9.7 文件系统 221 9.8 文件执行 227 9.9 永久存储模块 227 9.9.1 pickle和marshal模块 227 9.9.2 DBM风格的模块 228 9.9.3 shelve模块 228 9.10 相关模块 229 9.11 练习 230</span><br><span class="line"></span><br><span class="line"> 第10章 错误和异常 234 10.1 什么是异常 235 10.1.1 错误 235 10.1.2 异常 235 10.2 Python 中的异常 236 10.3 检测和处理异常 237 10.3.1 try-except语句 238 10.3.2 包装内建函数 238 10.3.3 带有多个except的try语句 240 10.3.4 处理多个异常的except语句 241 10.3.5 捕获所有异常 242 10.3.6 “异常参数” 244 10.3.7 在应用使用我们封装的函数 245 10.3.8 else子句 247 10.3.9 finally子句 248 10.3.10 try-finally语句 248 10.3.11 try-except-else-finally：厨房一锅端 250 10.4 上下文管理 251 10.4.1 with语句 251 10.4.2 上下文管理协议 252 10.5 字符串作为异常 252 10.6 触发异常 253 10.7 断言 254 10.8 标准异常 255 10.9 *创建异常 257 10.10 (现在)为什么用异常 262 10.11 到底为什么要异常 263 10.12 异常和sys模块 263 10.13 相关模块 264 10.14 练习 264</span><br><span class="line"></span><br><span class="line"> 第11章 函数和函数式编程 266 11.1 什么是函数？ 267 11.1.1 函数vs过程 267 11.1.2 返回值与函数类型 267 11.2 调用函数 268 11.2.1 函数操作符 268 11.2.2 关键字参数 269 11.2.3 默认参数 269 11.2.4 参数组 269 11.3 创建函数 272 11.3.1 def语句 272 11.3.2 声明与定义比较 272 11.3.3 前向引用 272 11.3.4 函数属性 273 11.3.5 内部&#x2F;内嵌函数 274 11.3.6 函数(与方法)装饰器 275 11.4 传递函数 278 11.5 Formal Arguments 279 11.5.1 位置参数 279 11.5.2 默认参数 279 11.6 可变长度的参数 282 11.6.1 非关键字可变长参数(元组) 282 11.6.2 关键字变量参数(字典) 283 11.6.3 调用带有可变长参数对象函数 284 11.7 函数式编程 286 11.7.1 匿名函数与lambda 286 11.7.2 内建函数apply()、filter()、map()、reduce() 288 11.7.3 偏函数应用 293 11.8 变量作用域 295 11.8.1 全局变量与局部变量 295 11.8.2 globa语句 296 11.8.3 作用域的数字 297 11.8.4 闭包 298 11.8.5 作用域和lambda 302 11.8.6 变量作用域和名称空间 304 11.9 递归 304 11.10 生成器 305 11.10.1 简单的生成器特性 305 11.10.2 加强的生成器特性 307 11.11 练习 308</span><br><span class="line"></span><br><span class="line"> 第12章 模块 310 12.1 什么是模块 311 12.2 模块和文件 311 12.2.1 模块名称空间 311 12.2.2 搜索路径和路径搜索 311 12.3 名称空间 312 12.3.1 名称空间与变量作用域比较 313 12.3.2 名称查找、确定作用域、覆盖 314 12.3.3 无限制的名称空间 314 12.4 导入模块 315 12.4.1 import语句 315 12.4.2 from-import语句 315 12.4.3 多行导入 316 12.4.4 扩展的import语句(as) 316 12.5 模块导入的特性 316 12.5.1 载入时执行模块 316 12.5.2 导入(import)和加载(load) 317 12.5.3 导入到当前名称空间的名称 317 12.5.4 被导入到导入者作用域的名字 317 12.5.5 关于future 318 12.5.6 警告框架 318 12.5.7 从ZIP文件中导入模块 319 12.5.8 “新的”导入钩子 319 12.6 模块内建函数 319 12.6.1 import() 319 12.6.2 globals()和locals() 320 12.6.3 reload() 320 12.7 包 321 12.7.1 目录结构 321 12.7.2 使用from-import导入包 322 12.8 模块的其他特性 323 12.8.1 自动载入的模块 323 12.8.2 阻止属性导入 323 12.8.3 不区分大小的导入 323 12.8.4 源代码编码 324 12.8.5 导入循环 324 12.8.6 模块执行 325 12.9 相关模块 325 12.10 练习 326</span><br><span class="line"></span><br><span class="line"> 第13章 面向对象编程 327 13.1 引言 328 13.2 面向对象编程 333 13.2.1 面向对象设计与面向对象编程的关系 333 13.2.2 现实中的问题 334 13.2.3 常用术语 334 13.3 类 335 13.3.1 创建类 336 13.3.2 声明与定义 336 13.4 类属性 336 13.4.1 类的数据属性 337 13.4.2 Methods 337 13.4.3 决定类的属性 338 13.4.4 特殊的类属性 339 13.5 实例 340 13.5.1 初始化：通过调用类对象来创建实例 340 13.5.2 init()“构造器”方法 341 13.5.3 new()“构造器”方法 342 13.5.4 del()“解构器”方法 342 13.6 实例属性 344 13.6.1 “实例化”实例属性(或创建一个更好的构造器) 344 13.6.2 查看实例属性 346 13.6.3 特殊的实例属性 346 13.6.4 建类型属性 347 13.6.5 实例属性vs类属性 348 13.7 绑定和方法调用 350 13.7.1 调用绑定方法 351 13.7.2 调用非绑定方法 351 13.8 静态方法和类方法 352 13.8.1 staticmethod()和classmethod()内建函数 352 13.8.2 使用函数修饰符 353 13.9 组合 353 13.10 子类和派生 354 13.11 继承 355 13.11.1 bases类属性 356 13.11.2 通过继承覆盖方法 356 13.11.3 从标准类型派生 358 13.11.4 多重继承 360 13.12 类、实例和其他对象的内建函数 363 13.12.1 issubclass() 363 13.12.2 isinstance() 363 13.12.3 hasattr()、getattr()、setattr()、delattr() 364 13.12.4 dir() 365 13.12.5 super() 365 13.12.6 vars() 366 13.13 用特殊方法定制类 367 13.13.1 简单定制(RoundFloat2) 370 13.13.2 数值定制(Time60) 372 13.13.3 迭代器(RandSeq和AnyIter) 375 13.13.4 多类型定制(NumStr) 377 13.14 私有化 381 13.15 *授权 382 13.15.1 包装 382 13.15.2 实现授权 383 13.16 新式类的高级特性(Python 2.2+) 388 13.16.1 新式类的通用特性 388 13.16.2 slots类属性 389 13.16.3 getattribute()特殊方法 390 13.16.4 描述符 390 13.16.5 元类和metaclass 399 13.17 相关模块和文档 403 13.18 练习 405</span><br><span class="line"></span><br><span class="line"> 第14章 执行环境 410 14.1 可调用对象 411 14.1.1 函数 411 14.1.2 方法 413 14.1.3 类 415 14.1.4 类的实例 415 14.2 代码对象 416 14.3 可执行的对象声明和内建函数 416 14.3.1 callable() 417 14.3.2 compile() 417 14.3.3 eval() 418 14.3.4 exec 419 14.3.5 input() 420 14.3.6 使用Python在运行时生成和执行Python代码 420 14.4 执行其他(Python)程序 426 14.4.1 导入 426 14.4.2 execfile() 427 14.4.3 将模块作为脚本执行 428 14.5 执行其他(非Python)程序 428 14.5.1 os.system() 429 14.5.2 os.popen() 430 14.5.3 os.fork()、os.exec()、os.wait() 431 14.5.4 os.spawn*() 432 14.5.5 subprocess 模块 432 14.5.6 相关函数 433 14.6 受限执行 433 14.7 结束执行 434 14.7.1 sys.exit() and SystemExit 434 14.7.2 sys.exitfunc() 435 14.7.3 os._exit() 函数 435 14.7.4 os.kill() Function 435 14.8 各种操作系统接口 436 14.9 相关模块 436 14.10 练习 437</span><br><span class="line"></span><br><span class="line"> 第2部分 高级主题 第15章 正则表达式 441 15.1 引言&#x2F;动机 442 15.2 正则表达式使用的特殊符号和字符 443 15.2.1 用管道符号(|)匹配多个正则表达式模式 444 15.2.2 匹配任意一个单个的字符(.) 444 15.2.3 从字符串的开头或结尾或单词边界开始匹配(^&#x2F;$ &#x2F;\b &#x2F;\B ) 444 15.2.4 创建字符类([]) 445 15.2.5 指定范围(-)和否定(^) 445 15.2.6 使用闭包操作符(*，+，?，&#123;&#125;)实现多次出现&#x2F;重复匹配 446 15.2.7 特殊字符表示、字符集 446 15.2.8 用圆括号(())组建组 447 15.3 正则表达式和Python语言 447 15.3.1 re模块：核心函数和方法 448 15.3.2 使用compile()编译正则表达式 449 15.3.3 匹配对象和group()、groups()方法 449 15.3.4 用match()匹配字符串 449 15.3.5 search()在一个字符串中查找一个模式(搜索与匹配的比较) 450 15.3.6 匹配多个字符串(|) 451 15.3.7 匹配任意单个字符(.) 451 15.3.8 创建字符集合([]) 452 15.3.9 重复、特殊字符和子组 452 15.3.10 从字符串的开头或结尾匹配及在单词边界上的匹配 454 15.3.11 用findall()找到每个出现的匹配部分 455 15.3.12 用sub()(和subn())进行搜索和替换 455 15.3.13 用split()分割(分隔模式) 455 15.4 正则表达式示例 458 15.4.1 匹配一个字符串 460 15.4.2 搜索与匹配的比较，“贪婪”匹配 461 15.5 练习 463</span><br><span class="line"></span><br><span class="line"> 第16章 网络编程 465 16.1 引言 466 16.1.1 什么是客户端&#x2F;服务器架构 466 16.1.2 客户端&#x2F;服务器网络编程 468 16.2 套接字：通信端点 468 16.2.1 什么是套接字 468 16.2.2 套接字地址：主机与端口 469 16.2.3 面向连接与无连接 469 16.3 Python中的网络编程 469 16.3.1 socket()模块函数 470 16.3.2 套接字对象(内建)方法 470 16.3.3 创建一个TCP服务器 471 16.3.4 创建TCP客户端 473 16.3.5 运行我们的客户端与TCP服务器 474 16.3.6 创建一个UDP服务器 475 16.3.7 创建一个UDP客户端 476 16.3.8 执行UDP服务器和客户端 477 16.3.9 Socket模块属性 478 16.4 *SocketServer模块 479 16.4.1 创建一个SocketServerTCP服务器 479 16.4.2 创建SocketServerTCP客户端 480 16.4.3 执行TCP服务器和客户端 481 16.5 Twisted框架介绍 482 16.5.1 创建一个Twisted Reactor TCP服务器 482 16.5.2 创建一个Twisted Reactor TCP客户端 483 16.5.3 执行TCP服务器和客户端 484 16.6 相关模块 484 16.7 练习 485</span><br><span class="line"></span><br><span class="line"> 第17章 网络客户端编程 487 17.1 什么是因特网客户端 488 17.2 文件传输 488 17.2.1 文件传输网际协议 488 17.2.2 文件传输协议(FTP) 488 17.2.3 Python和FTP 489 17.2.4 ftplib.FTP类方法 490 17.2.5 交互式FTP示例 490 17.2.6 客户端FTP程序举例 491 17.2.7 FTP的其他方面 492 17.3 网络新闻 493 17.3.1 Usenet与新闻组 493 17.3.2 网络新闻传输协议(NNTP) 493 17.3.3 Python和NNTP 494 17.3.4 nntplib.NNTP类方法 494 17.3.5 交互式NNTP举例 495 17.3.6 客户端程序NNTP举例 496 17.3.7 NNTP的其他方面 500 17.4 电子邮件 500 17.4.1 电子邮件系统组件和协议 500 17.4.2 发送电子邮件 501 17.4.3 Python和SMTP 501 17.4.4 smtplib.SMTP类方法 502 17.4.5 交互式SMTP示例 502 17.4.6 SMTP的其他方面 503 17.4.7 接收电子邮件 503 17.4.8 POP和IMAP 504 17.4.9 Python和POP3 504 17.4.10 交互式POP3举例 505 17.4.11 poplib.POP3类方法 506 17.4.12 客户端程序SMTP和POP3举例 506 17.5 相关模块 508 17.5.1 电子邮件 508 17.5.2 其他网络协议 508 17.6 练习 509</span><br><span class="line"></span><br><span class="line"> 第18章 多线程编程 512 18.1 引言&#x2F;动机 513 18.2 线程和进程 513 18.2.1 什么是进程 513 18.2.2 什么是线程 514 18.3 Python、线程和全局解释器锁 514 18.3.1 全局解释器锁(GIL) 514 18.3.2 退出线程 515 18.3.3 在Python中使用线程 515 18.3.4 没有线程支持的情况 515 18.3.5 Python的threading模块 516 18.4 thread模块 517 18.5 threading模块 520 18.5.1 Thread类 521 18.5.2 斐波那契、阶乘和累加和 525 18.5.3 threading模块中的其他函数 528 18.5.4 生产者-消费者问题和Queue模块 528 18.6 相关模块 531 18.7 练习 531</span><br><span class="line"></span><br><span class="line"> 第19章 图形用户界面编程 532 19.1 简介 533 19.1.1 什么是Tcl、Tk和Tkinter 533 19.1.2 安装和使用Tkinter 533 19.1.3 客户端&#x2F;服务器架构 534 19.2 Tkinter与Python编程 534 19.2.1 Tkinter模块：把Tk引入你的程序 534 19.2.2 GUI程序开发简介 534 19.2.3 顶层窗口：Tkinter.Tk() 535 19.2.4 Tk组件 535 19.3 Tkinter举例 536 19.3.1 标签组件 536 19.3.2 按钮组件 537 19.3.3 标签和按钮组件 537 19.3.4 标签、按钮和进度条组件 538 19.3.5 偏函数应用举例 539 19.3.6 中级Tkinter范例 541 19.4 其他GUI简介 545 19.4.1 Tk Interface eXtensions (Tix) 546 19.4.2 Python MegaWidgets (PMW) 547 19.4.3 wxWidgets和wxPython 547 19.4.4 GTK+和PyGTK 549 19.5 相关模块和其他GUI 551 19.6 练习 553</span><br><span class="line"></span><br><span class="line"> 第20章 Web编程 554 20.1 介绍 555 20.1.1 Web应用：客户端&#x2F;服务器计算 555 20.1.2 因特网 555 20.2 使用Python进行Web应用：创建一个简单的Web客户端 556 20.2.1 统一资源定位符 556 20.2.2 urlparse模块 557 20.2.3 urllib模块 558 20.2.4 urllib2模块 561 20.3 高级Web客户端 563 20.4 CGI：帮助Web服务器处理客户端数据 567 20.4.1 CGI介绍 567 20.4.2 CGI应用程序 568 20.4.3 cgi模块 569 20.5 建立CGI应用程序 569 20.5.1 建立Web服务器 569 20.5.2 建立表单页 569 20.5.3 生成结果页 570 20.5.4 生成表单和结果页面 571 20.5.5 全面交互的Web站点 574 20.6 在CGI中使用Unicode编码 577 20.7 高级CGI 579 20.7.1 Mulitipart表单提交和文件的上传 579 20.7.2 多值字段 579 20.7.3 cookie 579 20.7.4 使用高级CGI 580 20.8 Web(HTTP)服务器 587 20.9 相关模块 589 20.10 练习 590</span><br><span class="line"></span><br><span class="line"> 第21章 数据库编程 593 21.1 介绍 594 21.1.1 持久存储 594 21.1.2 基本的数据库操作和SQL语言 594 21.1.3 数据库和Python 596 21.2 Python数据库应用程序程序员接口(DB-API) 596 21.2.1 模块属性 597 21.2.2 连接对象 598 21.2.3 游标对象 599 21.2.4 类型对象和构造器 600 21.2.5 关系数据库 601 21.2.6 数据库和Python：接口程序 602 21.2.7 使用数据库接口程序举例 602 21.3 对象-关系管理器(ORM) 611 21.3.1 考虑对象，而不是SQL 611 21.3.2 Python和ORM 611 21.3.3 雇员数据库举例 611 21.3.4 总结 620 21.4 相关模块 620 21.5 练习 621</span><br><span class="line"></span><br><span class="line"> 第22章 扩展Python 623 22.1 引言&#x2F;动机 624 22.1.1 什么是扩展 624 22.1.2 为什么要扩展Python 624 22.2 创建Python扩展 625 22.2.1 创建您的应用程序代码 625 22.2.2 用样板来包装你的代码 627 22.2.3 编译 630 22.2.4 导入和测试 632 22.2.5 引用计数 633 22.2.6 线程和全局解释器锁(GIL) 635 22.3 相关话题 636 22.4 练习 637</span><br><span class="line"></span><br><span class="line"> 第23章 其他话题 638 23.1 Web服务 639 23.2 用Win32的COM来操作微软Office 641 23.2.1 客户端COM编程 641 23.2.2 微软Excel 642 23.2.3 微软Word 644 23.2.4 微软PowerPoint 645 23.2.5 微软Outlook 646 23.2.6 中等规模的例子 648 23.3 用Jython写Python和Java的程序 650 23.3.1 什么是Jython 650 23.3.2 Swing GUI开发(Java或者Python!) 651 23.4 练习 653</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001BKVXOA/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001BKVXOA&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51y8P%2BL7kgL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能网站建设指南</title>
    <url>/2020/04/19/B001C0CFTG/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 高性能网站建设指南<br>作者信息： 作者: 平均4.0 星  [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《高性能网站建设指南》适合Web架构师、信息架构师、Web开发人员及产品经理阅读和参考。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">序</span><br><span class="line">前言</span><br><span class="line">绪言A 前端性能的重要性</span><br><span class="line">绪言B HTTP概述</span><br><span class="line">第1章 规则1——减少HTTP请求</span><br><span class="line">第2章 规则2——实用内容发布网络</span><br><span class="line">第3章 规则3——添加Expires头</span><br><span class="line">第4章 规则4——压缩组件</span><br><span class="line">第5章 规则5——将样式表放在顶部</span><br><span class="line">第6章 规则6——将脚本放在底部</span><br><span class="line">第7章 规则7——避免CSS表达式</span><br><span class="line">第8章 规则8——使用外部和CSS</span><br><span class="line">第9章 规则9——减少DNS查找</span><br><span class="line">第10章 规则10——精简JavaScript</span><br><span class="line">第11章 规则11——避免重定向</span><br><span class="line">第12章 规则12——移出重复脚本</span><br><span class="line">第13章 规则13——配置ETag</span><br><span class="line">第14章 规则14——使AJAX可缓存</span><br><span class="line">第15章 析构十大网站</span><br><span class="line">索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001C0CFTG/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001C0CFTG&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51dQCSGthXL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript王者归来</title>
    <url>/2020/04/19/B001BTRFDO/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： JavaScript王者归来<br>作者信息： 作者: 浏览全部评论  [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>脚本神力与你同在 无忧版主月影力作。《JavaScript王者归来》是一本寻求JavaScript解决之道的书。《JavaScript王者归来》是一本探寻程序设计思想本源的“魔法典籍” 。从简单的语言基础到丰富的实际应用再到语言本质的深入剖析。字里行间包含作者对JavaScript实践乃至程序设计思想的深入思考和总结脚本攻击就在黎明发起。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分 概论</span><br><span class="line">第一章 从零开始</span><br><span class="line">1.1 为什么选择JavaScript?</span><br><span class="line">1.1.1 用户的偏好：B&#x2F;S模式</span><br><span class="line">1.1.2 在什么情况下用JavaScript</span><br><span class="line">1.1.3 对JavaScript的一些误解</span><br><span class="line">1.1.3.1 JavaScript和Java</span><br><span class="line">1.1.3.2 披着C外衣的Lisp</span><br><span class="line">1.1.3.3 思维定势</span><br><span class="line">1.1.3.4 业余爱好者</span><br><span class="line">1.1.3.5 面向对象</span><br><span class="line">1.1.3.6 其他误解</span><br><span class="line">1.1.4 警惕！脚本诱惑</span><br><span class="line">1.1.5 隐藏在简单表象下的复杂度</span><br><span class="line">1.1.6 令人迷惑的选择：锦上添花还是雪中送炭</span><br><span class="line">1.1.7 回到问题上来</span><br><span class="line">1.2 JavaScript的应用范围</span><br><span class="line">1.2.1 客户端的JavaScript</span><br><span class="line">1.2.2 服务器端的JavaScript</span><br><span class="line">1.2.3  其他环境中的JavaScript</span><br><span class="line">1.3  JavaScript的版本</span><br><span class="line">1.3.1  浏览器中的JavaScript版本</span><br><span class="line">1.3.2  其他版本</span><br><span class="line">1.4  一些值得留意的特性</span><br><span class="line">1.4.1  小把戏——神奇的魔法代码</span><br><span class="line">1.4.2  为客户端服务——经典Hello World！的另一种JavaScript实现</span><br><span class="line">1.4.3  数据交互——JavaScript的一项强大功能</span><br><span class="line">1.4.4  JavaScript表面上的禁忌及如何突破这些禁忌</span><br><span class="line">1.5  安全性和执行效率</span><br><span class="line">1.5.1  数据安全——永远的敏感话题</span><br><span class="line">1.5.2  实战！攻击与防范</span><br><span class="line">1.5.3  不容马虎——时刻关注性能</span><br><span class="line">1.6  一个例子——JavaScript编写的计算器</span><br><span class="line">1.6.1  从需求分析开始——什么是计算器？</span><br><span class="line">1.6.2  系统设计——如何实现计算器？</span><br><span class="line">1.6.3  系统实现——计算器的最终实现</span><br><span class="line">1.6.4  持续改进——迭代的软件开发过程</span><br><span class="line">1.7  学习和使用JavaScript的几点建议</span><br><span class="line">1.7.1  像程序员一样地思考——程序员的四个境界</span><br><span class="line">1.7.2  吝惜你的代码</span><br><span class="line">1.7.3  学会在环境中调试</span><br><span class="line">1.7.4  警惕那些小缺陷</span><br><span class="line">1.7.5  思考先于实践——不要轻易动手写代码</span><br><span class="line">1.7.6  时刻回头——圣贤也无法完全预知未来</span><br><span class="line">1.8  关于本书的其余部分 </span><br><span class="line"></span><br><span class="line"> 第2章 浏览器中的JavaScript 2.1 嵌入网页的可执行内容 2.1.1 在什么地方装载JavaScript代码 2.1.2 关于代码的Script标签 2.1.3 我的代码什么时候被执行——不同执行期的JavaScript代码 2.1.4 拿来主义——引入外部的JavaScript文件 2.2 赏心悦目的特效 2.2.1 生命在于运动——DHTML的效果 2.2.2 换一种风格——CSS的力量 2.2.3 用JavaScript操作DOM——一个可拖动窗口的例子 2.3 使用JavaScript来与用户交互 2.3.1 创建一个弹出式帮助和进度条 2.3.2 填错了哦 2.4 绕开脚本陷阱 2.4.1 现实并不总是完美的 2.4.2 不能完全相信你所见到的 2.5 总结</span><br><span class="line"></span><br><span class="line"> 第3章 开发环境和调试方法 3.1 我能用什么来编写脚本——适合编写JavaScript的 文本编辑器 3.2 来自浏览器的支持 3.2.1 主流浏览器 3.2.2 非主流浏览器 3.3 集成开发环境 3.3.1 什么是集成开发环境 3.3.2 我需要集成开发环境吗 3.3.3 适合JavaScript的集成开发环境 3.4 调试工具——提升开发效率的利器 3.4.1 什么是调试 3.4.2 原始的调试方法——利用输出语句、“反射”机制和调试对象来进行调试 3.4.3 适合JavaScript的调试工具 3.5 定位代码和调用堆栈 3.5.1 Step by Step——单步和断点 3.5.2 监视内存 3.5.3 追踪问题的源头——查看调用堆栈 3.5.4 遇到麻烦了——为什么我跟踪不到代码 3.6 浏览器捕获异常 3.6.1 异常处理机制——一个try&#x2F;catch&#x2F;finally模式的例子 3.6.2 异常的种类 3.6.3 应该在什么时候“吃掉”异常 3.7 总结</span><br><span class="line"></span><br><span class="line"> 第二部分 JavaScript核心 第4章 语言结构 第5章 数据类型 第6章 函数 第7章 对象 第8章 集合 第9章 字符串 第10章 正则表达式</span><br><span class="line"></span><br><span class="line"> 第三部分 浏览器与DOM 第11章 浏览器对象 第12章 文档对象模型 第13章 事件处理 第14章 级联样式表 第15章 数据存储的脚本化</span><br><span class="line"></span><br><span class="line"> 第四部分 数据交互 第16章 同步和异步 第17章 XML DOM和XML HTTP 第18章 Ajax简介 第19章 标准和兼容性 第20章 信息安全</span><br><span class="line"></span><br><span class="line"> 第五部分 超越JavaScript 第21章 面向对象 第22章 闭包与函数式编程 第23章 模块级管理 第24章 动态构建 第25章 执行效率 第26章 应用框架</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001BTRFDO/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001BTRFDO&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51e4w9Fyb7L._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript高级应用与实践</title>
    <url>/2020/04/19/B0018NT7D4/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： JavaScript高级应用与实践<br>作者信息： 作者: 浏览全部评论  [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《JavaScript高级应用与实践》适合于不同层次的JavaScript语言爱好者和技术人员学习和参考。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章  快速入门</span><br><span class="line">1.1  阅读本书方式</span><br><span class="line">1.1.1  融合注释，会说话的代码</span><br><span class="line">1.1.2  交叉阅读</span><br><span class="line">1.1.3  水到渠成</span><br><span class="line">1.1.4  环境</span><br><span class="line">1.2  规范和约定</span><br><span class="line">1.2.1  注释约定</span><br><span class="line">1.2.2  命名约定</span><br><span class="line">1.2.3  辅助调试编码约定</span><br><span class="line">1.3  本书公共代码（Jcore.js）导读</span><br><span class="line">1.4  本书常见代码语法预阅</span><br><span class="line">1.4.1  逗号运算符号</span><br><span class="line">1.4.2  JavaScript独特的逻辑或、逻辑与运算符号</span><br><span class="line">1.5  不推荐的中文命名方式</span><br><span class="line">1.6  本书的写作思想 </span><br><span class="line"></span><br><span class="line"> 第2章 Function扩展和性能 2.1 关于Function的设计原则建议 2.2 arguments，length 2.3 toString 方法和valueOf 方法 2.4 Function的toString还有个妙用 2.5 绑定技术 HTML DOM对象事件动态行为绑定 2.6 JavaScript中的this( )是什么 2.7 绑定NaN、Infinity、null、undefined给对象，this会是什么 2.8 Function对象的apply 和call的区别 2.9 不用new的时候应该注意什么 2.9.1 一般直接调用方式 2.9.2 new调用 2.9.3 apply方式 2.9.4 call方式 2.9.5 本书推荐的巧妙方式 2.10 如何给你的function增加[ ]运算符号的支持Web项目中HTML DOM的应用 2.11 如何让你的this加、减、乘、除 2.12 回调函数之函数“类型” 流行中的AJAX里的回调应用 2.13 打造方便的调试函数 2.14 匿名函数 2.15 匿名函数的递归调用 2.16 继承后如何在函数中访问Super的简化设计 2.17 静态函数、属性的访问问题 2.18 总结</span><br><span class="line"></span><br><span class="line"> 第3章 Object扩展和性能及Web应用之神兵利器 3.1 typeof和constructor总结 3.2 高性能初始化 3.2.1 和普通Object初始化的性能比较 3.2.2 与function的比较 3.3 当心，这里的bind对我无用 3.4 完美之绑定(bind)将通用于Object、Function和其他对象，同时支持给Object增加［　］运算符号 3.5 通用属性复制 3.6 “继承” 3.7 多态 3.8 推荐的对象模型方法[优点：一个名称空间，更便于内存才清理和释放] 3.9 Json引入 3.9.1 什么是Json 3.9.2 Json串形化有什么用途 3.9.3 我为Json修正了什么 3.9.4 Json使用举例 3.10 toString 3.11 融合HTML DOM支持的完美通用对象迭代器模型设计之each 3.12 通用迭代模式的元素属性的获取和设置Style外观样式对象的获取和设置设计 3.13 通用对象排序模型设计之继承Array的相关功能 3.14 isPrototypeOf和hasOwnProperty 3.14.1 isPrototypeOf 3.14.2 hasOwnProperty 3.15 给所有JavaScript对象扩展属性、方法 3.16 打造“完美中的完美”的HTML DOM对象XPath对象选择器 115 3.16.1 XPath对象选择器架构说明 3.16.2 模式匹配函数定义说明 3.16.3 基本正则表达式模式详解 3.16.4 可扩展的转义及可扩展模块说明 3.16.5 选择后的对象集合如何支持HTML事件的动态绑定 125 3.16.6 实现代码及使用举例 3.17 不要被怪物吓倒：0.1234[“each”]、true[“each”] 152 3.18 泛型设计之保留四舍五入保留小数：toFixed 3.19 addClass、removeClass、toggleClass、mstgcls、remove的扩展设计</span><br><span class="line"></span><br><span class="line"> 第4章 Array扩展和独辟蹊径的应用 4.1 高性能初始化 4.2 数字下标 4.3 文本下标 4.4 “特殊”数字下标揭秘 4.5 对象下标揭秘 4.6 迭代器 4.7 扩展Array及应用 4.7.1 Max、Min的扩展 4.7.2 indexOf、lastIndexOf的扩展 4.7.3 some、every、filter、forEach、map的扩展 4.7.4 克隆的实现 4.8 Array函数功能增强 4.8.1 push的增强，名为ps 4.8.2 pop的增强，名为pp 4.8.3 shift的增强，名为sft 4.8.4 unshift的增强，名为usft 4.8.5 splice的增强，名为splc 4.9 给自己定义的对象增加[ ]运算符号</span><br><span class="line"></span><br><span class="line"> 第5章 String的扩展 5.1 如何将自定义对象直接赋予HTML DOM的innerText、innerHTML、value和其他属性 5.2 扩展自己的append方法 5.3 也谈StringBuffer 5.3.1 StringBuffer的实现 5.3.2 和String扩展的append性能比较 5.4 扩展自己的trim、trimAll、trimL、trimR 5.5 兼容Java时equals的扩展 5.6 把replace玩到颠峰 5.6.1 稍微高级的玩法设计 5.6.2 最迷惑人的隐匿方式设计 5.7 转换汉字及双字节字符为Unicode 5.7.1 Unicode编码 5.7.2 Unicode解码 5.8 加密我的String加、解密的实现 5.9 Web常用验证功能集 5.9.1 身份证的验证和自动升位 5.9.2 E-mail的验证 5.9.3 数字范围验证及在Web开发中的应用、输入限制的设计 214 5.9.4 Web开发中IP地址的输入限制和验证 5.10 类似Java里的参数功能：toString的&#123;1 ……n&#125;参数模式的合成 5.11 String的Left、Right、Mid扩展</span><br><span class="line"></span><br><span class="line"> 第6章 For的优化和性能提升 6.1 使用For…in应该注意什么 6.2 do&#123;……&#125; while()和for的性能比较 6.3 匿名函数对象对性能的提升 6.4 倒着循环对性能的提升 6.5 最佳性能for的设计 6.6 本章for各种实现性能综合比较 第7章 window对象的性能应用</span><br><span class="line"></span><br><span class="line"> 第8章 Form开发经验之谈 8.1 通用获取输入对象元素value的设计 8.2 通用设置输入对象元素value的设计 8.3 异步支持设计 8.4 动态支持上传N个文件的封装设计 8.5 Web开发中自定义输入对象组和表达式求值的设计 309 8.6 Web开发中人性化输入值长度光标跟踪提示 8.7 如何在必输项没有输入值前其相关按钮、对象不可以操作 313 8.8 如何令表格中没有选择radio、checkbox输入对象的时候相应的 8.8 按钮、相应的对象不可以操作 8.9 AJAX让你的网站支持多语言——多语言的google Translate AJAX 8.8 的封装 …… 第15章 JavaScript在WebDAV中的应用 附录A 附录B 参考文献</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0018NT7D4/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0018NT7D4&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51RkF1GXhVL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Python源码剖析 深度探索动态语言核心技术</title>
    <url>/2020/04/19/B001D2C91M/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Python源码剖析 深度探索动态语言核心技术<br>作者信息： 作者: 浏览全部评论  [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Python源码剖析:深度探索动态语言核心技术》适合于Python程序员、动态语言爱好者、C程序员阅读。作为主流的动态语言，Python不仅简单易学、移植性好，而且拥有强大丰富的库的支持。此外，Python强大的可扩展性，让开发人员既可以非常容易地利用C/C++编写Python的扩展模块，还能将Python嵌入到C/C++程序中，为自己的系统添加动态扩展和动态编程的能力。为了更好地利用Python语言，无论是使用Python语言本身，还是将Python与C/C++交互使用，深刻理解Python的运行原理都是非常重要的。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第0章 Python源码剖析——编译Python</span><br><span class="line">0.1 Python总体架构</span><br><span class="line">0.2 Python源代码的组织</span><br><span class="line">0.3 Windows环境下编译Python </span><br><span class="line">0.4 Unix&#x2F;Linux环境下编译Python </span><br><span class="line">0.5 修改Python源代码 </span><br><span class="line">0.6 通往Python之路</span><br><span class="line">0.7 一些注意事项 </span><br><span class="line"></span><br><span class="line"> 第1部分 Python内建对象 第1章 Python对象初探 1.1 Python内的对象 1.1.1 对象机制的基石——PyObject 1.1.2 定长对象和变长对象 1.2 类型对象 1.2.1 对象的创建 1.2.2 对象的行为 1.2.3 类型的类型 1.3 Python对象的多态性 1.4 引用计数 1.5 Python对象的分类 第2章 Python中的整数对象 第3章 Python中的字符串对象 第4章 Python中的LIST对象 第5章 Python中的DICT对象 第6章 最简单的Python模拟——SMALL Python</span><br><span class="line"></span><br><span class="line"> 第2部分 Python的虚拟机 第7章 Python的编译结果——CODE 对象与PYC文件 第8章 Python虚拟机框架 第9章 Python虚拟机中的一般表达式 第10章 Python虚拟机中的控制流 第11章 Python虚拟机中的函数机制 第12章 Python虚拟机中的类机制</span><br><span class="line"></span><br><span class="line"> 第3部分 Python高级话题 第13章 Python运行环境初始化 第14章 Python模块的动态加载机制 第15章 Python多线程机制 第16章 Python的内存管理机制</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001D2C91M/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001D2C91M&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51SgXqYX0rL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows核心编程(第5版)</title>
    <url>/2020/04/19/B001GS7918/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Windows核心编程(第5版)<br>作者信息： 作者: 杰夫瑞 (Jeffrey Richter) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Windows核心编程(第5版)》是一本经典的Windows核心编程指南，从第1版到第5版，引领着数十万程序员走入Windows开发阵营，培养了大批精英。《Windows核心编程(第5版)》针对WindowsXP，WindowsVista和WindowsServer2008全面修订。主题广泛，内容丰富，讲解深入而精辟。透过这本Windows编程经典，我们可以在专家的悉心指导下，洞悉Windows编程精华，深入了解高级编程技巧，编写出高性能的Windows应用程序。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1部分 必备知识</span><br><span class="line">第1章 错误处理</span><br><span class="line">1.1 定义自己的错误代码</span><br><span class="line">1.2 Error Show示例程序</span><br><span class="line">第2章 字符和字符串处理</span><br><span class="line">2.1 字符编码</span><br><span class="line">2.2 ANSI字符和Unicode字符与字符串数据类型</span><br><span class="line">2.3 Windows中的Unicode函数和ANSI函数</span><br><span class="line">2.4 C运行库中的Unicode函数和ANSI函数</span><br><span class="line">2.5 C运行库中的安全字符串函数</span><br><span class="line">2.5.1 初识新的安全字符串函数</span><br><span class="line">2.5.2 在处理字符串时如何获得更多控制</span><br><span class="line">2.5.3 Windows字符串函数</span><br><span class="line">2.6 为何要用Unicode</span><br><span class="line">2.7 推荐的字符和字符串处理方式</span><br><span class="line">2.8 Unicode与ANSI字符串转换</span><br><span class="line">2.8.1 导出ANSI和Unicode DLL函数</span><br><span class="line">2.8.2 判断文本是ANSI还是Unicode</span><br><span class="line">第3章 内核对象</span><br><span class="line">3.1 何为内核对象</span><br><span class="line">3.1.1 使用计数</span><br><span class="line">3.1.2 内核对象的安全性</span><br><span class="line">3.2 进程内核对象句柄表</span><br><span class="line">3.2.1 创建一个内核对象</span><br><span class="line">3.2.2 关闭内核对象</span><br><span class="line">3.3 跨进程边界共享内核对象</span><br><span class="line">3.3.1 使用对象句柄继承</span><br><span class="line">3.3.2 改变句柄的标志</span><br><span class="line">3.3.3 为对象命名</span><br><span class="line">3.3.4 终端服务命名空间</span><br><span class="line">3.3.5 专有命名空间</span><br><span class="line">3.3.5 复制对象句柄</span><br><span class="line">第Ⅱ部分 工作机制</span><br><span class="line">第4章 进程</span><br><span class="line">4.1 编写第一个Windows应用程序</span><br><span class="line">4.1.1 进程实例句柄</span><br><span class="line">4.1.2 进程前一个实例的句柄</span><br><span class="line">4.1.3 进程的命令行</span><br><span class="line">4.1.4 进程的环境变量</span><br><span class="line">4.1.5 进程的关联性</span><br><span class="line">4.1.6 进程的错误模式</span><br><span class="line">4.1.7 进程当前所在的驱动器和目录</span><br><span class="line">4.1.8 进程的当前目录</span><br><span class="line">4.1.9 系统版本</span><br><span class="line">4.2 Create Process函数</span><br><span class="line">4.2.1 psz Application Name和psz Command Line参数</span><br><span class="line">4.2.2 psa Process，psaThread和bInherit Handles参数</span><br><span class="line">4.2.3 fdw Create参数</span><br><span class="line">4.2.4 pv Environment参数</span><br><span class="line">4.2.5 psz Cur Dir参数</span><br><span class="line">4.2.6 psi StartInfo参数</span><br><span class="line">4.2.7 ppi ProcInfo参数</span><br><span class="line">4.3 终止进程</span><br><span class="line">4.3.1 主线程的入口点函数返回</span><br><span class="line">4.3.2 Exit Process函数</span><br><span class="line">4.3.3 Terminate Process函数</span><br><span class="line">4.3.4 当进程中的所有线程终止时</span><br><span class="line">4.3.5 当进程终止运行时</span><br><span class="line">4.4 子进程</span><br><span class="line">4.5 管理员以标准用户权限运行时</span><br><span class="line">4.5.1 自动提升进程的权限</span><br><span class="line">4.5.2 手动提升进程的权限</span><br><span class="line">4.5.3 何为当前权限上下文</span><br><span class="line">4.5.4 枚举系统中正在运行的进程</span><br><span class="line">4.5.5 Process Information示例程序</span><br><span class="line">第5章 作业</span><br><span class="line">5.1 对作业中的进程施加限制</span><br><span class="line">5.2 将进程放入作业中</span><br><span class="line">5.3 终止作业中的所有线程查询作业统计信息</span><br><span class="line">5.4 作业通知</span><br><span class="line">5.6 Job Lab示例程序</span><br><span class="line">第6章 线程基础</span><br><span class="line">6.1 何时创建线程</span><br><span class="line">6.2 何时不应该创建线程</span><br><span class="line">6.3 编写第一个线程函数</span><br><span class="line">6.4 Create Thread函数</span><br><span class="line">6.4.1 psa参数</span><br><span class="line">6.4.2 cb Stack Size参数</span><br><span class="line">6.4.3 pfn Start Addr和pv Param参数</span><br><span class="line">6.4.4 dw Create Flags</span><br><span class="line">6.4.5 pdw ThreadID7</span><br><span class="line">6.5 终止运行线程</span><br><span class="line">6.5.1 线程函数返回</span><br><span class="line">6.5.2 Exit Thread函数</span><br><span class="line">6.5.3 Terminate Thread函数</span><br><span class="line">6.5.4 进程终止运行时</span><br><span class="line">6.5.5 线程终止运行时</span><br><span class="line">6.6 线程内幕</span><br><span class="line">6.7 C&#x2F;C++运行库注意事项</span><br><span class="line">6.7.1 用_beginthreadex而不要用Create Thread创建线程</span><br><span class="line">6.7.2 绝对不应该调用的C&#x2F;C++运行库函数</span><br><span class="line">6.8 了解自己的身份</span><br><span class="line">6.8.1 将伪句柄转换为真正的句柄</span><br><span class="line">第7章 线程调度、优先级和关联性</span><br><span class="line">7.1 线程的挂起和恢复</span><br><span class="line">7.2 进程的挂起和恢复</span><br><span class="line">7.3 睡眠</span><br><span class="line">7.4 切换到另一个线程</span><br><span class="line">7.5 在超线程CPU上切换到另一个线程</span><br><span class="line">7.6 线程的执行时间</span><br><span class="line">7.7 在实际上下文中谈CONTEXT结构</span><br><span class="line">7.8 线程优先级</span><br><span class="line">7.9 从抽象角度看优先级</span><br><span class="line">7.10 优先级编程</span><br><span class="line">7.10.1 动态提升线程优先级</span><br><span class="line">7.10.2 为前台进程微调调度程序</span><br><span class="line">7.10.3 调度I&#x2F;O请求优先级</span><br><span class="line">7.10.4 Scheduling Lab 示例程序</span><br><span class="line">7.11 关联性</span><br><span class="line">第8章 用户模式下的线程同步</span><br><span class="line">8.1 原子访问：Interlocked系列函数</span><br><span class="line">8.2 高速缓存行</span><br><span class="line">8.3 高级线程同步需要避免使用的一种方法</span><br><span class="line">8.4 关键段</span><br><span class="line">8.4.1 关键段：细节</span><br><span class="line">8.4.2 关键段和旋转锁</span><br><span class="line">8.4.3 关键段和错误处理</span><br><span class="line">8.5 Slim读&#x2F;写锁</span><br><span class="line">8.6 条件变量</span><br><span class="line">8.6.1 Queue示例程序</span><br><span class="line">8.6.2 在停止线程时的死锁问题</span><br><span class="line">8.6.3 一些有用的窍门和技巧</span><br><span class="line">第9章 用内核对象进行线程同步</span><br><span class="line">9.1 等待函数</span><br><span class="line">9.2 等待成功所引起的副作用</span><br><span class="line">9.3 事件内核对象</span><br><span class="line">9.4 可等待的计时器内核对象</span><br><span class="line">9.4.1 让可等待的计时器添加APC调用</span><br><span class="line">9.4.2 计时器的剩余问题</span><br><span class="line">9.5 信号量内核对象</span><br><span class="line">9.6 互斥量内核对象</span><br><span class="line">9.6.1 遗弃问题</span><br><span class="line">9.6.2 互斥量与关键段的比较</span><br><span class="line">9.6.3 Queue示例程序</span><br><span class="line">9.7 线程同步对象速查表</span><br><span class="line">9.8 其他的线程同步函数</span><br><span class="line">9.8.1 异步设备I&#x2F;O</span><br><span class="line">9.8.2 Wait For InputIdle函数</span><br><span class="line">9.8.3 Msg Wait For Multiple Objects（Ex）函数</span><br><span class="line">9.8.4 Wait For Debug Event函数</span><br><span class="line">9.8.5 Signal Object And Wait函数</span><br><span class="line">9.8.6 使用等待链遍历API来检测死锁</span><br><span class="line">第10章 同步设备I&#x2F;O与异步设备I&#x2F;O</span><br><span class="line">10.1 打开和关闭设备细看Create File函数</span><br><span class="line">10.2 使用文件设备</span><br><span class="line">10.2.1 取得文件的大小</span><br><span class="line">10.2.2 设置文件指针的位置</span><br><span class="line">10.2.3 设置文件尾</span><br><span class="line">10.3 执行同步设备I&#x2F;O</span><br><span class="line">10.3.1 将数据刷新至设备</span><br><span class="line">10.3.2 同步I&#x2F;O的取消</span><br><span class="line">10.4 异步设备I&#x2F;O基础</span><br><span class="line">10.4.1 OVERLAPPED结构</span><br><span class="line">10.4.2 异步设备I&#x2F;O的注意事项</span><br><span class="line">10.4.3 取消队列中的设备I&#x2F;O请求</span><br><span class="line">10.5 接收I&#x2F;O请求完成通知</span><br><span class="line">10.5.1 触发设备内核对象</span><br><span class="line">10.5.2 触发事件内核对象</span><br><span class="line">10.5.3 可提醒I&#x2F;O</span><br><span class="line">10.5.4 I&#x2F;O完成端口</span><br><span class="line">10.5.5 模拟已完成的I&#x2F;O请求</span><br><span class="line">第11章 Windows线程池</span><br><span class="line">11.1 情形1：以异步方式调用函数</span><br><span class="line">11.1.1 显式地控制工作项</span><br><span class="line">11.1.2 Batch示例程序</span><br><span class="line">11.2 情形2：每隔一段时间调用一个函数</span><br><span class="line">11.3 情形3：在内核对象触发时调用一个函数</span><br><span class="line">11.4 情形4：在异步I&#x2F;O请求完成时调用一个函数</span><br><span class="line">11.5 回调函数的终止操作</span><br><span class="line">11.5.1 对线程池进行定制</span><br><span class="line">11.5.2 得体地销毁线程池：清理组</span><br><span class="line">第12章 纤程</span><br><span class="line">第Ⅲ部分 内存管理</span><br><span class="line">第13章 Windows内存体系结构</span><br><span class="line">13.1 进程的虚拟地址空间</span><br><span class="line">13.2 虚拟地址空间的分区</span><br><span class="line">13.2.1 空指针赋值分区</span><br><span class="line">13.2.2 用户模式分区</span><br><span class="line">13.3 地址空间中的区域</span><br><span class="line">13.4 给区域调拨物理存储器</span><br><span class="line">13.5 物理存储器和页交换文件</span><br><span class="line">13.6 页面保护属性</span><br><span class="line">13.6.1 写时复制</span><br><span class="line">13.6.2 一些特殊的访问保护属性标志</span><br><span class="line">13.7 实例分析</span><br><span class="line">13.8 数据对齐的重要性</span><br><span class="line">第14章 探索虚拟内存</span><br><span class="line">14.1 系统信息</span><br><span class="line">14.2 虚拟内存状态</span><br><span class="line">14.3 NUMA机器中的内存管理</span><br><span class="line">14.4 确定地址空间的状态</span><br><span class="line">14.4.1 VM Query函数</span><br><span class="line">14.4.2 示例程序：虚拟内存映射</span><br><span class="line">第15章 在应用程序中使用虚拟内存</span><br><span class="line">15.1 预订地址空间区域</span><br><span class="line">15.2 给区域调拨物理存储器</span><br><span class="line">15.3 同时预订和调拨物理存储器</span><br><span class="line">15.4 何时调拨物理存储器</span><br><span class="line">15.5 撤销调拨物理存储器及释放区</span><br><span class="line">15.5.1 何时撤销调拨物理存储器</span><br><span class="line">15.5.2 虚拟内存分配示例程序</span><br><span class="line">15.6 改变保护属性</span><br><span class="line">15.7 重置物理存储器的内容</span><br><span class="line">15.8 地址窗口扩展</span><br><span class="line">第16章 线程栈</span><br><span class="line">16.1 C&#x2F;C++运行库的栈检查函数</span><br><span class="line">16.2 Summation示例程序</span><br><span class="line">第17章 内存映射文件</span><br><span class="line">17.1 映射到内存的可执行文件和DLL</span><br><span class="line">17.1.1 同一个可执行文件或DLL的多个实例不会共享静态数据</span><br><span class="line">17.1.2 在同一个可执行文件或DLL的多个实例间共享静态数据</span><br><span class="line">17.1.3 Application Instances示例程序</span><br><span class="line">17.2 映射到内存的数据文件</span><br><span class="line">17.2.1 方法1：一个文件，一块缓存</span><br><span class="line">17.2.2 方法2：两个文件，一块缓存</span><br><span class="line">17.2.3 方法3：一个文件，两块缓存</span><br><span class="line">17.2.4 方法4：一个文件，零个缓存</span><br><span class="line">17.3 使用内存映射文件</span><br><span class="line">17.3.1 第1步：创建或打开文件内核对象</span><br><span class="line">17.3.2 第2步：创建文件映射内核对象</span><br><span class="line">17.3.3 第3步：将文件的数据映射到进程的地址空间</span><br><span class="line">17.3.4 第4步：从进程的地址空间撤销对文件数据的映射</span><br><span class="line">17.3.5 第5步和第6步：关闭文件映射对象和文件对象</span><br><span class="line">17.6 File Reverse示例程序</span><br><span class="line">17.7 用内存映射文件来处理大文件</span><br><span class="line">17.8 内存映射文件和一致性</span><br><span class="line">17.9 给内存映射文件指定基地址</span><br><span class="line">17.10 内存映射文件的实现细节</span><br><span class="line">第18章 堆</span><br><span class="line">18.1 进程的默认堆</span><br><span class="line">18.2 为什么要创建额外的堆</span><br><span class="line">18.2.1 对组件进行保护</span><br><span class="line">18.2.2 更有效的内存管理</span><br><span class="line">18.2.3 使内存访问局部化</span><br><span class="line">18.2.4 避免线程同步的开销</span><br><span class="line">18.2.5 快速释放</span><br><span class="line">18.3 如何创建额外的堆</span><br><span class="line">18.3.1 从堆中分配内存块</span><br><span class="line">18.3.2 调整内存块的大小</span><br><span class="line">18.3.3 获得内存块的大小</span><br><span class="line">18.3.4 释放内存块</span><br><span class="line">18.3.5 销毁堆</span><br><span class="line">18.3.6 在C++中使用堆</span><br><span class="line">18.4 其他堆函数</span><br><span class="line">第Ⅳ部分 动态链接库</span><br><span class="line">第19章 DLL基础</span><br><span class="line">19.1 DLL和进程的地址空间</span><br><span class="line">19.2 纵观全局</span><br><span class="line">19.2.1 构建DLL模块</span><br><span class="line">19.2.2 构建可执行模块</span><br><span class="line">19.2.3 运行可执行模块</span><br><span class="line">第20章 DLL高级技术</span><br><span class="line">20.1 DLL模块的显式载入和符号链接</span><br><span class="line">20.1.1 显式地载入DLL模块</span><br><span class="line">20.1.2 显式地卸载DLL模块</span><br><span class="line">20.1.3 显式地链接到导出符号</span><br><span class="line">20.2 DLL的入口点函数</span><br><span class="line">20.2.1 DLL_PROCESS_ATTACH通知</span><br><span class="line">20.2.2 DLL_PROCESS_DETACH通知</span><br><span class="line">20.2.3 DLL_THREAD_ATTACH通知</span><br><span class="line">20.2.4 DLL_THREAD_DETACH通知</span><br><span class="line">20.2.5 Dll Main的序列化调用</span><br><span class="line">20.2.6 Dll Main和C&#x2F;C++运行库</span><br><span class="line">20.3 延迟载入DLL</span><br><span class="line">20.4 函数转发器</span><br><span class="line">20.5 已知的DLL</span><br><span class="line">20.6 DLL重定向</span><br><span class="line">20.7 模块的基地址重定位</span><br><span class="line">20.8 模块的绑定</span><br><span class="line">第21章 线程局部存储区</span><br><span class="line">21.1 动态TLS</span><br><span class="line">21.2 静态TLS0</span><br><span class="line">第22章 DLL注入和API拦截</span><br><span class="line">22.1 DLL注入的一个例子</span><br><span class="line">22.2 使用注册表来注入DLL</span><br><span class="line">22.3 使用Windows挂钩来注入DLL</span><br><span class="line">22.4 使用远程线程来注入DLL</span><br><span class="line">22.4.1 Inject Library示例程序</span><br><span class="line">22.4.2 Image Walk DLL</span><br><span class="line">22.5 使用木马DLL来注入DLL</span><br><span class="line">22.6 把DLL作为调试器来注入</span><br><span class="line">22.7 使用Create Process来注入代码</span><br><span class="line">22.8 API拦截的一个例子9</span><br><span class="line">22.8.1 通过覆盖代码来拦截API0</span><br><span class="line">22.8.2 通过修改模块的导入段来拦截API</span><br><span class="line">22.8.3 Last Message Box Info示例程序</span><br><span class="line">第Ⅴ部分 结构化异常处理</span><br><span class="line">第23章 终止处理程序</span><br><span class="line">第24章 异常处理程序与软件异常</span><br><span class="line">24.1 通过实例理解异常过滤程序和异常处理程序</span><br><span class="line">24.1.1 Funcmeister1函数</span><br><span class="line">24.1.2 Funcmeister2函数</span><br><span class="line">24.2 EXCEPTION_EXECUTE_HANDLER1</span><br><span class="line">24.2.1 一些有用的例子</span><br><span class="line">24.2.2 全局展开</span><br><span class="line">24.2.3 停止全局展开</span><br><span class="line">24.3 EXCEPTION_CONTINUE_EXECUTION</span><br><span class="line">24.4 EXCEPTION_CONTINUE_SEARCH0</span><br><span class="line">24.5 GetExceptionCode2</span><br><span class="line">24.6 GetExceptionInformation6</span><br><span class="line">24.7 软件异常</span><br><span class="line">第25章 未处理异常、向量化异常处理与C++异常</span><br><span class="line">25.1 Unhandled Exception Filter函数详解</span><br><span class="line">25.2 即时调试</span><br><span class="line">25.3 电子表格示例程序</span><br><span class="line">25.4 向量化异常和继续处理程序</span><br><span class="line">25.5 C++异常与结构化异常的比较</span><br><span class="line">25.6 异常与调试器</span><br><span class="line">第26章 错误报告与应用程序恢复</span><br><span class="line">26.1 Windows错误报告控制台</span><br><span class="line">26.2 可编程的Windows错误报告</span><br><span class="line">26.3 对进程中所有的问题报告进行定制</span><br><span class="line">26.4 问题报告的创建与定制</span><br><span class="line">26.4.1 创建一个自定义的问题报告</span><br><span class="line">26.4.2 设置报告参数：Wer Report Set Parameter</span><br><span class="line">26.4.3 将小型转储文件放入报告：Wer Report Add Dump 8</span><br><span class="line">26.4.4 将任意文件放入报告：Wer Report AddFile 9</span><br><span class="line">26.4.5 修改对话框文本：Wer Report Set UI Option</span><br><span class="line">26.4.6 提交错误报告：Wer Report Submit</span><br><span class="line">26.4.7 关闭问题报告：Wer Report Close Handle</span><br><span class="line">26.4.8 Customized WER示例程序</span><br><span class="line">26.5 应用程序的自动重启与恢复</span><br><span class="line">26.5.1 应用程序的自动重启</span><br><span class="line">26.5.2 对应用程序恢复的支持</span><br><span class="line">第Ⅵ部分</span><br><span class="line">附录A 构建环境</span><br><span class="line">附录B 消息处理宏、子控件宏和API宏</span><br><span class="line">索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001GS7918/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001GS7918&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51y1A9kbbBL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>写给大家看的设计书(第3版)</title>
    <url>/2020/04/19/B001MV7CXY/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 写给大家看的设计书(第3版)<br>作者信息： 作者: 威廉姆斯 (Robin Williams) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《写给大家看的设计书(第3版)》编辑推荐：通过《写给大家看的设计书(第3版)》，普通读者很快就能够自信地设计出专业级别的作品，而专业设计师也将从中获得灵感和解决问题的途径。有大师指导，人人都能成为设计师！优秀设计就这么简单：C.R.A.P四条基本原则，生动幽默，图文并茂，让你手不释卷、欲罢不能。在《写给大家看的设计书(第3版)》这部畅销全球多年、影响了一代设计师的经典著作中，Robjn Williams将优秀设计的秘诀归纳为对比、重复、对齐和亲密性四条基本原则，并用简洁通俗、幽默生动的文笔，同时配以大量经过修改进行前后对比的实例图解和设计练习（并提供解答），直观而清晰地传授给读者。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分 设计原则</span><br><span class="line">1 约书亚树</span><br><span class="line">4 大基本原则 </span><br><span class="line"></span><br><span class="line"> 2 亲密性 亲密性小结 根本目的 如何实现 要避免的问题</span><br><span class="line"></span><br><span class="line"> 3 对齐 对齐小结 根本目的 如何实现 要避免的问题</span><br><span class="line"></span><br><span class="line"> 4 重复 重复小结 根本目的 如何实现 要避免的问题</span><br><span class="line"></span><br><span class="line"> 5 对比 对比小结 根本目的 如何实现 要避免的问题</span><br><span class="line"></span><br><span class="line"> 6 复习 亲密性 对齐 重复 对比 小测验#1:设计原则 小测验#2:重新设计广告 小结</span><br><span class="line"></span><br><span class="line"> 7 颜色运用 不同凡响的色轮 颜色关系 互补 三色组 分裂互补三色组 类似色 暗色和亮色 建立你自己的暗色和亮色 单色 暗色和亮色的组合 注意色质 暖色与冷色 如何取舍 CMYK与RGB，印刷与Web</span><br><span class="line"></span><br><span class="line"> 8 更多提示与技巧 创建包装 企业名片 关于设计企业名片的提示 格式 字体大小 创建名片、信笺和信封共有的一致图像 信笺和信封 关于设计信笺和信封的提示 信封规格 创建中心点 对齐 第二页 传真和复印 传单 关于设计传单的提示 创建一个中心点 使用有对比的子标题 重复 对齐 新闻简报 关于设计新闻简报的提示 对齐 段落缩进 不要使用Helvetica 正文应当可读 宣传册 关于设计宣传册的提示 对比 重复 对齐 亲密性 明信片 关于设计明信片的提示 关键是什么 吸引人注意 对比 报纸广告 关于设计报纸广告的提示 对比 字体选择 反色文字 网站 关于设计网页的提示 重复 可读性</span><br><span class="line"></span><br><span class="line"> 第二部分 字体设计 9 字体(与人生) 协调 冲突 对比 小结</span><br><span class="line"></span><br><span class="line"> 10 字体类别 Oldstyle Modern Slabserif Sansserif Script 有意识地去做 小测验#3:字体类别 小测验#4:粗&#x2F;细过渡 小测验#5:截线 小结</span><br><span class="line"></span><br><span class="line"> 11 字体对比 大小 粗细 结构 形状 方向 颜色 结合多种对比 小结 小测验#6:对比还是冲突 小测验#7:可做与不可做 结合多种对比的练习</span><br><span class="line"></span><br><span class="line"> 第三部分 其他 12 你掌握了吗 过程 练习 好的——重新设计!</span><br><span class="line"></span><br><span class="line"> 13 测验答案 14 本书所用字体 附录 OpenType 迷你术语表 资源 索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001MV7CXY/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001MV7CXY&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41X7iEreSTL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title>Ruby on Rails Web开发之旅</title>
    <url>/2020/04/19/B001LNNG10/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Ruby on Rails Web开发之旅<br>作者信息： 作者: Patrick Lenz [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>阅读《Ruby on Rails Web开发之旅》可获得以下知识和技能：·Ruby的基本概念：·Rails1.2的新特性：·最实用的MVC结构体系：·建立并布署完整的Rails Web应用：·使用Rails的AJAX特性创建灵活的界面；·使用ActiveRecord操作数据库；·自动测试代码：·使用插件增强应用程序的功能。Patrick Lenz从事web应用开发已经10年了，他是freshmeat.net软件门户网站的创始人和首席开发者。他的Ralls咨询机构和应用开发公司limitedoverload主要负责eins.de公司的重新开张，eins.de是目前欧洲最流行Ruby on Rails网站。Sitepoint－SitePoint是全球著名的web开发与设计类图书出版商。出版高品质专业畅销书。通过互动、开源、全方位的网站配套服务，SitePoinl让每本畅销书都成为一个互动的阅读和代码交流的虚拟社区。2007年,SitePoint网站被美国sBizMBA评为全球“最受欢迎的电子商务网站”第3名；2008年，SitePoint荣登hitwise com澳大利亚计算机与Internet类网站排行榜榜首。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章　Ruby on Rails简介　1</span><br><span class="line">1.1　历史　3</span><br><span class="line">1.2　开发原则　4</span><br><span class="line">1.2.1　惯例优先　4</span><br><span class="line">1.2.2　不重复自我　5</span><br><span class="line">1.2.3　灵活的开发　6</span><br><span class="line">1.3　构建Web应用程序示例　7</span><br><span class="line">1.3.1　digg简介　7</span><br><span class="line">1.3.2　应用程序示例的特性　8</span><br><span class="line">1.4　小结　9 </span><br><span class="line"></span><br><span class="line"> 第2章　技术准备　11 2.1　所需软件的成本　12 2.2　在Windows系统上安装Ruby on Rails　12 2.3　在Mac OS X系统上安装Ruby on Rails　14 2.3.1　Mac OS X 10.5(Leopard)　14 2.3.2　Mac OS X 10.4(Tiger)和更早的版本　15 2.4　在Linux系统上安装Ruby on Rails　22 2.4.1　使用包管理器　22 2.4.2　先决条件　22 2.4.3　在Linux上安装Ruby　23 2.4.4　在Linux上安装RubyGems　24 2.4.5　在Linux上安装Rails　25 2.4.6　在Linux上安装MySQL　26 2.5　建立基础　28 2.5.1　管理所有内容的单目录结构　28 2.5.2　创建标准目录结构　29 2.6　开始编写应用程序　30 2.7　选择文本编辑器　32 2.7.1　Windows文本编辑器　32 2.7.2　Mac OS X文本编辑器　33 2.7.3　Linux和交叉平台编辑器　35 2.8　小结　35</span><br><span class="line"></span><br><span class="line"> 第3章　Ruby简介　36 3.1　Ruby是脚本语言　36 3.1.1　编译语言　36 3.1.2　脚本语言　37 3.1.3　较大的性能争议　37 3.2　Ruby是面向对象的语言　37 3.3　读写Ruby代码　40 3.3.1　交互式的Ruby界面(irb)　40 3.3.2　与Ruby对象交互　41 3.3.3　Ruby中的标点　42 3.4　在Ruby中使用面向对象编程　44 3.4.1　类和对象　45 3.4.2　对象层功能　45 3.4.3　类层功能　48 3.4.4　继承　50 3.4.5　返回值　50 3.5　标准输出　51 3.6　Ruby核心类　52 3.6.1　数组　52 3.6.2　散列表　53 3.6.3　字符串　54 3.6.4　数字　55 3.6.5　符号　56 3.6.6　空值　57 3.7　运行Ruby文件　57 3.8　控制结构　58 3.8.1　条件　59 3.8.2　循环　61 3.8.3　块　62 3.9　小结　64</span><br><span class="line"></span><br><span class="line"> 第4章　Rails揭秘　65 4.1　3种环境　65 4.2　数据库配置　66 4.2.1　数据库配置文件　66 4.2.2　创建数据库　67 4.3　MVC体系结构　69 4.3.1　MVC理论　69 4.3.2　MVC的Rails方式　70 4.3.3　ActiveRecord(模型)　71 4.3.4　ActionPack模块　74 4.4　代码生成　77 4.5　ActionMailer　78 4.6　测试和调试　79 4.6.1　测试　79 4.6.2　调试　80 4.7　MySQL的图形用户接口工具　80 4.8　小结　82</span><br><span class="line"></span><br><span class="line"> 第5章　模型、视图和控制器　84 5.1　创建模型　84 5.1.1　模型生成器　84 5.1.2　使用移植修改模式　87 5.1.3　使用Rails控制台管理数据　91 5.1.4　隐藏的SQL语句　94 5.2　生成控制器　95 5.2.1　运行generate脚本　95 5.2.2　输出结果分析　96 5.2.3　返回应用程序　97 5.3　创建视图　98 5.3.1　用支架生成视图　99 5.3.2　创建静态页面　100 5.3.3　创建动态页面　100 5.3.4　反复传递数据　101 5.3.5　引入模型　102 5.4　小结　103</span><br><span class="line"></span><br><span class="line"> 第6章　助手、窗体和布局　104 6.1　可信任助手　104 6.2　故事提交　105 6.2.1　创建窗体　105 6.2.2　保存数据到数据库中　109 6.2.3　创建布局　110 6.2.4　用户反馈和闪存　112 6.3　测试窗体　117 6.3.1　测试模型　117 6.3.2　测试控制器　121 6.3.3　再次访问日志　126 6.4　小结　127</span><br><span class="line"></span><br><span class="line"> 第7章　AJAX与Web 2.0　128 7.1　生成投票模型　128 7.1.1　创建模型　128 7.1.2　创建移植　129 7.1.3　执行移植　130 7.2　关系　130 7.2.1　has_many子句　130 7.2.2　belongs_to子句　132 7.2.3　关系框架　133 7.3　简洁URL与Permalink　133 7.3.1　实现简洁URL　134 7.3.2　为故事增加Permalink　135 7.3.3　故事显示　137 7.4　AJAX与Rails　139 7.4.1　AJAX简介　139 7.4.2　使用Prototype调用远程脚本　140 7.4.3　使用script.aculo.us完成视觉效果　140 7.4.4　“推选”故事　142 7.5　Partial简介　149 7.5.1　添加投票历史记录　150 7.5.2　创建partial　151 7.5.3　投票历史记录样式　151 7.5.4　处理投票历史记录　153 7.6　测试投票功能　154 7.6.1　测试模型　154 7.6.2　测试控制器　158 7.6.3　运行完整测试体系　161 7.7　小结　162</span><br><span class="line"></span><br><span class="line"> 第8章　安全措施　163 8.1　session和cookie　163 8.1.1　单一用户认证　163 8.1.2　cookie　164 8.1.3　session　165 8.1.4　Rails中的session　165 8.2　User模型　167 8.2.1　生成User模型　167 8.2.2　为User类添加关系　168 8.2.3　创建User　169 8.3　登录功能　170 8.3.1　创建控制器　170 8.3.2　创建视图　170 8.3.3　增加控制器功能　172 8.4　过滤器　174 8.4.1　before过滤器　174 8.4.2　after过滤器　174 8.4.3　around过滤器　175 8.4.4　关于过滤方法　175 8.5　用户登录管理　176 8.5.1　检索当前用户　176 8.5.2　显示当前用户姓名　177 8.5.3　允许用户退出　179 8.6　添加导航菜单　180 8.7　限制应用　182 8.7.1　保护表单　182 8.7.2　限制访问故事提交　184 8.7.3　建立故事和用户的关联　185 8.8　测试用户验证　186 8.8.1　测试模型　187 8.8.2　测试控制器　190 8.9　小结　198</span><br><span class="line"></span><br><span class="line"> 第9章　高级话题　199 9.1　受欢迎故事晋级　199 9.1.1　使用计数器缓存　199 9.1.2　完成首页　202 9.1.3　实现投票箱　205 9.1.4　抽象表示逻辑　206 9.1.5　请求用户登录来投票　209 9.1.6　添加故事属性　211 9.2　自动生成Permalinks　212 9.2.1　模型回调　213 9.2.2　添加回调　214 9.3　扩展提交窗体　215 9.4　添加用户页面　217 9.4.1　join模型关系　217 9.4.2　has_many:through关联　217 9.4.3　修改控制器　218 9.4.4　建立视图　219 9.5　测试新功能　220 9.5.1　测试模型　221 9.5.2　测试StoryController　224 9.5.3　测试AccountController　228 9.5.4　运行完整的测试包　228 9.6　小结　229</span><br><span class="line"></span><br><span class="line"> 第10章　Rails插件　231 10.1　插件简介　231 10.2　为Shovell添加标签　232 10.2.1　acts_as_taggable插件　233 10.2.2　实现标签提交　238 10.2.3　标签显示　239 10.2.4　创建标签　241 10.2.5　根据标签显示故事　242 10.3　测试标签功能　243 10.3.1　测试模型　243 10.3.2　测试控制器　245 10.3.3　运行测试体系　247 10.4　小结　248</span><br><span class="line"></span><br><span class="line"> 第11章　调试、测试和基准测试　249 11.1　调试应用程序　249 11.1.1　模板内调试　250 11.1.2　使用断点进行测试　254 11.1.3　使用Rails日志工具　258 11.1.4　克服调试中的问题　260 11.2　测试应用程序　260 11.2.1　集成测试　260 11.2.2　使用断点　262 11.2.3　Rails控制台　264 11.3　应用程序基准测试　266 11.3.1　从日志文件中取出基准　266 11.3.2　手动基准测试　268 11.4　小结　270</span><br><span class="line"></span><br><span class="line"> 第12章　部署和产品使用　271 12.1　“产品”的含义　271 12.2　选择产品环境　272 12.2.1　Web服务器选项　273 12.2.2　后台选项　274 12.3　部署Shovell　275 12.4　session存储的选择　283 12.4.1　ActiveRecord存储会话容器　283 12.4.2　MemCached存储会话容器　284 12.5　知识拓展　284 12.5.1　缓存　284 12.5.2　版本控制与部署管理　285 12.5.3　E-mail错误通知　285 12.6　小结　286</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001LNNG10/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001LNNG10&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51B3Rnzs3GL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>ruby</tag>
      </tags>
  </entry>
  <entry>
    <title>Ruby从入门到精通</title>
    <url>/2020/04/19/B001UQN6R2/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Ruby从入门到精通<br>作者信息： 作者: Peter cooper [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Ruby从入门到精通》：Ruby和Rails技术系列</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">译者序</span><br><span class="line">序言</span><br><span class="line">前言</span><br><span class="line">致谢</span><br><span class="line">第一篇 基础与脚手架</span><br><span class="line">第1章 让它跑起来：安装Ruby</span><br><span class="line">1.1 安装Ruby</span><br><span class="line">1.1.1 Windows平台</span><br><span class="line">1.1.2.AppleMacOSX平台</span><br><span class="line">1.1.3 Linux平台</span><br><span class="line">1.1.4 其他平台</span><br><span class="line">1.2 小结 </span><br><span class="line"></span><br><span class="line"> 第2章 编程等于快乐：Ruby和面向对象概览 2.1 初始步骤 2.1.1 irb：交互式Ruby 2.1.2 Ruby是计算机的通用语._ 2.1.3 为什么Ruby是如此杰出的编程语言 2.1.4 心灵小径 2.2 把思路转变成Ruby代码 2.2.1 Ruby怎么理解对象和类的概念 2.2.2 造人过程 2.2.3 基础变量 2.2.4 从人到宠物 2.3 一切都是对象 2.3.1 Kernel模块的方法 2.3.2 向方法传递数据 2.3.3 使用String类的方法 2.4 以非面向对象方式使用Ruby 2.5 小结</span><br><span class="line"></span><br><span class="line"> 第3章 Ruby的构造元素：数据、表达式和流程控制 3.1 数字与表达式 3.1.1 表达式基础知识 3.1.2 变量 3.1.3 比较运算符与表达式 3.1.4 用块和迭代子在数字中循环 3.1.5 浮点数 3.1.6 常量 3.2 文本与字符串 3.2.1 字面字符串 3.2.2 字符串表达式 3.2.3 插写 3.2.4 字符串方法 3.2.5 正则表达式与字符串操作 3.3 数组与列表 3.3.1 基本数组 3.3.2 字符串切分成数组 3.3.3 数组迭代 3.3.4 数组的其他方法 3.4 散列表 3.4.1 散列表的基础方法 3.4.2 散列表中的散列表 3.5 流程控制 3.5.1 if与unless 3.5.2 三元运算符 3.5.3 elsif与case 3.5.4 while与until 3.5.5 代码块 3.6 其他有用的构造元素 3.6.1 日期与时间 3.6.2 大数字 3.6.3 范围 3.6.4 符号 3.6.5 类间转换 3.7 小结</span><br><span class="line"></span><br><span class="line"> 第4章 开发基础的Ruby应用程序 4.1 处理源代码文件 4.1.1 创建测试文件 4.1.2 测试用源代码文件 4.1 _3运行源代码 4.2 我们的目标程序：文本分析器 4.2.1 基本功能需求 4.2.2 构建程序基本框架 4.2.3 获取哑文本 4.2.4 载入文本文件并统计行数 4.2.5 统计字符数 4.2.6 统计字数 4.2.7 统计句子和段落数 4.2.8 计算平均值 4.2.9 到目前为止的源代码 4.3 增加额外功能 4.3.1 “有用”字词的百分比 4.3.2 找出“有趣的”句子进行汇总 4.3.3 分析text.txt之外的其他文件 4.4 完整的程序 4.5 小结</span><br><span class="line"></span><br><span class="line"> 第5章 Ruby生态系统 5.1 Ruby的历史 5.1.1 Ruby的起源 5.1.2 Ruby的影响 5.1.3 向西方流传 5.2 RubyOnRails 5.2.1 Rails面世的由来 5.2.2 Web（2.0）是怎样赢的 5.3 开源文化 5.4 如何获得帮助 5.4.1 邮件列表 5.4.2 Usenet新闻组 5.4.3 因特网中继聊天工具 5.4.4 文档 5.4.5 论坛 5.5 加入社区 5.5.1 向别人提供帮助 5.5.2 贡献代码 5.5.3 网络博客 5.6 小结</span><br><span class="line"></span><br><span class="line"> 第二篇 Ruby的核心 第6章 类、对象和模块 6.1 为什么要用面向对象 6.2 面向对象基础知识 6.2.1 局部变量、全局变量、对象变量和类变量 6.2.2 类方法和对象方法 6.2.3 继承 6.2.4 覆写现有方法 6.2.5 对象方法的反射与发现 6.2.6 封装 6.2.7 多态 6.2.8 嵌套类 6.2.9 常量的作用域 6.3 模块、命名空间和掺入 6.3.1 命名空间 6.3.2 掺入 6.4 用对象构建“地下城”文本冒险游戏 6.4.1 地下城的概念 6.4.2 创建初始类 6.4.3 Structs：快捷简单的数据类 6.4.4 创建房间 6.4.5 让地下城运转起来 6.5 小结</span><br><span class="line"></span><br><span class="line"> 第7章 项目与程序库 7.1 项目和使用其他文件的代码 7.1.1 基本的文件包含 7.1.2 从其他目录包含 7.1.3 有条件地包含代码 7.1.4 嵌套包含 7.2 程序库 7.2.1 标准程序库 7.2.2 RubyGems包 7.3 小结</span><br><span class="line"></span><br><span class="line"> 第8章 文档编写、错误处理、调试和测试 8.1 文档编写 8.1.1 用RDoe生成文档 8.1.2 RDoc技术 8.2 调试与出错 8.2.1 异常和出错处理 8.2.2 Catch与Throw方法 8.2.3 Ruby调试器 8.3 测试 8.3.1 测试驱动开发的哲学 8.3.2 单元测试 8.3.3 更多的Test：Unit断言 8.4 性能基准度量和优化分析 8.4.1 性能基准简单度量 8.4.2 性能优化分析 8.5 小结</span><br><span class="line"></span><br><span class="line"> 第9章 文件和数据库 9.1 输入与输出 9.1.1 键盘输入 9.1.2 文件输入输出 9.2 数据库基础 9.2.1 文本文件数据库 9.2.2 对象和数据结构的存储 9.3 关系型数据库与SQL 9.3.1 关系型数据库概念 9.3.2 四大数据库：MySQL、PostgreSQL、Oracle和SQLite 9.3.3 安装SQLite 9.3.4 关于数据库基本操作和SQL的紧急教程 9.3.5 在Ruby中使用SQt。ite 9.3.6 连接其他数据库系统 9.3.7 ActiveRecord简介 9.4 小结</span><br><span class="line"></span><br><span class="line"> 第10章 部署Ruby应用和程序库 10.1 简单Ruby程序发布 10.1.1 shebang行 10.1.2 关联Windows的文件类型 10.1.3 “编译”Ruby程序 10.2 检测Ruby运行环境 10.2.1 用RUBY-PLATFORM作简单的操作系统检测 10.2.2 环境变量 10.2.3 读取命令行参数 10.3 以gem包形式发布Ruby程序库 10.3.1 创建gem包 10.3.2 发布gem包 10.3.3 RubyForge网站 10.4 以远程服务形式部署Ruby应用 10.4.1 CGI脚本 10.4.2 常见HTTP服务器 10.4.3 远程方法调用 10.5 小结</span><br><span class="line"></span><br><span class="line"> 第11章 Ruby高级功能 11.1 动态代码执行 11.1.1 绑定 11.1.2 eval的其他形式 11.1.3 创建attr-accessor 11.2 从Ruby中运行其他程序 11.2.1 获得其他程序的运行结果 11.2.2 向其他程序移交执行权 11.2.3 同时运行两个程序 11.2.4 与另一程序交互 11.3 安全地掌控数据和危险方法 11.3.1 被感染的数据和对象 ll.3.2 安全级别 11.4 使用微软Windows 11.4.1 使用Windows.API 11.4.2 控制Windows程序 11.5 线程 11.5.1 基础Ruby线程实战 11.5.2 高级线程操作 11.6 其他语言嵌入Ruby 11.6.1 为什么用c作为嵌入语言 11.6.2 创建基础方法或函数 11.6.3 性能基准度量：C和Ruby 11.7 对Unicodc和UTF-8的支持 11.8 小结</span><br><span class="line"></span><br><span class="line"> 第12章 综合演练：开发更大型的Ruby应用 12.1 构建机器人小程序 12.1.1 什么是机器人小程序 12.1.2 为什么要构建机器人小程序 12.1.3 怎样构建 12.2 创建文本处理工具程序库 12.2.1 构建WordPlay程序库 12.2.2 测试该程序库 12.2.3 WordPlay程序库的源代码 12.3 构建机器人小程序的核心功能 12.3.1 程序的生命周期和组成部分 12.3.2 机器人小程序的数据 12.3.3 构建Bot类和数据载入器 12.3.4 response_to方法 12.3.5 试用机器人小程序 12.4 机器人小程序主要代码清单 12.4.1 bot.rb文件 12.4.2 basic-client.rb文件 12.5 扩展机器人小程序的功能 12.5.1 用文本文件作为会话来源 12.5.2 把机器人小程序连接到万维网 12.5.3 机器人小程序之间的会话 12.6 小结</span><br><span class="line"></span><br><span class="line"> 第三篇 Ruby在线 第13章 RubyonRuby:Ruby的杀手级应用 第14章 Ruby与因特网 第15章 网络连接、套接字与后台进程 第16章 有用的Ruby程序库和gem包</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001UQN6R2/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001UQN6R2&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51BXemuxWjL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>ruby</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机科学丛书 Php和Mysql Web开发(原书第4版)</title>
    <url>/2020/04/19/B001TDLD80/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 计算机科学丛书 Php和Mysql Web开发(原书第4版)<br>作者信息： 作者: Luke Welling [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《计算机科学丛书:Php和Mysql Web开发(原书第4版)》为开发人员专业技术丛书。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">读者反馈</span><br><span class="line">译者序</span><br><span class="line">前言</span><br><span class="line">作者简介</span><br><span class="line">第一篇 使用PHP</span><br><span class="line">第1章 PHP快速入门教程</span><br><span class="line">1.1 开始之前：了解PHP </span><br><span class="line">1.2 创建一个示例应用：Bob汽车零部件商店</span><br><span class="line">1.2.1 创建订单表单</span><br><span class="line">1.2.2 表单处理</span><br><span class="line">1.3 在HTML中嵌入PHP</span><br><span class="line">1.3.1 使用PHP标记</span><br><span class="line">1.3.2 PHP语句</span><br><span class="line">1.3.3 空格</span><br><span class="line">1.3.4 注释</span><br><span class="line">1.4 添加动态内容</span><br><span class="line">1.4.1 调用函数</span><br><span class="line">1.4.2 使用date()函数</span><br><span class="line">1.5 访问表单变量</span><br><span class="line">1.5.1 简短、中等以及长风格的表单变量</span><br><span class="line">1.5.2 字符串的连接</span><br><span class="line">1.5.3 变量和文本</span><br><span class="line">1.6 理解标识符</span><br><span class="line">1.7 检查变量类型</span><br><span class="line">1.7.1 PHP的数据类型</span><br><span class="line">1.7.2 类型强度</span><br><span class="line">1.7.3 类型转换</span><br><span class="line">1.7.4 可变变量</span><br><span class="line">1.8 声明和使用常量</span><br><span class="line">1.9 理解变量的作用域</span><br><span class="line">1.10 使用操作符</span><br><span class="line">1.10.1 算术操作符</span><br><span class="line">1.10.2 字符串操作符</span><br><span class="line">1.10.3 赋值操作符</span><br><span class="line">1.10.4 比较操作符</span><br><span class="line">1.10.5 逻辑操作符</span><br><span class="line">1.10.6 位操作符</span><br><span class="line">1.10.7 其他操作符</span><br><span class="line">1.11  计算表单总金额</span><br><span class="line">1.12  理解操作符的优先级和结合性：</span><br><span class="line">1.13 使用可变函数</span><br><span class="line">1.13.1 测试和设置变量类型</span><br><span class="line">1.13.2 测试变量状态</span><br><span class="line">1.13.3 变量的重解释</span><br><span class="line">1.14 根据条件进行决策</span><br><span class="line">1.14.1 if语句</span><br><span class="line">1.14.2 代码块</span><br><span class="line">1.14.3 else语句</span><br><span class="line">1.14.4 elseif语句</span><br><span class="line">1.14.5 switch语句</span><br><span class="line">1.14.6 比较不同的条件</span><br><span class="line">1.15 通过迭代实现重复动作</span><br><span class="line">1.15.1 while循环</span><br><span class="line">1.15.2 for和foreach循环</span><br><span class="line">1.15.3 do…while循环</span><br><span class="line">1.16 从控制结构或脚本中跳出</span><br><span class="line">1.17 使用可替换的控制结构语法</span><br><span class="line">1.18 使用declare</span><br><span class="line">1.19 下一章 </span><br><span class="line"></span><br><span class="line"> 第2章 数据的存储与检索 2.1 保存数据以便后期使用 2.2 存储和检索Bob的订单 2.3 文件处理 2.4 打开文件 2.4.1 选择文件模式 2.4.2 使用fopen()打开文件 2.4.3 通过FTP或HTTP打开文件 2.4.4 解决打开文件时可能遇到的问题 2.5 写文件 2.5.1 fwrite()的参数 2.5.2 文件格式 2.6 关闭文件 2.7 读文件 2.7.1 以只读模式打开文件：fopen() 2.7.2 知道何时读完文件：feof() 2.7.3 每次读取一行数据：fgets()、fgetss()和fgetcsv() 2.7.4 读取整个文件：readfile()、fpassthru()和file() 2.7.5 读取一个字符：fgetc() 2.7.6 读取任意长度：fread() 2.8 使用其他有用的文件函数 2.8.1 查看文件是否存在：file_exists() 2.8.2 确定文件大小：filesize() 2.8.3 删除一个文件：unlink() 2.8.4 在文件中定位：rewind()、fseek()和ftell() 2.9 文件锁定 2.10 更好的方式：数据库管理系统 2.10.1 使用普通文件的几个问题 2.10.2 RDBMS是如何解决这些问题的 2.11 进一步学习 2.12 下一章</span><br><span class="line"></span><br><span class="line"> 第3章 使用数组 3.1 什么是数组 3.2 数字索引数组 3.2.1 数字索引数组的初始化 3.2.2 访问数组的内容 3.2.3 使用循环访问数组 3.3 使用不同索引的数组 3.3.1 初始化相关数组 3.3.2 访问数组元素 3.3.3 使用循环语句 3.4 数组操作符 3.5 多维数组 3.6 数组排序 3.6.1 使用sort()函数 3.6.2 使用asort()函数和ksort()函数对相关数组排序 3.6.3 反向排序 3.7 多维数组的排序 3.7.1 用户定义排序 3.7.2 反向用户排序 3.8 对数组进行重新排序 3.8.1 使用shuffle()函数 3.8.2 使用array_reverse()函数 3.9 从文件载入数组 3.10 执行其他的数组操作 3.10.1 在数组中浏览：each()、current()、reset()、end()、next()、pos()和prev() 3.10.2 对数组的每一个元素应用任何函数：array_walk() 3.10.3 统计数组元素个数：count()、sizeof()和array_count_values() 3.10.4 将数组转换成标量变量：extract() 3.11 进一步学习 3.12 下一章</span><br><span class="line"></span><br><span class="line"> 第4章 字符串操作与正则表达式 4.1 创建一个示例应用程序：智能表单邮件 4.2 字符串的格式化 4.2.1 字符串的整理：chop()、ltrim()和trim() 4.2.2 格式化字符串以便显示 4.2.3 格式化字符串以便存储：addslashes()和stripslashes() 4.3 用字符串函数连接和分割字符串 4.3.1 使用函数explode()、implode()和join() 4.3.2 使用strtok()函数 4.3.3 使用substr()函数 4.4 字符串的比较 4.4.1 字符串的排序：strcmp()、strcasecmp()和strnatcmp() 4.4.2 使用strlen()函数测试字符串的长度 4.5 使用字符串函数匹配和替换子字符串 4.5.1 在字符串中查找字符串：strstr()、strchr()、strrchr()和stristr() 4.5.2 查找子字符串的位置：strpos()、strrpos() 4.5.3 替换子字符串：str_replace()、substr_replace() 4.6 正则表达式的介绍 4.6.1 基础知识 4.6.2 字符集和类 4.6.3 重复 4.6.4 子表达式 4.6.5 子表达式计数 4.6.6 定位到字符串的开始或末尾 4.6.7 分支 4.6.8 匹配特殊字符 4.6.9 特殊字符一览 4.6.10 在智能表单中应用 4.7 用正则表达式查找子字符串 4.8 使用正则表达式分割字符串 4.9 比较字符串函数和正则表达式函数 4.10 进一步学习 4.11 下一章</span><br><span class="line"></span><br><span class="line"> 第5章 代码重用与函数编写 5.1 代码重用的好处 5.1.1 成本 5.1.2 可靠性 5.1.3 一致性 5.2 使用require()和include()函数 5.2.1 文件扩展名和require()语句 5.2.2 使用require()制作Web站点的模版 5.2.3 使用auto_prepend_file和auto_append_file 5.3 在PHP中使用函数 5.3.1 调用函数 5.3.2 调用未定义的函数 5.3.3 理解字母大小写和函数名称 5.4 理解为什么要定义自己的函数 5.5 了解基本的函数结构 5.5.1 函数命名 5.6 使用参数 5.7 理解作用域 5.8 参数的引用传递和值传递 5.9 使用Return关键字 5.9.1 从函数返回一个值 5.10 实现递归 5.10.1 名称空间 5.11 进一步学习 5.12 下一章</span><br><span class="line"></span><br><span class="line"> 第6章 面向对象的PHP 6.1 理解面向对象的概念 6.1.1 类和对象 6.1.2 多态性 6.1.3 继承 6.2 在PHP中创建类、属性和操作 6.2.1 类的结构 6.2.2 构造函数 6.2.3 析构函数 6.3 类的实例化 6.4 使用类的属性 6.5 使用private和public关键字控制访问 6.6 类操作的调用 6.7 在PHP中实现继承 6.7.1 通过继承使用private和protected访问修饰符控制可见性 6.7.2 重载 6.7.3 使用final关键字禁止继承和重载 6.7.4 理解多重继承 6.7.5 实现接口 6.8 类的设计 6.9 编写类代码 6.10 理解PHP面向对象新的高级功能 6.10.1 使用Per-Class常量 6.10.2 实现静态方法 6.10.3 检查类的类型和类型提示 6.10.4 克隆对象 6.10.5 使用抽象类 6.10.6 使用call()重载方法 6.10.7 使用autoload()方法 6.10.8 实现迭代器和迭代 6.10.9 将类转换成字符串 6.10.10 使用Reflection（反射）API 6.11 下一章</span><br><span class="line"></span><br><span class="line"> 第7章 错误和 异常处理 7.1 异常处理的概念 7.2 Exception类 7.3 用户自定义异常 7.4 Bob的汽车零部件商店应用程序的异常 7.5 异常和PHP的其他错误处理机制 7.6 进一步学习 7.7 下一章</span><br><span class="line"></span><br><span class="line"> 第二篇 使用MySQL 第8章 设计Web数据库 8.1 关系数据库的概念 8.1.1 表格 8.1.2 列 8.1.3 行 8.1.4 值 8.1.5 键 8.1.6 模式 8.1.7 关系 8.2 如何设计Web数据库 8.2.1 考虑要建模的实际对象 8.2.2 避免保存冗余数据 8.2.3 使用原子列值 8.2.4 选择有意义的键 8.2.5 考虑需要询问数据库的问题 8.2.6 避免多个空属性的设计 8.2.7 表格类型的总结 8.3 Web数据库架构 8.4 进一步学习 8.5 下一章</span><br><span class="line"></span><br><span class="line"> 第9章 创建Web数据库 9.1 使用MySQL监视程序 9.2 登录到MySQL 9.3 创建数据库和用户 9.4 设置用户与权限 9.5 MySQL权限系统的介绍 9.5.1 最少权限原则 9.5.2 创建用户：GRANT命令 9.5.3 权限的类型和级别 9.5.4 REVOKE命令 9.5.5 使用GRANT和REVOKE的例子 9.6 创建一个Web用户 9.7 使用正确的数据库 9.8 创建数据库表 9.8.1 理解其他关键字的意思 9.8.2 理解列的类型 9.8.3 用SHOW和DESCRIBE来查看数据库 9.8.4 创建索引 9.9 理解MySQL的标识符 9.10 选择列数据类型 9.10.1 数字类型 9.10.2 日期和时间类型 9.10.3 字符串类型 9.11 进一步学习 9.12 下一章</span><br><span class="line"></span><br><span class="line"> 第10章 使用MySQL数据库 10.1 SQL是什么 10.2 在数据库中插入数据 10.3 从数据库中获取数据 10.3.1 获取满足特定条件的数据 10.3.2 从多个表中获取数据 10.3.3 以特定的顺序获取数据 10.3.4 分组与合计数据 10.3.5 选择要返回的行 10.3.6 使用子查询 10.4 更新数据库记录 10.5 创建后修改表 10.6 删除数据库中的记录 10.7 表的删除 10.8 删除整个数据库 10.9 进一步学习 10.10 下一章</span><br><span class="line"></span><br><span class="line"> 第11章 使用PHP从Web访问MySQL数据库 11.1 Web数据库架构的工作原理 11.2 从Web查询数据库的基本步骤 11.2.1 检查与过滤用户输入数据 11.2.2 建立一个连接 11.2.3 选择使用的数据库 11.2.4 查询数据库 11.2.5 检索查询结果 11.2.6 从数据库断开连接 11.3 将新信息放入数据库 11.4 使用Prepared语句 11.5 使用PHP与数据库交互的其他接口 11.5.1 使用常规的数据库接口：PEAR MDB2 11.6 进一步学习 11.7 下一章</span><br><span class="line"></span><br><span class="line"> 第12章 MySQL高级管理 12.1 深入理解权限系统 12.1.1 user表 12.1.2 db表和host表 12.1.3 tables_priv表，columns_priv表和procs_priv表 12.1.4 访问控制：MySQL如何使用Grant表 12.1.5 更新权限：修改什么时候生效 12.2 提高MySQL数据库的安全性 12.2.1 从操作系统角度来保护MySQL 12.2.2 密码 12.2.3 用户权限 12.2.4 Web问题 12.3 获取更多关于数据库的信息 12.3.1 使用SHOW获取信息 12.3.2 使用DESCRIBE获取关于列的信息 12.3.3 用EXPLAIN理解查询操作的工作过程 12.4 数据库的优化 12.4.1 设计优化 12.4.2 权限 12.4.3 表的优化 12.4.4 使用索引 12.4.5 使用默认值 12.4.6 其他技巧 12.5 备份MySQL数据库 12.6 恢复MySQL数据库 12.7 实现复制 12.7.1 设置主服务器 12.7.2 执行初始的数据传输 12.7.3 设置一个&#x2F;多个从服务器 12.8 进一步学习 12.9 下一章</span><br><span class="line"></span><br><span class="line"> 第13章 MySQL高级编程 13.1 LOAD DATA INFILE语句 13.2 存储引擎 13.3 事务 13.3.1 理解事务的定义 13.3.2 通过InnoDB使用事务 13.4 外键 13.5 存储过程 13.5.1 基本示例 13.5.2 局部变量 13.5.3 游标和控制结构 13.6 进一步学习 13.7 下一章</span><br><span class="line"></span><br><span class="line"> 第三篇 电子商务与安全性 第14章 运营一个电子商务网站 14.1 我们要实现什么目标 14.2 考虑电子商务网站的类型 14.2.1 使用在线说明书公布信息 14.2.2 接收产品或服务的订单 14.2.3 提供服务和数字产品 14.2.4 为产品或服务增值 14.2.5 减少成本 14.3 理解风险和威胁 14.3.1 网络黑客 14.3.2 不能招揽足够的生意 14.3.3 计算机硬件故障 14.3.4 电力、通信、网络或运输故障 14.3.5 广泛的竞争 14.3.6 软件错误 14.3.7 不断变化的政府政策和税收 14.3.8 系统容量限制 14.4 选择一个策略 14.5 下一章</span><br><span class="line"></span><br><span class="line"> 第15章 电子商务的安全问题 15.1 信息的重要程度 15.2 安全威胁 15.2.1 机密数据的泄露 15.2.2 数据丢失和数据破坏 15.2.3 数据修改 15.2.4 拒绝服务 15.2.5 软件错误 15.2.6 否认 15.3 易用性，性能、成本和安全性 15.4 建立一个安全政策 15.5 身份验证原则 15.6 加密技术基础 15.6.1 私有密钥加密 15.6.2 公有密钥加密 15.6.3 数字签名 15.7 数字证书 15.8 安全的Web服务器 15.9 审计与日志记录 15.10 防火墙 15.11 备份数据 15.11.1 备份常规文件 15.11.2 备份与恢复MySQL数据库 15.12 自然环境安全 15.13 下一章</span><br><span class="line"></span><br><span class="line"> 第16章 Web应用的安全 16.1处理安全性问题的策略 16.1.1 以正确心态为开始 16.1.2 安全性和可用性之间的平衡 16.1.3 安全监视 16.1.4 基本方法 16.2 识别所面临的威胁 16.2.1 访问或修改敏感数据 16.2.2 数据丢失或破坏 16.2.3 拒绝服务 16.2.4 恶意代码注入 16.2.5 服务器被攻破 16.3了解与我们“打交道”的用户 16.3.1 破解人员 16.3.2 受影响机器的未知情用户 16.3.3 对公司不满的员工 16.3.4 硬件被盗 16.3.5 我们自身 16.4 代码的安全性 16.4.1 过滤用户输入 16.4.2 转义输出 16.4.3 代码组织 16.4.4 代码自身的问题 16.4.5 文件系统因素 16.4.6 代码稳定性和缺陷 16.4.7 执行引号和exec 16.5 Web服务器和PHP的安全性 16.5.1 保持软件的更新 16.5.2 查看php.ini文件 16.5.3 Web服务器配置 16.5.4 Web应用的商业主机服务 16.6 数据库服务器的安全性 16.6.1 用户和权限系统 16.6.2发送数据至服务器 16.6.3 连接服务器 16.6.4 运行服务器 16.7 保护网络 16.7.1 安装防火墙 16.7.2使用隔离区域（DMZ） 16.7.3应对DoS和DDoS攻击 16.8 计算机和操作系统的安全性 16.8.1 保持操作系统的更新 16.8.2只运行必须的软件 16.8.3 服务器的物理安全性 16.9 灾难计划 16.10 下一章</span><br><span class="line"></span><br><span class="line"> 第17章 使用PHP和MySQL实现身份验证 17.1 识别访问者 17.2 实现访问控制 17.2.1 保存密码 17.2.2 密码的加密 17.2.3 保护多个网页 17.3 使用基本身份验证 17.4 在PHP中使用基本身份验证 17.5 在Apache的.htaccess文件中使用基本身份验证 17.6 使用mod_auth_mysql身份验证 17.6.1 安装mod_auth_mysql 17.6.2 使用mod_auth_mysql 17.7 创建自定义身份验证 17.8 进一步学习 17.9 下一章</span><br><span class="line"></span><br><span class="line"> 第18章 使用PHP和MySQL实现安全事务 18.1 提供安全的事务处理 18.1.1 用户机器 18.1.2 Internet 18.1.3 我们的系统 18.2 使用加密套接字层（SSL） 18.3 屏蔽用户的输入 18.4 提供安全存储 18.5 存储信用卡号码 18.6 在PHP中使用加密技术 18.6.1 安装GPG 18.6.2 测试GPG 18.7 进一步学习 18.8 下一章</span><br><span class="line"></span><br><span class="line"> 第四篇 PHP的高级技术 第19章 与文件系统和服务器的交互 19.1 文件上载 19.1.1 文件上载的HTML代码 19.1.2 编写处理文件的PHP 19.1.3 避免常见上载问题 19.2 使用目录函数 19.2.1 从目录读取 19.2.2 获得当前目录的信息 19.2.3 创建和删除目录 19.3 与文件系统的交互 19.3.1 获取文件信息 19.3.2 更改文件属性 19.3.3 创建、删除和移动文件 19.4 使用程序执行函数 19.5 与环境变量交互：getenv()和putenv() 19.6 进一步学习 19.7 下一章</span><br><span class="line"></span><br><span class="line"> 第20章 使用网络函数和协议函数 20.1 了解可供使用的协议 20.2 发送和读取电子邮件 20.3 使用其他Web站点的数据 20.4 使用网络查找函数 20.5 备份或镜像一个文件 20.5.1 使用FTP备份或镜像一个文件 20.5.2 上传文件 20.5.3 避免超时 20.5.4 使用其他的FTP函数 20.6 进一步学习 20.7 下一章</span><br><span class="line"></span><br><span class="line"> 第21章 日期和时间的管理 21.1 在PHP中获取日期和时间 21.1.1 使用date()函数 21.1.2 使用UNIX时间戳 21.1.3 使用getdate()函数 21.1.4 使用checkdate()函数检验日期有效性 21.1.5 格式化时间戳 21.2 在PHP日期格式和MySQL日期格式之间进行转换 21.3 在PHP中计算日期 21.4 在MySQL中计算日期 21.5 使用微秒 21.6 使用日历函数 21.7 进一步学习 21.8 下一章</span><br><span class="line"></span><br><span class="line"> 第22章 创建图像 22.1 在PHP中设置图像支持 22.2 理解图像格式 22.2.1 JPEG 22.2.2 PNG 22.2.3 WBMP 22.2.4 GIF 22.3 创建图像 22.3.1 创建一个背景图像 22.3.2 在图像上绘图或打印文本 22.3.3 输出最终图形 22.3.4 清理 22.4 在其他页面中使用自动生成的图像 22.5 使用文本和字体创建图像 22.5.1 创建基本画布 22.5.2 将文本调整到适合按钮 22.5.3 放置文本 22.5.4 将文本写到按钮上 22.5.5 完成 22.6 绘制图像与用图表描绘数据 22.7 使用其他的图像函数 22.8 进一步学习 22.9 下一章</span><br><span class="line"></span><br><span class="line"> 第23章 在PHP中使用会话控制 23.1 什么是会话控制 23.2 理解基本的会话功能 23.2.1 什么是cookie 23.2.2 通过PHP设置cookie 23.2.3 在会话中使用cookie 23.2.4 存储会话 ID 23.3 实现简单的会话 23.3.1 开始一个会话 23.3.2 注册一个会话变量 23.3.3 使用会话变量 23.3.4 注销变量与销毁会话 23.4 创建一个简单的会话例子 23.5 配置会话控制 23.6 通过会话控制实现身份验证 23.7 进一步学习 23.8 下一章</span><br><span class="line"></span><br><span class="line"> 第24章 其他有用的特性 24.1 使用eval()函数对字符串求值 24.2 终止执行：die和exit 24.3 序列化变量和对象 24.4 获取PHP环境信息 24.4.1 找到所加载的PHP扩展部件 24.4.2 识别脚本所有者 24.4.3 确定脚本最近修改时间 24.5 暂时改变运行时环境 24.6 源代码加亮 24.7 在命令行中使用PHP 24.8 下一章</span><br><span class="line"></span><br><span class="line"> 第五篇 创建实用的PHP和MySQL项目 第25章 在大型项目中使用PHP和MySQL 25.1 在Web开发中应用软件工程 25.2 规划和运行Web应用程序项目 25.3 重用代码 25.4 编写可维护代码 25.4.1 编码标准 25.4.2 分解代码 25.4.3 使用标准的目录结构 25.4.4 文档化和共享内部函数 25.5 实现版本控制 25.6 选择一个开发环境 25.7 项目的文档化 25.8 建立原型 25.9 将逻辑和内容分离 25.10 优化代码 25.10.1 使用简单优化 25.10.2 使用Zend产品 25.11 测试 25.12 进一步学习 25.13 下一章</span><br><span class="line"></span><br><span class="line"> 第26章 调试 26.1 编程错误 26.1.1 语法错误 26.1.2 运行时错误 26.1.3 逻辑错误 26.2 使用变量帮助调试 26.3 错误报告级别 26.4 改变错误报告设置 26.5 触发自定义错误 26.6 巧妙地处理错误 26.7 下一章</span><br><span class="line"></span><br><span class="line"> 第27章 建立用户身份验证机制和个性化设置 27.1 解决方案的组成 27.1.1 用户识别和个性化设置 27.1.2 保存书签 27.1.3 推荐书签 27.2 解决方案概述 27.3 实现数据库 27.4 实现基本的网站 27.5 实现用户身份验证 27.5.1 注册 27.5.2 登录 27.5.3 登出 27.5.4 修改密码 27.5.5 重设遗忘的密码 27.6 实现书签的存储和检索 27.6.1 添加书签 27.6.2 显示书签 27.6.3 删除书签 27.7 实现书签推荐 27.8 考虑可能的扩展 27.9 下一章</span><br><span class="line"></span><br><span class="line"> 第28章 创建一个购物车 28.1 解决方案的组成 28.1.1 创建一个在线目录 28.1.2 在用户购买商品的时候记录购买行为 28.1.3 实现一个付款系统 28.1.4 创建一个管理界面 28.2 解决方案概述 28.3 实现数据库 28.4 实现在线目录 28.4.1 列出目录 28.4.2 列出一个目录中的所有图书 28.4.3 显示图书详细信息 28.5 实现购物车 28.5.1 使用show_cart.php脚本 28.5.2 浏览购物车 28.5.3 将物品添加到购物库 28.5.4 保存更新后的购物车 28.5.5 打印标题栏摘要 28.5.6 结账 28.6 实现付款 28.7 实现一个管理界面 28.8 扩展该项目 28.9 使用一个已有系统 28.10 下一章</span><br><span class="line"></span><br><span class="line"> 第29章 创建一个基于Web的电子邮件服务系统 29.1 解决方案的组成 29.1.1 电子邮件协议：POP3和IMAP 29.1.2 PHP对POP3和IMAP的支持 29.2 解决方案概述 29.3 建立数据库 29.4 了解脚本架构 29.5 登录与登出 29.6 建立账户 29.6.1 创建一个新账户 29.6.2 修改已有账户 29.6.3 删除账户 29.7 阅读邮件 29.7.1 选择账户 29.7.2 查看邮箱内容 29.7.3 阅读邮件消息 29.7.4 查看消息标题 29.7.5 删除邮件 29.8 发送邮件 29.8.1 发送一则新消息 29.8.2 回复或转发邮件 29.9 扩展这个项目 29.10 下一章</span><br><span class="line"></span><br><span class="line"> 第30章 创建一个邮件列表管理器 30.1 解决方案的组成 30.1.1 建立列表和订阅者数据库 30.1.2 上载新闻信件 30.1.3 发送带附件的邮件 30.2 解决方案概述 30.3 建立数据库 30.4 定义脚本架构 30.5 实现登录 30.5.1 新账户的创建 30.5.2 登录 30.6 用户函数的实现 30.6.1 查看列表 30.6.2 查看邮件列表信息 30.6.3 查看邮件列表存档 30.6.4 订阅与取消订阅 30.6.5 更改账户设置 30.6.6 更改密码 30.6.7 登出 30.7 管理功能的实现 30.7.1 创建新的邮件列表 30.7.2 上载新的新闻信件 30.7.3 多文件上载的处理 30.7.4 预览新闻信件 30.7.5 发送邮件 30.8 扩展这个项目 30.9 下一章</span><br><span class="line"></span><br><span class="line"> 第31章 创建一个Web论坛 31.1 理解流程 31.2 解决方案的组成 31.3 解决方案概述 31.4 数据库的设计 31.5 查看文章的树型结构 31.5.1 展开和折叠 31.5.2 显示文章 31.5.3 使用treenode类 31.6 查看单个的文章 31.7 添加新文章 31.8 添加扩充 31.9 使用一个已有的系统 31.10 下一章</span><br><span class="line"></span><br><span class="line"> 第32章 生成PDF格式的个性化文档 32.1 项目概述 32.1.1 评估文档格式 32.2 解决方案的组成 32.2.1 问题与回答系统 32.2.2 文档生成软件 32.3 解决方案概述 32.3.1 提问 32.3.2 给答题评分 32.3.3 生成RTF证书 32.3.4 从模板生成PDF证书 32.3.5 使用PDFlib生成PDF文档 32.3.6 使用PDFlib的一个“Hello World”程序 32.3.7 用PDFlib生成证书 32.4 处理标题的问题 32.5 扩展该项目 32.6 下一章</span><br><span class="line"></span><br><span class="line"> 第33章 使用XML和SOAP来连接Web服务 33.1 项目概述：使用XML和Web服务 33.1.1 理解XML 33.1.2 理解Web服务 33.2 解决方案的组成 33.2.1 使用Amazon的Web服务接口 33.2.2 XML的解析：REST响应 33.2.3 在PHP中使用SOAP 33.2.4 缓存 33.3 解决方案概述 33.3.1 核心应用程序 33.3.2 显示特定种类的图书 33.3.3 获得一个AmazonResultSet类 33.3.4 使用REST发送和接收请求 33.3.5 使用SOAP发送和接收请求 33.3.6 缓存请求返回的数据 33.3.7 创建购物车 33.3.8 到Amazon付账 33.4 安装项目代码 33.5 扩展这个项目 33.6 进一步学习</span><br><span class="line"></span><br><span class="line"> 第34 章使用Ajax构建Web 2.0应用 34.1 Ajax 是什么？ 34.1.1 HTTP请求和响应 34.1. 2 DHTML和XHTML 34.1.3 级联样式单（CSS） 34.1.4 客户端编程 34.1.5 服务器端编程 34.1.6 XML和XSLT 34.2 Ajax基础 34.2.1 XMLHTTPRequest对象 34.2.2 与服务器通信 34.2.3 处理服务器响应 34.2.4 整合应用 34.3 在以前的项目添加Ajax元素 34.3.1在PHPBookmark应用中添加Ajax元素 34.4 进一步学习 34.4.1 进一步了解文档对象模型（DOM） 34.4.2 Ajax应用可用的JavaScript函数库 34.4.3 Ajax开发人员网站</span><br><span class="line"></span><br><span class="line"> 第六篇 附录 附录A 安装PHP及MySQL 附录B Web资源 第1章 PHP快速入门教程 第2章 数据的存储与检索 第3章 使用数组 第4章 字符串操作与正则表达式 第5章 代码重用与函数编写 第6章 面向对象的PHP 第7章 错误和异常处理</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001TDLD80/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001TDLD80&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51bAJ6YbJgL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>Ruby Programming 向Ruby之父学程序设计(第2版)</title>
    <url>/2020/04/19/B0021L99F8/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Ruby Programming 向Ruby之父学程序设计(第2版)<br>作者信息： 作者: 博硕文化 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Ruby Programming:向Ruby之父学程序设计(第2版)》内容包括：第一部分  开始使用Ruby通过简单的Ruby程序来介绍程序的基本架构。第二部分  学习基础写Ruby程序时需要知道的基础语法规则，以及类、模块等面向对象程序设计的思考方法与用词。第三部分  使用类写程序时重要的不只是语法。使用Ruby之所以能够快乐地写程序，在相当程度上是因为它提供了设计精巧的标准程序库。在这里就对一些基础类逐一介绍其功能与用法。第四部分  灵活使用Ruby为了能灵活使用Ruby，这里要介绍一些比较高级的功能。比如Ruby的环境参数、环境变量、迭代器的用法与做法、Mix-in等在第二、三部分没有提到的内容。第五部分  制作应用在这里作为整《Ruby Programming:向Ruby之父学程序设计(第2版)》内容的综合，介绍比较复杂一点的程序范例。试着使用Ruby来写出比较实用的程序。附录使用Ruby时所需的知识、相关的资讯等，都整理在附录里。也介绍了Ruby的mailing-list、网络上的各种资源与其用法。安装Ruby的方法也写在这里，请在阅读《Ruby Programming:向Ruby之父学程序设计(第2版)》之前先在您的电脑上构建好可以使用Ruby的环境吧。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1部分 开始使用Ruby</span><br><span class="line">第1章 与Ruby的第一次接触</span><br><span class="line">1.1 执行Ruby</span><br><span class="line">1.1.1 Windows环境</span><br><span class="line">1.1.2 UNIX环境</span><br><span class="line">1.1.3 MacOS X环境</span><br><span class="line">1.1.4 确认执行正常</span><br><span class="line">1.2 程序的说明</span><br><span class="line">1.2.1 对象</span><br><span class="line">1.2.2 方法</span><br><span class="line">1.3 字符串</span><br><span class="line">1.3.1 换行字符与“\”</span><br><span class="line">1.3.2 “&#39;”与“&quot;“”</span><br><span class="line">1.4 调用方法</span><br><span class="line">1.5 puts方法</span><br><span class="line">1.6 p方法</span><br><span class="line">1.7 显示中文</span><br><span class="line">1.8 数值的显示与计算</span><br><span class="line">1.8.1 显示数值</span><br><span class="line">1.8.2 四则运算</span><br><span class="line">1.8.3 数学函数</span><br><span class="line">1.9 变量</span><br><span class="line">1.10 写注释</span><br><span class="line">1.11 控制结构</span><br><span class="line">1.12 条件判断：if～then～end</span><br><span class="line">1.13 字符串反复执行（循环）</span><br><span class="line">1.13.1 while语句</span><br><span class="line">1.13.2 times方法</span><br><span class="line">1.14 定义方法</span><br><span class="line">1.15 读入其他文件 </span><br><span class="line"></span><br><span class="line"> 第2章 方便的对象 2.1 数组 2.1.1 建立数组 2.1.2 从数组中取得对象 2.1.3 将对象存进数组里 2.1.4 数组的内容 2.1.5 数组的大小 2.1.6 逐项处理数组内容 2.2 杂凑（HASH） 2.2.1 建立杂凑 2.2.2 从杂凑获取对象 2.2.3 逐项处理杂凑内容 2.3 正则表达式</span><br><span class="line"></span><br><span class="line"> 第3章 指令设计 3.1 从命令行输入的数据 3.2 读取文件 3.2.1 读入文件内的文本数据并显示 3.2.2 从文件逐行读入数据并显示出来 3.2.3 只显示文件里符合特定样式的几行</span><br><span class="line"></span><br><span class="line"> 第2部分 学习基础 第4章 对象与变量、常数 4.1 对象 4.2 类 4.3 变量 4.4 常数 4.5 保留字</span><br><span class="line"></span><br><span class="line"> 第5章 条件判断 5.1 什么是条件判断 5.2 Ruby的条件 5.2.1 条件与真假值 5.2.2 逻辑运算符 5.3 if语句 5.4 unless语句 5.5 case语句 5.6 if修饰符与unless修饰符 5.7 总结</span><br><span class="line"></span><br><span class="line"> 第6章 循环 6.1 循环的基础 6.2 写循环时要注意的事情 6.3 实现循环的方式 6.4 times方法 6.5 for语句 6.6 一般的for语句 6.7 while语句 6.8 until语句 6.9 each方法 6.10 loop方法 6.11 循环的控制 6.11.1 break 6.11.2 next 6.11.3 redo 6.12 总结</span><br><span class="line"></span><br><span class="line"> 第7章 方法 7.1 调用方法 7.2 方法的分类 7.2.1 实例方法 7.2.2 类方法 7.2.3 函数性的方法 7.3 定义方法</span><br><span class="line"></span><br><span class="line"> 第8章 类与模块 8.1 什么是类 8.1.1 类与实例 8.1.2 继承 8.2 自己定义类 8.2.1 class语句 8.2.2 initialize方法 8.2.3 实例变量与实例方法 8.2.4 访问方法 8.2.5 类方法 8.2.6 常数 8.2.7 类变量 8.2.8 扩充类 8.2.9 使用继承 8.2.10 限制方法的调用 8.3 什么是面向对象 8.3.1 数据与处理程序 8.3.2 “数据与处理程序”方式的问题 8.3.3 对象 8.3.4 面向对象的特征 8.3.5 Duck Typing（行为决定类型） 8.4 什么是模块 8.5 自己定义模块 8.5.1 常数 8.5.2 定义方法</span><br><span class="line"></span><br><span class="line"> 第9章 错误处理与例外 9.1 关于错误处理 9.2 例外处理 9.3 例外处理的写法 9.4 善后处理 9.5 重新执行 9.6 rescue修饰符 9.7 例外处理语法的补充 9.8 指定要捕捉的例外 9.9 例外类 9.10 引发例外 9.11 catch与throw</span><br><span class="line"></span><br><span class="line"> 第3部分 使用类 第10章 数值（Numeric）类 10.1 Numeric的类架构 10.2 数值常数 10.3 算术运算 10.3.1 除法 10.3.2 Math模块 10.4 数值类型的转换 10.5 位运算 10.6 数数 练习</span><br><span class="line"></span><br><span class="line"> 第11章 数组（Array）类 11.1 复习数组 11.2 建立数组 11.2.1 使用Array.new 11.2.2 使用%w 11.2.3 使用to_a方法 11.2.4 使用字符串的split方法 11.3 索引的用法 11.3.1 获取元素 11.3.2 改写元素 11.3.3 插入元素 11.3.4 以多个索引建立新数组 11.4 不使用索引操作数组 11.5 作为集合的数组 11.6 作为“列表”的数组 11.7 数组的主要方法 11.7.1 将数据加入数组中 11.7.2 从数组中删除数据 11.7.3 换掉数组的元素 11.8 数组与迭代器 11.9 处理数组的每个元素 11.9.1 使用循环配合索引 11.9.2 使用each方法逐项获取元素 11.9.3 使用破坏性的方法反复操作 11.9.4 使用其他迭代器 11.9.5 自己设计迭代器 11.10 数组的元素 11.10.1 示例：使用简单的矩阵 11.10.2 小心初始化 11.11 并行处理多个数组的值 练习</span><br><span class="line"></span><br><span class="line"> 第12章 字符串（String）类 12.1 建立字符串 12.1.1 使用%Q、%q 12.1.2 使用嵌入文档 12.1.3 使用sprintf方法 12.2 获取字符串长度 12.3 分割字符串 12.4 连接字符串 12.5 字符串的索引 12.6 比较字符串 12.7 处理换行字符 12.8 字符串的查找与取代 12.8.1 查找字符串 12.8.2 字符串的取代 12.9 字符串与数组共同的方法 12.9.1 与索引操作有关的方法 12.9.2 Enumerable模块相关的方法 12.9.3 连接、逆转相关的方法 12.10 其他方法 练习</span><br><span class="line"></span><br><span class="line"> 第13章 杂凑（Hash）类 13.1 杂凑的复习 13.2 建立杂凑的方法 13.2.1 使用&#123;&#125; 13.2.2 使用Hash.new 13.3 获取、设定杂凑的值 13.3.1 直接取出所有键或值 13.3.2 杂凑的默认值 13.4 查询杂凑里是否存在某个键或值 13.5 查询杂凑的大小 13.6 删除键与值 13.7 初始化杂凑 13.8 应用示例：计算单字数量 练习</span><br><span class="line"></span><br><span class="line"> 第14章 正则表达式 第14章 （Regexp）类 14.1 关于正则表达式 14.1.1 正则表达式的写法与用途 14.1.2 建立正则表达式对象 14.2 正则表达式的样式与匹配 14.2.1 以一般文字进行匹配 14.2.2 匹配行首与行尾 14.2.3 指定想要匹配成功的文字范围 14.2.4 匹配任意字符 14.2.5 使用反斜线的样式 14.2.6 反复出现 14.2.7 最短匹配 14.2.8 “()”与反复 14.2.9 多选 14.3 使用quote方法的正则表达式 14.4 正则表达式的选项 14.5 回溯参照 14.6 使用正则表达式的方法 14.6.1 sub方法与gsub方法 14.6.2 scan方法 14.7 正则表达式的示例 练习</span><br><span class="line"></span><br><span class="line"> 第15章 IO类 15.1 输入&#x2F;输出的种类 15.1.1 标准输入&#x2F;输出 15.1.2 文件输入&#x2F;输出 15.1.3 open-uri.rb 15.1.4 stringio.rb 15.2 基本的输入&#x2F;输出操作 15.2.1 输入操作 15.2.2 输出操作 15.3 文件指针 15.4 二进制模式与文本模式 15.5 缓冲处理 15.6 与指令交换数据 练习</span><br><span class="line"></span><br><span class="line"> 第16章 File类与Dir类 16.1 File类 16.1.1 更改文件名 16.1.2 复制文件 16.1.3 删除文件 16.2 目录的操作 16.2.1 读取目录内容 16.2.2 Dir.glob 16.2.3 建立目录与删除 16.3 文件与目录的属性 16.3.1 获取属性 16.3.2 FileTest模块 16.4 文件名的操作 16.5 与文件操作相关的程序库 16.5.1 find.rb 16.5.2 tempfile.rb 16.5.3 fileutils.rb 练习</span><br><span class="line"></span><br><span class="line"> 第17章 Time类与Date类 17.1 Time类、Date类、 17.1 DateTime类 17.2 获取Time对象 17.3 计算时间 17.4 时间的格式 17.5 本地时间 17.6 解析字符串 17.7 使用DateTime类 17.8 DateTime类与Time类的差异 17.8.1 DateTime类表示一天的方式 17.8.2 时差处理的差异 17.9 使用Date类求日期 17.10 计算日期 17.11 日期格式 17.12 解析字符串 练习</span><br><span class="line"></span><br><span class="line"> 第4部分 灵活使用Ruby 第18章 Ruby的其他补充知识 18.1 命令行选项 18.1.1 调试、运行确认 18.1.2 获取信息 18.1.3 单行程序（one-liner） 18.1.4 安全性检查 18.1.5 其他 18.2 环境变量 18.3 常数 18.4 内建变量 18.5 内建常数 18.6 多重赋值 18.7 BEGIN&#123;&#125;与END&#123;&#125; 18.8 alias 18.9 undef 18.10 虚拟变量</span><br><span class="line"></span><br><span class="line"> 第19章 运算符 19.1 逻辑运算符的应用 19.2 条件运算符 19.3 自我赋值 19.4 范围运算符 19.5 运算符的优先次序 19.6 定义运算符 19.6.1 二元运算符 19.6.2 单项运算符 19.6.3 数组参照运算符</span><br><span class="line"></span><br><span class="line"> 第20章 迭代器（iterator） 20.1 迭代器与区块调用 20.2 迭代器的基础知识 20.3 各式各样的迭代器 20.3.1 用在数组上 20.3.2 用在杂凑上 20.3.3 用在文件上 20.4 Enumerable模块 20.4.1 each方法 20.4.2 collect方法 20.4.3 sort方法 20.4.4 sort_by方法 20.5 实现迭代器</span><br><span class="line"></span><br><span class="line"> 第21章 Mix-in 21.1 include方法 21.2 Comparable模块 21.3 Enumerable模块 21.4 与继承的关系 21.5 方法的查找规则</span><br><span class="line"></span><br><span class="line"> 第5部分 制作应用</span><br><span class="line"></span><br><span class="line"> 第22章 日志文件解析 22.1 浅谈日志文件访问 22.2 查询访问数 22.3 查询访问日期 22.4 以图表显示访问日期 22.5 只统计特定文件的访问次数</span><br><span class="line"></span><br><span class="line"> 第23章 查找邮政编码 23.1 邮政编码数据库 23.2 读文件 23.3 gdbm程序库 23.4 生成数据 23.5 查找数据 23.6 jzipcode.rb 23.7 执行与使用 23.8 总结</span><br><span class="line"></span><br><span class="line"> 第24章 解析HTML 24.1 关于HTML 24.1.1 元素与标签 24.1.2 注释 24.1.3 字符引用 24.2 建立程序 24.2.1 注释的解析 24.2.2 标签的解析（一） 24.2.3 文字数据的解析 24.2.4 示例 24.2.5 标签的解析（二） 24.3 超链接一览 附录A</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0021L99F8/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0021L99F8&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41V2MPAlcDL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>ruby</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows内核情景分析：采用开源代码ReactOS(上、下册)</title>
    <url>/2020/04/19/B002AKIVMM/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Windows内核情景分析：采用开源代码ReactOS(上、下册)<br>作者信息： 作者: 浏览全部评论  [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>•市面上唯一一本讲述Windows内核分析的图书。•历时三年，近1500页篇幅，毛德操老师最新力作！《Windows内核情景分析：采用开源代码ReactOS》：历时3年，近1500页篇幅，毛德操老师重磅著作</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上册</span><br><span class="line">第1章  概述 1</span><br><span class="line">1.1  Windows操作系统发展简史 1</span><br><span class="line">1.2  用户空间和系统空间 3</span><br><span class="line">1.3  Windows内核 4</span><br><span class="line">1.4  开源项目ReactOS及其代码 9</span><br><span class="line">1.5  Windows内核函数的命名 10 </span><br><span class="line"></span><br><span class="line"> 第2章 系统调用 12 2.1 内核与系统调用 12 2.2 系统调用的内核入口KiSystemService() 22 2.3 系统调用的函数跳转 29 2.4 系统调用的返回 32 2.5 快速系统调用 35 2.6 从内核中发起系统调用 42</span><br><span class="line"></span><br><span class="line"> 第3章 内存管理 44 3.1 内存区间的动态分配 47 3.1.1 内核对用户空间的管理 48 3.1.2 内核对于物理页面的管理 60 3.1.3 虚存页面的映射 67 3.1.4 Hyperspace的临时映射 78 3.1.5 系统空间的映射 86 3.1.6 系统调用NtAllocateVirtualMemory() 90 3.2 页面异常 97 3.3 页面的换出 107 3.4 共享映射区（Section） 115 3.5 系统空间的缓冲区管理 133</span><br><span class="line"></span><br><span class="line"> 第4章 对象管理 136 4.1 对象与对象目录 136 4.2 对象类型 148 4.3 句柄和句柄表 162 4.4 对象的创建 169 4.5 几个常用的内核函数 179 4.5.1 ObReferenceObjectByHandle() 179 4.5.2 ObReferenceObjectByPointer() 187 4.5.3 ObpLookupEntryDirectory() 188 4.5.4 ObpLookupObjectName() 192 4.5.5 ObOpenObjectByName() 209 4.5.6 ObReferenceObjectByName() 213 4.5.7 ObDereferenceObject() 214 4.6 对象的访问控制 218 4.7 句柄的遗传和继承 218 4.8 系统调用NtDuplicateObject() 223 4.9 系统调用NtClose() 233</span><br><span class="line"></span><br><span class="line"> 第5章 进程与线程 241 5.1 概述 241 5.2 Windows进程的用户空间 253 5.3 系统调用NtCreateProcess() 273 5.4 系统调用NtCreateThread() 284 5.5 Windows的可执行程序映像 300 5.6 Windows的进程创建和映像装入 305 5.7 Windows DLL的装入和连接 329 5.8 Windows的APC机制 358 5.9 Windows线程的调度和切换 381 5.9.1 x86系统结构与线程切换 382 5.9.2 几个重要的数据结构 385 5.9.3 线程的切换 388 5.9.4 线程的调度 395 5.10 线程和进程的优先级 409 5.11 线程本地存储TLS 421 5.12 进程挂靠 434 5.13 Windows的跨进程操作 442 5.14 Windows线程间的相互作用 450</span><br><span class="line"></span><br><span class="line"> 第6章 进程间通信 467 6.1 概述 467 6.2 共享内存区（Section） 469 6.3 线程的等待&#x2F;唤醒机制 470 6.4 信号量（Semaphore） 499 6.5 互斥门（Mutant） 505 6.6 事件（Event） 512 6.7 命名管道（Named Pipe）和信插（Mailslot） 516 6.8 本地过程调用（LPC） 521 6.9 视窗报文（Message） 555</span><br><span class="line"></span><br><span class="line"> 第7章 视窗报文 556 7.1 视窗线程与Win32k扩充系统调用 556 7.2 视窗报文的接收 566 7.3 Win32k的用户空间回调机制 590 7.4 用户空间的外挂函数 602 7.5 视窗报文的发送 615 7.6 键盘输入线程 628 7.7 鼠标器输入线程 642 7.8 默认的报文处理 662</span><br><span class="line"></span><br><span class="line"> 第8章 结构化异常处理 665 8.1 结构化异常处理的程序框架 666 8.2 系统空间的结构化异常处理 683 8.3 用户空间的结构化异常处理 710 8.4 软异常 720</span><br><span class="line"></span><br><span class="line"> 下册 第9章 设备驱动 729 9.1 Windows的设备驱动框架 729 9.2 一个“老式”驱动模块的实例 745 9.3 DPC函数及其执行 769 9.4 内核劳务线程 778 9.5 一组PnP设备驱动模块的实例 783 9.6 中断处理 817 9.7 一个过滤设备驱动模块的示例 828 9.8 设备驱动模块的装载 830 9.9 磁盘的设备驱动堆叠 858 9.9.1 类驱动disk.sys 860 9.10 磁盘的Miniport驱动模块 887 9.11 命名管道与Mailslot 896 9.12 MDL 918 9.13 同步I&#x2F;O与异步I&#x2F;O 932 9.14 IRP请求的完成与返回 946</span><br><span class="line"></span><br><span class="line"> 第10章 网络操作 957 10.1 概述 957 10.2 NDIS及其实现 959 10.3 Windows的网络驱动堆叠 974 10.3.1 NIC驱动 975 10.3.2 LAN驱动模块 997 10.3.3 TCP&#x2F;IP驱动模块 1014 10.3.4 AFD驱动与Winsock 1035 10.4 Socket的无连接通信 1062 10.5 Socket的有连接通信 1089 10.6 Winsock的实现 1093</span><br><span class="line"></span><br><span class="line"> 第11章 文件操作 1099 11.1 Win32 API函数CreateFileW() 1099 11.2 NT路径名 1109 11.3 文件路径名的解析 1119 11.4 FAT32文件系统 1144 11.5 文件系统驱动的装载和初始化 1169 11.6 文件卷的安装 1175 11.7 文件的创建 1199 11.8 缓存管理 1214 11.9 文件的读写 1237 11.10 NTFS文件系统简介 1252</span><br><span class="line"></span><br><span class="line"> 第12章 操作系统的安全性 1278 12.1 概述 1278 12.2 证章 1289 12.3 安全描述块和ACL 1305 12.4 访问权限检查 1322</span><br><span class="line"></span><br><span class="line"> 第13章 注册表 1351 13.1 注册表操作 1351 13.2 注册表的初始化和装载 1369 13.3 库函数RtlQueryRegistryValues() 1376</span><br><span class="line"></span><br><span class="line"> 第14章 系统管理进程与服务进程 1394 14.1 系统管理进程Smss 1394 14.2 Windows子系统的服务进程Csrss 1408 14.3 服务管理进程Services 1424 14.4 服务进程Svchost 1449 跋 1464 参考文献 1466</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B002AKIVMM/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B002AKIVMM&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/5160KtMq3iL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习手册(第3版)</title>
    <url>/2020/04/19/B002NKMS7I/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Python学习手册(第3版)<br>作者信息： 作者: Mark Lutz [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Python学习手册(第3版)》为机械工业出版社出版。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">第一部分 使用入门第1章 问答环节</span><br><span class="line">人们为何使用Python</span><br><span class="line">软件质量</span><br><span class="line">开发者效率</span><br><span class="line">Python是“脚本语言”吗</span><br><span class="line">好吧,Python的缺点是什么呢</span><br><span class="line">如今谁在使用Python</span><br><span class="line">使用Python可以做些什么</span><br><span class="line">系统编程</span><br><span class="line">用户图形接口</span><br><span class="line">Internet脚本</span><br><span class="line">组件集成</span><br><span class="line">数据库编程</span><br><span class="line">快速原型</span><br><span class="line">数值计算和科学计算编程</span><br><span class="line">游戏.图像.人工智能.XML.机器人等</span><br><span class="line">Python有哪些技术上的优点</span><br><span class="line">面向对象</span><br><span class="line">免费</span><br><span class="line">可移植</span><br><span class="line">功能强大</span><br><span class="line">可混合</span><br><span class="line">使用简单</span><br><span class="line">Python是工程,不是艺术</span><br><span class="line">简单易学</span><br><span class="line">名字来源于MontyPython</span><br><span class="line">Python和其他语言比较起来怎么样</span><br><span class="line">本章小结</span><br><span class="line">头脑风暴</span><br><span class="line">本章习题</span><br><span class="line">习题解答</span><br><span class="line">第2章 Python如何运行程序.</span><br><span class="line">Python解释器简介</span><br><span class="line">程序执行</span><br><span class="line">程序员的视角</span><br><span class="line">Python的视角</span><br><span class="line">执行模块的变种</span><br><span class="line">Python实现的替代者</span><br><span class="line">执行优化工具</span><br><span class="line">冻结二进制文件</span><br><span class="line">未来的可能性</span><br><span class="line">本章小结</span><br><span class="line">头脑风暴</span><br><span class="line">本章习题</span><br><span class="line">习题解答</span><br><span class="line">第3章 如何运行程序</span><br><span class="line">交互模式下编写代码</span><br><span class="line">在交互提示模式下测试代码</span><br><span class="line">使用交互提示模式</span><br><span class="line">系统命令行和文件</span><br><span class="line">使用命令行和文件</span><br><span class="line">UNIX可执行脚本(#!)</span><br><span class="line">UNIXenv查找技巧</span><br><span class="line">点击文件图标</span><br><span class="line">在Windows中点击图标</span><br><span class="line">raw_input的技巧</span><br><span class="line">图标点击的其他限制</span><br><span class="line">模块导入和重载</span><br><span class="line">模块的显要特性：属性</span><br><span class="line">import和reload的使用注意事项</span><br><span class="line">IDLE用户界面</span><br><span class="line">IDLE基础</span><br><span class="line">使用IDLE</span><br><span class="line">高级IDLE工具</span><br><span class="line">其他的IDE</span><br><span class="line">嵌入式调用</span><br><span class="line">动付二进制的可执行性</span><br><span class="line">文本编辑器启动的选择</span><br><span class="line">其他的启动选择</span><br><span class="line">未来的可能</span><br><span class="line">我应该选用哪种</span><br><span class="line">本章小结74..</span><br><span class="line">头脑风暴</span><br><span class="line">本章习题</span><br><span class="line">习题解答</span><br><span class="line">头脑风暴：第一部分 练习题 </span><br><span class="line"></span><br><span class="line"> 第二部分 类型和运算第4章 介绍Python对象类型. 为什么使用内置类型 Python的核心数据类型 数字 字符串 序列的操作 不可变性 类型特定的方法 寻求帮助 编写字符串的其他方法 模式匹配 列表 序列操作 类型特定的操作 边界检查 嵌套 列表解析 字典 映射操作 重访嵌套 键的排序：for循环 迭代和优化 不存在的键：if测试 元组 为什么要用元组 文件 其他文件类工具 其他核心类型 如何破坏代码的灵活性 用户定义的类 剩余的内容 本章小结 头脑风暴 本章习题 习题解答 第5章 数字 Python的数字类型 数字常量 内置数学工具和扩展 Python表达式操作符 混合操作所遵循的操作符优先级. 括号分组的子表达式 混合类型自动升级 预习：运算符重载 在实际应用中的数字 变量和基本的表达式 数字显示的格式 str和repr显示格式 除法：传统除法.Floor除法和真除法. 位操作 长整型数 复数 十六进制和八进制记数 其他的内置数学工具 其他数字类型 小数数字 集合 布尔型 第三方扩展 本章小结 头脑风暴 本章习题 习题解答 第6章 动态类型简介. 缺少类型声明语句的情况 变量.对象和引用 类型属于对象,而不是变量 对象的垃圾收集 共享引用 共享引用和在原处修改 共享引用和相等 动态类型随处可见 本章小结 头脑风暴 本章习题 习题解答 第7章 字符串 字符串常量 单双引号字符串是一样的 用转义序列代表特殊字节 字符串抑制转义 三重引号编写多行字符串块 字符串编码更大的字符集 实际应用中的字符串 基本操作 索引和分片 为什么要在意：分片 字符串转换工具 修改字符串 字符串格式化 更高级的字符串格式化 基于字典的字符串格式化 字符串方法 字符串方法实例：修改字符串 字符串方法实例：文本解析 实际应用中的其他常见字符串方法 最初的字符串模块 通常意义下的类型分类 同样分类的类型共享其操作集合 可变类型能够在原处修改 本章小结 头脑风暴 本章习题 习题解答 第8章 列表与字典. 列表 实际应用中的列表 基本列表操作 索引.分片和矩阵 原处修改列表 字典 实际应用中的字典 字典的基本操作 原处修改字典 其他字典方法 语言表 字典用法注意事项 为什么要在意字典接口 本章小结 头脑风暴 本章习题 习题解答 第9章 元组.文件及其他 元组 实际应用中的元组 为什么有了列表还要元组 文件 打开文件 使用文件 实际应用中的文件 其他文件工具 重访类型分类 为什么要在意操作符重载 对象灵活性 引用VS拷贝 比较.相等性和真值 Python中真和假的含义 Python的类型层次 Python中的其他类型 内置类型陷阱 赋值生成引用,而不是拷贝 重复能够增加层次深度. 留意循环数据结构 不可变类型不可以在原处改变 本章小结 头脑风暴 本章习题 习题解答 头脑风暴：第二部分 练习题</span><br><span class="line"></span><br><span class="line"> 第三部分 语句和语法第10章 Python语句简介. 重访Python程序结构 Python的语句 两个if的故事 Python增加了什么 Python删除了什么 终止行就是终止语句 为什么使用缩进语法 几个特殊实例 简短实例：交互循环 一个简单的交互式循环 对用户输入数据做数学运算 用测试输入数据来处理错误 用try语句处理错误 嵌套代码三层 本章小结 头脑风暴 本章习题 习题解答 第11章 赋值.表达式和打印 赋值语句 赋值语句的形式 序列赋值 多目标赋值语句 增强赋值语句 变量命名规则 表达式语句 表达式语句和在原处的修改 打印语句 Python的“HelloWorld”程序 重定向输出流 print&gt;&gt;file扩展 本章小结 头脑风暴 本章习题 习题解答 第12章 if测试. if语句 通用格式 基本例子 多路分支 Python语法规则 代码块分隔符 语句的分隔符 一些特殊情况 真值测试 if&#x2F;else三元表达式 为什么要在意布尔值 本章小结 头脑风暴 本章习题 习题解答 第13章 while和for循环 while循环 一般格式 例子 break.continue.pass和循环else 一般循环格式 例子 为什么要在意“模拟C语言的while循环” for循环 一般格式 例子 为什么要在意“文件扫描” 迭代器：初探 文件迭代器 其他内置类型迭代器 其他迭代环境 用户定义的迭代器 编写循环的技巧 循环计数器：while和range 非完备遍历：range 修改列表：range 并行遍历：zip和map 产生偏移和元素：enumerate 列表解析：初探 列表解析基础 对文件使用列表解析 扩展列表解析语法 本章小结 头脑风暴 本章习题 习题解答 第14章 文档 Python文档资源</span><br><span class="line"></span><br><span class="line"> 注释</span><br><span class="line"></span><br><span class="line"> dir函数 文档字符串：doc PyDoc：help函数 PyDoc：HTML报表 标准手册集 网络资源 已出版的书籍. 常见编写代码的陷阱 本章小结 头脑风暴 本章习题 习题解答 头脑风暴：第三部分 练习题</span><br><span class="line"></span><br><span class="line"> 第四部分 函数第15章 函数基础 为何使用函数 编写函数 def语句 def语句是实时执行的 第一个例子：定义和调用 定义 调用 Python中的多态 第二个例子：寻找序列的交集 定义 调用 重访多态 本地变量 本章小结 头脑风暴 本章习题 习题解答 第16章 作用域和参数 作用域法则 函数作用域基础 变量名解析：LEGB原则 作用域实例 内置作用域 global语句 最小化全局变量 最小化文件间的修改 其他访问全局变量的方法 作用域和嵌套函数 嵌套作用域的细节 嵌套作用域举例 传递参数 参数和共享引用 避免可变参数的修改 对参数输出进行模拟 特定的参数匹配模型 关键字参数和默认参数的实例 任意参数的实例 关键字参数和默认参数的混合 min调用 一个更有用的例子：通用set函数 参数匹配：细节 为什么要在意：关键字参数 本章小结 头脑风暴 本章习题 习题解答 第17章 函数的高级话题. 匿名函数：lambda lambda表达式 为什么使用lambda 如何（不要）让Python代码变得晦涩难懂 嵌套lambda和作用域 作为参数来应用函数 内置函数apply 为什么要在意：回调 传入关键字参数 和apply类似的调用语法 在序列中映射函数：map 函数式编程工具：filter和reduce 重访列表解析：映射 列表解析基础 增加测试和嵌套循环 列表解析和矩阵 理解列表解析 为什么要在意：列表解析和map 重访迭代器：生成器 生成器函数实例 扩展生成器函数协议：send和next 迭代器和内置类型 生成器表达式：迭代器遇到列表解析 对迭代的各种方法进行计时 函数设计概念 函数是对象：简洁调用 函数陷阱 本地变量是静态检测的 默认和可变对象 没有return语句的函数 嵌套作用域的循环变量 本章小结 头脑风暴 本章习题 习题解答 头脑风暴：第四部分 练习题</span><br><span class="line"></span><br><span class="line"> 第五部分 模块第18章 模块：宏伟蓝图. 为什么使用模块 Python程序构架 如何组织一个程序 导入和属性 标准库模块 import如何工作 搜索 编译（可选） 运行 第三方工具：distutils 本章小结 头脑风暴 本章习题 习题解答 第19章 模块代码编写基础. 模块的创建 模块的使用 import语句 from语句 from语句 导入只发生一次 import和from是赋值语句 文件间变量名的改变 import和from的对等性 from语句潜在的陷阱 模块命名空间 文件生成命名空间 属性名的点号运算 导入和作用域 命名空间的嵌套 重载模块 reload基础 reload实例 为什么要在意：模块重载 本章小结 头脑风暴 本章习题 习题解答 第20章 模块包 包导入基础 包和搜索路径设置 init.py包文件 包导入实例 包对应的from和import 为什么要使用包导入 三个系统的传说 为什么要在意：模块包 本章小结 头脑风暴 本章习题 习题解答 第21章高级模块话题 在模块中隐藏数据 最小化from的破坏：_X和all. 启用以后的语言特性 混合用法模式：name和main 以name进行单元测试 修改模块搜索路径 importas扩展 相对导入语法 为什么使用相对导入 模块设计理念 模块是对象：元程序 模块陷阱 顶层代码的语句次序的重要性 通过变量名字符串导入模块 from复制变量名,而不是连接 from*会让变量语义模糊 reload不会影响from导入 reload.from以及交互模式测试 reload的使用没有传递性 递归形式的fromimport无法工作 本章小结 头脑风暴 本章习题 习题解答 头脑风暴：第五部分 练习题</span><br><span class="line"></span><br><span class="line"> 第六部分 类和OOP第22章OOP：宏伟蓝图 为何使用类 概览OOP 属性继承搜索 类和实例 类方法调用 编写类树 OOP是为了代码重用 本章小结 头脑风暴 本章习题 习题解答 第23章类代码编写基础. 类产生多个实例对象 类对象提供默认行为 实例对象是具体的元素 第一个例子 类通过继承进行定制 第二个例子 类是模块内的属性 类可以截获Python运算符 第三个例子 为什么要使用运算符重载 世界上最简单的Python类 本章小结 头脑风暴 本章习题 习题解答 第24章类代码编写细节. class语句 一般形式 例子 方法 例子 调用超类的构造器 其他方法调用的可能性 继承 属性树的构造 继承方法的专有化 类接口技术 抽象超类 运算符重载 常见的运算符重载方法 getitem拦截索引运算 getitem和iter实现迭代 用户定义的迭代器 getattr和setattr捕捉属性的引用 模拟实例属性的私有性 repr和str会返回字符串表达形式 radd处理右侧加法 call拦截调用 函数接口和回调代码 del是析构器 命名空间：完整的内容 简单变量名：如果赋值就不是全局变量 属性名称：对象命名空间 Python命名空间的“禅”：赋值将变量名分类 命名空间字典 命名空间链接 一个更实际的例子 本章小结 头脑风暴 本章习题 习题解答 第25章类的设计 Python和OOP 通过调用标记进行重载（或不要） 类作为记录 类和继承：“是一个”关系 类和组合：“有一个”关系 重访流处理器 为什么要在意：类和持续性 OOP和委托 多重继承 类是对象：通用对象的工厂 为什么有工厂 方法是对象：绑定或无绑定 重访文档字符串 为什么要在意：绑定方法和回调函数 类和模块 本章小结 头脑风暴 本章习题 习题解答 第26章类的高级主题 扩展内置类型 通过嵌入扩展类型 通过子类扩展类型 类的伪私有属性 变量名压缩概览 为什么使用伪私有属性 新式类 钻石继承变动 其他新式类的扩展 静态和类方法 使用静态和类方法 函数装饰器 装饰器例子 类陷阱 修改类属性的副作用 多重继承：顺序很重要 类.方法以及嵌套作用域 “过度包装” 本章小结 头脑风暴 本章习题 习题解答 头脑风暴：第六部分 练习题</span><br><span class="line"></span><br><span class="line"> 第七部分 异常和工具第27章异常基础 为什么使用异常 异常的角色 异常处理：简明扼要 try&#x2F;except&#x2F;else语句 try语句分句 try&#x2F;else分句 例子：默认行为 例子：捕捉内置异常 try&#x2F;finally语句 例子：利用try&#x2F;finally编写终止行为 统一try&#x2F;except&#x2F;finally 通过嵌套合并finally和except 合并try的例子 raise语句 例子：引发并捕捉用户定义的异常 例子：利用raise传入额外的数据 例子：利用raise传递异常 assert语句 例子：收集约束条件（但不是错误） with&#x2F;as环境管理器 基本使用 环境管理协议 为什么要在意：错误检查 本章小结 头脑风暴 本章习题 习题解答 第28章异常对象 基于字符串的异常 字符串异常就要出局了 基于类的异常 类异常例子 为什么使用类异常 内置Exception类 定义异常文本 发送额外数据和实例行为 raise语句的一般形式 本章小结 头脑风暴 本章习题 习题解答 第29章异常的设计 嵌套异常处理器 例子：控制流程嵌套 例子：语法嵌套化 异常的习惯用法 异常不总是错误 函数信号条件和raise 在try外进行调试 运行进程中的测试 关于sys.exc_info 与异常有关的技巧 应该包装什么 捕捉太多：避免空except语句 捕捉过少：使用基于类的分类 异常陷阱 字符串异常匹配是通过同一性而不是通过值 捕捉到错误的异常 核心语言总结 Python工具集 大型项目的开发工具 本章小结 头脑风暴 本章习题 习题解答 头脑风暴：第七部分 练习题 第八部分 附录 附录A安装和配置 附录B每部分练习题解答</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B002NKMS7I/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B002NKMS7I&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51S722CSOWL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Web标准之道 博客园精华集</title>
    <url>/2020/04/19/B002KFYYWS/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Web标准之道 博客园精华集<br>作者信息： 作者: 阿一 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Web标准之道:博客园精华集》由人民邮电出版社出版。半年前，在博客同这杆大旗下的感召下，一群园友聚到了一起，组成了博客园精华集编委会，酝酿着一出好戏。这期间，有过争执，但更多的是合作。长期的磨合，使得来自五湖四海的编委会成员互相熟悉，甚至无话不谈。这，也是一种财富。今天，博客园这坛好酒，在陈酿了五年之后，终于要开封了。这是一本关于Web标准、前端编程、网站优化的集大成之作，代表了博客园在Web领域的最高水准。所选文章大多是经验之谈，所谓技术人士的“心灵老鸭汤”：全书最有撼力的文章，莫过于Cat Chen的《欲练CSS，必先宫IE》；鸟食轩和老赵的文章偏实用，主要集中在Javascript领域；爆牙齿的《重构之美》系列，则有“采菊东篱下，悠然见南山”的意境。  妙笔生花之作不胜枚举，正所谓：备美酒兮以飨佳朋，身心俱醉。博客园的草根技术文集，博客园五年精华与沉淀，众多MVP倾情奉献。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分　HTML&#x2F;CSS </span><br><span class="line"></span><br><span class="line"> 谈谈网页设计中的字体应用(1)——Font Set　2 目前的网页还是以文字信息为主，而字体作为文字表现形式的最重要参数之一，自然有着相当重要的地位。可惜字体的重要性在很长时间内并没有得到足够的重视</span><br><span class="line"></span><br><span class="line"> 谈谈网页设计中的字体应用(2)——serif和sans-serif　5 有多少人可以正确地使用它们呢？有多少人真正了解这两个通用字体族呢？本文将给您一个最清楚深入的剖析</span><br><span class="line"></span><br><span class="line"> 谈谈网页设计中的字体应用(3)——实战应用篇•上　10</span><br><span class="line"></span><br><span class="line"> 谈谈网页设计中的字体应用(4)——实战应用篇•下　14 纸上谈兵终是虚，让我们在战场上学习更多的技能</span><br><span class="line"></span><br><span class="line"> 让CSS区分各种各样的input　19 input代表的实在太多了，但它们却不可能使用相同的样式，当我们不想添加成片的class时，试试这里的方法，四个解决方案，总有一个您需要的</span><br><span class="line"></span><br><span class="line"> 一个常被问到的问题： 如何让层盖住select　25 IE 6依然是目前的主流浏览器，IE 6的select也一直“高高在上”，经常遇到的问题却成为一直以来的话题，本文将为您展现终极解决方案</span><br><span class="line"></span><br><span class="line"> 兼容IE、Firefox的图片自动缩放的CSS　29 厌烦了写大量的JavaScript来控制一个个的图片，那么来用CSS(当您不能确定expression将会带来什么的时候，请谨慎使用)</span><br><span class="line"></span><br><span class="line"> 第二部分　Web标准</span><br><span class="line"></span><br><span class="line"> Web标准页面设计——要注意的很多　32 本文是作者在做完一个大型项目之后的总结，提到了很多方面，相信这些知识点对所有走在Web标准化道路上的人都有很大的帮助</span><br><span class="line"></span><br><span class="line"> 欲练CSS，必先宫IE　39 Win国天下，欲练CSS之人不在少数，大多不得要领，又或是走火入魔，全为IE所累。故曰：欲练CSS，必先宫IE</span><br><span class="line"></span><br><span class="line"> 你有table&#x2F;强迫症吗　42 如果你宫了IE然而还是觉得不得要领，那就该怀疑自己是不是有传说中的table强迫症了</span><br><span class="line"></span><br><span class="line"> 根本不存在DIV + CSS布局这回事　44 看了上面的两篇文章，您是不是已经开始拿DIV+CSS布局来和table布局进行比较了？实际上，用于布局的只有CSS，根本不存在DIV+CSS布局这回事</span><br><span class="line"></span><br><span class="line"> 慎用XHTML标签的自关闭写法　47 请注意：并不是所有标签都可以自关闭</span><br><span class="line"></span><br><span class="line"> Web标准不标准　49 一群会用table蹩脚布局的网页初学者嘲笑着那些对网页制作一窍不通的门外汉；而一群自认为Table布局无所不能的Table布局拥护者则嘲笑着那群用Table蹩脚布局的网页初学者；那些刚试着将几个页面中的TABLE换成DIV的所谓的Web标准设计者则嘲笑着那群死抱Table布局不放的table布局设计者；而一群焦头烂额终于在网站上贴上“W3C验证通过HTML网站”图标的自认高人的Web标准设计者则嘲笑着那群以为“DIV+CSS”就是Web标准的Web标准设计初学者；但是当我们把网页放在不同的浏览器中的时候，却发现我们全部都被“Web标准设计”嘲笑了</span><br><span class="line"></span><br><span class="line"> 走在Web标准化设计的路上[唠叨先]　53 晕，现在才谈XHTML是不是太晚了点，这东东2004就火了一把了。其实，作为一项技术，没有火与不火的说法，也没有早与晚的说法。技术的生命力和火没有关系，不知道不理解没学会怎么都不晚</span><br><span class="line"></span><br><span class="line"> 走在Web标准化设计的路上——振臂一呼：CSS，Stop!　55 近几年Web标准的推广变成了CSS的推广，CSS重要吗？我们不要CSS行不行？你找一大堆完全合理的理由……“行不行？”“行！”那就对了，我说不要你的CSS，我要他的CSS，又行不行？那么和XHTML相比，CSS重要在哪里</span><br><span class="line"></span><br><span class="line"> 走在Web标准化设计的路上——对HTML&#x2F;XHTML&#x2F;XML&#x2F;XSL的 一些认识　57 让我们从这里开始更深入地了解这些L们</span><br><span class="line"></span><br><span class="line"> 走在Web标准化设计的路上——深入结构：理解h系列的不合理　60 HTML中的6个标题Tag(h1&#x2F;h2&#x2F;h3&#x2F;h4&#x2F;h5&#x2F;h6)，设计得是否合理？理由？解决办法</span><br><span class="line"></span><br><span class="line"> 走在Web标准化设计的路上——深入结构：合理运用DIV和SPAN　66 把DIV看成是布局元素的人非常多，类似有“用div代替table进行布局”、“实战CSS+DIV布局”等，太多了，可是，DIV却不是布局元素，更可怕的是XHTML中根本不存在一个布局元素</span><br><span class="line"></span><br><span class="line"> 走在Web标准化设计的路上深入结构：DIV再议以及对SPAN的迷惑　70 上篇文章中主要否定了使用DIV进行布局这种说法，提出DIV应当用于组织代码结构，现在我们再深入一点，DIV拥有语义吗</span><br><span class="line"></span><br><span class="line"> 走在Web标准化设计的路上——复杂表单　74</span><br><span class="line"></span><br><span class="line"> 走在Web标准化设计的路上[复杂表单：Reload]　77 一直有种说法：Table用于数据表，对于复杂表单，Table也是最好的选择，那么，到底复杂表单是否应该使用Table</span><br><span class="line"></span><br><span class="line"> 走在Web标准化设计的路上[深入语义：列表和表格的抉择]　83 问题：XHTML中的列表Tag(ul&#x2F;ol)和表格Tag(Table)区别何在？对于单列多行下的数据表，如何判断和选择</span><br><span class="line"></span><br><span class="line"> IE 7标准之道——1. 更丰富的CSS选择符　86 IE 7最令网页设计者兴奋的改进，便是支持更多、更丰富的CSS选择符，因此可以更方便地实现一些在IE 6中很难实现或者无法实现的效果。下面就让我们看看这些令人兴奋的、IE 7新支持的选择符</span><br><span class="line"></span><br><span class="line"> IE 7标准之道——2：引起页面布局混乱的祸首　98 页面乱了！谁搞的？让本文带您进入侦探之路</span><br><span class="line"></span><br><span class="line"> IE 7标准之道——3：歌剧院魅影bug　114 估计很多朋友都对这个华丽的“歌剧院魅影”有眼前一亮的感觉，其实这纯粹是一个标题党作为，这个Bug和歌剧院半毛钱关系都没有。这个bug在国际上比较获得认可的名字叫做——“IE 6重复文字Bug”。这是一个非常好玩但是又很令人摸不透的bug</span><br><span class="line"></span><br><span class="line"> IE 7标准之道——4：上去了！终于上去了　118 这是IE 6一个很著名且诡异的bug，很简单，也很容易重现。说白了就是：列表框(select)一直把DIV踩在脚底下。因为这个bug，不知道多少浮动菜单被破坏</span><br><span class="line"></span><br><span class="line"> IE 7标准之道——5：置换元素与行距bug　122 也许您没有听说过“置换元素”这个词，但这个问题您一定遇到过</span><br><span class="line"></span><br><span class="line"> IE 7标准之道——6：float双倍margin bug　129 很出名，很常见，很简单，如何修正呢？这里有最好的答案</span><br><span class="line"></span><br><span class="line"> IE 7标准之道——7：躲猫猫bug　134 我的文字不见了！躲哪里去了？IE开发团队都不知道，我们怎么可能知道？但是我们却有办法找出这个猫猫</span><br><span class="line"></span><br><span class="line"> IE 7标准之道——8：疯了的边框线　138 疯了，边框线算是彻底地疯掉了，这里却没有“为什么”，还好，我们有“怎么办”</span><br><span class="line"></span><br><span class="line"> 第三部分　安全与优化</span><br><span class="line"></span><br><span class="line"> Web开发中你注意这些问题了吗(前台构架篇)　146 Web 2.0带给我们更好的用户体验和更炫、更酷的效果，Javascript、Flash、Silverlight都跃跃欲试。于是，我们网站中有了越来越多的JS和CSS的文件和代码。随着数量的增多，如何管理这些文件和这些代码、如何通过合理的方式来提升性能，已经是我们必须面对的问题</span><br><span class="line"></span><br><span class="line"> 如何利用客户端缓存对网站进行优化　151 你的网站在并发访问量很大并且无法承受压力的情况下，你会如何优化？很多人会回答服务器缓存，其实这里有更好的方式—客户端才是我们真正的战场</span><br><span class="line"></span><br><span class="line"> 如何提高网页的效率(上篇)——提高网页效率的14</span><br><span class="line"></span><br><span class="line"> 条准则　155 网站最基本的东西是什么？——内容？SEO(搜索引擎优化)？UE(用户体验)？都不对！是速度</span><br><span class="line"></span><br><span class="line"> 如何提高网页的效率(下篇)——使用Yslow掌握网站慢的原因　164 工欲善其事，必先利其器，上篇讲到网站最基本要素是速度，这一次将为大家带来很好用的工具，来协助我们提升网站的速度</span><br><span class="line"></span><br><span class="line"> 关于Web应用程序安全的思考　169 没有绝对的安全，在Web上更没有。对于一个Web程序来讲，至少我们应该做到：自己(一个有经验的Web开发人员)攻不破这个系统。HTTP是开放的﹐因此谁都能向网络上公开的Web服务器发送request请求﹐要求一个URL，但可惜的是，Web服务器对于请求方的识别能力是很低的。使用URL进行安全管控的关键不是判断URL，而是判断每次request，检查每次request是否合法，以防止安全漏洞</span><br><span class="line"></span><br><span class="line"> SEO——我们是不是走错了路　194 多少公司把钱给了搜索引擎？多少人每天为SEO而工作？我们的工作是必要的吗？SEOer的存在是正确的吗？是不是在这条路上我们走进了迷途？存在即是合理，但我们依然可以停下来想一想，什么才应该是我们真正的追求</span><br><span class="line"></span><br><span class="line"> 第四部分　JavaScript</span><br><span class="line"></span><br><span class="line"> JavaScript变量作用域及可访问性的探讨　200 永远的话题，永远的焦点，不过，你可能永远无法找到比这里更好的探讨</span><br><span class="line"></span><br><span class="line"> JavaScript中的this关键字　207</span><br><span class="line"></span><br><span class="line"> 你不知道的JavaScript——“this”　215 两大高手共论“this”：太常用了，所有写过JavaScript的人都用过，以至于我们每个人都会认为自己很了解它，但是，我们真的了解吗？是不是在我们的理解之外，还有什么是我们没有想到的？看过这两篇文章后，你会发现一个不一样的“this”</span><br><span class="line"></span><br><span class="line"> JavaScript代码压缩、加密算法分析及工具实现　220 现在网上很多JavaScript都进行了压缩，同时代码变得不可直接阅读，也相当于一种简单的加密了，本文对其中一种典型的算法进行分析，并介绍如何解密代码和重新实现</span><br><span class="line"></span><br><span class="line"> JavaScript Table排序　230 网上也有很多其他的Table排序函数，有的基于数组，有的不够灵活。这个函数能在原有Table结构上加入功能，不用太多改动，基于OO的结构也易于使用(当然前提是对JS有一定认识)。这里只是满足基本需求，你可以自己动手扩展</span><br><span class="line"></span><br><span class="line"> 设计模式在JavaScript中的应用(1)——MVC　236 采用了设计模式，程序无疑将具有更好的健壮性，可维护性以及可读性。所以，作为能工巧匠的您，也一定不会放过令程序蓬荜生辉的机会。让我们一起领略MVC模式</span><br><span class="line"></span><br><span class="line"> 设计模式在JavaScript中的应用(2)——Observer　243 上篇我们讨论了Web开发中最重要的设计模式MVC，这一篇我们要讨论的是Observer模式。与MVC这样的大型设计模式相比，Observer模式则要轻量很多</span><br><span class="line"></span><br><span class="line"> JavaScript面向对象之属性实现　248 属性是对私有变量的一种保护手段，同时提供了像public变量一样的使用效果。近代的高级编程语言，(例如C#和Java)都支持属性这一特点，让我们在JavaScript里实现相同的功能</span><br><span class="line"></span><br><span class="line"> 基于“甘露模型”的多重继承和接口实现，附带“准”桥接模式的验证　251 你是否听过“甘露模型”呢？是否觉得它在某些地方还不是特别完善？那么，在这篇文章里，让我们继续这个话题，让甘露来得更多一些</span><br><span class="line"></span><br><span class="line"> 在JavaScript面向对象编程中使用继承(1)　257 前面几篇提到了使用JavaScript进行面向对象编程的一些内容，上一篇中实现了多重继承，在这里，让我们开始全面的了解“继承”在JavaScript中的应用，本篇列出了4种实现继承的方式</span><br><span class="line"></span><br><span class="line"> 在JavaScript面向对象编程中使用继承(2)　261 本篇详细介绍了继承构造法，适用于：小规模类之间的继承，基类和子类的属性方法在5～8个，还有就是以构造函数中赋值方式导入类的属性和方法，而不用prototype导入的类编写习惯的时候</span><br><span class="line"></span><br><span class="line"> 在JavaScript面向对象编程中使用继承(3)　264 原型继承法一样有它的缺点，仅适用于基类没有属性的情形，而优点也是相当明显：保持了子类构造函数的完整，可以不在里面添加任何和继承有关的代码，所有继承和重载操作都由对原型(prototype)的操作来完成</span><br><span class="line"></span><br><span class="line"> 在JavaScript面向对象编程中使用继承(4)　267 本文介绍实例继承法，此种方法没有太经典的应用场景，不过对于基类比较复杂，而子类需要添加的属性方法很少，实例法还是显得挺清晰的。特别是对于Javacript对象动态扩展很熟悉的人，就更觉得明确了</span><br><span class="line"></span><br><span class="line"> 在JavaScript面向对象编程中使用继承(5)　269 附加继承法，此方法由本系列作者独创，解决了上面3种经典继承方式的很多问题，使用起来异常强大，就像作者所说，适用场景为anywhere, anytime, anybody</span><br><span class="line"></span><br><span class="line"> 挣脱浏览器的束缚(1)——前言　273 工欲善，必先利其器</span><br><span class="line"></span><br><span class="line"> 挣脱浏览器的束缚(2)——别让脚本引入坏了事　276 Web应用中需要的脚本越来越多，传统的脚本引入方式已经越来越无法适应这种变化，在本篇中，老赵带我们一起看看如何完美解决脚本引入的问题</span><br><span class="line"></span><br><span class="line"> 挣脱浏览器的束缚(3)——两个连接还不够“并行”　281 浏览器很傻，但是我们很聪明，于是，就有了突破浏览器双连接限制的方法</span><br><span class="line"></span><br><span class="line"> 挣脱浏览器的束缚(4)——王道！动态添加script元素　285 突破双连接限制解决了一个很大的问题，但依然有更多的问题需要解决。动态添加script元素也同样有着很多的麻烦和问题，但这并不妨碍它成为“王道”，且听老赵慢慢道来</span><br><span class="line"></span><br><span class="line"> 挣脱浏览器的束缚(5)——哭笑不得的IE Bug　289 在IE中，如果同时建立两个以上“连接状态”的连接，那么就很不幸地出现了问题：浏览器停止响应了！不过还好，浏览器很傻，JavaScript也很傻，我们可以很容易地骗过去</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B002KFYYWS/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B002KFYYWS&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/511%2B9TghAzL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>Python UNIX和Linux系统管理指南</title>
    <url>/2020/04/19/B002PAQEEO/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Python UNIX和Linux系统管理指南<br>作者信息： 作者: 杨明华 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Python UNIX和Linux系统管理指南》是由机械工业出版社出版的。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">序</span><br><span class="line">前言</span><br><span class="line">第1章 Python简介</span><br><span class="line">为什么要选Python</span><br><span class="line">学习的动力</span><br><span class="line">一些基础知识</span><br><span class="line">在Python中执行命令</span><br><span class="line">在Python中使用函数</span><br><span class="line">通过Import语句实现代码复用 </span><br><span class="line"></span><br><span class="line"> 第2章 IPython 安装IPython 基础知识 从功能强大的函数获得帮助 UNIX Shell 信息搜集 自动和快捷方式 本章小结</span><br><span class="line"></span><br><span class="line"> 第3章 文本 Python的内建功能及模块 Element Tree 本章小结</span><br><span class="line"></span><br><span class="line"> 第4章 文档与报告 自动信息收集 手工信息收集 信息格式化 信息发布 本章小结</span><br><span class="line"></span><br><span class="line"> 第5章 网络 网络客户端 远程过程调用 SSH Twisted Scapy 使用Scapy创建脚本</span><br><span class="line"></span><br><span class="line"> 第6章 数据 引言 使用OS模块与Data进行交互 拷贝、移动、重命名和删除数据 使用路径.目录和文件 数据比较 合并数据 对文件和目录的模式匹配 包装rsync 元数据：关于数据的数据 存档.压缩.映像和恢复 使用tarfile模块创建TAR归档 使用tarfile模块检查TAR文件内容</span><br><span class="line"></span><br><span class="line"> 第7章 SNMP 引言 对SNMP的简要介绍 IPython与Net-SNMP 查找数据中心 使用Net-SNMP获取多个值 创建混合的SNMP工具 Net-SNMP扩展 SNMP设备控制 整合Zenoss的企业级SNMP</span><br><span class="line"></span><br><span class="line"> 第8章 操作系统什锦 引言 Python中跨平台的UNIX编辑 PyInotify OSX Red Hat Linux系统管理 Ubuntu管理 Solaris系统管理 虚拟化 云计算 使用Zenoss从Linux上管理Windows服务器</span><br><span class="line"></span><br><span class="line"> 第9章 包管理 引言 Setuptools和Python Egg 使用easy install Easy install的高级特征 创建egg 进入点及控制台脚本 使用Python包索引注册一个包 Distutils Buildout 使用Buildout 使用Buildout进行开发 virtualenv EPM包管理 EPM总结：真的非常简单</span><br><span class="line"></span><br><span class="line"> 第10章 进程与并发 引言 子进程 使用Supervisor来管理进程 使用Screen来管理进程 Python中的线程 进程 Processing模块 调度Python进程 daemonizer 本章小结</span><br><span class="line"></span><br><span class="line"> 第11章 创建GUI GUI创建理论 生成一个简单的PyGTK应用 使用PyGTK创建Apache日志浏览器 使用Curses创建Apache日志浏览器 Web应用 DJango 本章小结</span><br><span class="line"></span><br><span class="line"> 第12章 数据持久性 简单序列化 关系序列化 本章 小结</span><br><span class="line"></span><br><span class="line"> 第13章 命令行 引言 基本标准输入的使用 Optparse简介 简单的Optparse使用模式 UnixMashups：整合Shell命令到Python命令行工具中 整合配置文件 本章小结</span><br><span class="line"></span><br><span class="line"> 第14章 实例 使用Python管理DNS 使用OpenLDAP.ActiveDirectory以及其他Python工具实现LDAP Apache日志报告 FTP镜像 附录回调</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B002PAQEEO/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B002PAQEEO&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51Lz0K7hlvL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript宝典(第6版)</title>
    <url>/2020/04/19/B002BNKWI4/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： JavaScript宝典(第6版)<br>作者信息： 作者: 古德曼 (Goodman.D.) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>使用JavaSc ript。让您的网页在浩瀚的网络海洋中焕发出夺目光彩 这本专家级的指南，是畅销书《JavaScript Bible》的升级换代 不管您是JavaScript高手，还是初学者，《JavaScript宝典(第6版)》都值得JavaScript Web开发人员一遍一遍地反复研读。·掌握JavaSc ript基础，编写您的第一个实用脚本；·为单平台和跨平台用户开发代码，并满足不断发展的标准。·获悉文档对象模型以及HTML元素对象的要点；·编写脚本，动态修改Web网页，以响应用户操作；·学会新的Ajax技术，创建有效的网页用户接口；·应用最新的JavaScript异常处理，以及定制对象的技术；·创建站点的交互能力，如Google Maps。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1部分 JavaScript起步</span><br><span class="line">第1章 JavaScript在万维网及其他方面的作用3</span><br><span class="line">1.1 Web上的竞争3</span><br><span class="line">1.2 其他Web技术4</span><br><span class="line">1.2.1 超文本标记语言(HTML和XHTML)4</span><br><span class="line">1.2.2 CSS(层叠样式表)4</span><br><span class="line">1.2.3 服务器编程4</span><br><span class="line">1.2.4 辅助程序和插件程序5</span><br><span class="line">1.3 JavaScript：语言的集大成者6</span><br><span class="line">1.3.1 LiveScript变成了JavaScript6</span><br><span class="line">1.3.2 微软世界6</span><br><span class="line">1.4 JavaScript：灵活好用的工具7 </span><br><span class="line"></span><br><span class="line"> 第2章 开发适用于各种浏览器的JavaScript8 2.1 相互竞争8 2.2 相互包容9 2.3 当今的兼容性问题9 2.3.1 将语言从对象中独立出来9 2.3.2 核心语言标准10 2.3.3 文档对象模型11 2.3.4 层叠样式表11 2.3.5 动态HTML和定位12 2.4 开发脚本编写策略12</span><br><span class="line"></span><br><span class="line"> 第3章 第1个JavaScript脚本13 3.1 软件工具13 3.1.1 选择文本编辑器13 3.1.2 选择浏览器14 3.2 设置编写环境14 3.2.1 Windows14 3.2.2 MacOSX14 3.2.3 重载问题15 3.3 第一个脚本的功能15 3.4 输入第一个脚本16 3.5 检查脚本17 3.5.1 HTML文档17 3.5.2 script标记17 3.5.3 运行脚本的触发器17 3.5.4 插入文本17 3.5.5 获得浏览器信息18 3.6 轻松编写脚本18</span><br><span class="line"></span><br><span class="line"> 第2部分 JavaScript教程 第4章 浏览器对象和文档对象21 4.1 脚本运行初步21 4.2 何时使用JavaScript22 4.3 文档对象模型22 4.3.1 HTML结构和DOM23 4.3.2 浏览器窗口中的DOM23 4.4 载入文档时24 4.4.1 一个简单的文档24 4.4.2 添加段落元素24 4.4.3 添加段落文本24 4.4.4 生成新元素24 4.5 对象引用25 4.5.1 对象命名25 4.5.2 引用特定对象25 4.6 节点术语26 4.6.1 node概述26 4.6.2 父与子26 4.7 如何定义对象27 4.7.1 属性27 4.7.2 方法28 4.7.3 事件28 4.8 习题29</span><br><span class="line"></span><br><span class="line"> 第5章 脚本和HTML文档30 5.1 脚本放在文档何处30 5.1.1 script标记30 5.1.2 标记位置31 5.1.3 处理旧版本的浏览器32 5.2 JavaScript语句32 5.3 脚本语句何时执行33 5.3.1 文档载入时，即刻执行33 5.3.2 延时脚本33 5.4 观察脚本错误35 5.5 脚本和编程35 5.6 习题36</span><br><span class="line"></span><br><span class="line"> 第6章 程序设计基础之一37 6.1 关于JavaScript语言37 6.2 处理信息37 6.3 变量38 6.3.1 创建变量38 6.3.2 变量名38 6.4 表达式和求值39 6.4.1 脚本中的表达式39 6.4.2 表达式和变量40 6.5 数据类型转换40 6.5.1 将字符串转换为数值41 6.5.2 将数值转换为字符串41 6.6 操作符41 6.6.1 算术操作符41 6.6.2 比较操作符42 6.7 习题42</span><br><span class="line"></span><br><span class="line"> 第7章 程序设计基础之二43 7.1 决策和循环43 7.2 控制结构43 7.2.1 if结构44 7.2.2 if…else结构44 7.3 重复循环45 7.4 函数45 7.4.1 函数参数45 7.4.2 变量作用域46 7.5 大括号47 7.6 数组48 7.6.1 创建数组48 7.6.2 存取数组数据48 7.6.3 关联数组49 7.6.4 数组中的document对象50 7.7 习题50</span><br><span class="line"></span><br><span class="line"> 第8章 window和document对象51 8.1 顶层对象51 8.2 window对象51 8.2.1 访问窗口属性和方法52 8.2.2 创建窗口52 8.3 window对象的属性和方法53 8.3.1 window.alert()方法53 8.3.2 window.confirm()方法53 8.3.3 window.prompt()方法54 8.3.4 load事件54 8.4 location对象54 8.5 navigator对象55 8.6 document对象55 8.6.1 document.forms[]属性55 8.6.2 document.images[]属性56 8.6.3 document.write()方法56 8.6.4 document.createElement()和document.createTextNode()方法57 8.6.5 document.getElementById()方法58 8.7 习题58</span><br><span class="line"></span><br><span class="line"> 第9章 表单和表单元素59 9.1 form对象59 9.1.1 作为对象和容器的表单59 9.1.2 访问表单属性60 9.1.3 form.elements[]属性60 9.2 作为对象的表单控件60 9.2.1 文本相关的输入对象61 9.2.2 按钮对象62 9.2.3 复选框对象62 9.2.4 单选按钮对象63 9.2.5 select对象64 9.3 向函数传递表单数据和元素65 9.4 提交和预验证表单66 9.5 习题67</span><br><span class="line"></span><br><span class="line"> 第10章 String、Math和Date对象68 10.1 核心语言对象68 10.2 String对象68 10.2.1 连接字符串69 10.2.2 字符串方法69 10.3 Math对象70 10.4 Date对象71 10.5 日期计算72 10.6 习题73</span><br><span class="line"></span><br><span class="line"> 第11章 用脚本编写框架和多窗口74 11.1 框架：父框架和子框架74 11.2 家庭成员间的引用75 11.2.1 父到子的引用75 11.2.2 子到父的引用75 11.2.3 子到子的引用76 11.3 框架脚本编程提示76 11.4 iframe元素简介76 11.5 控制多框架——导航条77 11.6 多窗口引用78 11.7 习题79</span><br><span class="line"></span><br><span class="line"> 第12章 图像和动态HTML80 12.1 image对象80 12.1.1 可互换的图像80 12.1.2 预缓存图像81 12.1.3 创建图像翻转82 12.2 无须脚本的翻转84 12.3 Javascript：伪URL85 12.4 流行的动态HTML技术85 12.4.1 更改样式表设置86 12.4.2 通过W3CDOM节点实现动态内容86 12.4.3 通过innerHTML属性实现动态内容86 12.5 习题87</span><br><span class="line"></span><br><span class="line"> 第3部分 文档对象参考 第13章 JavaScript基础91 13.1 JavaScript版本91 13.2 核心语言标准——ECMAScript92 13.3 在HTML文档中嵌入脚本92 13.3.1 script标记92 13.3.2 从旧浏览器中隐藏脚本语句93 13.3.3 完全隐藏脚本94 13.3.4 向XHTML验证程序隐藏脚本94 13.3.5 脚本库(.js文件)95 13.4 浏览器版本检测95 13.4.1 非脚本浏览器的编码95 13.4.2 为不同的浏览器编写脚本96 13.5 兼容性设计99 13.5.1 处理beta版浏览器99 13.5.2 TheEvaluatorSr.1 00 13.5.3 参考章 节中的兼容性等级100 13.6 有经验程序员的语言基础101 13.7 对象模型的发展103</span><br><span class="line"></span><br><span class="line"> 第14章 文档对象模型基础104 14.1 对象模型层次104 14.1.1 作为路径图的层次104 14.1.2 浏览器文档对象路径图105 14.2 文档对象的产生过程105 14.3 对象属性106 14.4 对象方法106 14.5 对象事件处理器107 14.6 对象模型概述107 14.7 基本对象模型108 14.8 基本附加图像对象模型108 14.9 Navigator4扩展109 14.9.1 事件捕获模型109 14.9.2 层109 14.10 InternetExplorer4+扩展110 14.10.1 HTML元素对象110 14.10.2 元素包含层次110 14.10.3 层叠样式表111 14.10.4 事件冒泡111 14.11 InternetExplorer5+扩展111 14.12 W3CDOM112 14.12.1 DOM层112 14.12.2 规范中衡定不变的部分113 14.12.3 W3CDOM中不具备的特性113 14.12.4 新的HTML惯例113 14.12.5 新DOM概念114 14.12.6 静态W3CDOMHTML对象119 14.12.7 双向事件模型120 14.13 脚本编程趋势121 14.13.1 将内容与脚本分离121 14.13.2 尽可能使用W3CDOM122 14.13.3 处理事件122 14.14 标准兼容模式(DOCTYPE切换)122 14.15 JavaScript对象模型基础小结123</span><br><span class="line"></span><br><span class="line"> 第15章 通用html元素对象124 15.1 语法126 15.2 关于这些对象127 15.3 属性127 15.4 方法167 15.5 事件处理器211 15.6 常用键盘事件任务228</span><br><span class="line"></span><br><span class="line"> 第16章 window对象和frame对象239 16.1 window对象术语239 16.2 框架239 16.2.1 创建框架240 16.2.2 框架对象模型240 16.2.3 引用框架240 16.2.4 top和parent241 16.2.5 防止页面在其他Web站点的框架中显示241 16.2.6 确认页面载入框架集241 16.2.7 从有框架到去掉框架242 16.2.8 继承性和封装性242 16.2.9 框架同步242 16.2.10 空白框架242 16.2.11 查看框架源代码243 16.2.12 框架和frame元素对象243 16.3 window对象243 16.3.1 语法245 16.3.2 关于window对象245 16.3.3 属性246 16.3.4 方法268 16.3.5 事件处理器300 16.4 frame元素对象304 16.4.1 语法304 16.4.2 关于frame对象304 16.4.3 属性304 16.5 frameset元素对象308 16.5.1 语法308 16.5.2 关于frameset对象309 16.5.3 属性309 16.6 iframe元素对象312 16.6.1 语法312 16.6.2 关于iframe对象313 16.6.3 属性313 16.7 popup对象316 16.7.1 语法316 16.7.2 关于popup对象316 16.7.3 属性317 16.7.4 方法317</span><br><span class="line"></span><br><span class="line"> 第17章 location对象和history对象320 17.1 location对象320 17.1.1 语法320 17.1.2 关于location对象320 17.1.3 属性322 17.1.4 方法329 17.2 history对象331 17.2.1 语法331 17.2.2 关于history对象331 17.2.3 属性332 17.2.4 方法333</span><br><span class="line"></span><br><span class="line"> 第18章 document对象和body对象336 18.1 document对象336 18.1.1 语法338 18.1.2 关于document对象338 18.1.3 属性339 18.1.4 方法365 18.1.5 事件处理器380 18.2 body元素对象381 18.2.1 语法381 18.2.2 关于body对象381 18.2.3 属性382 18.2.4 方法385 18.2.5 事件处理器386 18.3 TreeWalker对象386 18.3.1 语法386 18.3.2 关于此对象386 18.3.3 属性387 18.3.4 方法387</span><br><span class="line"></span><br><span class="line"> 第19章 Link和Anchor对象389</span><br><span class="line"></span><br><span class="line"> 第20章 lmage对象、Area对象、Map对象和Canvas对象394 20.1 image和img元素对象394 20.1.1 语法395 20.1.2 关于此对象395 20.1.3 属性396 20.1.4 事件处理器405 20.2 area元素对象407 20.2.1 语法407 20.2.2 关于此对象407 20.2.3 属性408 20.3 map元素对象409 20.3.1 语法409 20.3.2 关于此对象409 20.3.3 属性410 20.4 canvas对象411 20.4.1 语法412 20.4.2 关于此对象412 20.4.3 属性414 20.4.4 方法416</span><br><span class="line"></span><br><span class="line"> 第21章 Form及其相关对象419 21.1 对象层次中的表单419 21.2 form对象419 21.2.1 语法420 21.2.2 关于该对象420 21.2.3 引用表单控件420 21.2.4 将表单和元素传递到函数421 21.2.5 用电子邮件传输表单423 21.2.6 改变表单属性424 21.2.7 表单按钮424 21.2.8 提交后的重定位424 21.2.9 表单元素数组424 21.2.1 0关于input元素对象425 21.2.1 1属性425 21.2.1 2方法428 21.2.1 3事件处理器430 21.3 fieldset和legend元素对象431 21.3.1 语法431 21.3.2 关于这些对象431 21.4 label元素对象432 21.4.1 语法432 21.4.2 关于该对象432 21.4.3 属性432 21.5 脚本编程和WebForms2.0432 21.5.1 什么是WebForms2.0433 21.5.2 WebForms2.0和JavaScript433</span><br><span class="line"></span><br><span class="line"> 第22章 按钮对象434 22.1 button元素对象以及button、submit、reset输入对象434 22.1.1 语法434 22.1.2 关于这些对象435 22.1.3 属性436 22.1.4 方法436 22.1.5 事件处理器437 22.2 复选框输入对象438 22.2.1 语法438 22.2.2 关于该对象438 22.2.3 属性438 22.2.4 方法440 22.2.5 事件处理器441 22.3 单选button输入对象442 22.3.1 语法442 22.3.2 关于该对象442 22.3.3 属性443 22.3.4 方法445 22.3.5 事件处理器445 22.4 图像输入对象446 22.4.1 语法446 22.4.2 关于该对象447 22.4.3 属性447</span><br><span class="line"></span><br><span class="line"> 第23章 文本相关表单对象448 23.1 文本输入对象448 23.1.1 语法448 23.1.2 关于该对象449 23.1.3 文本域和事件449 23.1.4 属性450 23.1.5 方法454 23.1.6 事件处理器456 23.2 password输入对象458 23.2.1 语法458 23.2.2 关于该对象458 23.3 hidden输入对象458 23.3.1 语法458 23.3.2 关于该对象458 23.4 textarea表单对象459 23.4.1 语法459 23.4.2 关于该对象459 23.4.3 文本域中的回车460 23.4.4 属性460 23.4.5 方法461</span><br><span class="line"></span><br><span class="line"> 第24章 选择、选项和文件上传对象462 24.1 select元素对象462 24.1.1 语法462 24.1.2 关于select对象463 24.1.3 修改select选项(NN3+、IE4+)464 24.1.4 修改select选项(IE4+)466 24.1.5 修改select选项(W3CDOM)467 24.1.6 属性468 24.1.7 方法473 24.1.8 事件处理器473 24.2 option元素对象474 24.2.1 语法475 24.2.2 关于该对象475 24.2.3 属性475 24.3 optgroup元素对象475 24.3.1 语法476 24.3.2 关于该对象476 24.3.3 属性476 24.4 file输入元素对象477 24.4.1 语法477 24.4.2 关于该对象477</span><br><span class="line"></span><br><span class="line"> 第25章 event对象479 25.1 事件479 25.1.1 事件的内容和事件何时发生480 25.1.2 静态event对象480 25.2 事件传播480 25.2.1 NN4事件传播481 25.2.2 IE4+事件传播482 25.2.3 W3C事件传播485 25.3 引用事件对象488 25.4 绑定事件488 25.4.1 通过标记属性绑定事件489 25.4.2 通过对象属性绑定事件489 25.4.3 通过IE附加绑定事件490 25.4.4 通过W3C监听器绑定事件490 25.4.5 跨浏览器事件绑定解决方案491 25.5 事件对象兼容性491 25.6 深入事件模型493 25.6.1 检查跨平台的修改键493 25.6.2 跨平台的按键捕获494 25.7 事件类型494 25.8 IE4+事件对象496 25.8.1 语法497 25.8.2 关于该对象497 25.8.3 属性497 25.9 NN6+&#x2F;Moz&#x2F;Safarievent对象510 25.9.1 语法511 25.9.2 关于该对象511 25.9.3 属性511 25.9.4 方法523</span><br><span class="line"></span><br><span class="line"> 第26章 styleSheet表和style对象525 26.1 理解对象名称525 26.2 导入样式表526 26.3 读取样式属性527 26.4 style元素对象527 26.4.1 语法527 26.4.2 关于该对象527 26.4.3 属性528 26.5 styleSheet对象528 26.5.1 语法529 26.5.2 关于该对象529 26.5.3 属性529 26.5.4 方法533 26.6 cssRule和rule对象534 26.6.1 语法535 26.6.2 关于这些对象535 26.6.3 属性535 26.7 currentStyle、runtimeStyle和style对象536 26.7.1 语法537 26.7.2 关于这些对象537 26.7.3 Style属性537 26.7.4 属性值538 26.7.5 文本和字体属性540 26.7.6 内联显示和布局属性544 26.7.7 定位属性548 26.7.8 背景属性549 26.7.9 边框和边界属性550 26.7.1 0列表属性553 26.7.1 1滚动条属性554 26.7.1 2表属性554 26.7.1 3页面和打印属性555 26.7.1 4杂项属性555 26.7.1 5听觉属性556 26.8 filter对象557 26.8.1 语法557 26.8.2 关于该对象557 26.8.3 WinIE5.5 +滤镜语法变化561</span><br><span class="line"></span><br><span class="line"> 第27章 Ajax和XML565 27.1 元素和节点565 27.2 xml元素对象567 27.2.1 语法567 27.2.2 关于此对象567 27.2.3 属性567 27.3 XMLHttpRequest对象568 27.3.1 语法568 27.3.2 关于此对象568 27.3.3 属性570 27.3.4 方法572</span><br><span class="line"></span><br><span class="line"> 第4部分JavaScript核心语言参考</span><br><span class="line"></span><br><span class="line"> 第28章 string对象577 28.1 字符串和数值数据类型577 28.1.1 简单字符串577 28.1.2 建立长字符串变量578 28.1.3 连接字符串文字和变量578 28.1.4 特殊内嵌字符578 28.2 string对象579 28.2.1 语法579 28.2.2 关于该对象579 28.2.3 属性580 28.2.4 解析方法581 28.3 字符串使用函数593 28.4 URL字符串编码和译码595</span><br><span class="line"></span><br><span class="line"> 第29章 Math、Number和Boolean对象596 29.1 JavaScript中的数值596 29.1.1 整型和浮点数值596 29.1.2 十六进制和八进制整数598 29.1.3 将字符串转换为数值598 29.1.4 将数值转换为字符串599 29.1.5 数值不是数值型时599 29.2 Math对象600 29.2.1 语法600 29.2.2 关于该对象600 29.2.3 属性600 29.2.4 方法600 29.2.5 创建随机数601 29.2.6 Math对象的快捷引用601 29.3 Number对象602 29.3.1 语法602 29.3.2 关于该对象602 29.3.3 属性602 29.3.4 方法603 29.4 Boolean对象604 29.4.1 语法604 29.4.2 关于该对象604</span><br><span class="line"></span><br><span class="line"> 第30章 date对象605 30.1 时区和GMT605 30.2 date对象606 30.2.1 创建date对象606 30.2.2 内部对象的属性和方法607 30.2.3 日期方法607 30.2.4 处理时区610 30.2.5 字符串日期610 30.2.6 适于以前浏览器的日期格式610 30.2.7 更多的转换611 30.2.8 日期和时间运算611 30.2.9 计算天数612 30.2.1 0早期浏览器中日期的bug和漏洞614 30.3 表单中确认日期输入的方法614</span><br><span class="line"></span><br><span class="line"> 第31章 Array对象617 31.1 结构化数据617 31.2 创建空数组618 31.3 向数组添加数据618 31.4 JavaScript数组创建环境619 31.5 删除数组项619 31.6 并行数组619 31.7 多维数组621 31.8 模拟Hash表622 31.9 array对象属性622 31.1 0array对象方法623</span><br><span class="line"></span><br><span class="line"> 第32章 控制结构和异常处理633 32.1 if和if…else判定633 32.1.1 简单判定633 32.1.2 关于(条件)表达式634 32.1.3 复杂判定634 32.1.4 嵌套if…else语句635 32.2 条件表达式636 32.3 重复(for)循环636 32.3.1 使用循环计数器637 32.3.2 跳出循环638 32.3.3 使用continue继续循环639 32.4 while循环639 32.5 do-while循环640 32.6 循环遍历属性(for-in)640 32.7 with语句641 32.8 标签语句642 32.9 switch语句643 32.10 异常处理645 32.10.1 异常和错误645 32.10.2 异常机制645 32.11 使用try-catch-finally结构646 32.12 产生异常648 32.13 error对象650 32.13.1 语法651 32.13.2 关于该对象651 32.13.3 属性651 32.13.4 方法652</span><br><span class="line"></span><br><span class="line"> 第33章 JavaScript操作符653 33.1 操作符类别653 33.2 比较操作符654 33.3 不同数据类型的比较654 33.4 结合操作符655 33.5 赋值操作符657 33.6 布尔操作符658 33.6.1 布尔运算658 33.6.2 使用布尔操作符660 33.7 按位操作符660 33.8 对象操作符661 33.9 其他操作符663 33.10 操作符优先级665</span><br><span class="line"></span><br><span class="line"> 第34章 函数和自定义对象667 34.1 Function对象667 34.1.1 语法667 34.1.2 关于该对象667 34.1.3 创建函数668 34.1.4 嵌套函数668 34.1.5 函数参数669 34.1.6 属性669 34.1.7 方法671 34.2 函数应用注意事项672 34.2.1 调用函数672 34.2.2 变量范围：全局还是局部673 34.2.3 参数变量675 34.2.4 递归函数675 34.2.5 创建函数库676 34.2.6 封闭区间的意义676 34.3 使用面向对象的JavaScript创建自定义对象677 34.3.1 对象的具体细节678 34.3.2 例子：行星对象679 34.3.3 进一步封装682 34.3.4 创建对象数组682 34.3.5 利用嵌套对象683 34.3.6 创建对象的现代方法684 34.3.7 定义对象属性的获得者和设置者684 34.4 面向对象的概念685 34.4.1 增加原型685 34.4.2 原型继承686 34.4.3 嵌套对象和原型继承686 34.5 object对象687 34.5.1 语法687 34.5.2 关于该对象687 34.5.3 方法688</span><br><span class="line"></span><br><span class="line"> 第35章 全局函数和语句690 35.1 函数690 35.2 语句695</span><br><span class="line"></span><br><span class="line"> 第5部分 附录 附录A JavaScript和浏览器对象快速参考703</span><br><span class="line"></span><br><span class="line"> 附录B JavaScript保留字718</span><br><span class="line"></span><br><span class="line"> 附录C 练习答案719 C.1 第4章 答案719 C.2 第5章 答案720 C.3 第6章 答案721 C.4 第7章 答案721 C.5 第8章 答案724 C.6 第9章 答案725 C.7 第10章 答案727 C.8 第11章 答案728 C.9 第12章 答案728</span><br><span class="line"></span><br><span class="line"> 附录D JavaScript和DOMInternet资源729 D.1 本书的技术支持和更新729 D.2 新闻组729 D.3 FAQ730 D.4 在线文档730 D.5 万维网730</span><br><span class="line"></span><br><span class="line"> 附录E 本书配套光盘内容731 E.1 系统需求731 E.2 光盘内容731 E.2.1 文本编辑器的JavaScript清单731 E.2.2 附录A的JavaScript和浏览器对象快速参考的可打印版本732 E.2.3 本书主题参考的PDF版本732 E.3 疑难解答732</span><br><span class="line"></span><br><span class="line"> 第6部分 附赠章 节(本部分内容在光盘中) 第36章 主体文本对象735 36.1 blockquote和q元素对象735 36.1.1 语法735 36.1.2 关于这些对象736 36.1.3 属性736 36.2 br元素对象736 36.2.1 语法736 36.2.2 关于该对象736 36.2.3 属性736 36.3 font元素对象736 36.3.1 语法737 36.3.2 关于本对象737 36.3.3 属性737 36.4 h1…h6元素对象739 36.4.1 语法739 36.4.2 关于这些对象739 36.4.3 属性739 36.5 hr元素对象740 36.5.1 语法740 36.5.2 关于该对象740 36.5.3 属性740 36.6 label元素对象742 36.6.1 语法742 36.6.2 关于该对象742 36.6.3 属性742 36.7 marquee元素对象743 36.7.1 语法743 36.7.2 关于该对象744 36.7.3 属性744 36.8 方法746 36.9 事件处理器746 36.10 Range对象747 36.10.1 语法747 36.10.2 关于该对象748 36.10.3 使用range748 36.10.4 属性749 36.10.5 方法751 36.11selection对象762 36.11.1 语法762 36.11.2 关于该对象762 36.11.3 属性763 36.11.4 方法764 36.12 ext和TextNode对象766 36.12.1 语法767 36.12.2 关于该对象767 36.1.3 属性767 36.12.4 方法768 36.13 extRange对象770 36.13.1 语法771 36.13.2 关于该对象771 36.13.3 使用文本范围772 36.13.4 关于浏览器兼容性773 36.13.5 属性773 36.13.6 方法775 36.14 extRectangle对象790 36.14.1 语法790 36.14.2 关于该对象790 36.14.3 属性791</span><br><span class="line"></span><br><span class="line"> 第37章 HTML指示性对象793 37.1 HTML元素对象793 37.1.1 语法793 37.1.2 关于该对象794 37.1.3 属性794 37.2 head元素对象794 37.2.1 语法794 37.2.2 关于该对象794 37.2.3 属性794 37.3 base元素对象795 37.3.1 语法795 37.3.2 关于该对象795 37.3.3 属性795 37.4 link元素对象795 37.4.1 语法796 37.4.2 关于该对象796 37.4.3 属性796 37.4.4 事件处理器798 37.5 meta元素对象798 37.5.1 语法798 37.5.2 关于该对象798 37.5.3 属性799 37.6 script元素对象799 37.6.1 语法799 37.6.2 关于该对象800 37.6.3 属性800 37.7 title元素对象801 37.7.1 语法801 37.7.2 关于该对象801 37.7.3 属性801</span><br><span class="line"></span><br><span class="line"> 第38章 表和列表对象802 38.1 表对象层次结构802 38.1.1 填充表单元格804 38.1.2 修改表单元格内容804 38.1.3 修改表行805 38.1.4 修改表列809 38.1.5 W3CDOM表对象类811 38.2 table元素对象811 38.2.1 语法812 38.2.2 关于该对象812 38.2.3 属性812 38.2.4 方法820 38.3 tbody、tfoot和thead元素对象822 38.3.1 语法822 38.3.2 关于这些对象822 38.3.3 属性823 38.4 caption元素对象823 38.4.1 语法823 38.4.2 关于该对象823 38.5 col和colgroup元素对象824 38.5.1 语法824 38.5.2 关于这些对象824 38.5.3 属性825 38.6 tr元素对象825 38.6.1 语法825 38.6.2 关于该对象826 38.6.3 属性826 38.6.4 方法827 38.7 td和th元素对象827 38.7.1 语法828 38.7.2 关于这些对象828 38.7.3 属性828 38.8 ol元素对象830 38.8.1 语法830 38.8.2 关于该对象830 38.8.3 属性831 38.9 ul元素对象831 38.9.1 语法832 38.9.2 关于该对象832 38.9.3 属性832 38.10 i元素对象832 38.10.1 语法832 38.10.2 关于该对象832 38.1 0.3 属性832 38.11dl、DT和DD元素对象833 38.11.1 语法833 38.11.2 关于这些对象833 38.12dir和menu元素对象834 38.12.1 语法834 38.12.2 关于这些对象834</span><br><span class="line"></span><br><span class="line"> 第39章 Navigator和其他环境对象835 39.1 clientInformation对象(IE4+)和navigator对象(所有浏览器)835 39.1.1 语法836 39.1.2 关于该对象836 39.1.3 属性836 39.1.4 使用appVersion属性837 39.1.5 userAgent属性细节838 39.1.6 方法846 39.2 mimeType对象849 39.2.1 语法849 39.2.2 关于该对象849 39.2.3 属性849 39.3 plugin对象851 39.3.1 语法851 39.3.2 关于该对象851 39.3.3 属性852 39.3.4 方法852 39.4 查找mime类型和插件程序852 39.4.1 概述：使用mimeType和plugin对象853 39.4.2 验证mime类型853 39.4.3 验证插件程序853 39.4.4 验证插件程序和mime类型854 39.4.5 管理手工插件程序安装855 39.4.6 WinIE中的插件程序检测855 39.5 screen对象857 39.5.1 语法858 39.5.2 关于该对象858 39.5.3 属性858 39.6 userProfile对象860 39.6.1 语法860 39.6.2 关于该对象860 39.6.3 方法862</span><br><span class="line"></span><br><span class="line"> 第40章 定位对象864 40.1 层的概念864 40.2 现代DOM中的定位元素865 40.2.1 改变元素背景865 40.2.2 剪切层866 40.2.3 嵌套层的脚本编写870 40.2.4 将外部HTML装入层874 40.2.5 定位元素的可见行为875 40.2.6 堆栈顺序的脚本编程876 40.2.7 拖动层和调整层的大小877</span><br><span class="line"></span><br><span class="line"> 第41章 嵌入对象882 41.1 applet元素对象883 41.1.1 语法883 41.1.2 关于该对象883 41.1.3 属性884 41.2 object元素885 41.2.1 语法886 41.2.2 关于该对象886 41.2.3 属性886 41.3 embed元素对象890 41.3.1 语法890 41.3.2 关于该对象890 41.3.3 属性890 41.4 param元素的特例891</span><br><span class="line"></span><br><span class="line"> 第42章 正则表达式和RegExp对象892 42.1 正则表达式和模式892 42.2 语言基础893 42.2.1 简单模式893 42.2.2 特殊字符893 42.2.3 分组和向后引用895 42.3 对象关系895 42.4 使用正则表达式897 42.4.1 是否有匹配897 42.4.2 获得匹配信息898 42.4.3 字符串替换900 42.5 正则表达式对象901 42.5.1 语法901 42.5.2 关于该对象901 42.5.3 属性901 42.5.4 方法902 42.6 RegExp对象903 42.6.1 语法903 42.6.2 关于该对象903 42.6.3 属性904</span><br><span class="line"></span><br><span class="line"> 第43章 数据输入验证906 43.1 实时验证与批处理验证906 43.1.1 实时验证触发器906 43.1.2 批处理(模式)验证907 43.2 设计筛选器908 43.3 构建筛选器函数库908 43.3.1 isEmpty()908 43.3.2 isPosInteger()909 43.3.3 isInteger()909 43.3.4 isNumber()909 43.3.5 自定义验证函数909 43.4 复合验证函数910 43.5 日期和时间验证911 43.6 工业级强度的验证方案913 43.6.1 结构913 43.6.2 调度机制914 43.6.3 验证示例915 43.6.4 最后的检查921 43.6.5 检验922 43.7 设计数据验证922</span><br><span class="line"></span><br><span class="line"> 第44章 脚本化Javaapplet和插件923 44.1 NPAPI概述923 44.2 为什么要控制Javaapplet924 44.3 关于Java924 44.3.1 Java基础类924 44.3.2 Java方法924 44.3.3 Javaapplet“属性”926 44.3.4 访问Java字段926 44.4 脚本化applet实练926 44.4.1 了解可脚本化方法926 44.4.2 applet的局限性928 44.4.3 匿名applet929 44.4.4 数据类型转换931 44.5 applet与脚本间的交互&#x2F;通信931 44.5.1 applet需要什么931 44.5.2 HTML需要什么932 44.5.3 关于JSObject类932 44.5.4 数据类型转换933 44.5.5 applet到脚本的应用程序示例933 44.6 插件的脚本化935 44.6.1 HTML端935 44.6.2 API方法936 44.6.3 构建点唱机938 44.6.4 嵌入多个声音939 44.7 直接脚本化Java类941</span><br><span class="line"></span><br><span class="line"> 第45章 脚本调试943 45.1 语法错误与运行时错误943 45.2 错误消息通知943 45.2.1 MozillaConsole窗口944 45.2.2 Safari错误944 45.2.3 多重错误消息944 45.3 详细错误消息945 45.3.1 错误文件名945 45.3.2 错误定位945 45.3.3 错误消息文本946 45.4 Mozilla控制台中的警告949 45.5 问题嗅探949 45.5.1 检查HTML标签949 45.5.2 阅读源代码949 45.5.3 时序问题950 45.5.4 重新打开文档950 45.5.5 找出什么能正常工作950 45.5.6 注释语句951 45.5.7 检查运行时表达式赋值951 45.6 调试工具951 45.6.1 WinIE脚本调试器951 45.6.2 Mazilla的Venkman调试器952 45.6.3 Firefox的FireBug调试器952 45.6.4 Safari的Drosera调试器952 45.6.5 使用可嵌入的Evaluator952 45.6.6 直接赋值953 45.7 一个简单的跟踪工具954 45.7.1 trace()函数954 45.7.2 为trace.js准备文档954 45.7.3 调用trace()955 45.8 浏览器缓存955 45.9 问题预防956 45.9.1 结构正确956 45.9.2 逐步构建956 45.9.3 测试表达式求值956 45.9.4 创建函数工作台956 45.1 0检测作品956</span><br><span class="line"></span><br><span class="line"> 第46章 安全和NetScape签名脚本958 46.1 未雨绸缪958 46.2 当出现冲突时959 46.3 Java沙箱959 46.4 安全策略959 46.5 同源策略960 46.5.1 设置document.domain960 46.5.2 源检查960 46.6 Netscape签名脚本策略961 46.6.1 签名对象和脚本962 46.6.2 从签名脚本能获得什么962 46.7 数字证书962 46.7.1 如何获得证书962 46.7.2 激活codebase原则963 46.8 脚本签名963 46.8.1 签名工具963 46.8.2 准备好为脚本签名964 46.8.3 访问签名脚本964 46.8.4 编辑和移动签名脚本964 46.9 访问受保护的属性和方法964 46.9.1 获得权限964 46.9.2 指定目标965 46.10 脚本中加入权限966 46.10.1 保持小窗口966 46.10.2 考虑用户966 46.11 示例966 46.11.1 访问私有浏览器信息966 46.11.2 访问受保护的窗口属性967 46.12 处理权限管理器错误967 46.13 签名脚本其他相关事宜968 46.13.1 导出和导入签名脚本968 46.13.2 锁定签名页面968 46.13.3 国际字符968</span><br><span class="line"></span><br><span class="line"> 第47章 跨浏览器动态HTML问题969 47.1 什么是DHTML969 47.2 力争兼容性970 47.3 处理不兼容性971 47.3.1 老式兼容技巧971 47.3.2 现代方法实现兼容性973 47.3.3 处理非DHTML浏览器975 47.4 DHTMLAPI示例975</span><br><span class="line"></span><br><span class="line"> 第48章 InternetExplorer的行为977 48.1 脚本样式表977 48.2 嵌入行为组件978 48.2.1 链入行为组件978 48.2.2 启用和禁用行为978 48.3 组件结构978 48.3.1 脚本语句978 48.3.2 变量的作用域979 48.3.3 指派事件处理器979 48.3.4 导出属性和方法979 48.4 行为示例979 48.4.1 示例1：元素拖动行为980 48.4.2 示例2：文本的鼠标划过行为981 48.5 参考资料983</span><br><span class="line"></span><br><span class="line"> 第49章 应用程序：表格和日历984 49.1 关于日历984 49.2 静态表格985 49.3 动态表格986 49.4 混用988 49.5 动态HTML表格988 49.6 深层思考991</span><br><span class="line"></span><br><span class="line"> 第50章 应用程序：查找表992 50.1 无服务器数据库992 50.2 数据库992 50.3 实现计划993 50.4 代码993 50.5 深层思考998</span><br><span class="line"></span><br><span class="line"> 第51章 应用程序：较小的订单999 51.1 确定任务999 51.2 设计表单1000 51.3 表单HTML和脚本1000 51.3.1 全局调整1000 51.3.2 数学计算1001 51.3.3 “炮制”HTML1002 51.3.4 丢掉冗长1002 51.3.5 取回冗长1002 51.4 深层思考1003</span><br><span class="line"></span><br><span class="line"> 第52章 应用程序：分级式目录1004 52.1 实现计划1004 52.2 代码1005 52.2.1 设置框架1005 52.2.2 分级结构代码1005 52.2.3 装配分级目录1007 52.3 Ajax(XML)分级结构1008 52.3.1 XML规范的生成1008 52.3.2 OPML分级属性1009 52.3.3 XML和HTML代码1009 52.3.4 设置脚本状态1010 52.3.5 堆积HTML1011 52.3.6 开关节点展开1013 52.3.7 结束1014 52.4 深层思考1014</span><br><span class="line"></span><br><span class="line"> 第53章 应用程序：计算和绘图1015 53.1 计算1015 53.2 用户界面构思1015 53.3 代码1016 53.3.1 基本数组1016 53.3.2 计算和格式化1017 53.3.3 预加载图片1017 53.3.4 任意更换图片1018 53.3.5 创建select对象1018 53.3.6 绘制初始图片1019 53.4 深层思考1020</span><br><span class="line"></span><br><span class="line"> 第54章 应用程序：智能Updated标志位1021 54.1 Cookie之谜1021 54.2 时间不在你这一边1022 54.3 应用程序1022 54.4 代码1023 54.4.1 设置状态1024 54.4.2 日期比较1025 54.4.3 实时body1025 54.5 深层思考1026</span><br><span class="line"></span><br><span class="line"> 第55章 应用程序：DecisionHelper1027 55.1 应用程序1027 55.2 设计1027 55.3 文件1028 55.4 代码1028 55.4.1 index.htm1029 55.4.2 dhNav.htm1032 55.4.3 dh1.htm1033 55.4.4 dh2.htm1034 55.4.5 dh3.htm1035 55.4.6 dh4.htm1037 55.4.7 dh5.htm1038 55.4.8 dhHelp.htm1040 55.5 深层思考1041</span><br><span class="line"></span><br><span class="line"> 第56章 应用程序：跨浏览器DHTML拼图游戏1042 56.1 拼图设计1042 56.2 实现细节1043 56.2.1 自定义API1043 56.2.2 主程序1043 56.3 本课要点1050</span><br><span class="line"></span><br><span class="line"> 第57章 转换XML数据1051 57.1 应用程序概述1051 57.2 实施计划1052 57.3 代码1053 57.3.1 样式表1053 57.3.2 初始化序列1053 57.3.3 转换数据1054 57.3.4 JavaScript数据库排序1055 57.3.5 构建表格1058 57.3.6 选择控件1059 57.4 构想其他视图1060</span><br><span class="line"></span><br><span class="line"> 第58章 应用程序：创建自定义google地图1061 58.1 GoogleMaps入门1061 58.2 GoogleMaps定制基础1063 58.2.1 获得自己的API密钥1063 58.2.2 GoogleMapsAPI内部1063 58.2.3 获得地点的地理坐标1064 58.3 设计GoogleMaps应用1065 58.4 开发自定义地图文档1065 58.5 整合自定义GoogleMap1066 58.5.1 显示自定义地图1066 58.5.2 自定义信息窗口样式设计1068 58.5.3 测试成品地图1069 58.6 深层思考1069</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B002BNKWI4/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B002BNKWI4&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51qTjtrJdeL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery用户界面库学习指南</title>
    <url>/2020/04/19/B002T1G8XQ/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： jQuery用户界面库学习指南<br>作者信息： 作者: 韦尔曼(Dan Wellman) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《jQuery用户界面库学习指南》提供了使用jQuery用户界面库的完整体验.书中依次介绍了每种组件，并通过大量从初级到高级用法的示例，循序渐进地帮助读者掌握这些知识。《jQuery用户界面库学习指南》内容：用tab和aCCordion形式将相关内容的不同部分组织起来以节省页面空间；使用对话框控件显示消息、图片和表单型的交互内容；在应用程序中使用滑动条进行音量或颜色控制，通过动态地左右拖动来显示不同的取值范围；允许页面访问者通过日期选择控件从日历中选择日期；使用自动完成控件丰富页面功能；提供拖放机制使用户能够直接安排页面中的各种元素；选择元素群组中的几个元素。并对它们应用统一的动作；创建带有多个内容框的页面。并且根据访问者的个性化需求,将这些内容框排列到不同的位置。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章　jQuery UI简介　1</span><br><span class="line">1.1　本书适合我吗　2</span><br><span class="line">1.2　程序库的下载　3</span><br><span class="line">1.3　建立开发环境　4</span><br><span class="line">1.4　程序库结构　4</span><br><span class="line">1.4.1　单元测试　5</span><br><span class="line">1.4.2　控件主题　6</span><br><span class="line">1.4.3　简化的打包组件　6</span><br><span class="line">1.5　主题定制器　7</span><br><span class="line">1.6　简化的API　8</span><br><span class="line">1.7　组件的类别　9</span><br><span class="line">1.8　浏览器支持　10</span><br><span class="line">1.9　本书范例　10</span><br><span class="line">1.10　程序库的许可　11</span><br><span class="line">1.11　小结　11 </span><br><span class="line"></span><br><span class="line"> 第2章　选项卡控件　13 2.1　选项卡的基本实现　14 2.2　选项卡风格　16 2.3　可配置属性　17 2.4　过渡效果　21 2.5　选项卡控件的事件　23 2.6　使用选项卡方法　27 2.6.1　激活和禁用选项卡　27 2.6.2　增加和除去选项卡　29 2.6.3　模拟点击　32 2.6.4　创建选项卡的幻灯效果　33 2.7　AJAX选项卡　36 2.8　选项卡的乐趣　43 2.9　小结　46</span><br><span class="line"></span><br><span class="line"> 第3章　Accordion控件　47 3.1　Accordion控件的结构　48 3.2　设置Accordion的样式　50 3.3　配置accordion　55 3.4　Accordion控件的方法　61 3.4.1　销毁方法　61 3.4.2　激活和禁用　63 3.4.3　打开“抽屉”　68 3.5　Accordion动画　69 3.6　Accordion事件　72 3.7　Accordion的乐趣　73 3.8　小结　78</span><br><span class="line"></span><br><span class="line"> 第4章　对话框　79 4.1　基本对话框　80 4.2　自定义对话框皮肤　82 4.3　对话框属性　85 4.4　使用对话框的回调属性　90 4.5　使用对话框动画　92 4.6　以编程方式控制对话框　94 4.7　从对话框中获取数据　99 4.8　对话框的乐趣　102 4.9　小结　107</span><br><span class="line"></span><br><span class="line"> 第5章　滑动条　108 5.1　实现滑动条　109 5.2　改写默认的主题　110 5.3　可配置属性　113 5.4　使用滑动条的回调函数　116 5.5　滑动条的方法　119 5.6　滑动条动画　122 5.7　多手柄的滑动条　122 5.8　滑动条的乐趣　125 5.9　小结　129</span><br><span class="line"></span><br><span class="line"> 第6章　日期选择器　130 6.1　默认的日期选择器　131 6.2　定制日期选择器的皮肤　132 6.3　日期选择器的可配置属性　135 6.3.1　改变日期的格式　138 6.3.2　本地化　140 6.3.3　回调属性　146 6.3.4　触发按钮　149 6.3.5　多月选择　150 6.3.6　激活日期范围选择　152 6.3.7　配置可选动画　154 6.3.8　日期选择控件的方法　155 6.4　日期选择器的乐趣　165 6.5　小结　172</span><br><span class="line"></span><br><span class="line"> 第7章　自动完成控件　173 7.1　基 本 实 现　174 7.2　可配置属性　175 7.2.1　滚动　178 7.2.2　自动完成控件的样式　180 7.2.3　多项选择　185 7.2.4　高级格式　186 7.2.5　匹配属性　192 7.2.6　远程数据　194 7.2.7　向服务端发送附加数据　196 7.2.8　缓存　197 7.3　自动完成控件的方法　197 7.4　自动完成控件的乐趣　200 7.5　小结　204</span><br><span class="line"></span><br><span class="line"> 第8章　拖放组件　205 8.1　使用拖放组件　206 8.2　拖动助手　206 8.3　配置拖动属性　208 8.3.1　重设拖动后的元素　212 8.3.2　拖动手柄　213 8.3.3　Helper元素　215 8.3.4　限制拖动区域　218 8.3.5　Snapping　220 8.4　拖动事件回调函数　222 8.5　使用拖动组件的方法　227 8.6　投放组件　229 8.7　配置投放对象　231 8.8　投放事件回调函数　238 8.9　投放组件的方法　245 8.10　投放组件的乐趣　245 8.11　小结　250</span><br><span class="line"></span><br><span class="line"> 第9章　尺寸改变组件　252 9.1　尺寸改变组件的基本实现　253 9.2　定制尺寸改变组件的皮肤　255 9.3　尺寸改变组件的属性　256 9.3.1　配置尺寸改变手柄　257 9.3.2　定义尺寸限制　260 9.3.3　尺寸改变的阴影（ghosts）　262 9.3.4　限制尺寸改变的范围和宽高比　264 9.3.5　尺寸改变动画　266 9.4　尺寸改变组件的回调函数　268 9.5　尺寸改变组件的方法　271 9.6　尺寸改变组件的乐趣　271 9.7　小结　274</span><br><span class="line"></span><br><span class="line"> 第10章　选择组件　275 10.1　基本实现　275 10.2　Selectee样式类名　279 10.2.1　选择类的配置属性　280 10.2.2　过滤选择项　280 10.3　选择组件的回调函数　282 10.4　选择组件的方法　285 10.5　选择组件的乐趣　289 10.6　小结　301</span><br><span class="line"></span><br><span class="line"> 第11章　排序组件　302 11.1　基本实现　302 11.2　配置排序组件的属性　306 11.2.1　占位符　311 11.2.2　排序助手　313 11.2.3　排序条目　315 11.2.4　连接列表　317 11.3　对排序事件的响应　321 11.4　连接列表的相关回调属性　327 11.5　排序方法　330 11.6　控件兼容性　334 11.7　排序组件的乐趣　336 11.8　小结　352</span><br><span class="line"></span><br><span class="line"> 第12章　UI特效　353 12.1　核心特效文件　354 12.1.1　颜色动画　354 12.1.2　样式类切换　356 12.1.3　高级缓冲动画　358 12.2　highlight　359 12.3　boucing　361 12.4　shaking　363 12.5　transference　365 12.6　scaling　368 12.7　element explosion　370 12.8　puff特效　372 12.9　pulsate　374 12.10　drop　376 12.11　slide　379 12.12　clip　382 12.13　blind　383 12.14　fold　385 12.15　小结　388</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B002T1G8XQ/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B002T1G8XQ&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/514s2zp-XGL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Python高级编程</title>
    <url>/2020/04/19/B0031M9GIG/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Python高级编程<br>作者信息： 作者: 夏海轮 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Python专家TarekZiade将带你漫游Python应用程序开发的全过程。《Python高级编程》首先介绍如何配置最优的开发环境，然后以Python敏捷开发方法为线索，告诉你如何将经过验证的面向对象原则应用到自己的设计中。《Python高级编程》是关于Python最佳实践以及适用于Python应用程序的敏捷开发方法的权威说明，用实例展示了设计、编码和交付Python软件的实践过程。  你将从《Python高级编程》中学到以下技能：配置高效的开发环境；自定义Python提示符和用于部署的setlJptools；编写高效语法iterator、generator和decorator；根据设计设置参数，遵循设计API的最佳实践；构建、发布和交付应用程序；编写基于多个egg的应用程序；使用zc.buildout交付、部署应用程序；构建并发布软件包，安排开发周期；使用版本管理系统和持续集成策略管理代码；实践测试驱动开发；对代码进行监测与优化。提高软件运行速度；在应用程序中使用设计模式。  旧金山湾Python社区主持人  Shannon-jj Behrens倾情作序</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章　准备工作　1</span><br><span class="line">1.1　安装Python　1</span><br><span class="line">1.1.1　Python实现版本　2</span><br><span class="line">1.1.2　在Linux环境下安装　3</span><br><span class="line">1.1.3　在Windows环境下安装　5</span><br><span class="line">1.1.4　在Mac OS X环境下安装　8</span><br><span class="line">1.2　Python命令行　9</span><br><span class="line">1.2.1　定制交互式命令行　10</span><br><span class="line">1.2.2　iPython：增强型命令行　11</span><br><span class="line">1.3　安装setuptools　12</span><br><span class="line">1.3.1　工作原理　12</span><br><span class="line">1.3.2　使用EasyInstall安装setuptools　13</span><br><span class="line">1.3.3　将MinGW整合到distutils中　15</span><br><span class="line">1.4　工作环境　15</span><br><span class="line">1.4.1　使用文本编辑器与辅助工具的组合　15</span><br><span class="line">1.4.2　使用集成开发环境　19</span><br><span class="line">1.5　小结　22 </span><br><span class="line"></span><br><span class="line"> 第2章　语法最佳实践——低于类级　23 2.1　列表推导　24 2.2　迭代器和生成器　25 2.2.1　生成器　27 2.2.2　协同程序　31 2.2.3　生成器表达式　33 2.2.4　itertools模块　34 2.3　装饰器　37 2.3.1　如何编写装饰器　39 2.3.2　参数检查　40 2.3.3　缓存　42 2.3.4　代理　45 2.3.5　上下文提供者　46 2.4　with和contextlib　47 2.4.1　contextlib模块　49 2.4.2　上下文实例　50 2.5　小结　52</span><br><span class="line"></span><br><span class="line"> 第3章　语法最佳实践——类级　53 3.1　子类化内建类型　53 3.2　访问超类中的方法　55 3.2.1　理解Python的方法解析顺序　56 3.2.2　super的缺陷　60 3.3　最佳实践　63 3.4　描述符和属性　64 3.4.1　描述符　65 3.4.2　属性　71 3.5　槽　74 3.6　元编程　75 3.6.1　new方法　75 3.6.2　metaclass方法　77 3.7　小结　80</span><br><span class="line"></span><br><span class="line"> 第4章　选择好的名称　81 4.1　PEP 8和命名最佳实践　81 4.2　命名风格　82 4.2.1　变量　82 4.2.2　函数和方法　86 4.2.3　属性　88 4.2.4　类　89 4.2.5　模块和包　89 4.3　命名指南　90 4.3.1　使用“has”或“is”前缀命名布尔元素　90 4.3.2　用复数形式命名序列元素　90 4.3.3　用显式的名称命名字典　90 4.3.4　避免通用名称　91 4.3.5　避免现有名称　91 4.4　参数最佳实践　92 4.4.1　根据迭代设计构建参数　92 4.4.2　信任参数和测试　93 4.4.3　小心使用*args和**kw魔法参数　94 4.5　类名　96 4.6　模块和包名称　96 4.7　使用API　97 4.7.1　跟踪冗长　97 4.7.2　构建命名空间树　98 4.7.3　分解代码　100 4.7.4　使用Egg　101 4.7.5　使用deprecation过程　101 4.8　有用的工具　102 4.8.1　Pylint　103 4.8.2　CloneDigger　104 4.9　小结　105</span><br><span class="line"></span><br><span class="line"> 第5章　编写一个包　106 5.1　用于所有包的公共模式　106 5.2　基于模板的方法　118 5.2.1　Python Paste　118 5.2.2　创建模板　120 5.3　创建包模板　120 5.4　开发周期　125 5.5　小结　128</span><br><span class="line"></span><br><span class="line"> 第6章　编写一个应用程序　129 6.1　Atomisator概述　129 6.2　整体描述　130 6.3　工作环境　131 6.3.1　添加一个测试运行程序　133 6.3.2　添加一个包结构　133 6.4　编写各个包　134 6.4.1　atomisator.parser　134 6.4.2　atomisator.db　139 6.4.3　atomisator.feed　143 6.4.4　atomisator.main　145 6.5　分发Atomisator　147 6.6　包之间的依赖性　148 6.7　小结　149</span><br><span class="line"></span><br><span class="line"> 第7章　使用zc.buildout　150 7.1　zc.buildout原理　151 7.1.1　配置文件结构　151 7.1.2　buildout命令　152 7.1.3　recipe　154 7.1.4　Atomisator buildout环境　157 7.1.5　更进一步　158 7.2　发行与分发　159 7.2.1　发行包　160 7.2.2　添加一个发行配置文件　160 7.2.3　构建和发行应用程序　161 7.3　小结　162</span><br><span class="line"></span><br><span class="line"> 第8章　代码管理　163 8.1　版本控制系统　163 8.1.1　集中式系统　163 8.1.2　分布式系统　165 8.1.3　集中还是分布　167 8.1.4　Mercurial　167 8.1.5　使用Mercurial进行项目管理　171 8.2　持续集成　178 8.3　小结　183</span><br><span class="line"></span><br><span class="line"> 第9章　生命周期管理　184 9.1　不同的方法　184 9.1.1　瀑布开发模型　184 9.1.2　螺旋开发模型　185 9.1.3　迭代开发模型　185 9.2　定义生命周期　187 9.2.1　计划　188 9.2.2　开发　188 9.2.3　整体调试　188 9.2.4　发行　188 9.3　建立一个跟踪系统　189 9.3.1　Trac　189 9.3.2　使用Trac管理项目生命周期　194 9.4　小结　196</span><br><span class="line"></span><br><span class="line"> 第10章　编写项目文档　197 10.1　技术性写作的7条规则　197 10.1.1　分两步编写　198 10.1.2　以读者为目标　199 10.1.3　使用简单的风格　199 10.1.4　限制信息的范围　200 10.1.5　使用真实的代码示例　200 10.1.6　保持简单，够用即可　201 10.1.7　使用模板　202 10.2　reStructuredText入门　202 10.2.1　小节结构　204 10.2.2　列表　205 10.2.3　内联标签　205 10.2.4　文字块　206 10.2.5　链接　206 10.3　构建文档　207 10.4　建立自己的工件集　214 10.5　小结　220</span><br><span class="line"></span><br><span class="line"> 第11章　测试驱动开发　221 11.1　我不测试　221 11.1.1　测试驱动开发原理　221 11.1.2　哪一类测试　225 11.2　我测试　229 11.2.1　Unittest的缺陷　229 11.2.2　Unittest替代品　230 11.2.3　仿真和模拟　236 11.2.4　文档驱动开发　240 11.3　小结　242</span><br><span class="line"></span><br><span class="line"> 第12章　优化：通用原则和剖析技术　243 12.1　优化的3条规则　243 12.1.1　首先使它能够正常工作　243 12.1.2　从用户的观点进行　244 12.1.3　保持代码易读(从而易于维护)　245 12.2　优化策略　245 12.2.1　寻找其他原因　245 12.2.2　度量硬件　246 12.2.3　编写速度测试　246 12.3　查找瓶颈　247 12.3.1　剖析CPU的使用情况　247 12.3.2　剖析内存使用情况　256 12.3.3　剖析网络使用情况　262 12.4　小结　263</span><br><span class="line"></span><br><span class="line"> 第13章　优化：解决方案　264 13.1　降低复杂度　265 13.1.1　测量回路复杂度　265 13.1.2　测量大O记号　265 13.1.3　简化　268 13.2　多线程　274 13.2.1　什么是多线程　274 13.2.2　Python处理线程的方式　274 13.2.3　什么时候应该使用线程　275 13.3　多进程　280 13.4　缓存　284 13.4.1　确定性缓存　284 13.4.2　非确定性缓冲　287 13.4.3　主动式缓冲　288 13.5　小结　289</span><br><span class="line"></span><br><span class="line"> 第14章　有用的设计模式　290 14.1　创建型模式　290 14.2　结构型模式　293 14.3　行为型模式　299 14.3.1　观察者　299 14.3.2　访问者　301 14.3.3　模板　304 14.4　小结　306</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0031M9GIG/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0031M9GIG&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51FjDNvQcjL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Cookbook(第2版)中文版</title>
    <url>/2020/04/19/B003LPO4KS/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Python Cookbook(第2版)中文版<br>作者信息： 作者: 马特利(Alex Martelli) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Python Cookbook(第2版)中文版》是在Python程序员圈子中备受推崇的一部著作。在《Python Cookbook(第2版)中文版》中，你会发现很多常见Python编程问题的实用解决方案，而这些方案来自Python社区。几年来，Python程序员在 ActiveState建立的在线Python Cookbook贡献的代码和文章构成了《Python Cookbook(第2版)中文版》的主体。这些代码和解决方案都经历过实践的检验，被反复地审查、精练和加强，并最终汇集到《Python Cookbook(第2版)中文版》中。《Python Cookbook(第2版)中文版》包含了三百多个解决方案和技巧，主要覆盖以下主题：搜索和排序；操纵文本；文件处理；面向对象编程；多线程编程；系统管理；Web编程；网络编程；XML处理；分布式编程；调试和测试；元编程。《Python Cookbook(第2版)中文版》中所有的方案和技巧都是根据不同的主题来组织的。每章以一段引言开始，这些引言的作者都是Python社区中知名的杰出人物。《Python Cookbook(第2版)中文版》的主要编辑是Alex Martelli他也是Python in a Nutshell一书的作者。Anna MartelliRavensCroft是一位热心的Python用户和会议发言者。ACtiveState的David Ascher是LearningPython一书的合著者之一。Python之父Guido van Rossum为《Python Cookbook(第2版)中文版》第13章撰写了引言。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 文本 1</span><br><span class="line">引言 1</span><br><span class="line">1.1 每次处理一个字符 6</span><br><span class="line">1.2 字符和字符值之间的转换 7</span><br><span class="line">1.3 测试一个对象是否是类字符串 8</span><br><span class="line">1.4 字符串对齐 10</span><br><span class="line">1.5 去除字符串两端的空格 11</span><br><span class="line">1.6 合并字符串 11</span><br><span class="line">1.7 将字符串逐字符或逐词反转 14</span><br><span class="line">1.8 检查字符串中是否包含某字符集合中的字符 15</span><br><span class="line">1.9 简化字符串的translate方法的使用 18</span><br><span class="line">1.10 过滤字符串中不属于指定集合的字符 20</span><br><span class="line">1.11 检查一个字符串是文本还是二进制 23</span><br><span class="line">1.12 控制大小写 25</span><br><span class="line">1.13 访问子字符串 26</span><br><span class="line">1.14 改变多行文本字符串的缩进 29</span><br><span class="line">1.15 扩展和压缩制表符 31</span><br><span class="line">1.16 替换字符串中的子串 33</span><br><span class="line">1.17 替换字符串中的子串-Python 2.4 34</span><br><span class="line">1.18 一次完成多个替换 36</span><br><span class="line">1.19 检查字符串中的结束标记 39</span><br><span class="line">1.20 使用Unicode来处理国际化文本 40</span><br><span class="line">1.21 在Unicode和普通字符串之间转换 43</span><br><span class="line">1.22 在标准输出中打印Unicode字符 45</span><br><span class="line">1.23 对Unicode数据编码并用于XML和HTML 46</span><br><span class="line">1.24 让某些字符串大小写不敏感 49</span><br><span class="line">1.25 将HTML文档转化为文本显示到UNIX终端上 52 </span><br><span class="line"></span><br><span class="line"> 第2章 文件 55 引言 55 2.1 读取文件 59 2.2 写入文件 62 2.3 搜索和替换文件中的文本 64 2.4 从文件中读取指定的行 65 2.5 计算文件的行数 66 2.6 处理文件中的每个词 68 2.7 随机输入&#x2F;输出 70 2.8 更新随机存取文件 71 2.9 从zip文件中读取数据 73 2.10 处理字符串中的zip文件 74 2.11 将文件树归档到一个压缩的tar文件 76 2.12 将二进制数据发送到Windows的标准输出 77 2.13 使用C++的类iostream语法 78 2.14 回退输入文件到起点 80 2.15 用类文件对象适配真实文件对象 83 2.16 遍历目录树 84 2.17 在目录树中改变文件扩展名 85 2.18 从指定的搜索路径寻找文件 86 2.19 根据指定的搜索路径和模式寻找文件 87 2.20 在Python的搜索路径中寻找文件 88 2.21 动态地改变Python搜索路径 89 2.22 计算目录间的相对路径 91 2.23 跨平台地读取无缓存的字符 93 2.24 在Mac OS X平台上统计PDF文档的页数 94 2.25 在Windows平台上修改文件属性 95 2.26 从OpenOffice.org文档中提取文本 96 2.27 从微软Word文档中抽取文本 97 2.28 使用跨平台的文件锁 98 2.29 带版本号的文件名 100 2.30 计算CRC-64循环冗余码校验 102</span><br><span class="line"></span><br><span class="line"> 第3章 时间和财务计算 105 引言 105 3.1 计算昨天和明天的日期 111 3.2 寻找上一个星期五 112 3.3 计算日期之间的时段 114 3.4 计算歌曲的总播放时间 115 3.5 计算日期之间的工作日 116 3.6 自动查询节日 118 3.7 日期的模糊查询 121 3.8 检查夏令时是否正在实行 123 3.9 时区转换 124 3.10 反复执行某个命令 125 3.11 定时执行命令 127 3.12 十进制数学计算 129 3.13 将十进制数用于货币处理 130 3.14 用Python实现的简单加法器 133 3.15 检查信用卡校验和 136 3.16 查看汇率 137</span><br><span class="line"></span><br><span class="line"> 第4章 Python技巧 139 引言 139 4.1 对象拷贝 140 4.2 通过列表推导构建列表 144 4.3 若列表中某元素存在则返回之 146 4.4 循环访问序列中的元素和索引 147 4.5 在无须共享引用的条件下创建列表的列表 148 4.6 展开一个嵌套的序列 149 4.7 在行列表中完成对列的删除和排序 152 4.8 二维阵列变换 154 4.9 从字典中取值 155 4.10 给字典增加一个条目 157 4.11 在无须过多援引的情况下创建字典 158 4.12 将列表元素交替地作为键和值来创建字典 159 4.13 获取字典的一个子集 161 4.14 反转字典 163 4.15 字典的一键多值 164 4.16 用字典分派方法和函数 166 4.17 字典的并集与交集 167 4.18 搜集命名的子项 169 4.19 用一条语句完成赋值和测试 171 4.20 在Python中使用printf 174 4.21 以指定的概率获取元素 174 4.22 在表达式中处理异常 176 4.23 确保名字已经在给定模块中被定义 178</span><br><span class="line"></span><br><span class="line"> 第5章 搜索和排序 180 引言 180 5.1 对字典排序 185 5.2 不区分大小写对字符串列表排序 185 5.3 根据对象的属性将对象列表排序 187 5.4 根据对应值将键或索引排序 189 5.5 根据内嵌的数字将字符串排序 192 5.6 以随机顺序处理列表的元素 193 5.7 在增加元素时保持序列的顺序 195 5.8 获取序列中最小的几个元素 197 5.9 在排序完毕的序列中寻找元素 199 5.10 选取序列中最小的第n个元素 200 5.11 三行代码的快速排序 203 5.12 检查序列的成员 206 5.13 寻找子序列 208 5.14 给字典类型增加排名功能 210 5.15 根据姓的首字母将人名排序和分组 214</span><br><span class="line"></span><br><span class="line"> 第6章 面向对象编程 217 引言 217 6.1 温标的转换 223 6.2 定义常量 225 6.3 限制属性的设置 227 6.4 链式字典查询 229 6.5 继承的替代方案-自动托管 231 6.6 在代理中托管特殊方法 234 6.7 有命名子项的元组 237 6.8 避免属性读写的冗余代码 239 6.9 快速复制对象 240 6.10 保留对被绑定方法的引用且支持垃圾回收 243 6.11 缓存环的实现 245 6.12 检查一个实例的状态变化 249 6.13 检查一个对象是否包含某种必要的属性 252 6.14 实现状态设计模式 255 6.15 实现单例模式 257 6.16 用Borg惯用法来避免“单例”模式 259 6.17 Null对象设计模式的实现 263 6.18 用 init 参数自动初始化实例变量 266 6.19 调用超类的 init 方法 267 6.20 精确和安全地使用协作的超类调用 270</span><br><span class="line"></span><br><span class="line"> 第7章 持久化和数据库 273 引言 273 7.1 使用marshal模块序列化数据 275 7.2 使用pickle和cPickle模块序列化数据 277 7.3 在Pickling的时候压缩 280 7.4 对类和实例使用cPickle模块 281 7.5 Pickling被绑定方法 284 7.6 Pickling代码对象 286 7.7 通过shelve修改对象 288 7.8 使用Berkeley DB数据库 291 7.9 访问MySQL数据库 294 7.10 在MySQL数据库中储存BLOB 295 7.11 在PostgreSQL中储存BLOB 296 7.12 在SQLite中储存BLOB 298 7.13 生成一个字典将字段名映射为列号 300 7.14 利用dtuple实现对查询结果的灵活访问 302 7.15 打印数据库游标的内容 304 7.16 适用于各种DB API模块的单参数传递风格 306 7.17 通过ADO使用Microsoft Jet 308 7.18 从Jython Servlet访问JDBC数据库 310 7.19 通过Jython和ODBC获得Excel数据 313</span><br><span class="line"></span><br><span class="line"> 第8章 调试和测试 315 引言 315 8.1 阻止某些条件和循环的执行 316 8.2 在Linux上测量内存使用 317 8.3 调试垃圾回收进程 318 8.4 捕获和记录异常 320 8.5 在调试模式中跟踪表达式和注释 322 8.6 从traceback中获得更多信息 324 8.7 当未捕获异常发生时自动启用调试器 327 8.8 简单的使用单元测试 328 8.9 自动运行单元测试 330 8.10 在Python 2.4中使用doctest和unittest 331 8.11 在单元测试中检查区间 334</span><br><span class="line"></span><br><span class="line"> 第9章 进程、线程和同步 336 引言 336 9.1 同步对象中的所有方法 339 9.2 终止线程 342 9.3 将Queue.Queue用作优先级队列 344 9.4 使用线程池 346 9.5 以多组参数并行执行函数 349 9.6 用简单的消息传递协调线程 351 9.7 储存线程信息 353 9.8 无线程的多任务协作 357 9.9 在Windows中探测另一个脚本实例的运行 359 9.10 使用MsgWaitForMultipleObjects处理Windows消息 360 9.11 用popen驱动外部进程 363 9.12 获取UNIX Shell命令的输出流和错误流 364 9.13 在UNIX中fork一个守护进程 367</span><br><span class="line"></span><br><span class="line"> 第10章 系统管理 370 引言 370 10.1 生成随机密码 371 10.2 生成易记的伪随机密码 372 10.3 以POP服务器的方式验证用户 375 10.4 统计Apache中每个IP的点击率 376 10.5 统计Apache的客户缓存的命中率 378 10.6 在脚本中调用编辑器 379 10.7 备份文件 381 10.8 选择性地复制邮箱文件 383 10.9 通过邮箱创建一个邮件地址的白名单 384 10.10 阻塞重复邮件 386 10.11 检查你的Windows声音系统 388 10.12 在Windows中注册和反注册DLL 388 10.13 检查并修改Windows自动运行任务 390 10.14 在Windows中创建共享 391 10.15 连接一个正在运行的Internet Explorer实例 392 10.16 读取Microsoft Outlook Contacts 393 10.17 在Mac OS X中收集详细的系统信息 396</span><br><span class="line"></span><br><span class="line"> 第11章 用户界面 400 引言 400 11.1 在文本控制台中显示进度条 402 11.2 避免在编写回调函数时使用lambda 404 11.3 在tkSimpleDialog函数中使用默认值和区间 405 11.4 给Tkinter列表框增加拖曳排序能力 406 11.5 在Tkinter部件中输入一个重音字符 408 11.6 在Tkinter中嵌入内联的GIF 410 11.7 转换图片格式 412 11.8 在Tkinter中实现一个秒表 415 11.9 用线程实现GUI和异步I&#x2F;O 的结合 417 11.10 在Tkinter中使用IDLE的 Tree部件 421 11.11 在Tkinter Listbox中支持单行多值 423 11.12 在Tkinter部件之间复制Geometry方法和选项 427 11.13 在Tkinter中实现一个带标签的记事本 429 11.14 使用wxPython实现带面板的记事本 431 11.15 在Jython中实现一个ImageJ插件 433 11.16 用Swing和Jython来通过URL查看图片 434 11.17 在Mac OS中获得用户输入 434 11.18 程序化地创建Python Cocoa GUI 437 11.19 用IronPython实现淡入窗口 439</span><br><span class="line"></span><br><span class="line"> 第12章 XML处理 441 引言 441 12.1 检查XML的格式完好性 443 12.2 计算文档中标签的个数 444 12.3 获得XML文档中的文本 445 12.4 自动探测XML的编码 447 12.5 将一个XML文档转化成Python对象树 449 12.6 从XML DOM节点的子树中删除仅有空白符的文本节点 451 12.7 解析Microsoft Excel的XML 452 12.8 验证XML文档 454 12.9 过滤属于指定命名空间的元素和属性 455 12.10 用SAX合并连续的文本事件 458 12.11 使用MSHTML来解析XML或HTML 461</span><br><span class="line"></span><br><span class="line"> 第13章 网络编程 462 引言 462 13.1 通过Socket数据报传输消息 464 13.2 从Web抓取文档 466 13.3 过滤FTP站点列表 467 13.4 通过SNTP协议从服务器获取时间 468 13.5 发送HTML邮件 469 13.6 在MIME消息中绑入文件 471 13.7 拆解一个分段MIME消息 474 13.8 删除邮件消息中的附件 475 13.9 修复Python 2.4的email.FeedParser 解析的消息 477 13.10 交互式地检查POP3邮箱 479 13.11 探测不活动的计算机 482 13.12 用HTTP监视网络 487 13.13 网络端口的转发和重定向 489 13.14 通过代理建立SSL隧道 492 13.15 实现动态IP协议 495 13.16 登录到IRC并将消息记录到磁盘 498 13.17 访问LDAP服务 500</span><br><span class="line"></span><br><span class="line"> 第14章 Web编程 502 引言 502 14.1 测试CGI是否在工作 503 14.2 用CGI脚本处理URL 506 14.3 用CGI上传文件 507 14.4 检查web页面的存在 509 14.5 通过HTTP检查内容类型 510 14.6 续传HTTP下载文件 512 14.7 抓取Web页面时处理Cookie 513 14.8 通过带身份验证的代理进行HTTPS导航 516 14.9 用Jython实现Servlet 517 14.10 寻找Internet Explorer的cookie 519 14.11 生成OPML文件 521 14.12 聚合RSS Feed 524 14.13 通过模板将数据放入Web页面 527 14.14 在Nevow中呈现任意对象 530</span><br><span class="line"></span><br><span class="line"> 第15章 分布式编程 534 引言 534 15.1 实现一个XML-RPC方法调用 536 15.2 服务XML-RPC请求 537 15.3 在Medusa中使用XML-RPC 539 15.4 允许XML-RPC服务被远程终止 541 15.5 SimpleXMLRPCServer的一些细节 542 15.6 给一个XML-RPC服务提供一个wxPython GUI 544 15.7 使用Twisted的Perspective Broker 546 15.8 实现一个CORBA服务和客户 549 15.9 使用telnetlib执行远程登录 551 15.10 使用SSH执行远程登录 554 15.11 通过HTTPS验证一个SSL客户端 557</span><br><span class="line"></span><br><span class="line"> 第16章 关于程序的程序 559 引言 559 16.1 验证字符串是否代表着一个合法的数字 564 16.2 导入一个动态生成的模块 565 16.3 导入一个名字在运行时被确定的模块 567 16.4 将参数和函数联系起来 568 16.5 组合函数 571 16.6 使用内建的Tokenizer给Python源码上色 572 16.7 合并和拆解Token 575 16.8 检查字符串是否有平衡的圆括号 577 16.9 在Python中模拟枚举 580 16.10 在创建列表推导时引用它自身 583 16.11 自动化py2exe将脚本编译成Windows可执行文件的过程 585 16.12 在UNIX中将主脚本和模块绑成一个可执行文件 587</span><br><span class="line"></span><br><span class="line"> 第17章 扩展和嵌入 590 引言 590 17.1 实现一个简单的扩展类型 592 17.2 用Pyrex实现一个简单的扩展类型 597 17.3 在Python中使用C++库 598 17.4 调用Windows DLL的函数 601 17.5 在多线程环境中使用SWIG生成的模块 603 17.6 用PySequence_Fast将Python序列转为 C数组 604 17.7 用迭代器逐个访问Python序列的元素 608 17.8 从Python可调用的C函数中返回None 611 17.9 用gdb调试动态载入的C扩展 613 17.10 调试内存问题 614</span><br><span class="line"></span><br><span class="line"> 第18章 算法 616 引言 616 18.1 消除序列中的重复 619 18.2 在保留序列顺序的前提下消除其中的重复 621 18.3 生成回置采样 625 18.4 生成无回置的抽样 626 18.5 缓存函数的返回值 627 18.6 实现一个FIFO容器 629 18.7 使用FIFO策略来缓存对象 631 18.8 实现一个Bag（Multiset）收集类型 634 18.9 在Python模拟三元操作符 637 18.10 计算素数 640 18.11 将整数格式化为二进制字符串 642 18.12 以任意数为基将整数格式化为字符串 644 18.13 通过法雷分数将数字转成有理数 646 18.14 带误差传递的数学计算 648 18.15 以最大精度求和 651 18.16 模拟浮点数 653 18.17 计算二维点集的凸包和直径 656</span><br><span class="line"></span><br><span class="line"> 第19章 迭代器和生成器 660 引言 660 19.1 编写一个类似range的浮点数递增的函数 663 19.2 从任意可迭代对象创建列表 665 19.3 生成Fibonacci序列 667 19.4 在多重赋值中拆解部分项 669 19.5 自动拆解出需要的数目的项 670 19.6 以步长n将一个可迭代对象切成n片 672 19.7 通过重叠窗口循环序列 674 19.8 并行地循环多个可迭代对象 678 19.9 循环多个可迭代对象的矢量积 680 19.10 逐段读取文本文件 683 19.11 读取带有延续符的行 685 19.12 将一个数据块流处理成行流 687 19.13 用生成器从数据库中抓取大记录集 688 19.14 合并有序序列 690 19.15 生成排列、组合以及选择 694 19.16 生成整数的划分 696 19.17 复制迭代器 697 19.18 迭代器的前瞻 701 19.19 简化队列消费者线程 703 19.20 在另一个线程中运行迭代器 705 19.21 用itertools.groupby来计算汇总报告 706</span><br><span class="line"></span><br><span class="line"> 第20章 描述符、装饰器和元类 710 引言 710 20.1 在函数调用中获得常新的默认值 712 20.2 用嵌套函数来编写property属性 715 20.3 给属性值起别名 717 20.4 缓存属性值 719 20.5 用同一个方法访问多个属性 722 20.6 封装一个方法来给类增加功能 723 20.7 增强所有方法来给类增加功能 726 20.8 在运行时给一个类实例添加方法 728 20.9 检查接口的实现 730 20.10 在自定义元类中正确地使用 new 和 init _ 732 20.11 允许对List的可变方法的链式调用 734 20.12 通过更紧凑的语法使用协作的超类调用 736 20.13 不使用 init _来初始化实例属性 738 20.14 实例属性的自动初始化 740 20.15 重新加载时自动更新类实例 743 20.16 在编译时绑定常量 747 20.17 解决元类冲突 752</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B003LPO4KS/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B003LPO4KS&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51GJYR2nXDL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux程序设计(第4版)</title>
    <url>/2020/04/19/B003Q97NPC/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Linux程序设计(第4版)<br>作者信息： 作者: 马修(Neil Matthew) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Linux程序设计(第4版)》：最负盛名的Linux程序设计图书，内容全面深入，全球开源社区集体智慧结晶。时至今日，Linux系统已经从一个个人作品发展为可以用于各种关键任务的成熟、高效和稳定的操作系统，因为具备跨平台、开源、支持众多应用软件和网络协议等优点，它得到了各大主流软硬件厂商的支持，也成为广大程序设计人员理想的开发平台。《Linux程序设计(第4版)》是Linux程序设计领域的经典名著，以简单易懂、内容全面和示例丰富而广受好评。中文版前两版出版后。在国内的Linux爱好者和程序员中引起了强烈反响。这一热潮一直持续至今。《Linux程序设计(第4版)》是国内读者翘首以待的第4版，此次新版内容组织更加严谨，译者更是细心雕琢，保留了这部权威著作的原汁原味。对Ljnux所提供的功能全面而准确的阐述，以及贯穿全书的示例程序体验，使《Linux程序设计(第4版)》不仅成为初学者的最佳Linux程序设计指南。而且是中高级程序员不可或缺的参考书。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 入门</span><br><span class="line">1.1 LNIX、Linux和GNU简介</span><br><span class="line">1.1.1 什么是IYNIX</span><br><span class="line">1.1.2 什么是Linux</span><br><span class="line">1.1.3 GNL，项目和自由软件基金会</span><br><span class="line">1.1.4 Linux发行版</span><br><span class="line">1.2 Linux程序设计.</span><br><span class="line">1.2.1 Linux程序</span><br><span class="line">1.2.2 文本编辑器</span><br><span class="line">1.2.3 C语言编译器</span><br><span class="line">1.2.4 开发系统导引</span><br><span class="line">1.3 获得帮助</span><br><span class="line">1.4 小结 </span><br><span class="line"></span><br><span class="line"> 第2章 shell程序设计 2.1 为什么使用shell编程 2.2 一点哲学 2.3 什么是shell 2.4 管道和重定向 2.4.1 重定向输出 2.4.2 重定向输入 2.4.3 管道 2.5 作为程序设计语言的shell 2.5.1 交互式程序 2.5.2 创建脚本 2.5.3 把脚本设置为可执行 2.6 shell的语法 2.6.1 变量 2.6.2 条件 2.6.3 控制结构 2.6.4 函数 2.6.5 命令 2.6.6 命令的执行 2.6.7 1aere文档 2.6.8 调试脚本程序 2.7 迈向图形化：dialog工具 2.8 综合应用 2.8.1 需求 2.8.2 设计 2.8.3 应用程序的说明 2.9 小结</span><br><span class="line"></span><br><span class="line"> 第3章 文件操作. 3.1 Linux文件结构 3.1.1 目录 3.1.2 文件和设备 3.2 系统调用和设备驱动程序 3.3 库函数 3.4 底层文件访问 3.4.1 write系统调用 3.4.2 read系统调用 3.4.3 open系统调用 3.4.4 访问权限的初始值 3.4.5 其他与文件管理有关的系统调用 3.5 标准I／O库 3.5.1 fopen函数 3.5.2 fread函数 3.5.3 fwrite函数 3.5.4 fclose函数 3.5.5 f￡1ush函数 3.5.6 fseek函数 3.5.7 fgetc、getc和getchar函数 3.5.8 fputc、putc和putchar函数 3.5.9 fgets和gets函数 3.6 格式化输入和输出 3.6.1 printf、fprintf和sprin七函数 3.6.2 scanf、fscanf和sscanf函数 3.6.3 其他流函数 3.6.4 文件流错误 3.6.5 文件流和文件描述符 3.7 文件和目录的维护 3.7.1 chIrrod系统调用 3.7.2 chown系统调用 3.7.3 unlink、1ink和symlink系统调用 3.7.4 mkdJ.r和rmdir系统调用 3.7.5 chdir系统调用和getcwd函数 3.8 扫描目录 3.8.1 opendir函数 3.8.2 readdir函数 3.8.3 elldir函数 3.8.4 see]kdir函数 3.8.5 closedir函数 3.9 错误处理 3.9.1 strerror函数 3.9.2 perror函数 3.10 proc文件系统 3.11 高级主题：fcntl和mmap 3.11.1 fcntl系统调用 3.11.2 map函数 3.12 小结</span><br><span class="line"></span><br><span class="line"> 第4章 Linux环境 4.1 程序参数 4.1.1 qetopt 4.1.2 getooptlong 4.2 环境变量 4.2.1 环境变量的用途 4.2.2 environ变量 4.3 时间和日期 4.4 临时文件 4.5 用户信息 4.6 主机信息 4.7 日志 4.8 资源和限制 4.9 小结</span><br><span class="line"></span><br><span class="line"> 第5章 终端 5.1 对终端进行读写 5.2 与终端进行对话 5.3 终端驱动程序和通用终端接口 5.3.1 概述 5.3.2 硬件模型 5.4 temios结构 5.4.1 输入模式 5.4.2 输出模式 5.4.3 控制模式 5.4.4 本地模式 5.4.5 特殊控制字符 5.4.6 终端速度 5.4.7 其他函数 5.5 终端的输出 5.5.1 终端的类型 5.5.2 识别终端类型 5.5.3 使用teminfo功能标志 5.6 检测击键动作 5.7 虚拟控制台 5.8 伪终端 5.9 小结</span><br><span class="line"></span><br><span class="line"> 第6章 使用curses函数库管理基于文本的屏幕 6.1 用curses函数库进行编译 6.2 curses术语和概念 6.3 屏幕 6.3.1 输出到屏幕 6.3.2 从屏幕读取 6.3.3 清除屏幕 6.3.4 移动光标 6.3.5 字符属性 6.4 键盘 6.4.1 键盘模式 6.4.2 键盘输入 6.5 窗口 6.5.1 wINDOW结构 6.5.2 通用函数 6.5.3 移动和更新窗口 6.5.4 优化屏幕刷新 6.6 子窗口 6.7 keypad模式 6.8 彩色显示 6.9 pad 6.10 CD唱片应用程序 6.10.1 新CD唱片应用程序的开始部分 6.10.2 main函数 6.10.3 建立菜单 6.10.4 操作数据库文件 6.10.5 查询CD数据库 6.11 小结</span><br><span class="line"></span><br><span class="line"> 第7章 数据管理 7.1 内存管理 7.1.1 简单的内存分配 7.1.2 分配大量的内存 7.1.3 滥用内存 7.1.4 空指针 7.1.5 释放内存 7.1.6 其他内存分配函数 7.2 文件锁定 7.2.1 创建锁文件 7.2.2 区域锁定 7.2.3 锁定状态下的读写操作 7.2.4 文件锁的竞争 7.2.5 其他锁命令 7.2.6 死锁 7.3 数据库 7.3.1 dbm数据库 7.3.2 dbm例程 7.3.3 d.bm访问函数 7.3.4 其他dbm函数 7.4 CD唱片应用程序 7.4.1 更新设计 7.4.2 使用dbm数据库的CD唱片应用程序 7.5 小结</span><br><span class="line"></span><br><span class="line"> 第8章 MySQL 8.1 安装 8.1.1 MySQL软件包 8.1.2 安装后的配置 8.1.3 安装后的故障修复 8.2 MySQL管理 8.2.1 命令 8.2.2 创建用户并赋予权限 8.2.3 密码 8.2.4 创建数据库 8.2.5 数据类型 8.2.6 创建表 8.2.7 图形化工具 8.3 使用C语言访问。MySQL数据 8.3.1 连接例程 8.3.2 错误处理 8.3.3 执行SQL语句 8.3.4 更多的函数 8.4 CD数据库应用程序 8.4.1 创建表 8.4.2 添加数据 8.4.3 使用C语言访问数据 8.5 小结</span><br><span class="line"></span><br><span class="line"> 第9章 开发工具 9.1 多个源文件带来的问题 9.2 make命令和makefile文件 9.2.1 mekefile的语法 9.2.2 make命令的选项和参数 9.2.3 makefile文件中的注释 9.2.4 mekefile文件中的宏 9.2.5 多个目标 9.2.6 内置规则 9.2.7 后缀和模式规则 9.2.8 用make管理函数库 9.2.9 高级主题：makefile文件和子目录 9.2.1 0GNUmake和qcc 9.3 源代码控制 9.3.1 RCS 9.3.2 SCCS 9.3.3 RCS和SCCS的比较 9.3.4 CVS 9.3.5 CVS的前端程序 9.3.6 SubvcrsiOn 9.4 编写手册页 9.5 发行软件 9.5.1 pach程序 9.5.2 其他软件发行工具 9.6 RPM软件包 9.6.1 使用RPM软件包文件 9.6.2 安装RPM软件包 9.6.3 创建RPM软件包 9.7 其他软件包格式 9.8 开发环境 9.8.1 KDevelop 9.8.2 其他开发环境 9.9 小结</span><br><span class="line"></span><br><span class="line"> 第10章 调试 10.1 错误类型 10.2 常用调试技巧 10.2.1 有漏洞的程序 10.2.2 代码检查 10.2.3 取样法 10.2.4 程序的受控执行 10.3 使用gdb进行调试 10.3.1 启动gdb 10.3.2 运行一个程序 10.3.3 栈跟踪 10.3.4 检查变量 10.3.5 列出程序源代码 10.3.6 设置断点 10.3.7 用调试器打补丁 10.3.8 深入学习gdb 10.4 其他调试工具 10.4.1 lint清理程序中的“垃圾” 10.4.2 函数调用工具 10.4.3 用prof／gprof产生执行存档 10.5 断言 10.6 内存调试 10.6.1 ElectnicFence函数库 10.6.2 valgrind 10.7 小结</span><br><span class="line"></span><br><span class="line"> 第11章 进程和信号 11.1 什么是进程 11.2 进程的结构 11.2.1 进程表 11.2.2 查看进程 11.2.3 系统进程 11.2.4 进程调度 11.3 启动新进程 11.3.1 等待一个进程 11.3.2 僵尸进程 11.3.3 输入和输出重定向 11.3.4 线程 11.4 信号 11.4.1 发送信号 11.4.2 信号集 11.5 小结</span><br><span class="line"></span><br><span class="line"> 第12章 POSlX线程 12.1 什么是线程 12.2 线程的优点和缺点 12.3 第一个线程程序 12.4 同时执行 12.5 同步 12.5.1 用信号量进行同步 12.5.2 用互斥量进行同步 …… 第13章 进程音通信：管道 第14章 信号量、共享内存和消息队列 第15章 套接字 第16章 用GTK+进行+GNOME编程 第17章 用Qt进行KDE编程 第18章 Linux标准</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B003Q97NPC/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B003Q97NPC&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51L1Hqh7vNL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>SEO必知必会51技</title>
    <url>/2020/04/19/B003M92AJK/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： SEO必知必会51技<br>作者信息： 作者: 利布(Rebecca Lieb) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《SEO必知必会51技》：大道至简的SEO思想高效卓著的SEO技巧网络营销人员的掌中宝还在苦于你的SEO没有带来流量么?或许你还游离在某些技巧之外，从而觉得：SEO与管理、营销和公共关系领域毫不相干；关键词?链接策略?开玩笑!我可以随处spam；SEO还需要技巧?我分分钟就可以搞定。来自一线专家的51条技巧将颠覆你原有的SEO理念，让你快速掌握实用的SEO技能。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1部分 搜索引擎的基本知识</span><br><span class="line">第1技 获得蜘蛛、机器人和爬虫的关注</span><br><span class="line">第2技 学会与Google共舞</span><br><span class="line">第3技 流量？不，是有价值的流量</span><br><span class="line">第4技 网上有你的口碑 </span><br><span class="line"></span><br><span class="line"> 第2部分 让站点脱颖而出 第5技 SEO是一个持续性工程，千万别做完了就扔在那 第6技 SEO不是马后炮 第7技 SEO效果不是马上生效，也不是持久不变 第8技 你不再有主页 第9技 就算不是出版商，你也要像他们一样思考 第10技 网站和网页设计盘点 第11技 为用户撰写内容，搜索引擎随之而至 第12技 关键字才是关键 第13技 使用关键字分析和研究工具 第14技 网站统计也会带来坏消息 第15技 对新技术要三思而后行 第16技 内容管理系统的问题多多</span><br><span class="line"></span><br><span class="line"> 第3部分 这就是奇妙的标签 第17技 标题中有什么？所有…… 第18技 元标签的相对重要性 第19技 图像、音频、视频和其他媒体的标签问题</span><br><span class="line"></span><br><span class="line"> 第4部分 关于链接 第20技 相同的链接在搜索引擎面前会出现不同的结果 第21技 通过目录网站建立链接 第22技 将SEO公共关系作为链接策略 第23技 付费链接 第24技 交换链接 第25技 广告也是链接 第26技 让您的网站择邻而居 第27技 博客是巧妙的链接策略 第28技 关于nofollow</span><br><span class="line"></span><br><span class="line"> 第5部分 那些也是搜索引擎吗 第29技 搜索正在垂直化 第30技 本地搜索 第31技 目录网站提交 第32技 站外搜索引擎优化 第33技 通用搜索和个性化搜索</span><br><span class="line"></span><br><span class="line"> 第6部分 你生活在社会化网络中 第34技 为搜索引擎优化建立博客 第35技 使用RSS feeds来提升搜索引擎优化工作效果 第36技 让用户为你创建内容 第37技 为图像、视频、链接和其他媒体打上标签</span><br><span class="line"></span><br><span class="line"> 第7部分 搜索排名 第38技 排名 第一的悄然改变 第39技 PageRank不是关系网站生死存亡的关键因素 第40技 摇摆的长尾</span><br><span class="line"></span><br><span class="line"> 第8部分 关于SEO管理 第41技 内部维护还是外包 第42技 雇用一名优秀的搜索专家 第43技 优秀的SEO应该注重细节的东西</span><br><span class="line"></span><br><span class="line"> 第9部分 不作恶 第44技 小心黑帽搜索引擎优化 第45技 搜索引擎对关键词堆砌和垃圾广告不“感冒” 第46技 不要建立链接工厂 第47技 想取消屏蔽是很难的 第48技 换到新域名将面临一定的压力</span><br><span class="line"></span><br><span class="line"> 第10部分 除此以外 第49技 全球搜索引擎优化 第50技 移动SEO比以往更重要 第51技 有时候你并不希望被找到</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B003M92AJK/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B003M92AJK&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41GPjazVaHL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX网络编程(卷1) 套接字联网API(第3版)</title>
    <url>/2020/04/19/B003SWP8XG/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： UNIX网络编程(卷1) 套接字联网API(第3版)<br>作者信息： 作者: 史蒂文斯(W.Richard Stevens) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《UNIX网络编程(卷1):套接字联网API(第3版)》中顶级网络编程专家Bill Fenner和Andrew M. Rudoff应邀执笔，对W. Richard Stevens的经典作品进行修订。书中吸纳了近几年网络技术的发展，增添了IPv6、SCTP协议和密钥管理套接字等内容，深入讨论了最新的关键标准、实现和技术。书中的所有示例都是在UNIX系统上测试通过的真实的、可运行的代码，继承了Stevens一直强调的理念：“学习网络编程的最好方法就是下载这些程序，对其进行修改和改进。只有这样实际编写代码才能深入理解有关概念和方法。”读者可以从图灵网站《UNIX网络编程(卷1):套接字联网API(第3版)》网页免费注册下载这些示例的源代码。 《UNIX网络编程(卷1):套接字联网API(第3版)》为UNIX网络编程提供全面的指导，是网络研究和开发人员公认的权威参考书，无论网络编程的初学者还是网络专家都会大受裨益。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分 简介和TCP&#x2F;IP</span><br><span class="line">第1章 简介 2</span><br><span class="line">1.1 概述 2</span><br><span class="line">1.2 一个简单的时间获取客户程序 5</span><br><span class="line">1.3 协议无关性 9</span><br><span class="line">1.4 错误处理：包裹函数 10</span><br><span class="line">1.5 一个简单的时间获取服务器程序 12</span><br><span class="line">1.6 本书中客户&#x2F;服务器程序示例索引表 14</span><br><span class="line">1.7 OSI模型 16</span><br><span class="line">1.8 BSD网络支持历史 17</span><br><span class="line">1.9 测试用网络及主机 19</span><br><span class="line">1.10 Unix标准 22</span><br><span class="line">1.11 64位体系结构 24</span><br><span class="line">1.12 小结 25</span><br><span class="line">习题 25 </span><br><span class="line"></span><br><span class="line"> 第2章 传输层：TCP、UDP和SCTP 27 2.1 概述 27 2.2 总图 27 2.3 用户数据报协议（UDP） 29 2.4 传输控制协议（TCP） 30 .2.5 流控制传输协议（SCTP） 31 2.6 TCP连接的建立和终止 31 2.7 TIME_WAIT状态 37 2.8 SCTP关联的建立和终止 38 2.9 端口号 42 2.10 TCP端口号与并发服务器 43 2.11 缓冲区大小及限制 45 2.12 标准因特网服务 50 2.13 常见因特网应用的协议使用 51 2.14 小结 52 习题 53</span><br><span class="line"></span><br><span class="line"> 第二部分 基本套接字编程 第3章 套接字编程简介 56 3.1 概述 56 3.2 套接字地址结构 56 3.3 值-结果参数 61 3.4 字节排序函数 63 3.5 字节操纵函数 66 3.6 inet_aton、inet_addr和inet_ntoa函数 67 3.7 inet_pton和inet_ntop函数 68 3.8 sock_ntop和相关函数 70 3.9 readn、writen和readline函数 72 3.10 小结 76 习题 76</span><br><span class="line"></span><br><span class="line"> 第4章 基本TCP套接字编程 77 4.1 概述 77 4.2 socket函数 77 4.3 connect函数 80 4.4 bind函数 81 4.5 listen函数 84 4.6 accept函数 88 4.7 fork和exec函数 90 4.8 并发服务器 91 4.9 close函数 93 4.10 getsockname和getpeername函数 94 4.11 小结 96 习题 96</span><br><span class="line"></span><br><span class="line"> 第5章 TCP客户&#x2F;服务器程序示例 97 5.1 概述 97 5.2 TCP回射服务器程序：main函数 97 5.3 TCP回射服务器程序：str_echo函数 98 5.4 TCP回射客户程序：main函数 99 5.5 TCP回射客户程序：str_cli函数 100 5.6 正常启动 101 5.7 正常终止 102 5.8 POSIX信号处理 103 5.9 处理SIGCHLD信号 106 5.10 wait和waitpid函数 108 5.11 accept返回前连接中止 111 5.12 服务器进程终止 112 5.13 SIGPIPE信号 113 5.14 服务器主机崩溃 114 5.15 服务器主机崩溃后重启 115 5.16 服务器主机关机 116 5.17 TCP程序例子小结 116 5.18 数据格式 117 5.19 小结 120 习题 120</span><br><span class="line"></span><br><span class="line"> 第6章 I&#x2F;O复用：select和poll函数 122 6.1 概述 122 6.2 I&#x2F;O模型 122 6.3 select函数 127 6.4 str_cli函数（修订版） 132 6.5 批量输入 133 6.6 shutdown函数 136 6.7 str_cli函数（再修订版） 137 6.8 TCP回射服务器程序（修订版） 138 6.9 pselect函数 142 6.10 poll函数 144 6.11 TCP回射服务器程序（再修订版） 146 6.12 小结 148 习题 149</span><br><span class="line"></span><br><span class="line"> 第7章 套接字选项 150 7.1 概述 150 7.2 getsockopt和setsockopt函数 150 7.3 检查选项是否受支持并获取默认值 152 7.4 套接字状态 156 7.5 通用套接字选项 156 7.6 IPv4套接字选项 168 7.7 ICMPv6套接字选项 169 7.8 IPv6套接字选项 169 7.9 TCP套接字选项 171 7.10 SCTP套接字选项 173 7.11 fcntl函数 182 7.12 小结 184 习题 184</span><br><span class="line"></span><br><span class="line"> 第8章 基本UDP套接字编程 186 8.1 概述 186 8.2 recvfrom和sendto函数 187 8.3 UDP回射服务器程序：main函数 187 8.4 UDP回射服务器程序：dg_echo函数 188 8.5 UDP回射客户程序：main函数 190 8.6 UDP回射客户程序：dg_cli函数 190 8.7 数据报的丢失 191 8.8 验证接收到的响应 191 8.9 服务器进程未运行 193 8.10 UDP程序例子小结 194 8.11 UDP的connect函数 196 8.12 dg_cli函数（修订版） 199 8.13 UDP缺乏流量控制 200 8.14 UDP中的外出接口的确定 203 8.15 使用select函数的TCP和UDP回射服务器程序 204 8.16 小结 206 习题 207</span><br><span class="line"></span><br><span class="line"> 第9章 基本SCTP套接字编程 208 9.1 概述 208 9.2 接口模型 208 9.3 sctp_bindx函数 212 9.4 sctp_connectx函数 213 9.5 sctp_getpaddrs函数 213 9.6 sctp_freepaddrs函数 213 9.7 sctp_getladdrs函数 214 9.8 sctp_freeladdrs函数 214 9.9 sctp_sendmsg函数 214 9.10 sctp_recvmsg函数 215 9.11 sctp_opt_info函数 215 9.12 sctp_peeloff函数 216 9.13 shutdown函数 216 9.14 通知 217 9.15 小结 221 习题 222</span><br><span class="line"></span><br><span class="line"> 第10章 SCTP客户&#x2F;服务器程序例子 223 10.1 概述 223 10.2 SCTP一到多式流分回射服务器程序：main函数 223 10.3 SCTP一到多式流分回射客户程序：main函数 225 10.4 SCTP流分回射客户程序：sctpstr_cli函数 226 10.5 探究头端阻塞 228 10.6 控制流的数目 233 10.7 控制终结 233 10.8 小结 234 习题 235</span><br><span class="line"></span><br><span class="line"> 第11章 名字与地址转换 236 11.1 概述 236 11.2 域名系统 236 11.3 gethostbyname函数 239 11.4 gethostbyaddr函数 242 11.5 getservbyname和getservbyport函数 242 11.6 getaddrinfo函数 245 11.7 gai_strerror函数 250 11.8 freeaddrinfo函数 251 11.9 getaddrinfo函数：IPv6 251 11.10 getaddrinfo函数：例子 253 11.11 host_serv函数 254 11.12 tcp_connect函数 254 11.13 tcp_listen函数 257 11.14 udp_client函数 261 11.15 udp_connect函数 263 11.16 udp_server函数 264 11.17 getnameinfo函数 266 11.18 可重入函数 267 11.19 gethostbyname_r和gethostbyaddr_r函数 270 11.20 作废的IPv6地址解析函数 271 11.21 其他网络相关信息 272 11.22 小结 273 习题 274</span><br><span class="line"></span><br><span class="line"> 第三部分 高级套接字编程 第12章 IPv4与IPv6的互操作性 278 12.1 概述 278 12.2 IPv4客户与IPv6服务器 278 12.3 IPv6客户与IPv4服务器 281 12.4 IPv6地址测试宏 283 12.5 源代码可移植性 284 12.6 小结 284 习题 285</span><br><span class="line"></span><br><span class="line"> 第13章 守护进程和inetd超级服务器 286 13.1 概述 286 13.2 syslogd守护进程 286 13.3 syslog函数 287 13.4 daemon_init函数 289 13.5 inetd守护进程 293 13.6 daemon_inetd函数 297 13.7 小结 299 习题 299</span><br><span class="line"></span><br><span class="line"> 第14章 高级I&#x2F;O函数 300 14.1 概述 300 14.2 套接字超时 300 14.3 recv和send函数 305 14.4 readv和writev函数 306 14.5 recvmsg和sendmsg函数 307 14.6 辅助数据 310 14.7 排队的数据量 313 14.8 套接字和标准I&#x2F;O 313 14.9 高级轮询技术 316 14.10 T&#x2F;TCP：事务目的TCP 320 14.11 小结 322 习题 323</span><br><span class="line"></span><br><span class="line"> 第15章 Unix域协议 324 15.1 概述 324 15.2 Unix域套接字地址结构 324 15.3 socketpair函数 326 15.4 套接字函数 327 15.5 Unix域字节流客户&#x2F;服务器程序 327 15.6 Unix域数据报客户&#x2F;服务器程序 329 15.7 描述符传递 330 15.8 接收发送者的凭证 337 15.9 小结 340 习题 340</span><br><span class="line"></span><br><span class="line"> 第16章 非阻塞式I&#x2F;O 341 16.1 概述 341 16.2 非阻塞读和写：str_cli函数（修订版） 342 16.3 非阻塞connect 351 16.4 非阻塞connect：时间获取客户程序 352 16.5 非阻塞connect：Web客户程序 354 16.6 非阻塞accept 362 16.7 小结 363 习题 363</span><br><span class="line"></span><br><span class="line"> 第17章 ioctl操作 365 17.1 概述 365 17.2 ioctl函数 365 17.3 套接字操作 366 17.4 文件操作 367 17.5 接口配置 367 17.6 get_ifi_info函数 369 17.7 接口操作 378 17.8 ARP高速缓存操作 378 17.9 路由表操作 380 17.10 小结 381 习题 381</span><br><span class="line"></span><br><span class="line"> 第18章 路由套接字 382 18.1 概述 382 18.2 数据链路套接字地址结构 382 18.3 读和写 383 18.4 sysctl操作 390 18.5 get_ifi_info函数 394 18.6 接口名字和索引函数 397 18.7 小结 401 习题 401</span><br><span class="line"></span><br><span class="line"> 第19章 密钥管理套接字 402 19.1 概述 402 19.2 读和写 403 19.3 倾泻安全关联数据库 404 19.4 创建静态安全关联 407 19.5 动态维护安全关联 412 19.6 小结 415 习题 416</span><br><span class="line"></span><br><span class="line"> 第20章 广播 417 20.1 概述 417 20.2 广播地址 418 20.3 单播和广播的比较 419 20.4 使用广播的dg_cli函数 422 20.5 竞争状态 424 20.6 小结 431 习题 432</span><br><span class="line"></span><br><span class="line"> 第21章 多播 433 21.1 概述 433 21.2 多播地址 433 21.3 局域网上多播和广播的比较 436 21.4 广域网上的多播 438 21.5 源特定多播 440 21.6 多播套接字选项 441 21.7 mcast_join和相关函数 445 21.8 使用多播的dg_cli函数 450 21.9 接收IP多播基础设施会话声明 451 21.10 发送和接收 454 21.11 SNTP：简单网络时间协议 457 21.12 小结 461 习题 461</span><br><span class="line"></span><br><span class="line"> 第22章 高级UDP套接字编程 462 22.1 概述 462 22.2 接收标志、目的IP地址和接口索引 462 22.3 数据报截断 467 22.4 何时用UDP代替TCP 467 22.5 给UDP应用增加可靠性 469 22.6 捆绑接口地址 478 22.7 并发UDP服务器 482 22.8 IPv6分组信息 483 22.9 IPv6路径MTU控制 486 22.10 小结 487 习题 488</span><br><span class="line"></span><br><span class="line"> 第23章 高级SCTP套接字编程 489 23.1 概述 489 23.2 自动关闭的一到多式服务器程序 489 23.3 部分递送 490 23.4 通知 492 23.5 无序的数据 495 23.6 捆绑地址子集 496 23.7 确定对端和本端地址信息 497 23.8 给定IP地址找出关联ID 500 23.9 心搏和地址不可达 501 23.10 关联剥离 502 23.11 定时控制 503 23.12 何时改用SCTP代替TCP 505 23.13 小结 506 习题 506</span><br><span class="line"></span><br><span class="line"> 第24章 带外数据 507 24.1 概述 507 24.2 TCP带外数据 507 24.3 sockatmark函数 513 24.4 TCP带外数据小结 519 24.5 客户&#x2F;服务器心搏函数 520 24.6 小结 524 习题 524</span><br><span class="line"></span><br><span class="line"> 第25章 信号驱动式I&#x2F;O 525 25.1 概述 525 25.2 套接字的信号驱动式I&#x2F;O 525 25.3 使用SIGIO的UDP回射服务器程序 527 25.4 小结 532 习题 533</span><br><span class="line"></span><br><span class="line"> 第26章 线程 534 26.1 概述 534 26.2 基本线程函数：创建和终止 535 26.3 使用线程的str_cli函数 537 26.4 使用线程的TCP回射服务器程序 538 26.5 线程特定数据 542 26.6 Web客户与同时连接 549 26.7 互斥锁 552 26.8 条件变量 555 26.9 Web客户与同时连接（续） 558 26.10 小结 560 习题 560</span><br><span class="line"></span><br><span class="line"> 第27章 IP选项 561 27.1 概述 561 27.2 IPv4选项 561 27.3 IPv4源路径选项 562 27.4 IPv6扩展首部 569 27.5 IPv6步跳选项和目的地选项 569 27.6 IPv6路由首部 573 27.7 IPv6粘附选项 577 27.8 历史性IPv6高级API 578 27.9 小结 579 习题 579</span><br><span class="line"></span><br><span class="line"> 第28章 原始套接字 580 28.1 概述 580 28.2 原始套接字创建 580 28.3 原始套接字输出 581 28.4 原始套接字输入 582 28.5 ping程序 584 28.6 traceroute程序 596 28.7 一个ICMP消息守护程序 608 28.8 小结 622 习题 622</span><br><span class="line"></span><br><span class="line"> 第29章 数据链路访问 623 29.1 概述 623 29.2 BPF：BSD分组过滤器 623 29.3 DLPI：数据链路提供者接口 625 29.4 Linux：SOCK_PACKET和 PFPACKET 626 29.5 libpcap：分组捕获函数库 627 29.6 libnet：分组构造与输出函数库 627 29.7 检查UDP的校验和字段 628 29.8 小结 645 习题 645</span><br><span class="line"></span><br><span class="line"> 第30章 客户&#x2F;服务器程序设计范式 646 30.1 概述 646 30.2 TCP客户程序设计范式 648 30.3 TCP测试用客户程序 649 30.4 TCP迭代服务器程序 650 30.5 TCP并发服务器程序，每个客户一个子进程 650 30.6 TCP预先派生子进程服务器程序，accept无上锁保护 653 30.7 TCP预先派生子进程服务器程序，accept使用文件上锁保护 659 30.8 TCP预先派生子进程服务器程序，accept使用线程上锁保护 662 30.9 TCP预先派生子进程服务器程序，传递描述符 663 30.10 TCP并发服务器程序，每个客户一个线程 667 30.11 TCP预先创建线程服务器程序，每个线程各自accept 669 30.12 TCP预先创建线程服务器程序，主线程统一accept 671 30.13 小结 673 习题 674</span><br><span class="line"></span><br><span class="line"> 第31章 流 675 31.1 概述 675 31.2 概貌 675 31.3 getmsg和putmsg函数 678 31.4 getpmsg和putpmsg函数 679 31.5 ioctl函数 680 31.6 TPI：传输提供者接口 680 31.7 小结 689 习题 689</span><br><span class="line"></span><br><span class="line"> 附录A IPv4、IPv6、ICMPv4和ICMPv6 690 附录B 虚拟网络 704 附录C 调试技术 708 附录D 杂凑的源代码 714 附录E 精选习题答案 726 参考文献 756 索引 763</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B003SWP8XG/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B003SWP8XG&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51zuPI39naL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础教程(第2版)</title>
    <url>/2020/04/19/B003TSBAMM/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Python基础教程(第2版)<br>作者信息： 作者: 赫特兰 (Magnus Lie Hetland) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Python基础教程(第2版)》内容涉及的范围较广，既能为初学者夯实基础，又能帮助程序员提升技能，适合各个层次的Python开发人员阅读参考。《Python基础教程(第2版)》是经典教程的全新改版.作者根据Python版本的种种变化，全面改写了书中内容，做到既能“瞻前”也能“顾后”。《Python基础教程(第2版)》层次鲜明、结构严谨、内容翔实，特别是在最后几章。作者将前面讲述的内容应用到了10个引人入胜的项目中，并以模板的形式介绍了项目的开发过程。《Python基础教程(第2版)》既适合初学者夯实基础。又能帮助Python程序员提升技能，即使是Python方面的技术专家，也能从书里找到令你耳目一新的东西。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 基础知识</span><br><span class="line">1.1 安装Python</span><br><span class="line">1.1.1 Windows</span><br><span class="line">1.1.2 Linux和UNIX</span><br><span class="line">1.1.3 苹果机（Macintosh）</span><br><span class="line">1.1.4 其他发布版</span><br><span class="line">1.1.5 时常关注，保持更新</span><br><span class="line">1.2 交互式解释器</span><br><span class="line">1.3 算法是什么</span><br><span class="line">1.4 数字和表达式</span><br><span class="line">1.4.1 长整型数</span><br><span class="line">1.4.2 十六进制和八进制</span><br><span class="line">1.5 变量</span><br><span class="line">1.6 语句</span><br><span class="line">1.7 获取用户输入</span><br><span class="line">1.8 函数</span><br><span class="line">1.9 模块</span><br><span class="line">1.9.1 cmath和复数</span><br><span class="line">1.9.2 回到future</span><br><span class="line">1.10 保存并执行程序</span><br><span class="line">1.10.1 通过命令提示符运行Python脚本</span><br><span class="line">1.10.2 让脚本像普通程序一样运行</span><br><span class="line">1.10.3 注释</span><br><span class="line">1.11 字符串</span><br><span class="line">1.11.1 单引号字符串和转义引号</span><br><span class="line">1.11.2 拼接字符串</span><br><span class="line">1.11.3 字符串表示和repr</span><br><span class="line">1.11.4 input和rawinpm的比较</span><br><span class="line">1.11.5 长字符串、原始字符串和Unicode</span><br><span class="line">1.12 小结</span><br><span class="line">1.12.1 本章的新函数</span><br><span class="line">1.12.2 接下来学什么 </span><br><span class="line"></span><br><span class="line"> 第2章 列表和元组 2.1 序列概览 2.2 通用序列操作 2.2.1 索引 2.2.2 分片 2.2.3 序列相加 2.2.4.乘法 2.2.5 成员资格 2.2.6 长度、最小值和最大值 2.3 列表：Python的“苦力” 2.3.1 list函数 2.3.2 基本的列表操作 2.3.3 列表方法 2.4 元组：不可变序列 2.4.1 tuple函数 2.4.2 基本元组操作 2.4.3 那么，意义何在 2.5 小结 2.5.1 本章的新函数 2.5.2 接下来学什么</span><br><span class="line"></span><br><span class="line"> 第3章 使用字符串 3.1 基本字符串操作 3.2 字符串格式化：精简版 3.3 字符串格式化：完整版 3.3.1 简单转换 3.3.2 字段宽度和精度 3.3.3 符号、对齐和0填充 3.4 字符串方法 3.4.1 f1nd 3.4.2 join 3.4.3 jower 3.4.4 replace 3.4.5 spl1t 3.4.6 strlD 3.4.7 tralqslate 3.5 小结 3.5.1 本章的新函数 3.5.2 接下来学什么</span><br><span class="line"></span><br><span class="line"> 第4章 字典：当索引不好用时 4.1 字典的使用 4.2 创建和使用字典 4.2.1 dict函数 4.2.2 基本字典操作 4.2.3 字典的格式化字符串 4.2.4 字典方法 4.3 小结 4.3.1 本章的新函数 4.3.2 接下来学什么</span><br><span class="line"></span><br><span class="line"> 第5章 条件、循环和其他语句 5.1 print和import的更多信息 5.1.1 使用逗号输出 5.1.2 把某件事作为另一件事导入 5.2 赋值魔法 5.2.1 序列解包 5.2.2 链式赋值 5.2.3 增量赋值 5.3 语句块：缩排的乐趣 5.4 条件和条件语句 5.4.1 这就是布尔变量的作用 5.4.2 条件执行和if语句 5.4.3 else子句 5.4.4 elif子句 5.4.5 嵌套代码块 5.4.6 更复杂的条件 5.4.7 断言 5.5 循环 5.5.1 while循环 5.5.2 for循环 5.5.3 循环遍历字典元素 5.5.4 一些迭代工具 5.5.5 跳出循环 5.5.6 循环中的else子句 5.6 列表推导式——轻量级循环 5.7 三人行 5.7.1 什么都没发生 5.7.2 使用del删除 5.7.3 使用exec和eval执行和求值字符串 5.8 小结 5.8.1 本章的新函数 5.8.2 接下来学什么</span><br><span class="line"></span><br><span class="line"> 第6章 抽象 6.1 懒惰即美德 6.2 抽象和结构 6.3 创建函数 6.3.1 记录函数 6.3.2 并非真正函数的函数 6.4 参数魔法 6.4.1 值从哪里来 6.4.2 我能改变参数吗 6.4.3 关键字参数和默认值 6.4.4 收集参数 6.4.5 反转过程 6.4.6 练习使用参数 6.5 作用域 6.6 递归 6.6.1 两个经典：阶乘和幂 6.6.2 另外一个经典：二元查找 6.7 小结 6.7.1 本章的新函数 6.7.2 接下来学什么</span><br><span class="line"></span><br><span class="line"> 第7章 更加抽象 7.1 对象的魔力 7.1.1 多态 7.1.2 封装 7.1.3 继承 7.2 类和类型 7.2.1 类到底是什么 7.2.2 创建自己的类 7.2.3 特性、函数和方法 7.2.4 类的命名空间 7.2.5 指定超类 7.2.6 调查继承 7.2.7 多个超类 7.2.8 接口和内省 7.3 一些关于面向对象设计的思考 7.4 简明总结 7.4.1 本章的新函数 7.4.2 接下来学什么</span><br><span class="line"></span><br><span class="line"> 第8章 异常 8.1 什么是异常 8.2 按自己的方式出错 8.2.1 raise语句 8.2.2 自定义异常类 8.3 捕捉异常 8.4 不止一个except子句 8.5 用一个块捕捉两个异常 8.6 捕捉对象 8.7 真正的全捕捉 8.8 万事大吉 8.9 最后 8.10 异常和函数 8.11 异常之禅 8.12小结 8.12.1 本章的新函数 8.12.2 接下来学什么</span><br><span class="line"></span><br><span class="line"> 第9章 魔法方法、属性和迭代器 9.1 准备工作 9.2 构造方法 9.2.1 重写一般方法和特殊的构造方法 9.2.2 调用未绑定的超类构造方法 9.2.3 使用super、函数 9.3 成员访问 9.3.1 基本的序列和映射规则 9.3.2 子类化列表，字典和字符串 9.4 更多魔力 9.5 属性 9.5.1 property函数 9.5.2 静态方法和类成员方法 9.5.3 getattr、setattr和它的朋友们 9.6 迭代器 9.6.1 迭代器规则 9.6.2 从迭代器得到序列 9.7 生成器 9.7.1 创建生成器 9.7.2 递归生成器 9.7.3 通用生成器 9.7.4 生成器方法 9.7.5 模拟生成器 9.8 八皇后问题 9.8.1 生成器和回溯 9.8.2 问题 9.8.3 状态表示 9.8.4 寻找冲突 9.8.5 基本情况 9.8.6 需要递归的情况 9.8.7 打包 9.9 小结 9.9.1 本章的新函数 9.9.2 接下来学什么</span><br><span class="line"></span><br><span class="line"> 第10章 充电时刻 10.1 模块 10.1.1 模块是程序 10.1.2 模块用于定义 10.1.3 让你的模块可用 10.1.4 包 10.2 探究模块 10.2.1 模块中有什么 10.2.2 用help获取帮助 10.2.3 文档 10.2.4 使用源代码 10.3 标准库：一些最爱 10.3.1 sys 10.3.2 OS 10.3.3 fileinput 10.3.4 集合、堆和双端队列 10.3.5 time 10.3.6 random 10.3.7 shelve 10.3.8 re 10.3.9 其他有趣的标准模块 10.4 小结 10.4.1 本章的新函数 10.4.2 接下来学什么</span><br><span class="line"></span><br><span class="line"> 第11章 文件和素材 11.1 打开文件 11.1.1 文件模式 11.1.2 缓冲 11.2 基本文件方法 11.2.1 读和写 11.2.2 管式输出 11.2.3 读写行 11.2.4 关闭文件 11.2.5 使用基本文件方法 11.3 对文件内容进行迭代 11.3.1 按字节处理 11.3.2 按行操作 11.3.3 读取所有内容 11.3.4 使用fileinput实现懒惰行迭代 11.3.5 文件迭代器 11.4 小结 11.4.1 本章的新函数 11.4.2 接下来学什么</span><br><span class="line"></span><br><span class="line"> 第12章 图形用户界面 12.1 丰富的平台 12.2 下载和安装wxpytbon 12.3 创建示例GUI应用程序 12.3.1 开始 12.3.2 窗口和组件 12.3.3 标签、标题和位置 12.3.4 更智能的布局 12.3.5 事件处理 12.3.6 完成了的程序 12.4 但是我宁愿用 12.4..1 使用Tkinter 12.4.2 使用Jython和Swing 12.4..3 使用其他开发包 12.5 小结</span><br><span class="line"></span><br><span class="line"> 第13章 数据库支持 13.1 Python数据库API 13.1.1 全局变量 13.1.2 异常 13.1.3 连接和游标 13.1.4 类型 13.2 SQLite和PySQLite 13.2.1 入门 13.2.2 数据库应用程序示例 13.3 小结 13.3.1 本章的新函数 13.3.2 接下来学什么</span><br><span class="line"></span><br><span class="line"> 第14章 网络编程 14.1 少数几个网络设计模块 14.1.1 socket模块 14.1.2 urllib和urllib2模块 14.1.3 其他模块 14.2 SocketServer和它的朋友们 14.3 多连接 14.3.1 使用SocketServer进行分叉和线程处理 14.3.2 带有select和port的异步I／O 14.4 Twisted 14.4.1 下裁并安装Twisted 14.4.2 编写Twisted服务器 14.5 小结 14.5.1 本章的新函数 14.5.2 接下来学什么</span><br><span class="line"></span><br><span class="line"> 第15章 Python和万维网 15.1 屏幕抓取 15.1.1 Tidy和XHTML解析 …… 第16章 测试 第17章 扩展Python 第18章 程序打包 第19章 好玩的编程 第20章 项目1：即时标记 第21章 项目2：画幅好画 第22章 项目3：万能的XML 第23章 项目4：新闻聚合 第24章 项目5：虚拟茶话会 第25章 项目6：使用CGI进行远程编辑 第26章 项目7：自定义电子公告板 第27章 项目8：使用XML-RPC进行文件共享 第28章 项目9：文件共享2——GUI版本 第29章 项目10：DIY街机游戏 附录A 简明版本 附录B Python参考手册 附录C 在线资源 附录D Python3.0</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B003TSBAMM/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B003TSBAMM&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51gh5X9rz7L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>编写高质量代码 Web前端开发修炼之道</title>
    <url>/2020/04/19/B003U8XUKQ/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 编写高质量代码 Web前端开发修炼之道<br>作者信息： 作者: 曹刘阳 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《编写高质量代码:Web前端开发修炼之道》:Web前端开发者的内功修炼秘笈4大社区鼎立推荐！在这个用户体验为王的Web 2.0时代，Web应用所涉及的领域越来越广，规模越来越大，需求越来越多样化和复杂化，更新的速度也越来越快。如何才能让我们的应用应对规模化、多样化、复杂化和快速变化带来的种种问题？编写高质量的、易于维护的Web前端代码似乎是解决这些问题的唯一途径。如何才能编写出高质量的、易于维护的Web前端代码？《编写高质量代码：Web前端开发修炼之道》的主要内容围绕Web前端开发的三大技术要素——HTML、CSS和JavaScript展开，深入地讨论了编写高质量的HTML代码、CSS代码和JavaScript代码的方法、技巧、规范和最佳实践，从而为编写易于维护的Web前端代码打下坚实的基础。希望《编写高质量代码：Web前端开发修炼之道》能帮助大家从一筹莫展的前端维护工作中走出，从此微笑地面对需求的“变化”。互联网进入Web 20时代以后，Web应用敲响了传统桌面应用的丧钟，它一路摧城拔寨，如今几乎所有的应用都打上了“Web”的烙印。与之相应的，Web开发技术得到了空前的发展，尤其是前端技术。近年来，随着用户对使用体验的要求越来越高，前端开发的技术难度越来越大，昔日设计和制作不分的网页设计师这一职位终于“拆分”成了视觉设计师和前端开发工程师两个职位，分别向着艺术和技术的方向纵深发展。Web前端开发工程师是一个很新的职业，在国内乃至国际上真正开始受到重视的时间也不超过5年，这类专业人才一直供不应求。从知识体系上讲，前端开发工程师需要掌握和了解的知识非常之多，甚至可以用庞杂来形容。作为一名没有太多经验的前端开发工程师，我们应该如何去全面认识自己的工作，如何找准自己的定位，如何从合格成为优秀，最后迈向卓越？《编写高质量代码:Web前端开发修炼之道》尝试从如何编写易于维护的、高质量的Web前端代码的角度给出答案。如果你在思考下面这些问题，也许《编写高质量代码:Web前端开发修炼之道》就是你想要的！作为一名合格的web前端开发工程师，究竟需要具备哪些技能和素质？为什么说如果要精Web前端开发这一行，必须先精通十行？在Web应用的实现代码中，有哪些技术因素会导致应用难以维护？高质量的Web前端代码应该满足哪些条件？如何才能提高Web前端代码的可读性和可重用性？在HTML代码中，为何要使用语义化标签？如何检查你使用的标签是否语义良好？语义化标签时应该注意哪些问题？如何编写CSS代码和JavaScript代码可以避免团队合作时产生冲突？如何组织CSS文件才能让它们更易于管理？如何让CSS模块化，从而提高代码的重用率？CSS的命名应该注意哪些问题？何谓优良的CSS编码风格？如何在CSS编码中引入面向对象的编程思想？这样做有哪些好处？原生JavaScript和JavaScript类库之间有何关系？如何编写自己的JavaScript类库？JavaScript有哪些常见的跨浏览器兼容问题？如何解决这些问题？如何组织JavaScript才能让代码的结构更清晰有序，从而更易于维护？如何才能编写出弹性良好的JavaScript代码？编写过程中应该注意哪些问题？JavaScript的对象编程是如何实现的？如何用面向对象的方式重写原有的代码？编写高质量的JavaScript代码有哪些实用的技巧？又有哪些常见的问题需要注意？为了提高Web前端代码的可维护性，我们应该遵循哪些规范？</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">推荐序</span><br><span class="line">赞誉</span><br><span class="line">前言</span><br><span class="line">致谢</span><br><span class="line">第1章 从网站重构说起</span><br><span class="line">1.1 糟糕的页面实现，头疼的维护工作</span><br><span class="line">1.2 Web标准-结构、样式和行为的分离</span><br><span class="line">1.3 前端的现状</span><br><span class="line">1.4 打造高品质的前端代码，提高代码的可维护性-精简、重用、有序 </span><br><span class="line"></span><br><span class="line"> 第2章 团队合作 2.1 揭秘前端开发工程师 2.2 欲精一行，必先通十行 2.3 增加代码可读性-注释 2.4 提高重用性-公共组件和私有组件的维护 2.5 冗余和精简的矛盾-选择集中还是选择分散 2.6 磨刀不误砍柴工-前期的构思很重要 2.7 制订规范 2.8 团队合作的最大难度不是技术，是人</span><br><span class="line"></span><br><span class="line"> 第3章 高质量的HTML 3.1 标签的语义 3.2 为什么要使用语义化标签 3.3 如何确定你的标签是否语义良好 3.4 常见模块你真的很了解吗 3.4.1 标题和内容 3.4.2 表单 3.4.3 表格 3.4.4 语义化标签应注意的一些其他问题</span><br><span class="line"></span><br><span class="line"> 第4章 高质量的CSS4 4.1 怪异模式和DTD 4.2 如何组织CSS 4.3 推荐的base.css 4.4 模块化CSS-在CSS中引入面向对象编程思想 4.4.1 如何划分模块-单一职责 4.4.2 CSS的命名-命名空间的概念 4.4.3 挂多个class还是新建class-多用组合，少用继承 4.4.4 如何处理上下margin 4.5 低权重原则-避免滥用子选择器 4.6 CSS sprite 4.7 CSS的常见问题 4.7.1 CSS的编码风格 4.7.2 id和class 4.7.3 CSS hack 4.7.4 解决超链接访问后hover样式不出现的问题 4.7.5 hasLayout4 4.7.6 块级元素和行内元素的区别 4.7.7 display: inline-block和hasLayout7 4.7.8 relative、absolute和float3 4.7.9 居中4 4.7.10 网格布局 4.7.11 z-index的相关问题以及Flash和IE6下的select元素 4.7.12 插入png图片 4.7.13 多版本IE并存方案-CSS的调试利器IETester</span><br><span class="line"></span><br><span class="line"> 第5章 高质量的JavaScript 5.1 养成良好的编程习惯 5.1.1 团队合作-如何避免JS冲突 5.1.2 给程序一个统一的入口-window.onload和DOMReady 5.1.3 CSS放在页头，JavaScript放在页尾 5.1.4 引入编译的概念-文件压缩 5.2 JavaScript的分层概念和JavaScript库 5.2.1 JavaScript如何分层 5.2.2 base层3 5.2.3 common层 5.2.4 page层4 5.2.5 JavaScript库 5.3 编程实用技巧7 5.3.1 弹性7 5.3.2 getElementById、getElementsByTagName和getElements-ByClassName3 5.3.3 可复用性 5.3.4 避免产生副作用9 5.3.5 通过传参实现定制3 5.3.6 控制this关键字的指向7 5.3.7 预留回调接口 5.3.8 编程中的DRY规则 5.3.9 用hash对象传参 5.4 面向对象编程 5.4.1 面向过程编程和面向对象编程 5.4.2 JavaScript的面向对象编程 5.4.3 用面向对象方式重写代码 5.5 其他问题 5.5.1 prototype和内置类 5.5.2 标签的自定义属性 5.5.3 标签的内联事件和event对象 5.5.4 利用事件冒泡机制 5.5.5 改变DOM样式的三种方式</span><br><span class="line"></span><br><span class="line"> 附录A 写在规则前面的话 附录B 命名规则 附录C 分工安排 附录D 注释规则 附录E HTML规范 附录F CSS规范 附录G JavaScript规范</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B003U8XUKQ/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B003U8XUKQ&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41%2BlswZt9LL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript高级程序设计(第2版)</title>
    <url>/2020/04/19/B003V42XZW/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： JavaScript高级程序设计(第2版)<br>作者信息： 作者: 尼古拉斯·泽卡斯(Nicholas C.Zakas) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《JavaScript高级程序设计(第2版)》：JavaScript经典教程Amazon超级畅销书前端开发人员必备JavaScrpt的应用在广度和深度上日益扩大和加深，前端开发亟待掌握的JavaScrpt技能也越来越具有挑战性。这个新版本几乎全部更新、重写了上一版的内容，融入了作者近几年来奋战在前端开发一线的宝贵经验，是学习和提高JavaScrpt技能的必读经典。《JavaScript高级程序设计(第2版)》不仅全面深入地讲述了，JavaScript的基本概念，阑释了它特有的面向对象和继承的机制.还详尽讨论了JavaScrpt实现的各个组成部分。在以大量篇幅全景式剖析ECMAScript和DOM的过程中，各个级别的DOM规范在作者笔下纷至沓来，诸如事件模拟、XML解析、XPath查询等高级主题也讲得分外清楚。此外，错误处理与调试、Ajax与JSON，乃至客户端存储、未来的API等章节也都条理清晰、异彩纷呈。《JavaScript高级程序设计(第2版)》适合有一定编程经验的前端开发人员阅读，也可作为高校相关专业课程的教材。一幅浓墨重彩的语言画卷，一部推陈出新的技术名著</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 JavaScript简介 1</span><br><span class="line">1.1 JavaScript简史 1</span><br><span class="line">1.2 JavaScript实现 2</span><br><span class="line">1.2.1 ECMAScript 3</span><br><span class="line">1.2.2 文档对象模型(DOM) 5</span><br><span class="line">1.2.3 浏览器对象模型(BOM) 7</span><br><span class="line">1.3 JavaScript版本 8</span><br><span class="line">1.4 小结 8 </span><br><span class="line"></span><br><span class="line"> 第2章 在HTML中使用JavaScript 9 2.1 script元素 9 2.1.1 标签的位置 11 2.1.2 延迟脚本 11 2.1.3 在XHTML中的用法 12 2.1.4 不推荐使用的语法 13 2.1.5 嵌入代码与外部文件 13 2.2 文档模式 14 2.3 noscript元素 15 2.4 小结 16</span><br><span class="line"></span><br><span class="line"> 第3章 基本概念 17 3.1 语法 17 3.1.1 区分大小写 17 3.1.2 标识符 17 3.1.3 注释 18 3.1.4 语句 18 3.2 关键字和保留字 18 3.3 变量 19 3.4 数据类型 20 3.4.1 typeof操作符 20 3.4.2 Undefined类型 21 3.4.3 Null类型 22 3.4.4 Boolean类型 22 3.4.5 Number类型 23 3.4.6 String类型 28 3.4.7 Object类型 30 3.5 操作符 31 3.5.1 一元操作符 31 3.5.2 位操作符 34 3.5.3 布尔操作符 38 3.5.4 乘性操作符 40 3.5.5 加性操作符 42 3.5.6 关系操作符 43 3.5.7 相等操作符 44 3.5.8 条件操作符 46 3.5.9 赋值操作符 46 3.5.10 逗号操作符 47 3.6 语句 47 3.6.1 if语句 47 3.6.2 do-while语句 48 3.6.3 while语句 48 3.6.4 for语句 48 3.6.5 for-in语句 49 3.6.6 label语句 50 3.6.7 break和continue语句 50 3.6.8 with语句 52 3.6.9 switch语句 52 3.7 函数 54 3.7.1 理解参数 55 3.7.2 没有重载 57 3.8 小结 57</span><br><span class="line"></span><br><span class="line"> 第4章 变量、作用域和内存问题 59 4.1 基本类型和引用类型的值 59 4.1.1 动态属性 60 4.1.2 复制变量值 60 4.1.3 传递参数 62 4.1.4 检测类型 63 4.2 执行环境及作用域 64 4.2.1 延长作用域链 66 4.2.2 没有块级作用域 66 4.3 垃圾收集 69 4.3.1 标记清除 69 4.3.2 引用计数 69 4.3.3 性能问题 70 4.3.4 管理内存 71 4.4 小结 72</span><br><span class="line"></span><br><span class="line"> 第5章 引用类型 73 5.1 Object类型 73 5.2 Array类型 75 5.2.1 转换方法 77 5.2.2 栈方法 78 5.2.3 队列方法 79 5.2.4 重排序方法 80 5.2.5 操作方法 81 5.3 Date类型 83 5.3.1 继承的方法 84 5.3.2 日期格式化方法 85 5.3.3 日期&#x2F;时间组件方法 85 5.4 RegExp类型 86 5.4.1 RegExp实例属性 88 5.4.2 RegExp实例方法 89 5.4.3 RegExp构造函数属性 90 5.4.4 模式的局限性 92 5.5 Function类型 92 5.5.1 没有重载(深入理解) 93 5.5.2 函数声明与函数表达式 94 5.5.3 作为值的函数 94 5.5.4 函数内部属性 96 5.5.5 函数属性和方法 97 5.6 基本包装类型 99 5.6.1 Boolean类型 100 5.6.2 Number类型 101 5.6.3 String类型 102 5.7 内置对象 109 5.7.1 Global对象 109 5.7.2 Math对象 111 5.8 小结 114</span><br><span class="line"></span><br><span class="line"> 第6章 面向对象的程序设计 115 6.1 创建对象 115 6.1.1 工厂模式 115 6.1.2 构造函数模式 116 6.1.3 原型模式 119 6.1.4 组合使用构造函数模式和原型模式 128 6.1.5 动态原型模式 129 6.1.6 寄生构造函数模式 129 6.1.7 稳妥构造函数模式 130 6.2 继承 131 6.2.1 原型链 131 6.2.2 借用构造函数 136 6.2.3 组合继承 137 6.2.4 原型式继承 138 6.2.5 寄生式继承 139 6.2.6 寄生组合式继承 139 6.3 小结 142</span><br><span class="line"></span><br><span class="line"> 第7章 匿名函数 143 7.1 递归 144 7.2 闭包 144 7.2.1 闭包与变量 147 7.2.2 关于this对象 148 7.2.3 内存泄漏 149 7.3 模仿块级作用域 150 7.4 私有变量 152 7.4.1 静态私有变量 153 7.4.2 模块模式 154 7.4.3 增强的模块模式 156 7.5 小结 157</span><br><span class="line"></span><br><span class="line"> 第8章 BOM 158 8.1 window对象 158 8.1.1 全局作用域 158 8.1.2 窗口关系及框架 159 8.1.3 窗口位置 161 8.1.4 窗口大小 162 8.1.5 导航和打开窗口 163 8.1.6 间歇调用和超时调用 166 8.1.7 系统对话框 168 8.2 location对象 169 8.2.1 查询字符串参数 170 8.2.2 位置操作 171 8.3 navigator对象 172 8.3.1 检测插件 173 8.3.2 注册处理程序 175 8.4 screen对象 176 8.5 history对象 177 8.6 小结 178</span><br><span class="line"></span><br><span class="line"> 第9章 客户端检测 179 9.1 能力检测 179 9.2 怪癖检测 181 9.3 用户代理检测 181 9.3.1 用户代理字符串的历史 182 9.3.2 用户代理字符串检测技术 187 9.3.3 完整的代码 199 9.3.4 使用方法 202 9.4 小结 202</span><br><span class="line"></span><br><span class="line"> 第10章 DOM 204 10.1 节点层次 204 10.1.1 Node类型 205 10.1.2 Document类型 210 10.1.3 Element类型 217 10.1.4 Text类型 225 10.1.5 Comment类型 228 10.1.6 CDATASection类型 228 10.1.7 DocumentType类型 229 10.1.8 DocumentFragment类型 229 10.1.9 Attr类型 230 10.2 DOM扩展 231 10.2.1 呈现模式 231 10.2.2 滚动 232 10.2.3 children属性 232 10.2.4 contains()方法 233 10.2.5 操作内容 234 10.3 DOM操作技术 239 10.3.1 动态脚本 239 10.3.2 动态样式 241 10.3.3 操作表格 242 10.3.4 使用NodeList 245 10.4 小结 245</span><br><span class="line"></span><br><span class="line"> 第11章 DOM2和DOM3 247 11.1 DOM变化 247 11.1.1 针对XML命名空间的变化 248 11.1.2 其他方面的变化 250 11.2 样式 254 11.2.1 访问元素的样式 254 11.2.2 操作样式表 258 11.2.3 元素大小 261 11.3 遍历 267 11.3.1 NodeIterator 268 11.3.2 TreeWalker 271 11.4 范围 272 11.4.1 DOM中的范围 272 11.4.2 IE中的范围 279 11.5 小结 282</span><br><span class="line"></span><br><span class="line"> 第12章 事件 283 12.1 事件流 283 12.1.1 事件冒泡 283 12.1.2 事件捕获 284 12.1.3 DOM事件流 285 12.2 事件处理程序(或事件侦听器) 285 12.2.1 HTML事件处理程序 286 12.2.2 DOM0级事件处理程序 286 12.2.3 DOM2级事件处理程序 287 12.2.4 IE事件处理程序 288 12.2.5 跨浏览器的事件处理程序 289 12.3 事件对象 290 12.3.1 DOM中的事件对象 291 12.3.2 IE中的事件对象 293 12.3.3 跨浏览器的事件对象 295 12.4 事件类型 296 12.4.1 UI事件 297 12.4.2 鼠标事件 297 12.4.3 键盘事件 303 12.4.4 HTML事件 307 12.4.5 变动事件 312 12.4.6 专有事件 316 12.4.7 移动Safari支持的事件 325 12.5 内存和性能 328 12.5.1 事件委托 328 12.5.2 移除事件处理程序 330 12.6 模拟事件 331 12.6.1 DOM中的事件模拟 331 12.6.2 IE中的事件模拟 335 12.7 小结 336</span><br><span class="line"></span><br><span class="line"> 第13章 表单脚本 337 13.1 表单 337 13.1.1 提交表单 338 13.1.2 重置表单 338 13.1.3 表单字段 339 13.2 文本框脚本 343 13.2.1 选择文本 344 13.2.2 过滤输入 347 13.2.3 自动切换焦点 350 13.3 选择框脚本 351 13.3.1 选择选项 352 13.3.2 添加选项 354 13.3.3 移除选项 354 13.3.4 移动和重排选项 355 13.4 表单序列化 355 13.5 富文本编辑 357 13.5.1 操作富文本 358 13.5.2 富文本选区 359 13.5.3 表单与富文本 361 13.6 小结 361</span><br><span class="line"></span><br><span class="line"> 第14章 错误处理与调试 363 14.1 浏览器错误报告 363 14.1.1 Internet Explorer 363 14.1.2 Firefox 364 14.1.3 Safari 366 14.1.4 Opera 367 14.1.5 Chrome 368 14.2 错误处理 369 14.2.1 try-catch语句 369 14.2.2 抛出错误 372 14.2.3 错误(error)事件 374 14.3 错误处理策略 375 14.3.1 常见的错误类型 375 14.3.2 区分致命错误和非致命错误 379 14.3.3 把错误记录到服务器 380 14.4 调试技术 381 14.4.1 将消息记录到控制台 381 14.4.2 将消息记录到当前页面 383 14.4.3 抛出错误 384 14.5 常用的IE错误 384 14.5.1 操作终止 384 14.5.2 无效字符 386 14.5.3 未找到成员 386 14.5.4 未知运行时错误 387 14.5.5 语法错误 387 14.5.6 系统无法找到指定资源 387 14.6 调试工具 388 14.6.1 IE中的调试器 388 14.6.2 Firebug 392 14.6.3 Drosera 396 14.6.4 Opera中的JavaScript调试器 398 14.6.5 其他调试工具 401 14.7 小结 401</span><br><span class="line"></span><br><span class="line"> 第15章 JavaScript与XML 402 15.1 浏览器对XML DOM的支持 402 15.1.1 DOM2级核心 402 15.1.2 DOMParser类型 403 15.1.3 XMLSerializer类型 404 15.1.4 DOM3级加载和保存 404 15.1.5 IE对XML的支持 409 15.1.6 跨浏览器处理XML 412 15.2 浏览器对XPath的支持 414 15.2.1 DOM3级XPath 414 15.2.2 IE中的XPath 418 15.2.3 跨浏览器使用XPath 419 15.3 浏览器对XSLT的支持 421 15.3.1 IE中的XSLT 421 15.3.2 XSLTProcessor类型 425 15.3.3 跨浏览器使用XSLT 427 15.4 小结 428</span><br><span class="line"></span><br><span class="line"> 第16章 E4X 429 16.1 E4X的类型 429 16.1.1 XML类型 429 16.1.2 XMLList类型 430 16.1.3 命名空间类型 431 16.1.4 QName类型 432 16.2 一般用法 432 16.2.1 访问特性 433 16.2.2 其他节点类型 434 16.2.3 查询 436 16.2.4 构建和操作XML 437 16.2.5 解析和序列化 439 16.2.6 命名空间 439 16.3 其他变化 441 16.4 全面启用E4X 442 16.5 小结 442</span><br><span class="line"></span><br><span class="line"> 第17章 Ajax与JSON 443 17.1 XHR对象 443 17.1.1 XHR的用法 445 17.1.2 HTTP头部信息 446 17.1.3 GET请求 448 17.1.4 POST请求 448 17.1.5 浏览器差异 449 17.1.6 安全 451 17.2 跨域请求 452 17.2.1 XDomainRequest对象 452 17.2.2 跨域XHR 454 17.3 JSON 454 17.3.1 在Ajax中使用JSON 456 17.3.2 安全 458 17.4 小结 459</span><br><span class="line"></span><br><span class="line"> 第18章 高级技巧 460 18.1 高级函数 460 18.1.1 作用域安全的构造函数 460 18.1.2 惰性载入函数 462 18.1.3 函数绑定 464 18.1.4 函数柯里化 465 18.2 高级定时器 467 18.2.1 重复的定时器 469 18.2.2 Yielding Processes 470 18.2.3 函数节流 472 18.3 自定义事件 474 18.4 拖放 476 18.4.1 修缮拖动功能 478 18.4.2 添加自定义事件 480 18.5 小结 482</span><br><span class="line"></span><br><span class="line"> 第19章 客户端存储 483 19.1 cookie 483 19.1.1 限制 483 19.1.2 cookie的成分 484 19.1.3 JavaScript中的cookie 485 19.1.4 子cookie 487 19.1.5 关于cookie的思考 491 19.2 IE用户数据 491 19.3 DOM存储机制 492 19.3.1 存储类型 492 19.3.2 sessionStorage对象 493 19.3.3 globalStorage对象 494 19.3.4 localStorage对象 495 19.3.5 StorageItem类型 496 19.3.6 storage事件 496 19.3.7 限制 496 19.4 总结 497</span><br><span class="line"></span><br><span class="line"> 第20章 最佳实践 498 20.1 可维护性 498 20.1.1 什么是可维护的代码 498 20.1.2 代码约定 498 20.2 松散耦合 501 20.3 性能 507 20.3.1 注意作用域 508 20.3.2 选择正确方法 509 20.3.3 最小化语句数 513 20.3.4 优化DOM交互 515 20.4 部署 517 20.4.1 构建过程 517 20.4.2 验证 518 20.4.3 压缩 520 20.5 小结 522</span><br><span class="line"></span><br><span class="line"> 第21章 未来的API 523 21.1 选择器API 523 21.1.1 querySelector()方法 523 21.1.2 querySelectorAll()方法 524 21.1.3 现今和未来的支持情况 525 21.2 HTML5 525 21.2.1 字符集属性 525 21.2.2 类相关的增加 526 21.2.3 自定义数据特性 528 21.2.4 跨文档消息传递 528 21.2.5 媒体元素 529 21.2.6 canvas元素 532 21.2.7 离线支持 540 21.2.8 历史的改变 541 21.2.9 数据库存储 541 21.2.10 拖放操作 543 21.2.11 WebSocket类型 546 21.2.12 HTML5的未来 547 21.3 小结 547</span><br><span class="line"></span><br><span class="line"> 第22章 JavaScript的未来 548 22.1 ECMAScript4&#x2F;JavaScript2 548 22.1.1 JavaScript1.5 548 22.1.2 JavaScript1.6 550 22.1.3 JavaScript1.7 552 22.1.4 JavaScript1.8 557 22.1.5 JavaScript1.9 558 22.1.6 ECMAScript4提案 559 22.1.7 变量类型 559 22.1.8 函数 561 22.1.9 类型定义 563 22.1.10 类和接口 565 22.1.11 接口 569 22.1.12 继承 569 22.1.13 命名空间 571 22.1.14 包 572 22.1.15 语言上的其他变更 572 22.1.16 ECMAScript4的未来 577 22.2 ECMAScript3.1 577 22.2.1 对对象内部实现的变更 578 22.2.2 静态对象方法 578 22.2.3 本地的JSON支持 585 22.2.4 Decimal 586 22.2.5 用法子集 589 22.2.6 ECMAScript3.1的未来 590 22.3 小结 590 附录A JavaScript库 591 附录B JavaScript工具 595</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B003V42XZW/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B003V42XZW&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/513OxZ4naNL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>大巧不工 Web前端设计修炼之道</title>
    <url>/2020/04/19/B0040NO87O/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 大巧不工 Web前端设计修炼之道<br>作者信息： 作者: 赖定清 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《大巧不工:Web前端设计修炼之道》：全面探讨Web前端设计的方法、原则、技巧和最佳实践5大专业社区一致鼎力推荐!前端开发工程师、前端设计师、前端架构师和用户体验设计师等新兴职业的出现，为前端设计和开发领域注入了新的生命和活力。随着用户对应用的体验的要求越来越高，前端领域面临的挑战越来越大，问题也越来越突出。其中最突出的问题便是缺少复合型的前端人才。从知识体系上讲，复合型的前端人才需要掌握和了解的知识非常之多，甚至可以用“庞杂”二字来形容。这导致一名出色的前端开发人才需要很长的时间来成长，因此行业对此类人才的需求极其迫切，从业前景看好。作为一个没有太多Web前端开发和设计经验的程序员，我们如何才能投身于这个充满美好前景和想象空间的领域？如何修炼自己的内功才能让自己从不会到会，从合格到优秀，从优秀到卓越？《大巧不工:Web前端设计修炼之道》能在你修炼的过程中提供良好的指导与参考。如果你在思考下面这些问题，也许《大巧不工:Web前端设计修炼之道》就是你想要的！作为一名合格的Web前端开发工程师，究竟需要具备哪些技能和素质？为什么说如果要精通Web前端开发这一行，必须先精通十行？前端设计者如何才能正确地理解自己的用户？如何理解并实践以用户为中心的设计原则？原型设计应该注意哪些问题？如何更好地利用工具快速地进行原型设计？可用性设计的关键要素是什么？如何设计高可用性的页面元素（导航、表单、链接等）？“可用性”的首要原则是“别让我思考”，你的网站如何才能做到不让用户思考呢？可用性测试的5项目标是什么？如何通过可用性测试发现问题现象背后的本质？如何保持设计的一致性？一致性设计的三项原则是什么？如何理解”样式就是设计”这句话？有哪些样式技术是前端开发者和设计者必须掌握的？样式究竟有哪些功能？如何编写易于管理、维护和复用的、JavaScript代码？、JavaScript有哪些最佳实践？如何理解HTML文件、CSS文件和、JavaScript文件之间的关系？如何良好地组织这些文件从而让它们更易于管理、复用和维护？如何平衡网站的色彩？如何让你的网站设计简洁而美观？页面排版的艺术你知多少？Web前端设计领域有哪些经典的设计思维？如何才能掌握这些设计思维的本质？如何测试前端的性能？前端性能优化的基本原则是什么？如何进行页面内容的优化和服务器端的优化？如何利用SEO技术让你的网站更容易被发现？CSS3与HTML5将带来哪些全新的设计方式？Web3.0真的来了吗？Web3.0的先驱者们有哪些杰出的表现？Web前端开发与设计的未来会怎样？</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">赞誉</span><br><span class="line">前言</span><br><span class="line">致谢</span><br><span class="line">第1章 Web前端开发ABC／1</span><br><span class="line">1.1 Web大局观／2</span><br><span class="line">1.1.1 混沌初开——Web的诞生／2</span><br><span class="line">1.1.2 网络技术的领导者——W3C／4</span><br><span class="line">1.1.3 不断优化的客户端技术／7</span><br><span class="line">1.1.4 服务端技术的成熟／8</span><br><span class="line">1.2 地位、曲线和使命／11</span><br><span class="line">1.2.1 前端开发路漫漫／11</span><br><span class="line">1.2.2 千军易得，一将难求／12</span><br><span class="line">1.2.3 令人望而却步的学习曲线／14</span><br><span class="line">1.2.4 前端开发人员如何自身定位／16</span><br><span class="line">1.3 前端开发所需掌握的技术／17</span><br><span class="line">1.4 前端开发常用的工具／25</span><br><span class="line">1.4.1 设计类工具／25</span><br><span class="line">1.4.2 原型类工具／26</span><br><span class="line">1.4.3 调试类工具／27</span><br><span class="line">1.4.4 辅助类工具／32</span><br><span class="line">1.5 小结／33 </span><br><span class="line"></span><br><span class="line"> 第2章 打造前端设计的基石——交出你的原型稿／34 2.1 UCD——以用户为中心的设计原则／35 2.1.1 关注用户／36 2.1.2 用户调研／39 2.1.3 更含蓄的方式／42 2.2 交出第一份设计稿／46 2.2.1 为什么原型设计很重要／47 2.2.2 原型如何表现／48 2.2.3 做好原型产品的注意事项／56 2.3 让工具帮助你／57 2.3.1 创建用户模型／58 2.3.2 BalsamiqMockups设计概念图／59 2.3.3 AxureRP设计交互原型／60 2.3.4 更真实的表现／66 2.4 小结／71</span><br><span class="line"></span><br><span class="line"> 第3章 从过去到未来——前端设计演变之路／72 3.1 最熟悉的陌生人／73 3.1.1 浏览器之争／73 3.1.2 性能对比／74 3.1.3 IEPKWeb标准／77 3.2 结构的变迁／83 3.2.1 表格噩梦／83 3.2.2 基于DIV和CSS的布局结构／86 3.3 不单纯是脚本／90 3.3.1 JavaScript的原貌／90 3.3.2 华丽的进化／92 3.3.3 AjaX不得不提／95 3.3.4 脚本框架的出现／96 3.4 接触未来(一)——初探HTML5／101 3.4.1 摘要／101 3.4.2 结构／102 3.4.3 Flash杀手Canvas?／105 3.4.4 设计一个布局结构文档／107 3.4.5 对表单的支持／109 3.5 接触未来(二)——CSS3的世界很精彩／110 3.5.1 选择器的变化／113 3.5.2 布局的变化／116 3.5.3 样式的变化／119 3.5.4 动画／120 3.6 小结／121</span><br><span class="line"></span><br><span class="line"> 第4章 让你的设计深入人心——可用性设计／122 4.1 可用性原则／123 4.1.1 别让我思考／124 4.1.2 停止你的假设／129 4.1.3 针对扫描而设计／132 4.2 高可用性页面／136 4.2.1 导航之道／137 4.2.2 当链接变成云／145 4.2.3 设计可用的表单／147 4.2.4 拒绝写作艺术／153 4.3 可用性测试／156 4.3.1 如何测试／157 4.3.2 现象与本质／158 4.4 巧妙地应对错误／159 4.4.1 提前预防／162 4.4.2 设计有用的信息／165 4.4.3 人性化操作／169 4.5 系统一致性设计／170 4.5.1 规范设计／172 4.5.2 有始有终／172 4.6 小结／173</span><br><span class="line"></span><br><span class="line"> 第5章 原型模型化／174 5.1 布局之道／175 …… 第6章 探索、品味、总结——经典设计思维 第7章 让你的设计更加完美——优化技巧和最佳实践 第8章 思考与展望——浅谈Web发展的未来</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0040NO87O/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0040NO87O&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41wMjtcHS3L._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>Python自然语言处理(影印版)</title>
    <url>/2020/04/19/B0047BHUTC/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Python自然语言处理(影印版)<br>作者信息： 作者: 洛普(Edward Loper) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Python自然语言处理(影印版)》由东南大学出版社出版。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Preface</span><br><span class="line">1.Language Processing and Python</span><br><span class="line">1.1 Computing with Language: Texts and Words</span><br><span class="line">1.2 A Closer Look at Python: Texts as Lists of Words</span><br><span class="line">1.3 Computing with Language: Simple Statistics</span><br><span class="line">1.4 Back to Python: Making Decisions and Taking Control</span><br><span class="line">1.5 Automatic Natural Language Understanding</span><br><span class="line">1.6 Summary</span><br><span class="line">1.7 Further Reading</span><br><span class="line">1.8 Exercises </span><br><span class="line"></span><br><span class="line"> 2.Accessing Text Corpora and Lexical Resources 2.1 Accessing Text Corpora 2.2 Conditional Frequency Distributions 2.3 More Python: Reusing Code 2.4 Lexical Resources 2.5 WordNet 2.6 Summary 2.7 Further Reading 2.8 Exercises</span><br><span class="line"></span><br><span class="line"> 3.Processing Raw Text 3.1 Accessing Text from the Web and from Disk 3.2 Strings: Text Processing at the Lowest Level 3.3 Text Processing with Unicode 3.4 Regular Expressions for Detecting Word Patterns 3.5 Useful Applications of Regular Expressions 3.6 Normalizing Text 3.7 Regular Expressions for Tokenizing Text 3.8 Segmentation 3.9 Formatting: From Lists to Strings 3.10 Summary 3.11 Further Reading 3.12 Exercises</span><br><span class="line"></span><br><span class="line"> 4.Writing Structured Programs 4.1 Back to the Basics 4.2 Sequences 4.3 Questions of Style 4.4 Functions: The Foundation of Structured Programming 4.5 Doing More with Functions 4.6 Program Development 4.7 Algorithm Design 4.8 A Sample of Python Libraries 4.9 Summary 4.10 Further Reading 4.11 Exercises</span><br><span class="line"></span><br><span class="line"> 5.Categorizing andTagging Words 5.1 Using a Tagger 5.2 Tagged Corpora 5.3 Mapping Words to Properties Using Python Dictionaries 5.4 Automatic Tagging 5.5 N-Gram Tagging 5.6 Transformation-Based Tagging 5.7 How to Determine the Category of a Word 5.8 Summary 5.9 Further Reading 5.10 Exercises</span><br><span class="line"></span><br><span class="line"> 6.Learning to Classify Text 6.1 Supervised Classification 6.2 Further Examples of Supervised Classification 6.3 Evaluation 6.4 Decision Trees 6.5 Naive Bayes Classifiers 6.6 Maximum Entropy Classifiers 6.7 Modeling Linguistic Patterns 6.8 Summary 6.9 Further Reading 6.10 Exercises</span><br><span class="line"></span><br><span class="line"> 7.Extracting Information from Text 7.1 Information Extraction 7.2 Chunking 7.3 Developing and Evaluating Chunkers 7.4 Recursion in Linguistic Structure 7.5 Named Entity Recognition 7.6 Relation Extraction 7.7 Summary 7.8 Further Reading 7.9 Exercises</span><br><span class="line"></span><br><span class="line"> 8.Analyzing Sentence Structure 8.1 Some Grammatical Dilemmas 8.2 What’s the Use of Syntax? 8.3 Context-Free Grammar 8.4 Parsing with Context-Free Grammar 8.5 Dependencies and Dependency Grammar 8.6 Grammar Development 8.7 Summary 8.8 Further Reading 8.9 Exercises</span><br><span class="line"></span><br><span class="line"> 9.Building Feature-Based Grammars 9.1 Grammatical Features 9.2 Processing Feature Structures 9.3 Extending a Feature-Based Grammar 9.4 Summary 9.5 Further Reading 9.6 Exercises</span><br><span class="line"></span><br><span class="line"> 10.Analyzing the Meaning of Sentences 10.1 Natural Language Understanding 10.2 Propositional Logic 10.3 First-Order Logic 10.4 The Semantics of English Sentences 10.5 Discourse Semantics 10.6 Summary 10.7 Further Reading 10.8 Exercises</span><br><span class="line"></span><br><span class="line"> 11.Managing Linguistic Data 11.1 Corpus Structure: A Case Study 11.2 The Life Cycle of a Corpus 11.3 Acquiring Data 11.4 Working with XML 11.5 Working with Toolbox Data 11.6 Describing Language Resources Using OLAC Metadata 11.7 Summary 11.8 Further Reading 11.9 Exercises Afterword: The Language Challenge Bibliography NLTK Index General Index</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0047BHUTC/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0047BHUTC&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51T9DBzcYRL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>犀利开发 jQuery内核详解与实践</title>
    <url>/2020/04/19/B0044KMLMC/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 犀利开发 jQuery内核详解与实践<br>作者信息： 作者: 朱印宏 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《犀利开发:jQuery内核详解与实践》：阿基米德说，给我一个支点，我能把地球撬起来。jQuery说，给你一个方法，你能让互联网炫目富有。顾名思义，jQuery融合了JavaScript+Query（查询）技术，汲取CSS+Xpath设计模式，让生涩的Java Script脚本变得敏捷而又犀利。掌握Queryg技术，就能够~JavaScript、DOM、CSS、Event、DHTML、Ajax、Form等技术之间游刃有余，让恼人的Web开发变得轻松而又生动。《犀利开发:jQuery内核详解与实践》从破解jQuery技术内核为切入点，由点入面，然后探析jQuery功能实现和开发，并比较Query技术与原生的JavaScript技术在实现方面的异同，及其执行效率之差异，真正帮助读者知其然，又能知其所以然。最后，通过一个综合案例让读者在实践中快速掌握Query开发。第一部破解jQuery核心技术的先锋图书，生动jQuery与JavaScript技术执行，效率和实现方法之异同，使用通俗易懂的语言深度刮忻iQuery框架设计模式和选择器实现原理潜心研究iQuery多年，耗时近一年，国内著名原创IT作者又一力作。CD-ROM：本书实例素材和源代码，CSS参考手册，jQuery参考手册，Ajax参考手册，JavaScript参考手册，HTML参考手册。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 jQuery起步</span><br><span class="line">1.1 认识jQuery</span><br><span class="line">1.1 JavaScnpt及其库</span><br><span class="line">1.1.2 选用jQuery框架的理由～</span><br><span class="line">1.2 jQuery初步体验</span><br><span class="line">1.2.1 安装jQuery库</span><br><span class="line">1.2.2 导入jQuery库</span><br><span class="line">1.2 ,3编写jQuery代码</span><br><span class="line">1.2.4 区分jQuery对象和DOM对象</span><br><span class="line">1.2.5 jQuery对象和DOM对象的相互转换</span><br><span class="line">1.2.6 ready事件和load事件比较</span><br><span class="line">1.3 jQuery核心特性</span><br><span class="line">1.3.1 jQuery构造函数</span><br><span class="line">1.3.2 jQuery链式语法</span><br><span class="line">1.3.3 jQuery选择器</span><br><span class="line">1.3.4 jQuery扩展性 </span><br><span class="line"></span><br><span class="line"> 第2章 jQuery技术解密 2,1jQuery框架设计概述 2.1.1 设计目标 2.1.2 目标实现 2.2 jQuery原型技术分解 2.2.1 起源——原型继承 2.2.2 生命——返回实例 2.2.3 学步——分隔作用域 2.2.4 生长_跨域访问 2.2.5 成熟——选择器 2,2.6 延续——迭代器 2.2.7 延续——功能扩展 2.2.8 延续——参数处理 2.2.9 涅槃——名字空间 2.3 破解jQuery选择器接口 2,3.1 简单但很复杂的黑洞 2.3.2 盘根错节的逻辑关系 2.3.3 jQuery构造器 2.3.4 生成DOM元素 2.3.5 引用DOM元素 2.4 解析jQuery选择器引擎Sizzle 2,4.1 回顾CSS的选择器 2.4.2 解析jQuery选择器引擎的设计思路 2.4.3 选择器和过滤器 2.4.4 Sizzle引擎结构～ 2.4.5 Sizzle构造器 2.4.6 Sizzle选择器 2.4.7 Sizzle过滤器 2.4.8 jQuery选择器应用优化 2.5 类数组 2.5.1 定义类数组 2.5.2 操作类数组</span><br><span class="line"></span><br><span class="line"> 第3章 高效选择的技巧与原理 3.1 选择器是什么 3.1.1 从CSS选择器说起 3.1.2 jQuery盗了谁的版 3.1.3 认识cssQuery选择器 3.1.4 使用cssQuery选择器 3.1.5 初步接触jQuery选择器 3.2 简单选择器 3.2.1 选择指定ID元素 3.2.2 选择指定类型元素 3.2.3 选择指定类元素 3.2.4 选择所有元素及其优化 3.2.5 选择多组元素及其实现 3.3 关系选择器 3.3.1 层级选择器 3.3.2 层级选择器的实现方法 3.3.3 子元素选择器 3.3.4 子元素选择器的实现方法 3.4 过滤选择器 3.4.1.定位过滤器 3.4.2 定位过滤器的实现方法 3.4.3 内容过滤器 3.4.4 内容过滤器的实现方法 3.4.5 可见过滤器 3.4.6 可见选择器的实现方法 3.5 属性选择器 3.5.1 使用属性选择器 3.5.2 属性选择器的实现方法 3.6 表单选择器 3.6.1 基本表单选择器 3.6.2 高级表单选择器 3.6.3 表单选择器的实现方法</span><br><span class="line"></span><br><span class="line"> 第4章 文档对象的操作及其 高效实践 4.1 DOM标准 4.1.1 分解DOM 4.1.2 HTMLDOM 4.1.3 DOMCore 4.1.4 DOM文档树 4.2 创建节点 4.2.1 创建元素 4.2.2 创建文本 4.2.3 创建属性 4.3 插入元素 4.3.1 jQuery实现 4.3.2 JavaScript实现 4.3.3 自定义JavaScript扩展DOM功能函数 4.3.4.使用JavaScript自定义appendT00和prependTo()方法 4.3.5 使用IavaScript自定义 after()和before()方法 4.3.6 使用JavaScript自定义insertAfter()和insertBefore()方法 4.4 删除元素 4.4.1 jQuery实现 4.4 ,2JavaScript实现 4.4.3 使用IavaScript自定义empty()方法 4.5 复制元素 4.5.1 jQuery实现 4.5.2 JavaScript实现 4.6 替换元素 4.6.1 jQuery实现 4.6.2 IavaScript实现 4.6.3 使用IavaScript：自定义replaceWith()和replaceAll()方法 4.7 包裹元素 4.7.1 jQuery实现 4.7.2 使用IavaScript自定义wrap0、wrapAllCl和wraplnner(一)方法 4.8 操作属性 4.8.1 设置属性 4.8.2 获取属性 4.8.3 删除属性 4.9 操作类样式 4.9.1 追加样式 4.9.2 移出样式 4.9.3 切换样式 4.9.4 判断样式 4.1 0操作HTML、文本和值 4.1 0.1.读写HTML字符串 4.1 0.2 读写文本内容 4.1 0.3 读写表单值 4.1 1操作样式表 4.1 1.1 通用CSS样式读写方法 4.1 1.2 绝对偏移位置 4.1 1.3 相对偏移位置 4.1 1.4 扩展DOM操作函数 4.1 1.5 元素的宽和高 4.1 2元素遍历操作 4.1 2.1 jQuery实现的元素遍历方法 4.1 2.2 JavaScript.实现的元素遍历方法</span><br><span class="line"></span><br><span class="line"> 第5章 事件封装机制与解析 5.1 事件模型 5.1.1 0级事件模型 5.1.2 事件模型中的Event对象 5.1.3 事件模型中的冒泡现象 5.1..4 事件流控制与默认事件动作 5.1.5 2级DOM标准事件模型 5.1.6 IE事件模型 5.2 jQuery事件模型 5.2.1 绑定事件 5.2.2 注销事件 5.2.3 jQuery事件模型中的Event对象 5.2.4 jQuery事件触发 5.2.5 jQuery事件切换 5.2.6 jQuery事件委派 5.2.7 jQuery事件命名空间 5.2.8 jQuery的多事件绑定 5.2.9 jQuery自定义事件 5.3 jQuery页面初始化 5.3.1 使用jQuery的ready0方法 5.3.2 ready事件的触发时机 5.3.3 初始化事件的多次调用 5.3.4 使用IavaScript自定义addLoadEvent()方法 5.4 使用IavaScript自定义jQuery事件方法 5.4.1 JavaScript与jQuery的执行效率比较 5.4.2 自定义ready()方法 5.4.3 目定义bind()方法 5.4.4 自定义one()方法</span><br><span class="line"></span><br><span class="line"> 第6章 动画效果设计及其高效实践 6.1 直接显示和隐藏 6.1.1 jQuery实现显隐效果 6.1.2 JavaScript实现显隐效果 6.1.3 折叠效果 6.1.4 树形结构 6.1.5 Tab选项卡 6.1.6 显隐切换 6.2 滑动显示和隐藏 6.2.1 jQuery实现的滑动显隐效果 6.2.2 JavaScript实现的滑动显示效果 6.2.3 JavaScript实现的滑动隐藏效果 6.2.4 jQuery设计的滑动显隐切换 6.3 渐隐和渐显 6.3.1 jQuery实现的渐隐渐显效果 6.3.2 JavaScript实现的渐显效果 6.3.3 IavaScript实现的渐隐效果 6.4 自定义动画 6.4.1 jQuery自定义动画 6.4 ,2使用jQuery停止动画 6.4.3 使用jQuery关闭动画 6.4.4 使用lavaScript实现滚动动画</span><br><span class="line"></span><br><span class="line"> 第7章 AjaX异步通信高效实践 7.1 Ajax应用准备 7.1.1 Ajax应用利弊分析 7.1.2 安装虚拟服务器 7.2 Ajax应用的第一个示例 7.2.1 jQuery实现 7.2.2 JavaScript实现 7.3 从JavaScript角度分析XMLHttpRequest对象 7.3.1 XMLHttpRequest对象成员和用法 7.3.2 建立异步连接 7.3.3 发送请求 7.3.4 发送GET请求 7.3.5 发送POST请求 7.3.6 跟踪响应状态 7.3.7 获取响应信息 7.4 从jQuery角度分析XMLHttpRequest对象 7.4.1 使用GET方式请求 7.4.2 使用POST方式请求 7.4.3 使用ajax()方法请求 7.4.4 跟踪响应状态 7.4.5 载入网页文件 7.4.6 预设Ajax选项 7.4.7 预处理请求的字符串</span><br><span class="line"></span><br><span class="line"> 第8章 高效开发和使用插件 8.1 创建jQuery插件 8.1.1 jQuery插件的类型 8.1.2 解析jQuery插件机制 8.1.3 创建jQuery全局函数 8.1.4 使用jQuery.fn对象创建jQuery对象方法 8.1.5 使用extend()方法创建jQuery对象方法 8.1.6 创建自定义选择器 8.1.7 优化jQuery默认选择器 8.1.8 封装jQuery插件 …… 第9章 jQuery辅助工具 第10章 使用jQuery打造Ajax异步交互式动态网站</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0044KMLMC/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0044KMLMC&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41U3ixtQ3vL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>与孩子一起学编程</title>
    <url>/2020/04/19/B004BNA3HW/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 与孩子一起学编程<br>作者信息： 作者: 桑德(Warren Sande) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《与孩子一起学编程》：一本老少咸宜的编程入门奇书！一册在手，你完全可以带着自己的孩子，跟随Sande父子在轻松的氛围中熟悉那些编程概念。如内存、循环、输入和输出、数据结构和图形用户界面等。这些知识一点儿也不高深。听起来备感亲切。书中言语幽默风趣而不失真义。让学习过程充满乐趣。细心的作者还配上了孩子们都喜欢的可爱漫画和经过运行测试的程序示例，教你用最易编写和最易理解的Python语言。写出你梦想中的游戏程序。“Hello，world我来了！”编程乐趣无穷，起点就在脚下。请引导你的孩子走进这奇妙的世界。无论是中小学生还是其他初学者，都可以跟随《与孩子一起学编程》学习Python编程，并过渡到任何其他语言，重要的是你将学会思考问题和解决问题的方法。荣获Jolt生产效率大奖，亚马逊畅销图书，生动风趣，图文并茂。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 出发吧</span><br><span class="line">1.1 安装Python</span><br><span class="line">1.2 从IDLE启动Python</span><br><span class="line">1.3 来点指令吧</span><br><span class="line">1.4 与Python交互</span><br><span class="line">1.5 该编程了</span><br><span class="line">1.6 运行你的第一个程序</span><br><span class="line">1.7 如果出问题</span><br><span class="line">1.8 你的第二个程序 </span><br><span class="line"></span><br><span class="line"> 第2章 记住内存和变量 2.1 输入、处理和输出 2.2 名字 2.3 名字里是什么 2.4 数字和字符串 2.5 它们有多“可变” 2.6 全新的我</span><br><span class="line"></span><br><span class="line"> 第3章 基本数学运算 3.1 四大基本运算 3.2 操作符 3.3 运算顺序 3.4 另外两个操作符 3.5 非常大和非常小</span><br><span class="line"></span><br><span class="line"> 第4章 数据的类型 4.1 改变类型 4.2 得到更多信息：type（） 4.3 类型转换错误 4.4 使用类型转换</span><br><span class="line"></span><br><span class="line"> 第5章 输入 5.1 raw_input（） 5.2 Print命令和逗号 5.3 输入数字 5.4 来自互联网的输入</span><br><span class="line"></span><br><span class="line"> 第6章 GUI——图形用户界面 6.1 什么是GUI 6.2 第一个GUI 6.3 GUI输入 6.4 选择你的口味 6.5 再看猜数游戏 6.6 其他GUI组件</span><br><span class="line"></span><br><span class="line"> 第7章 判断再判断 7.1 测试，测试 7.2 缩进 7.3 是不是有问题 7.4 其他类型的测试 7.5 如果测试为假会怎么样 7.6 测试多个条件 7.7 使用and 7.8 使用or 7.9 使用not</span><br><span class="line"></span><br><span class="line"> 第8章 转圈圈 8.1 计数循环 8.2 使用计数循环 8.3 一条捷径——range（） 8.4.风格问题——循环变量名 8.5 按步长计数 8.6 没有数字的计数 8.7 关于这个问题 8.8 跳出循环——break和continue</span><br><span class="line"></span><br><span class="line"> 第9章 全都为了你——注释 9.1 增加注释 9.2 单行注释 9-3行末注释 9.4 多行注释 9.5 注释风格 9.6 注释掉</span><br><span class="line"></span><br><span class="line"> 第10章 游戏时间到了</span><br><span class="line"></span><br><span class="line"> 第11章 嵌囊与可变循环 11.1 嵌套循环 11.2 可变循环 11.3 可变嵌套循环 11.4 更多可变嵌套循环 11.5 使用嵌套循环</span><br><span class="line"></span><br><span class="line"> 第12章 收集起来——列表 12.1 什么是列表 12.2 创建列表 12.3 向列表增加元素 12.4 这个点是什么 12.5 列表可以包含任何内容 12.6 从列表获取元素 12.7 列表“分片 12.8 修改元素 12.9 向列表增加元素的其他方法 12.10 从列表删除元素 12.11 搜索列表 12.12 循环处理列表 12.13 列表排序 12.14 可改变和不可改变 12.15 双重列表：数据表</span><br><span class="line"></span><br><span class="line"> 第13章 函数 13.1 函数——积木 13.2 调用函数 13.3 向函数传递参数 13.4 有多个参数的函数 13.5 返回值的函数 13.6 变量作用域 13.7 强制为全局 13.8 关于变量命名的一点建议</span><br><span class="line"></span><br><span class="line"> 第14章 对象 14.1 真实世界中的对象 14.2 Python中的对象 14.3 对象&#x3D;属性+方法 14.4 这个点是什么 14.5 创建对象 14.6 一个示例类——Hot Dog 14.7 隐藏数据 14.8 多态和继承 14.9 未雨绸缪</span><br><span class="line"></span><br><span class="line"> 第15章 模块 15.1 什么是模块 15.2 为什么使用模块 15.3 积木桶 15.4 如何创建模块 15.5 如何使用模块 15.6 命名空间 15.7 标准模块</span><br><span class="line"></span><br><span class="line"> 第16章 图形 16.1 寻求帮助——Pygame 16.2 Pygame窗口 163在窗口中画图 16.4 单个像素 16.5 图像 16.6 动起来 16.7 动画 16.8 更流畅的动画 16.9 让球反弹 16.10 让球翻转</span><br><span class="line"></span><br><span class="line"> 第17章 动画精灵和碰撞检测 17.1 动画精灵 17.2 嘣！碰撞检测 17.3 统计时间</span><br><span class="line"></span><br><span class="line"> 第18章 一种新的输入——事件 18.1 事件 18.2 键盘事件 18.3 鼠标事件 18.4 定时器事件 18.5 另一个游戏PyPong</span><br><span class="line"></span><br><span class="line"> 第19章 声音 19.1 从Pygame寻求更多帮助——mixer 19.2 制造声音与播放声音 19.3 播放声音 19.4 控制音量 19.5 重复音乐 19.6 为PyPong增加声音 19.7 更多声音 19.8 为PyPong增加音乐</span><br><span class="line"></span><br><span class="line"> 第20章 更多GUI 20.1 使用Python Card 20.2 组件 20.3 让GUI做点事情 20.4 事件处理器的返回 20.5 移动按钮 20.6 更多有用的GUI 20.7 Temp GUI 20.8 菜单上是什么</span><br><span class="line"></span><br><span class="line"> 第21章 打印格式化与字符串 21.1 换行 21.2 水平间隔——制表符 21.3 在字符串中插入变量 21.4 数字格式化 21.5 更多字符串处理</span><br><span class="line"></span><br><span class="line"> 第22章 文件输入与输出 22.1 什么是文件 22.2 文件名 22.3 文件位置 22.4 打开文件 22.5 读文件 22.6 文本文件和二进制文件 22.7 写文件 22.8 在文件中保存内容：pickle 22.9 又到了游戏时间——Hangman</span><br><span class="line"></span><br><span class="line"> 第23章 碰运气——随机性 23.1 什么是随机性 23.2 掷骰子 23.3 创建一副牌 23.4 Crazy Eights</span><br><span class="line"></span><br><span class="line"> 第24章 计算机仿真 24.1 真实世界建模 24.2 LHnar Lander 24.3 跟踪时间 24.4 时间对象 24.5 把时间保存到文件 24.6 电子宠物</span><br><span class="line"></span><br><span class="line"> 第25章 接下来呢 25.1 一般编程 25.2 Python 25.3 游戏编程与Pygame 25.4 其他Python模块 25.5 回顾 附录 变量命名规则 自测题答案</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B004BNA3HW/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B004BNA3HW&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41rWtpINaJL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python参考手册(第4版)</title>
    <url>/2020/04/19/B004H0784U/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Python参考手册(第4版)<br>作者信息： 作者: David M.Beazley [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Python参考手册(第4版)》：经典著作全面升级Python程序员案头必备涵盖Python 2和Python 3共有特性</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分 Python语言</span><br><span class="line">第1章 Python简介</span><br><span class="line">1.1 运行Python</span><br><span class="line">1.2 变量和算术表达式</span><br><span class="line">1.3 条件语句</span><br><span class="line">1.4 文件输入和输出</span><br><span class="line">1.5 字符串</span><br><span class="line">1.6 列表</span><br><span class="line">1.7 元组</span><br><span class="line">1.8 集合</span><br><span class="line">1.9 字典</span><br><span class="line">1.10 迭代与循环</span><br><span class="line">1.11 函数</span><br><span class="line">1.12 生成器</span><br><span class="line">1.13协程</span><br><span class="line">1.14 对象与类</span><br><span class="line">1.15 异常</span><br><span class="line">1.16 模块</span><br><span class="line">1.17 获得帮助 </span><br><span class="line"></span><br><span class="line"> 第2章 词汇和语法约定 2.1 行结构和缩进 2.2 标识符和保留字 2.3 数字字面量 2.4.字符串字面量 2.5 容器 2.6 运算符、分隔符及特殊符号 2.7 文档字符串 2.8 装饰器 2.9 源代码编码</span><br><span class="line"></span><br><span class="line"> 第3章 类型与对象 3.1 术语 3.2 对象的身份与类型 3.3 引用计数与垃圾收集 3.4 引用与复制 3.5 第一类对象 3.6 表示数据的内置类型 3.6.1 None类型 3.6.2 数字类型 3.6.3 序列类型 3.6.4 映射类型 3.6.5 集合类型 3.7 表示程序结构的内置类型 3.7.1 可调用类型 3.7.2 类、类型与实例 3.7.3 模块 3.8 解释器内部使用的内置类型 3.8.1 代码对象 3.8.2 帧对象 3.8.3 跟踪对象 3.8.4 生成器对象 3.8.5 切片对象 3.8.6 Ellipsis对象 3.9 对象行为与特殊方法 3.9.1 对象的创建与销毁 3.9.2 对象字符串表示 3.9.3 对象比较与排序 3.9.4 类型检查 3.9.5 属性访问 3.9.6 属性包装与描述符 3.9.7 序列与映射方法 3.9.8 迭代 3.9.9 数学操作 3.9.10 可调用接口 3.9.11 上下文管理协议 3.9.12 对象检查与dir()</span><br><span class="line"></span><br><span class="line"> 第4章 运算符与表达式 4.1 数字操作 4.2 序列操作 4.3 字符串格式化 4.4 高级字符串格式化 4.5 字典操作 4.6 集合操作 4.7 增量赋值 4.8 属性(.)运算符 4.9 函数调用()运算符 4.10 转换函数 4.11 布尔表达式与真值 4.12 对象的比较与身份 4.13 运算优先级 4.14 条件表达式</span><br><span class="line"></span><br><span class="line"> 第5章 程序结构与控制流 5.1 程序结构与执行 5.2 执行条件语句 5.3 循环与迭代 5.4 异常 5.4.1 内置异常 5.4.2 定义新异常 5.5 上下文管理器与with语句 5.6 断言与debug</span><br><span class="line"></span><br><span class="line"> 第6章 函数与函数编程 6.1 函数 6.2 参数传递与返回值 6.3 作用域规则 6.4 函数对象与闭包 6.5 装饰器 6.6 生成器与yield 6.7 协程与yield表达式 6.8 使用生成器与协程 6.9 列表包含 6.10 生成器表达式 6.11 声明式编程 6.12 lambda运算符 6.13 递归 6.14 文档字符串 6.15 函数属性 6.16 eval()、exec()和compile()函数</span><br><span class="line"></span><br><span class="line"> 第7章 类与面向对象编程 7.1 class语句 7.2 类实例 7.3 范围规则 7.4 继承 7.5 多态动态绑定和鸭子类型 7.6 静态方法和类方法 7.7 特性 7.8 描述符 7.9 数据封装和私有属性 7.10 对象内存管理 7.11 对象表示和属性绑定 7.12 slots 7.13 运算符重载 7.14 类型和类成员测试 7.15 抽象基类 7.16 元类 7.17 类装饰器</span><br><span class="line"></span><br><span class="line"> 第8章 模块、包与分发 8.1 模块与import语句 8.2 从模块导入选定符号 8.3 以主程序的形式执行 8.4 模块搜索路径 8.5 模块加载和编译 8.6 模块重新加载和卸载 8.7 包 8.8 分发Python程序和库 8.9 安装第三方库</span><br><span class="line"></span><br><span class="line"> 第9章 输入与输出 9.1 读取命令行选项 9.2 环境变量 9.3 文件和文件对象 9.4 标准输入、输出和错误 9.5 print语句 9.6 print()函数 9.7 文本输出中的变量插入 9.8 生成输出 9.9 Unicode字符串处理 9.10 UnicodeI／O 9.10.1 Unicode数据编码 9.10.2 Unicode字符特性 9.11 对象持久性与pickle模块</span><br><span class="line"></span><br><span class="line"> 第10章 执行环境 10.1 解释器选项与环境 10.2 交互式会话 10.3 启动python应用程序 10.4 站点配置文件 10.5 用户站点包 10.6 启用新功能 10.7 程序终止</span><br><span class="line"></span><br><span class="line"> 第11章 测试、调试、探查与调优 11.1 文档字符串和doctest模块 11.2 单元测试和unittest模块 11.3 Python调试器和pdb模块 11.3.1 调试器命令 11.3.2 从命令行进行调试 11.3.3 配置调试器 11.4 程序探查 11.5 调优与优化 11.5.1 进行计时测量 11.5.2 进行内存测量 11.5.3 反汇编 11.5.4 调优策略</span><br><span class="line"></span><br><span class="line"> 第二部分 Python库 第12章 内置函数和异常 12.1 内置函数和类型 12.2 内置异常 12.2.1 异常基类 12.2.2 异常实例 12.2.3 预定义的异常类 12.3 内置警告 12.4 future_builtins</span><br><span class="line"></span><br><span class="line"> 第13章 Python运行时服务 13.1 a七exit 13.2 copy 13.3 gc 13.4 inspect 13.5 marshal 13.6 pickle 13.7 SYS 13.7.1 变量 13.7.2 函数 13.8 traceback 13.9 types 13.10 warnings 13.11 weakref</span><br><span class="line"></span><br><span class="line"> 第14章 数学运算 14.1 decimal 14.1.1 Decimal对象 14.1.2 Context对象 14.1.3 函数和常量 14.1.4 示例 14.2 fractions 14.3 math 14.4 numbers 14.5 random 14.5.1 种子和初始化 14.5.2 随机整数 14.5.3 随机序列 14.5.4 实值随机分布</span><br><span class="line"></span><br><span class="line"> 第15章 数据结构、算法与代码简化 15.1 abc 15.2 array 15.3 bisect 15.4 collections 15.4.1 deque和defaultdict 15.4.2 命名元组 15.4.3 抽象基类 15.5 contextlib 15.6 functoos 15.7 heapq 15.8 itertools 15.9 operator</span><br><span class="line"></span><br><span class="line"> 第16章 字符串和文本处理 16.1 odecs 16.1.1 低级codecs接口 16.1.2 I／O相关函数 16.1.3 有用的常量 16.1.4 标准编码 16.1.5 注意 16.2 re 16.2.1 模式语法 16.2.2 函数 16.2.3 正则表达式对象 16.2.4 匹配对象 16.2.5 示例 16.2.6 注意 16.3 string 16.3.1 常量 16.3.2 Formatter对象 16.3.3 Template字符串 16.3.4 实用工具函数 16.4 struct 16.4.1 打包和解包函数 16.4.2 Struct对象 16.4.3 格式编码 16.4.4 注意 16.5 unicodedata</span><br><span class="line"></span><br><span class="line"> 第17章 Python数据库访问 17.1 关系数据库API规范 17.1.1 连接 17.1.2 Cursor 17.1.3 生成查询 17.1.4 类型对象 17.1.5 错误处理 17.1.6 多线程 17.1.7 将结果映射到字典中 17.1.8 数据库API扩展 17.2 sqlite3模块 17.2.1 模块级函数 17.2.2 连接对象 17.2 13游标和基本操作 17.3 DBM风格的数据库模块 17.4 shelve模块</span><br><span class="line"></span><br><span class="line"> 第18章 文件和目录处理 18.1 bz2 18.2 filecmp 18.3 fnmatch 18.4 glob 18.5 gzip 18.6 Shutil 18.7 tarfile 18.7.1 异常 18.7.2 示例 18.8 tempfile 18.9 zipfile 18.10 z1ib</span><br><span class="line"></span><br><span class="line"> 第19章 操作系统服务 19.1 Commands模块 19.2 ConfigParser、configparser模块 19.2.IconfigParser类 19.2.2 示例 19.2.3 注意 19.3 datetime模块 19.3.1 date对象 19.3.2 time对象 19.3.3 datetime对象 19.3.4 timedelta对象</span><br><span class="line"></span><br><span class="line"> …… 第20章 线程与并发性 第21章 网络编程和套接字 第22章 Internet应用程序编程 第23章 Web编程 第24章 Internet数据处理和编码 第25章 其他库模块</span><br><span class="line"></span><br><span class="line"> 第三部分 扩展与嵌入 第26章 扩展与嵌入Python 附录 Python 3</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B004H0784U/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B004H0784U&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/519tug9lYhL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Head First PHP &amp; MySQL(中文版)</title>
    <url>/2020/04/19/B004R1QIJU/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Head First PHP &amp; MySQL(中文版)<br>作者信息： 作者: 贝伊利(Lynn Beighley) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Head First PHP &amp; MySQL(中文版)》：发现数据库驱动的动态网站背后的秘密，避免Web表单的尴尬遭遇，把所有关键语法直接载入大脑，关联PHP和MySQL代码，通过数千个练习巩固你的脚本知识。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">引子</span><br><span class="line">充满生机：静态页面赋予生命</span><br><span class="line">如何连接在一起：连接My SQL</span><br><span class="line">创建你自己的数据：创建与填充数据库</span><br><span class="line">你的Web应用：现实的实际应用</span><br><span class="line">如果数据库还不够：使用存储在文件中的数据</span><br><span class="line">假想他们都在搜寻你：保证应用安全</span><br><span class="line">还记得我吗?构建个性化Web应用</span><br><span class="line">分享就是关爱：消除重复代码</span><br><span class="line">收获数据：控制你的数据，世界在你手中</span><br><span class="line">通过函数改善生活：串与定制函数</span><br><span class="line">替换规则：正则表达式</span><br><span class="line">绘制动态图像：数据可视化……以及更多!</span><br><span class="line">与世界连接：合成与Web服务</span><br><span class="line">(我们没有谈到的)十大主题：其他</span><br><span class="line">搭建舞台：建立开发环境</span><br><span class="line">还可以更多：扩展PHP</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B004R1QIJU/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B004R1QIJU&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51%2BHb8c4Q-L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>哥德尔、艾舍尔、巴赫 集异璧之大成</title>
    <url>/2020/04/19/B0049MPCAS/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 哥德尔、艾舍尔、巴赫 集异璧之大成<br>作者信息： 作者: 侯世达 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《哥德尔、艾舍尔、巴赫:集异璧之大成》由商务印书馆出版。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">作者为中文版所写的前言</span><br><span class="line">译校者的话</span><br><span class="line">概览</span><br><span class="line">插图目录</span><br><span class="line">鸣谢</span><br><span class="line">题献</span><br><span class="line">上篇：集异璧GEB</span><br><span class="line">导言 一首音乐—逻辑的奉献</span><br><span class="line">三部创意曲</span><br><span class="line">第一章 WU谜题</span><br><span class="line">二部创意曲</span><br><span class="line">第二章 数学中的意义与形式</span><br><span class="line">无伴奏阿基里斯奏鸣曲</span><br><span class="line">第三章 图形与衬底</span><br><span class="line">对位藏头诗</span><br><span class="line">第四章 一致性、完全性与几何学</span><br><span class="line">和声小迷宫</span><br><span class="line">第五章 递归结构和递归过程</span><br><span class="line">音程增值的卡农</span><br><span class="line">第六章 意义位于何处</span><br><span class="line">半音阶幻想曲，及互格</span><br><span class="line">第七章 命题演算</span><br><span class="line">螃蟹卡农</span><br><span class="line">第八章 印符数论</span><br><span class="line">一首无的奉献</span><br><span class="line">第九章 无门与哥德尔 </span><br><span class="line"></span><br><span class="line"> 下篇： 异集璧EGB 前奏曲 第十章 描述的层次和计算机系统 蚂蚁赋格 第十一章 大脑和思维 英、法、德、中组曲 第十二章 心智和思维 咏叹调及其种种变奏 第十三章 BlooP和FlooP和Gl00P G弦上的咏叹调 第十四章 论TNT及有关系统中形式上不可判定的命题 生日大合唱哇哇哇乌阿乌阿乌阿 第十五章 跳出系统 一位烟民富于启发性的思想 第十六章 自指和自复制 的确该赞美螃蟹 第十七章 丘奇、图灵、塔斯基及别的人 施德鲁，人设计的玩具 第十八章 人工智能：回顾 对实 第十九章 人工智能：展望 树懒卡农 第二十章 怪圈，或缠结的层次结构 六部无插入赋格 注释 文献目录 索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0049MPCAS/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0049MPCAS&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51tDUoeYGwL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>Python灰帽子 黑客与逆向工程师的Python编程之道</title>
    <url>/2020/04/19/B004S76ZOG/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Python灰帽子 黑客与逆向工程师的Python编程之道<br>作者信息： 作者: 丁赟卿 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Python灰帽子:黑客与逆向工程师的Python编程之道》：安全技术大系</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 搭建开发环境</span><br><span class="line">1.1 操作系统要求</span><br><span class="line">1.2 获取和安装Python 2.5</span><br><span class="line">1.2.1 在Windows下安装Python</span><br><span class="line">1.2.2 在Linux下安装Python</span><br><span class="line">1.3 安装Eclipse和PyDev</span><br><span class="line">1.3.1 黑客挚友:ctype库</span><br><span class="line">1.3.2 使用动态链接库</span><br><span class="line">1.3.3 构建C数据类型</span><br><span class="line">1.3.4 按引用传参</span><br><span class="line">1.3.5 定义结构体和联合体 </span><br><span class="line"></span><br><span class="line"> 第2章 调试器原理和设计 2.1 通用寄存器 2.2 栈 2.3 调试事件 2.4 断点 2.4.1 软断点 2.4.2 硬件断点 2.4.3 内存断点</span><br><span class="line"></span><br><span class="line"> 第3章 构建自己的Windows调试器 3.1 Debugee,敢问你在何处 3.2 获取寄存器状态信息 3.2.1 线程枚举 3.2.2 功能整合 3.3 实现调试事件处理例程 3.4 无所不能的断点 3.4.1 软断点 3.4.2 硬件断点 3.4.3 内存断点 3.5 总结</span><br><span class="line"></span><br><span class="line"> 第4章 PyDbg——Windows下的纯Python调试器 4.1 扩展断点处理例程 4.2 非法内存操作处理例程 4.3 进程快照 4.3.1 获取进程快照 4.3.2 汇总与整合</span><br><span class="line"></span><br><span class="line"> 第5章 Immunity Debugger-两极世界的最佳选择 5.1 安装Immunity Debugger 5.2 Immunity Debugger 5.2.1 PyCommand命令 5.2.2 PyHooks 5.3 Exploit（漏洞利用程序）开发 5.3.1 搜寻exploit友好指令 5.3.2“坏”字符过滤 5.3.3 绕过Windows下的DEP机制 5.4 破除恶意软件中的反调试例程 5.4 1 lsDebuugerPresent 5.4.2 破除进程枚举例程</span><br><span class="line"></span><br><span class="line"> 第6章 钩子的艺术 6.1 使用PyDbg部署软钩子 6.2 使用Immunity Debugger部署硬钩子</span><br><span class="line"></span><br><span class="line"> 第7章 DLL注入与代码注入技术 7.1 创建远程线程 7.1.1 DLL注入 7.1.2 代码注入 ……</span><br><span class="line"></span><br><span class="line"> 第8章 Fuzzing 第9章 Sulley 第10章 面向Windows驱动的Fuzzing测试技术 第11章 IDAPyrhon——IDA PRO环境下的Pyrhon 第12章 PYEmu——脚本驱动式仿真器</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B004S76ZOG/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B004S76ZOG&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51bnNY6QgqL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习手册(第4版)</title>
    <url>/2020/04/19/B004TUJ7A6/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Python学习手册(第4版)<br>作者信息： 作者: 鲁特兹(Mark Lutz) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Google和YouTube由于PythonF的高可适应性、易于维护以及适合于快速开发而采用它。《Python学习手册(第4版)》将帮助你使用Python编写出高质量、高效的并且易于与其他语言和工具集成的代码。《Python学习手册(第4版)》根据Python专家MarkLutz的著名培训课程编写而成，是易于掌握和自学的Python教程。《Python学习手册(第4版)》每一章都对Python语言的关键内容做单独讲解，并且配有章首习题，便于你学习新的技能并巩固加深自己的理解。书中配有大量注释的示例以及图表，它们都将帮助你轻松地学习Python3．0。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言1</span><br><span class="line">第一部分 使用入门</span><br><span class="line">第1章 问答环节19</span><br><span class="line">人们为何使用Python19</span><br><span class="line">软件质量20</span><br><span class="line">开发效率21</span><br><span class="line">Python是“脚本语言”吗21</span><br><span class="line">好吧，Python的缺点是什么呢23</span><br><span class="line">如今谁在使用Python23</span><br><span class="line">使用Python可以做些什么24</span><br><span class="line">系统编程25</span><br><span class="line">用户图形接口25</span><br><span class="line">Internet脚本25</span><br><span class="line">组件集成26</span><br><span class="line">数据库编程26</span><br><span class="line">快速原型27</span><br><span class="line">数值计算和科学计算编程27</span><br><span class="line">游戏、图像、人工智能、XML、机器人等27</span><br><span class="line">Python如何获得支持28</span><br><span class="line">Python有哪些技术上的优点28</span><br><span class="line">面向对象28</span><br><span class="line">免费29</span><br><span class="line">可移植29</span><br><span class="line">功能强大30</span><br><span class="line">可混合31</span><br><span class="line">简单易用31</span><br><span class="line">简单易学32</span><br><span class="line">Python和其他语言比较起来怎么样32</span><br><span class="line">本章小结33</span><br><span class="line">本章习题33</span><br><span class="line">习题解答34</span><br><span class="line">Python是工程，不是艺术34 </span><br><span class="line"></span><br><span class="line"> 第2章 Python如何运行程序36 Python解释器简介36 程序执行37 程序员的视角37 Python的视角39 执行模块的变体41 Python实现的替代者42 执行优化工具43 冻结二进制文件44 其他执行选项45 未来的可能性46 本章小结46 本章习题47 习题解答47</span><br><span class="line"></span><br><span class="line"> 第3章 如何运行程序48 交互提示模式下编写代码48 交互地运行代码49 为什么使用交互提示模式51 使用交互提示模式52 系统命令行和文件54 第一段脚本55 使用命令行运行文件56 使用命令行和文件57 UNIX可执行脚本(#!)58 UNIX env查找技巧59 点击文件图标60 在Windows中点击图标60 input的技巧61 图标点击的其他限制63 模块导入和重载63 模块的显要特性：属性65 import和reload的使用注意事项68 使用exec运行模块文件69 IDLE用户界面70 IDLE基础71 使用IDLE72 高级IDLE工具74 其他的IDE74 其他启动选项76 嵌入式调用76 冻结二进制的可执行性77 文本编辑器启动的选择77 其他的启动选择77 未来的可能77 我应该选用哪种78 调试Python代码78 本章小结80 本章习题80 习题解答80 第一部分 练习题81</span><br><span class="line"></span><br><span class="line"> 第二部分 类型和运算 第4章 介绍Python对象类型87 为什么使用内置类型88 Python的核心数据类型88 数字90 字符串92 序列的操作92 不可变性94 类型特定的方法94 寻求帮助96 编写字符串的其他方法97 模式匹配98 列表98 序列操作98 类型特定的操作99 边界检查100 嵌套100 列表解析101 字典103 映射操作103 重访嵌套104 键的排序：for 循环105 迭代和优化107 不存在的键：if 测试107 元组109 为什么要用元组109 文件110 其他文件类工具111 其他核心类型111 如何破坏代码的灵活性113 用户定义的类114 剩余的内容115 本章小结115 本章习题116 习题解答116</span><br><span class="line"></span><br><span class="line"> 第5章 数字117 Python的数字类型117 数字常量118 内置数学工具和扩展119 Python表达式操作符120 在实际应用中的数字125 变量和基本的表达式125 数字显示的格式126 比较：一般的和连续的127 str和repr显示格式128 除法： 传统除法、Floor除法和真除法129 整数精度133 复数133 十六进制、八进制和二进制记数134 位操作136 其他的内置数学工具137 其他数字类型139 小数数字139 分数类型141 集合145 布尔型151 数字扩展152 本章小结153 本章习题153 习题解答153</span><br><span class="line"></span><br><span class="line"> 第6章 动态类型简介155 缺少类型声明语句的情况155 变量、对象和引用156 类型属于对象，而不是变量157 对象的垃圾收集158 共享引用159 共享引用和在原处修改161 共享引用和相等163 动态类型随处可见164 本章小结165 本章习题165 习题解答165</span><br><span class="line"></span><br><span class="line"> 第7章 字符串167 字符串常量169 单双引号字符串是一样的170 用转义序列代表特殊字节171 raw字符串抑制转义173 三重引号编写多行字符串块175 实际应用中的字符串176 基本操作176 索引和分片177 为什么要在意：分片181 字符串转换工具181 修改字符串184 字符串方法185 字符串方法实例：修改字符串187 字符串方法实例：文本解析189 实际应用中的其他常见字符串方法190 最初的字符串模块（在Python 3.0中删除）191 字符串格式化表达式192 更高级的字符串格式化表达式194 基于字典的字符串格式化196 字符串格式化调用方法196 基础知识197 添加键、属性和偏移量198 添加具体格式化198 与%格式化表达式比较200 为什么用新的格式化方法203 通常意义下的类型分类206 同样分类的类型共享其操作集合206 可变类型能够在原处修改207 本章小结208 本章习题208 习题解答208</span><br><span class="line"></span><br><span class="line"> 第8章 列表与字典210 列表210 实际应用中的列表213 基本列表操作213 列表迭代和解析213 索引、分片和矩阵214 原处修改列表215 字典220 实际应用中的字典222 字典的基本操作222 原处修改字典223 其他字典方法224 语言表225 字典用法注意事项226 为什么要在意字典接口229 创建字典的其他方法230 Python 3.0中的字典变化231 本章小结237 本章习题237 习题解答237</span><br><span class="line"></span><br><span class="line"> 第9章 元组、文件及其他239 元组239 实际应用中的元组241 为什么有了列表还要元组243 文件243 打开文件244 使用文件245 实际应用中的文件246 其他文件工具252 重访类型分类254 为什么要在意操作符重载255 对象灵活性255 引用 VS 拷贝256 比较、相等性和真值258 Python 3.0的字典比较260 Python中真和假的含义261 Python的类型层次263 Type对象263 Python中的其他类型265 内置类型陷阱265 赋值生成引用，而不是拷贝265 重复能够增加层次深度266 留意循环数据结构266 不可变类型不可以在原处改变267 本章小结267 本章习题268 习题解答268 第二部分练习题269</span><br><span class="line"></span><br><span class="line"> 第三部分 语句和语法 第10章 Python语句简介275 重访Python程序结构275 Python的语句276 两个if的故事278 Python增加了什么279 Python删除了什么279 为什么使用缩进语法281 几个特殊实例283 简短实例：交互循环285 一个简单的交互式循环285 对用户输入数据做数学运算287 用测试输入数据来处理错误288 用try语句处理错误289 嵌套代码三层290 本章小结290 本章习题291 习题解答291</span><br><span class="line"></span><br><span class="line"> 第11章 赋值、表达式和打印292 赋值语句292 赋值语句的形式293 序列赋值294 Python 3.0中的扩展序列解包297 多目标赋值语句301 增强赋值语句302 变量命名规则305 Python的废弃协议306 表达式语句308 表达式语句和在原处的修改309 打印操作310 Python 3.0的print函数311 Python 2.6 print语句313 打印流重定向315 版本独立的打印318 为什么要注意print和stdout319 本章小结320 本章习题321 习题解答321</span><br><span class="line"></span><br><span class="line"> 第12章 if测试和语法规则322 if语句322 通用格式322 基本例子323 多路分支323 Python语法规则325 代码块分隔符326 语句的分隔符328 一些特殊情况329 真值测试330 if&#x2F;else三元表达式332 为什么要在意布尔值334 本章小结335 本章习题335 习题解答335</span><br><span class="line"></span><br><span class="line"> 第13章 while和for循环336 while循环336 一般格式336 例子337 break、continue、pass和循环else338 一般循环格式338 pass338 continue340 break340 循环else341 为什么要在意“模拟C 语言的while循环”342 for循环343 一般格式343 例子344 为什么要在意“文件扫描”349 编写循环的技巧350 循环计数器：while和range351 非完备遍历：range和分片352 修改列表：range353 并行遍历：zip和map354 产生偏移和元素：enumerate357 本章小结358 本章习题358 习题解答359</span><br><span class="line"></span><br><span class="line"> 第14章 迭代器和解析，第一部分360 迭代器：初探360 文件迭代器361 手动迭代：iter和next363 其他内置类型迭代器365 列表解析：初探367 列表解析基础知识368 在文件上使用列表解析369 扩展的列表解析语法370 其他迭代环境371 Python 3.0中的新的可迭代对象375 range迭代器376 map、zip和filter迭代器377 多个迭代器 VS单个迭代器378 字典视图迭代器379 其他迭代器主题381 本章小结381 本章习题381 习题解答382</span><br><span class="line"></span><br><span class="line"> 第15章 文档383 Python文档资源383</span><br><span class="line"></span><br><span class="line"> 注释384</span><br><span class="line"></span><br><span class="line"> dir函数384 文档字符串：doc385 PyDoc：help函数388 PyDoc：HTML报表390 标准手册集393 网络资源394 已出版的书籍394 常见编写代码的陷阱395 本章小结397 本章习题397 习题解答397 第三部分练习题398</span><br><span class="line"></span><br><span class="line"> 第四部分 函数 第16章 函数基础403 为何使用函数404 编写函数405 def语句406 def语句是实时执行的407 第一个例子：定义和调用408 定义408 调用408 Python中的多态409 第二个例子：寻找序列的交集410 定义410 调用411 重访多态411 本地变量412 本章小结413 本章习题413 习题解答413</span><br><span class="line"></span><br><span class="line"> 第17章 作用域415 Python作用域基础415 作用域法则416 变量名解析：LEGB原则418 作用域实例419 内置作用域420 在Python 2.6中违反通用性422 global语句422 最小化全局变量423 最小化文件间的修改424 其他访问全局变量的方法426 作用域和嵌套函数427 嵌套作用域的细节427 嵌套作用域举例427 nonlocal语句433 nonlocal基础433 nonlocal应用435 为什么使用nonlocal437 本章小结440 本章习题441 习题解答442</span><br><span class="line"></span><br><span class="line"> 第18章 参数444 传递参数444 参数和共享引用445 避免可变参数的修改447 对参数输出进行模拟448 特定的参数匹配模型449 基础知识449 匹配语法450 细节452 关键字参数和默认参数的实例452 任意参数的实例455 Python 3.0 Keyword-Only参数459 min调用462 满分463 加分点464 结论465 一个更有用的例子：通用set函数465 模拟Python 3.0 print函数466 使用Keyword-Only参数467 为什么要在意：关键字参数469 本章小结469 本章习题470 习题解答470</span><br><span class="line"></span><br><span class="line"> 第19章 函数的高级话题472 函数设计概念472 递归函数474 用递归求和474 编码替代方案475 循环语句VS递归476 处理任意结构477 函数对象：属性和注解478 间接函数调用478 函数内省479 函数属性480 Python 3.0中的函数注解481 匿名函数： lambda483 lambda表达式483 为什么使用lambda484 如何（不要）让Python代码变得晦涩难懂486 嵌套lambda和作用域487 为什么要在意：回调488 在序列中映射函数：map489 函数式编程工具：filter和reduce490 本章小结492 本章习题492 习题解答492</span><br><span class="line"></span><br><span class="line"> 第20章 迭代和解析，第二部分494 回顾列表解析：函数式编程工具494 列表解析与map495 增加测试和嵌套循环496 列表解析和矩阵498 理解列表解析499 为什么要在意：列表解析和map500 重访迭代器：生成器501 生成器函数：yield VS return502 生成器表达式：迭代器遇到列表解析506 生成器函数 VS 生成器表达式507 生成器是单迭代器对象508 用迭代工具模拟zip和map510 为什么你会留意：单次迭代514 内置类型和类中的值生成515 Python 3.0解析语法概括516 解析集合和字典解析517 针对集合和字典的扩展的解析语法517 对迭代的各种方法进行计时518 对模块计时519 计时脚本519 计时结果520 计时模块替代方案523 其他建议527 函数陷阱528 本地变量是静态检测的528 默认和可变对象529 没有return语句的函数531 嵌套作用域的循环变量532 本章小结532 本章习题532 习题解答533 第四部分练习题533 第五部分 模块</span><br><span class="line"></span><br><span class="line"> 第21章 模块：宏伟蓝图539 为什么使用模块540 Python程序架构540 如何组织一个程序541 导入和属性541 标准库模块543 import如何工作543 1.搜索544 2.编译（可选）544 3.运行545 模块搜索路径545 配置搜索路径547 搜索路径的变动548 sys.path列表548 模块文件选择549 高级的模块选择概念550 第三方工具：distutils550 本章小结551 本章习题551 习题解答551</span><br><span class="line"></span><br><span class="line"> 第22章 模块代码编写基础553 模块的创建553 模块的使用554 import语句554 from语句555 from *语句555 导入只发生一次555 import和from是赋值语句556 文件间变量名的改变557 import和from的对等性557 from语句潜在的陷阱558 模块命名空间560 文件生成命名空间560 属性名的点号运算562 导入和作用域562 命名空间的嵌套563 重载模块564 reload基础565 reload实例566 为什么要在意：模块重载567 本章小结568 本章习题568 习题解答568 第23章 模块包570 包导入基础570 包和搜索路径设置571 init.py包文件572 包导入实例573 包对应的from语句和import语句574 为什么要使用包导入575 三个系统的传说576 包相对导入578 Python 3.0中的变化578 相对导入基础知识579 为什么使用相对导入581 相对导入的作用域583 模块查找规则总结583 相对导入的应用584 为什么要在意：模块包589 本章小结590 本章习题590 习题解答590</span><br><span class="line"></span><br><span class="line"> 第24章 高级模块话题592 在模块中隐藏数据592 最小化from 的破坏：_X和all593 启用以后的语言特性593 混合用法模式：name和main594 以name进行单元测试595 使用带有name的命令行参数596 修改模块搜索路径599 Import语句和from语句的as扩展599 模块是对象：元程序600 用名称字符串导入模块603 过渡性模块重载604 模块设计理念607 模块陷阱607 顶层代码的语句次序的重要性608 from复制变量名，而不是连接609 from 会让变量语义模糊610 reload不会影响from导入610 reload、from以及交互模式测试611 递归形式的from导入无法工作612 本章小结613 本章习题613 习题解答613 第五部分练习题614 第六部分 类和OOP</span><br><span class="line"></span><br><span class="line"> 第25章 OOP：宏伟蓝图619 为何使用类620 概览OOP621 属性继承搜索621 类和实例623 类方法调用624 编写类树624 OOP是为了代码重用627 本章小结629 本章习题629 习题解答630</span><br><span class="line"></span><br><span class="line"> 第26章 类代码编写基础631 类产生多个实例对象631 类对象提供默认行为632 实例对象是具体的元素632 第一个例子632 类通过继承进行定制635 第二个例子635 类是模块内的属性637 类可以截获Python运算符638 第三个例子639 为什么要使用运算符重载641 世界上最简单的Python类641 类与字典的关系644 本章小结646 本章习题646 习题解答646</span><br><span class="line"></span><br><span class="line"> 第27章 更多实例649 步骤1：创建实例650 编写构造函数650 在进行中测试651 以两种方式使用代码652 版本差异提示654 步骤2：添加行为方法654 编写方法656 步骤3：运算符重载658 提供打印显示658 步骤4：通过子类定制行为659 编写子类660 扩展方法：不好的方式660 扩展方法：好的方式661 多态的作用663 继承、定制和扩展664 OOP：大思路664 步骤5：定制构造函数665 OOP比我们认为的要简单666 组合类的其他方式667 在Python 3.0中捕获内置属性669 步骤6：使用内省工具670 特殊类属性670 一种通用显示工具671 实例与类属性的关系672 工具类的命名考虑673 类的最终形式674 步骤7（最后一步）：把对象存储到数据库中676 Pickle和Shelve676 在shelve数据库中存储对象677 交互地探索shelve678 更新shelve中的对象680 未来方向681 本章小结683 本章习题684 习题解答684</span><br><span class="line"></span><br><span class="line"> 第28章 类代码编写细节686 class语句686 一般形式686 例子687 方法689 例子690 调用超类构造函数691 其他方法调用的可能性691 继承692 属性树的构造692 继承方法的专有化693 类接口技术694 抽象超类695 Python 2.6和Python 3.0的抽象超类696 命名空间：完整的内容698 简单变量名：如果赋值就不是全局变量698 属性名称：对象命名空间698 Python命名空间的“禅”：赋值将变量名分类699 命名空间字典701 命名空间链接704 回顾文档字符串706 类与模块的关系707 本章小结708 本章习题708 习题解答708</span><br><span class="line"></span><br><span class="line"> 第29章 运算符重载710 基础知识710 构造函数和表达式：init和sub711 常见的运算符重载方法711 索引和分片：getitem和setitem713 拦截分片713 Python 2.6中的分片和索引715 索引迭代：getitem716 迭代器对象：iter和next717 用户定义的迭代器717 有多个迭代器的对象719 成员关系：contains、iter和getitem721 属性引用：getattr和setattr723 其他属性管理工具725 模拟实例属性的私有性：第一部分725 repr和str会返回字符串表达形式726 右侧加法和原处加法：radd和iadd729 原处加法730 Call表达式：call731 函数接口和回调代码732 比较：lt、gt和其他方法734 Python 2.6的cmp方法（已经从Python 3.0中移除了）734 布尔测试：bool和len735 Python 2.6中的布尔736 对象析构函数：del738 本章小结739 本章习题739 习题解答739</span><br><span class="line"></span><br><span class="line"> 第30章 类的设计741 Python和OOP741 通过调用标记进行重载（或不要）742 OOP和继承：“是一个”关系743 OOP和组合：“有一个”关系744 重访流处理器746 为什么要在意：类和持续性748 OOP和委托：“包装”对象749 类的伪私有属性751 变量名压缩概览751 为什么使用伪私有属性752 方法是对象：绑定或无绑定754 在Python 3.0中，无绑定方法是函数756 绑定方法和其他可调用对象757 为什么要在意：绑定方法和回调函数760 多重继承：“混合”类760 编写混合显示类761 类是对象：通用对象的工厂771 为什么有工厂772 与设计相关的其他话题773 本章小结773 本章习题774 习题解答774</span><br><span class="line"></span><br><span class="line"> 第31章 类的高级主题775 扩展内置类型775 通过嵌入扩展类型776 通过子类扩展类型777 新式类779 新式类变化780 类型模式变化781 钻石继承变动785 新式类的扩展789 slots实例789 类特性793 getattribute和描述符795 元类795 静态方法和类方法796 为什么使用特殊方法796 Python 2.6和Python 3.0中的静态方法797 静态方法替代方案799 使用静态和类方法800 使用静态方法统计实例801 用类方法统计实例802 装饰器和元类：第一部分805 函数装饰器基础805 装饰器例子806 类装饰器和元类807 更多详细信息808 类陷阱809 修改类属性的副作用809 修改可变的类属性也可能产生副作用810 多重继承：顺序很重要811 类、方法以及嵌套作用域812 Python中基于委托的类：getattr和内置函数814 “过度包装”814 本章小结815 本章习题815 习题解答815</span><br><span class="line"></span><br><span class="line"> 第六部分 练习题816 为什么要在意：大师眼中的OOP821 第七部分 异常和工具 第32章 异常基础825 为什么使用异常826 异常的角色826 异常处理：简明扼要827 默认异常处理器827 捕获异常828 引发异常829 用户定义的异常830 终止行为830 为什么要在意：错误检查832 本章小结833 本章习题833 习题解答834</span><br><span class="line"></span><br><span class="line"> 第33章 异常编码细节835 try&#x2F;except&#x2F;else语句835 try语句分句836 try&#x2F;else分句839 例子：默认行为840 例子：捕捉内置异常841 try&#x2F;finally语句841 例子：利用try&#x2F;finally编写终止行为842 统一try&#x2F;except&#x2F;finally语句843 统一try语句语法845 通过嵌套合并finally和except845 合并try的例子846 raise语句847 利用raise传递异常849 Python 3.0异常链：raise from849 assert语句850 例子：收集约束条件（但不是错误）850 with&#x2F;as环境管理器851 基本使用852 环境管理协议853 本章小结855 本章习题855 习题解答856</span><br><span class="line"></span><br><span class="line"> 第34章 异常对象857 异常：回到未来858 字符串异常很简单858 基于类的异常858 类异常例子859 为什么使用类异常861 内置Exception类864 内置异常分类865 默认打印和状态866 定制打印显示867 定制数据和行为868 提供异常细节868 提供异常方法869 本章小结870 本章习题870 习题解答870</span><br><span class="line"></span><br><span class="line"> 第35章 异常的设计872 嵌套异常处理器872 例子：控制流程嵌套873 例子：语法嵌套化874 异常的习惯用法876 异常不总是错误876 函数信号条件和raise876 关闭文件和服务器连接877 在try外进行调试878 运行进程中的测试879 关于sys.exc_info879 与异常有关的技巧880 应该包装什么881 捕捉太多：避免空except语句881 捕捉过少：使用基于类的分类883 核心语言总结884 Python工具集884 大型项目的开发工具885 本章小结888 第七部分练习题889 第八部分 高级话题注1</span><br><span class="line"></span><br><span class="line"> 第36章 Unicode和字节字符串893 Python 3.0中的字符串修改894 字符串基础知识895 字符编码方法895 Python的字符串类型897 文本和二进制文件899 Python 3.0中的字符串应用900 常量和基本属性900 转换901 编码Unicode字符串903 编码ASCII文本903 编码非ASCII文本904 编码和解码非ASCII文本904 其他Unicode编码技术905 转换编码907 在Python 2.6中编码Unicode字符串908 源文件字符集编码声明910 使用Python 3.0 Bytes对象911 方法调用912 序列操作913 创建bytes对象的其他方式913 混合字符串类型914 使用Python 3.0（和Python 2.6）bytearray对象915 使用文本文件和二进制文件918 文本文件基础919 Python 3.0中的文本和二进制模式919 类型和内容错误匹配921 使用Unicode文件922 在Python 3.0中读取和写入Unicode922 在Python 3.0中处理BOM924 Python 2.6中的Unicode文件927 Python 3.0中其他字符串工具的变化927 re模式匹配模块927 Struct二进制数据模块928 pickle对象序列化模块931 XML解析工具932 本章小结935 本章习题935 习题解答936</span><br><span class="line"></span><br><span class="line"> 第37章 管理属性938 为什么管理属性938 插入在属性访问时运行的代码939 特性940 基础知识940 第一个例子941 计算的属性942 使用装饰器编写特性943 描述符944 基础知识945 第一个示例947 计算的属性949 在描述符中使用状态信息950 特性和描述符是如何相关的952 getattr和getattribute953 基础知识954 第一个示例956 计算属性958 getattr和getattribute比较959 管理技术比较960 拦截内置操作属性963 重访基于委托的Manager967 示例：属性验证970 使用特性来验证971 使用描述符验证973 使用getattr来验证974 使用getattribute验证976 本章小结977 本章习题977 习题解答977</span><br><span class="line"></span><br><span class="line"> 第38章 装饰器979 什么是装饰器979 管理调用和实例980 管理函数和类980 使用和定义装饰器981 为什么使用装饰器981 基础知识982 函数装饰器982 类装饰器986 装饰器嵌套988 装饰器参数990 装饰器管理函数和类991 编写函数装饰器991 跟踪调用992 状态信息保持选项993 类错误之一：装饰类方法997 计时调用1002 添加装饰器参数1004 编写类装饰器1007 单体类1007 跟踪对象接口1009 类错误之二：保持多个实例1012 装饰器与管理器函数的关系1013 为什么使用装饰器（重访）1015 直接管理函数和类1016 示例：“私有”和“公有”属性1018 实现私有属性1019 实现细节之一1021 公有声明的泛化1022 实现细节之二1024 开放问题1025 Python不是关于控制1029 示例：验证函数参数1030 目标1030 针对位置参数的一个基本范围测试装饰器1031 针对关键字和默认泛化1033 实现细节1036 开放问题1038 装饰器参数 VS 函数注解1039 其他应用程序：类型测试1041 本章小结1042 本章习题1042 习题解答1043</span><br><span class="line"></span><br><span class="line"> 第39章 元类1046 要么是元类，要么不是元类1046 提高魔力层次1047 “辅助”函数的缺点1049 元类与类装饰器的关系：第一回合1051 元类模型1053 类是类型的实例1053 元类是Type的子类1055 Class语句协议1056 声明元类1057 编写元类1058 基本元类1058 定制构建和初始化1059 其他元类编程技巧1060 实例与继承的关系1063 示例：向类添加方法1064 手动扩展1064 基于元类的扩展1065 元类与类装饰器的关系：第二回合1067 示例：对方法应用装饰器1070 用装饰器手动跟踪1070 用元类和装饰器跟踪1071 把任何装饰器应用于方法1073 元类与类装饰器的关系：第三回合1074 “可选的”语言功能1076 本章小结1078 本章习题1078 习题解答1078 第九部分 附录注2 附录A 安装和配置1083 附录B 各部分练习题的解答 1093</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B004TUJ7A6/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B004TUJ7A6&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51qFpYVexpL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>0day安全 软件漏洞分析技术(第2版)</title>
    <url>/2020/04/19/B00566HJVQ/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 0day安全 软件漏洞分析技术(第2版)<br>作者信息： 作者: 浏览全部评论  [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>王清主编的《Oday安全：软件漏洞分析技术（第2版）》将系统全面地介绍Windows平台软件缓冲区溢出漏洞的发现、检测、分析和利用等方面的知识。    为了保证这些技术能够被读者轻松理解并掌握，本书在叙述中尽量避免枯燥乏味的大段理论阐述和代码粘贴。书中所有概念和方法都会在紧随其后的调试实验中被再次解释，实验和案例是本书的精髓所在。从为了阐述概念而精心自制的漏洞程序调试实验到现实中已经造成很大影响的著名漏洞分析，每一个调试实验都有着不同的技术侧重点，每一个漏洞利用都有自己的独到之处。    我将带领您一步一步地完成调试的每一步，并在这个过程中逐步解释漏洞分析思路。不管您是网络安全从业人员、黑客技术发烧友、网络安全专业的研究生或本科生，如果您能够完成这些分析实验，相信您的软件调试技术、对操作系统底层的理解等计算机能力一定会得到一次质的飞跃，并能够对安全技术有一个比较深入的认识。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目    录</span><br><span class="line">第1篇  漏洞利用原理（初级）</span><br><span class="line">第1章  基础知识 2</span><br><span class="line">1.1  漏洞概述 2</span><br><span class="line">1.1.1  bug与漏洞 2</span><br><span class="line">1.1.2  几个令人困惑的安全问题 2</span><br><span class="line">1.1.3  漏洞挖掘、漏洞分析、漏洞利用 3</span><br><span class="line">1.1.4  漏洞的公布与0 day响应 5</span><br><span class="line">1.2  二进制文件概述 5</span><br><span class="line">1.2.1  PE文件格式 5</span><br><span class="line">1.2.2  虚拟内存 6</span><br><span class="line">1.2.3  PE文件与虚拟内存之间的映射 7</span><br><span class="line">1.3  必备工具 11</span><br><span class="line">1.3.1  OllyDbg简介 11</span><br><span class="line">1.3.2  SoftICE简介 11</span><br><span class="line">1.3.3  WinDbg简介 16</span><br><span class="line">1.3.4  IDA Pro简介 18</span><br><span class="line">1.3.5  二进制编辑器 20</span><br><span class="line">1.3.6  VMware简介 21</span><br><span class="line">1.3.7  Python编程环境 28</span><br><span class="line">1.4  Crack小实验 29</span><br><span class="line">第2章  栈溢出原理与实践 38</span><br><span class="line">2.1  系统栈的工作原理 38</span><br><span class="line">2.1.1  内存的不同用途 38</span><br><span class="line">2.1.2  栈与系统栈 39</span><br><span class="line">2.1.3  函数调用时发生了什么 40</span><br><span class="line">2.1.4  寄存器与函数栈帧 43</span><br><span class="line">2.1.5  函数调用约定与相关指令 44</span><br><span class="line">2.2  修改邻接变量 47</span><br><span class="line">2.2.1  修改邻接变量的原理 47</span><br><span class="line">2.2.2  突破密码验证程序 49</span><br><span class="line">2.3  修改函数返回地址 53</span><br><span class="line">2.3.1  返回地址与程序流程 53</span><br><span class="line">2.3.2  控制程序的执行流程 57</span><br><span class="line">2.4  代码植入 62</span><br><span class="line">2.4.1  代码植入的原理 62</span><br><span class="line">2.4.2  向进程中植入代码 62</span><br><span class="line">第3章  开发shellcode的艺术 71</span><br><span class="line">3.1  shellcode概述 71</span><br><span class="line">3.1.1  shellcode与exploit 71</span><br><span class="line">3.1.2  shellcode需要解决的问题 72</span><br><span class="line">3.2  定位shellcode 73</span><br><span class="line">3.2.1  栈帧移位与jmp esp 73</span><br><span class="line">3.2.2  获取“跳板”的地址 76</span><br><span class="line">3.2.3  使用“跳板”定位的exploit 78</span><br><span class="line">3.3  缓冲区的组织 81</span><br><span class="line">3.3.1  缓冲区的组成 81</span><br><span class="line">3.3.2  抬高栈顶保护shellcode 83</span><br><span class="line">3.3.3  使用其他跳转指令 83</span><br><span class="line">3.3.4  不使用跳转指令 84</span><br><span class="line">3.3.5  函数返回地址移位 85</span><br><span class="line">3.4  开发通用的shellcode 87</span><br><span class="line">3.4.1  定位API的原理 87</span><br><span class="line">3.4.2  shellcode的加载与调试 88</span><br><span class="line">3.4.3  动态定位API地址的shellcode 89</span><br><span class="line">3.5  shellcode编码技术 98</span><br><span class="line">3.5.1  为什么要对shellcode编码 98</span><br><span class="line">3.5.2  会“变形”的shellcode 99</span><br><span class="line">3.6  为shellcode“减肥” 103</span><br><span class="line">3.6.1  shellcode瘦身大法 103</span><br><span class="line">3.6.2  选择恰当的hash算法 105</span><br><span class="line">3.6.3  191个字节的bindshell 107</span><br><span class="line">第4章  用MetaSploit开发Exploit 119</span><br><span class="line">4.1  漏洞测试平台MSF 简介 119</span><br><span class="line">4.2  入侵Windows系统 121</span><br><span class="line">4.2.1  漏洞简介 121</span><br><span class="line">4.2.2  图形界面的漏洞测试 121</span><br><span class="line">4.2.3  console界面的漏洞测试 125</span><br><span class="line">4.3  利用MSF制作shellcode 126</span><br><span class="line">4.4  用MSF扫描“跳板” 128</span><br><span class="line">4.5  Ruby语言简介 129</span><br><span class="line">4.6 “傻瓜式”Exploit开发 134</span><br><span class="line">4.7  用MSF发布POC 140</span><br><span class="line">第5章  堆溢出利用 144</span><br><span class="line">5.1  堆的工作原理 144</span><br><span class="line">5.1.1  Windows堆的历史 144</span><br><span class="line">5.1.2  堆与栈的区别 145</span><br><span class="line">5.1.3  堆的数据结构与管理策略 146</span><br><span class="line">5.2  在堆中漫游 151</span><br><span class="line">5.2.1  堆分配函数之间的调用关系 151</span><br><span class="line">5.2.2  堆的调试方法 152</span><br><span class="line">5.2.3  识别堆表 155</span><br><span class="line">5.2.4  堆块的分配 158</span><br><span class="line">5.2.5  堆块的释放 159</span><br><span class="line">5.2.6  堆块的合并 159</span><br><span class="line">5.2.7  快表的使用 161</span><br><span class="line">5.3  堆溢出利用（上）——DWORD SHOOT 163</span><br><span class="line">5.3.1  链表“拆卸”中的问题 163</span><br><span class="line">5.3.2  在调试中体会“DWORD SHOOT” 165</span><br><span class="line">5.4  堆溢出利用（下）——代码植入 169</span><br><span class="line">5.4.1  DWORD SHOOT的利用方法 169</span><br><span class="line">5.4.2  狙击P.E.B中RtlEnterCritical-Section()的函数指针 170</span><br><span class="line">5.4.3  堆溢出利用的注意事项 175</span><br><span class="line">第6章  形形色色的内存攻击技术 178</span><br><span class="line">6.1  狙击Windows异常处理机制 178</span><br><span class="line">6.1.1  S.E.H概述 178</span><br><span class="line">6.1.2  在栈溢出中利用S.E.H 180</span><br><span class="line">6.1.3　在堆溢出中利用S.E.H 184</span><br><span class="line">6.1.4　深入挖掘Windows异常处理 187</span><br><span class="line">6.1.5　其他异常处理机制的利用思路 192</span><br><span class="line">6.2 “off by one”的利用 196</span><br><span class="line">6.3　攻击C++的虚函数 198</span><br><span class="line">6.4　Heap Spray：堆与栈的协同攻击 201</span><br><span class="line">第7章  手机里的缓冲区溢出 204</span><br><span class="line">7.1  Windows Mobile简介 204</span><br><span class="line">7.1.1  Windows Mobile前世今生 204</span><br><span class="line">7.1.2  Windows Mobile架构概述 205</span><br><span class="line">7.1.3  Windows Mobile的内存管理 209</span><br><span class="line">7.2  ARM简介 212</span><br><span class="line">7.2.1  ARM是什么 212</span><br><span class="line">7.2.2  ARM寄存器结构 212</span><br><span class="line">7.2.3  ARM汇编指令结构 215</span><br><span class="line">7.2.4  ARM指令寻址方式 220</span><br><span class="line">7.2.5  ARM的函数调用与返回 222</span><br><span class="line">7.3  Windows Mobile上的HelloWorld 223</span><br><span class="line">7.4  远程调试工具简介 227</span><br><span class="line">7.4.1  远程信息查看管理套件 227</span><br><span class="line">7.4.2  手机上的调试——Microsoft Visual Studio 231</span><br><span class="line">7.4.3  手机上的调试——IDA 233</span><br><span class="line">7.5  手机上的exploit me 237</span><br><span class="line">第8章  其他类型的软件漏洞 243</span><br><span class="line">8.1　格式化串漏洞 243</span><br><span class="line">8.1.1　printf中的缺陷 243</span><br><span class="line">8.1.2　用printf读取内存数据 244</span><br><span class="line">8.1.3　用printf向内存写数据 245</span><br><span class="line">8.1.4　格式化串漏洞的检测与防范 246</span><br><span class="line">8.2　SQL注入攻击 247</span><br><span class="line">8.2.1　SQL注入原理 247</span><br><span class="line">8.2.2　攻击PHP+MySQL网站 248</span><br><span class="line">8.2.3　攻击ASP+SQL Server网站 250</span><br><span class="line">8.2.4　注入攻击的检测与防范 252</span><br><span class="line">8.3　其他注入方式 253</span><br><span class="line">8.3.1　Cookie注入，绕过马其诺防线 253</span><br><span class="line">8.3.2　XPath注入，XML的阿喀琉斯之踵 254</span><br><span class="line">8.4　XSS攻击 255</span><br><span class="line">8.4.1　脚本能够“跨站”的原因 255</span><br><span class="line">8.4.2　XSS Reflection攻击场景 256</span><br><span class="line">8.4.3　Stored XSS攻击场景 258</span><br><span class="line">8.4.4　攻击案例回顾：XSS蠕虫 258</span><br><span class="line">8.4.5　XSS的检测与防范 259</span><br><span class="line">8.5  路径回溯漏洞 260</span><br><span class="line">8.5.1  路径回溯的基本原理 260</span><br><span class="line">8.5.2  范式化与路径回溯 261</span><br><span class="line">第2篇  漏洞利用原理（高级）</span><br><span class="line">第9章  Windows安全机制概述 264</span><br><span class="line">第10章  栈中的守护天使：GS 267</span><br><span class="line">10.1  GS安全编译选项的保护原理 267</span><br><span class="line">10.2  利用未被保护的内存突破GS 271</span><br><span class="line">10.3  覆盖虚函数突破GS 273</span><br><span class="line">10.4  攻击异常处理突破GS 276</span><br><span class="line">10.5  同时替换栈中和.data中的Cookie突破GS 280</span><br><span class="line">第11章  亡羊补牢：SafeSEH 284</span><br><span class="line">11.1  SafeSEH对异常处理的保护原理 284</span><br><span class="line">11.2  攻击返回地址绕过SafeSEH 288</span><br><span class="line">11.3  利用虚函数绕过SafeSEH 288</span><br><span class="line">11.4  从堆中绕过SafeSEH 288</span><br><span class="line">11.5  利用未启用SafeSEH模块绕过SafeSEH 292</span><br><span class="line">11.6  利用加载模块之外的地址绕过SafeSEH 299</span><br><span class="line">11.7  利用Adobe Flash Player ActiveX控件绕过SafeSEH 305</span><br><span class="line">第12章  数据与程序的分水岭：DEP 313</span><br><span class="line">12.1  DEP机制的保护原理 313</span><br><span class="line">12.2  攻击未启用DEP的程序 316</span><br><span class="line">12.3  利用Ret2Libc挑战DEP 317</span><br><span class="line">12.3.1  Ret2Libc实战之利用ZwSetInformationProcess 318</span><br><span class="line">12.3.2  Ret2Libc实战之利用VirtualProtect 330</span><br><span class="line">12.3.3  Ret2Libc实战之利用VirtualAlloc 339</span><br><span class="line">12.4  利用可执行内存挑战DEP 348</span><br><span class="line">12.5  利用.NET挑战DEP 352</span><br><span class="line">12.6  利用Java applet挑战DEP 359</span><br><span class="line">第13章  在内存中躲猫猫：ASLR 363</span><br><span class="line">13.1  内存随机化保护机制的原理 363</span><br><span class="line">13.2  攻击未启用ASLR的模块 367</span><br><span class="line">13.3  利用部分覆盖进行定位内存地址 372</span><br><span class="line">13.4  利用Heap spray技术定位内存地址 376</span><br><span class="line">13.5  利用Java applet heap spray技术定位内存地址 379</span><br><span class="line">13.6  为.NET控件禁用ASLR 382</span><br><span class="line">第14章  S.E.H终极防护：SEHOP 386</span><br><span class="line">14.1  SEHOP的原理 386</span><br><span class="line">14.2  攻击返回地址 388</span><br><span class="line">14.3  攻击虚函数 388</span><br><span class="line">14.4  利用未启用SEHOP的模块 388</span><br><span class="line">14.5  伪造S.E.H链表 390</span><br><span class="line">第15章  重重保护下的堆 396</span><br><span class="line">15.1  堆保护机制的原理 396</span><br><span class="line">15.2  攻击堆中存储的变量 397</span><br><span class="line">15.3  利用chunk重设大小攻击堆 398</span><br><span class="line">15.4  利用Lookaside表进行堆溢出 407</span><br><span class="line">第3篇  漏洞挖掘技术</span><br><span class="line">第16章  漏洞挖掘技术简介 414</span><br><span class="line">16.1  漏洞挖掘概述 414</span><br><span class="line">16.2  动态测试技术 415</span><br><span class="line">16.2.1  SPIKE简介 415</span><br><span class="line">16.2.2  beSTORM简介 421</span><br><span class="line">16.3　静态代码审计 429</span><br><span class="line">第17章  文件类型漏洞挖掘 与Smart Fuzz 431</span><br><span class="line">17.1  Smart Fuzz概述 431</span><br><span class="line">17.1.1  文件格式Fuzz的基本方法 431</span><br><span class="line">17.1.2  Blind Fuzz和Smart Fuzz 432</span><br><span class="line">17.2  用Peach挖掘文件漏洞 433</span><br><span class="line">17.2.1  Peach介绍及安装 433</span><br><span class="line">17.2.2  XML介绍 434</span><br><span class="line">17.2.3  定义简单的 Peach Pit 436</span><br><span class="line">17.2.4  定义数据之间的依存关系 440</span><br><span class="line">17.2.5  用Peach Fuzz PNG文件 441</span><br><span class="line">17.3  010脚本，复杂文件解析的瑞士军刀 446</span><br><span class="line">17.3.1  010 Editor简介 446</span><br><span class="line">17.3.2  010脚本编写入门 447</span><br><span class="line">17.3.3  010脚本编写提高——PNG文件解析 449</span><br><span class="line">17.3.4  深入解析，深入挖掘——PPT文件解析 452</span><br><span class="line">第18章  FTP的漏洞挖掘 457</span><br><span class="line">18.1  FTP协议简介 457</span><br><span class="line">18.2  漏洞挖掘手记1：DOS 457</span><br><span class="line">18.3  漏洞挖掘手记2：访问权限 466</span><br><span class="line">18.4  漏洞挖掘手记3：缓冲区溢出 468</span><br><span class="line">18.5  漏洞挖掘手记4：Fuzz DIY 472</span><br><span class="line">第19章  E-Mail的漏洞挖掘 477</span><br><span class="line">19.1  挖掘SMTP漏洞 477</span><br><span class="line">19.1.1  SMTP协议简介 477</span><br><span class="line">19.1.2  SMTP漏洞挖掘手记 478</span><br><span class="line">19.2  挖掘POP3漏洞 480</span><br><span class="line">19.2.1  POP3协议简介 480</span><br><span class="line">19.2.2  POP3漏洞挖掘手记 481</span><br><span class="line">19.3  挖掘IMAP4漏洞 489</span><br><span class="line">19.3.1  IMAP4协议简介 489</span><br><span class="line">19.3.2  IMAP4漏洞挖掘手记 490</span><br><span class="line">19.4  其他E-mail漏洞 491</span><br><span class="line">19.4.1  URL中的路径回溯 491</span><br><span class="line">19.4.2  内存中的路径回溯 494</span><br><span class="line">19.4.3  邮件中的XSS 500</span><br><span class="line">第20章  ActiveX控件的漏洞挖掘 502</span><br><span class="line">20.1  ActiveX控件简介 502</span><br><span class="line">20.1.1  浏览器与ActiveX控件的关系 502</span><br><span class="line">20.1.2  控件的属性 503</span><br><span class="line">20.2  手工测试ActiveX控件 504</span><br><span class="line">20.2.1  建立测试模板 504</span><br><span class="line">20.2.2  获取控件的接口信息 505</span><br><span class="line">20.3  用工具测试ActiveX控件：COMRaider 509</span><br><span class="line">20.4  挖掘ActiveX漏洞 516</span><br><span class="line">20.4.1  ActiveX漏洞的分类 516</span><br><span class="line">20.4.2  漏洞挖掘手记1：超星阅读器溢出 517</span><br><span class="line">20.4.3  漏洞挖掘手记2：目录操作权限 521</span><br><span class="line">20.4.4  漏洞挖掘手记3：文件读权限 523</span><br><span class="line">20.4.5  漏洞挖掘手记3：文件删除权限 525</span><br><span class="line">第4篇  操作系统内核安全</span><br><span class="line">第21章  探索ring0 528</span><br><span class="line">21.1  内核基础知识介绍 528</span><br><span class="line">21.1.1  内核概述 528</span><br><span class="line">21.1.2  驱动编写之Hello World 528</span><br><span class="line">21.1.3  派遣例程与IRP结构 533</span><br><span class="line">21.1.4  Ring3打开驱动设备 537</span><br><span class="line">21.1.5  DeviceIoControl函数与IoControlCode 538</span><br><span class="line">21.1.6  Ring3&#x2F;Ring0的四种通信方式 539</span><br><span class="line">21.2  内核调试入门 541</span><br><span class="line">21.2.1  创建内核调试环境 541</span><br><span class="line">21.2.2  蓝屏分析 549</span><br><span class="line">21.3  内核漏洞概述 551</span><br><span class="line">21.3.1  内核漏洞的分类 551</span><br><span class="line">21.3.2  内核漏洞的研究过程 553</span><br><span class="line">21.4  编写安全的驱动程序 555</span><br><span class="line">21.4.1  输入输出检查 555</span><br><span class="line">21.4.2  验证驱动的调用者 556</span><br><span class="line">21.4.3  白名单机制的挑战 556</span><br><span class="line">第22章  内核漏洞利用技术 557</span><br><span class="line">22.1  利用实验之exploitme.sys 557</span><br><span class="line">22.2  内核漏洞利用思路 559</span><br><span class="line">22.3  内核漏洞利用方法 560</span><br><span class="line">22.4  内核漏洞利用实战与编程 565</span><br><span class="line">22.5  Ring0 Shellcode的编写 570</span><br><span class="line">第23章  FUZZ驱动程序 579</span><br><span class="line">23.1  内核FUZZ思路 579</span><br><span class="line">23.2  内核FUZZ工具介绍 581</span><br><span class="line">23.3  内核FUZZ工具DIY 583</span><br><span class="line">23.3.1  Fuzz对象、Fuzz策略、Fuzz项 583</span><br><span class="line">23.3.2  IoControl MITM Fuzz 583</span><br><span class="line">23.3.3  IoControl Driver Fuzz 585</span><br><span class="line">23.3.4  MyIoControl Fuzzer界面 586</span><br><span class="line">23.4  内核漏洞挖掘实战 588</span><br><span class="line">23.4.1  超级巡警ASTDriver.sys本地提权漏洞 588</span><br><span class="line">23.4.2  东方微点mp110013.sys本地提权漏洞 594</span><br><span class="line">23.4.3  瑞星HookCont.sys驱动本地拒绝服务漏洞 601</span><br><span class="line">第24章  内核漏洞案例分析 605</span><br><span class="line">24.1  远程拒绝服务内核漏洞 605</span><br><span class="line">24.2  本地拒绝服务内核漏洞 611</span><br><span class="line">24.3  缓冲区溢出内核漏洞 614</span><br><span class="line">24.4  任意地址写任意数据内核漏洞 619</span><br><span class="line">24.5  任意地址写固定数据内核漏洞 622</span><br><span class="line">第5篇  漏洞分析案例</span><br><span class="line">第25章  漏洞分析技术概述 628</span><br><span class="line">25.1  漏洞分析的方法 628</span><br><span class="line">25.2运动中寻求突破：调试技术 629</span><br><span class="line">25.2.1  断点技巧 630</span><br><span class="line">25.2.2  回溯思路 644</span><br><span class="line">25.3　用“白眉”在PE中漫步 647</span><br><span class="line">25.3.1　指令追踪技术与Paimei 647</span><br><span class="line">25.3.2　Paimei的安装 648</span><br><span class="line">25.3.3　使用PE Stalker 649</span><br><span class="line">25.3.4　迅速定位特定功能对应的代码 652</span><br><span class="line">25.4　补丁比较 654</span><br><span class="line">第26章  RPC入侵：MS06-040 与MS08-067 658</span><br><span class="line">26.1  RPC漏洞 658</span><br><span class="line">26.1.1  RPC漏洞简介 658</span><br><span class="line">26.1.2  RPC编程简介 658</span><br><span class="line">26.2  MS06-040 659</span><br><span class="line">26.2.1  MS06-040简介 659</span><br><span class="line">26.2.2  动态调试 660</span><br><span class="line">26.2.3  静态分析 667</span><br><span class="line">26.2.4  实现远程exploit 670</span><br><span class="line">26.3  Windows XP环境下的MS06-040 exploit 677</span><br><span class="line">26.3.1  静态分析 677</span><br><span class="line">26.3.2  蠕虫样本的exploit方法 682</span><br><span class="line">26.3.3  实践跨平台exploit 684</span><br><span class="line">26.4  MS08-067 690</span><br><span class="line">26.4.1  MS08-067简介 690</span><br><span class="line">26.4.2  认识Legacy Folder 693</span><br><span class="line">26.4.3 “移经”测试 694</span><br><span class="line">26.4.4 “移经”风险 695</span><br><span class="line">26.4.5  POC的构造 696</span><br><span class="line">26.5  魔波、Conficker与蠕虫病毒 703</span><br><span class="line">第27章  MS06-055分析：实战Heap Spray 705</span><br><span class="line">27.1　MS06-055简介 705</span><br><span class="line">27.1.1　矢量标记语言（VML）简介 705</span><br><span class="line">27.1.2　0 day安全响应纪实 706</span><br><span class="line">27.2　漏洞分析 707</span><br><span class="line">27.3  漏洞利用 710</span><br><span class="line">第28章  MS09-032分析：一个“＆”引发的血案 713</span><br><span class="line">28.1  MS09-032简介 713</span><br><span class="line">28.2  漏洞原理及利用分析 713</span><br><span class="line">第29章  Yahoo!Messenger栈 溢出漏洞 719</span><br><span class="line">29.1  漏洞介绍 719</span><br><span class="line">29.2  漏洞分析 719</span><br><span class="line">29.3  漏洞利用 723</span><br><span class="line">第30章  CVE-2009-0927：PDF中的JS 725</span><br><span class="line">30.1  CVE-2009-0927简介 725</span><br><span class="line">30.2  PDF文档格式简介 725</span><br><span class="line">30.3  漏洞原理及利用分析 727</span><br><span class="line">第31章  坝之蚁穴：超长URL溢出漏洞 731</span><br><span class="line">31.1  漏洞简介 731</span><br><span class="line">31.3  漏洞原理及利用分析 731</span><br><span class="line">第32章  暴风影音M3U文件解析漏洞 737</span><br><span class="line">32.1  漏洞简介 737</span><br><span class="line">32.2  M3U文件简介 737</span><br><span class="line">32.3  漏洞原理及利用分析 738</span><br><span class="line">第33章  LNK快捷方式文件漏洞 744</span><br><span class="line">33.1  漏洞简介 744</span><br><span class="line">33.2  漏洞原理及利用分析 744</span><br><span class="line">附录A  已公布的内核程序漏洞列表 750</span><br><span class="line">参考文献 753</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00566HJVQ/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00566HJVQ&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/514Si0pGjLL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Python编程(上下)(影印版)(第4版)</title>
    <url>/2020/04/19/B005B99QK0/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Python编程(上下)(影印版)(第4版)<br>作者信息： 作者: 浏览全部评论  [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Python编程(影印版)(第4版)(套装共2册)》针对该语言的主要应用领域——系统管理、GUI和Web——做了深入讲解，并且探索了它在数据库、网络、前端脚本撰写层、文本处理和更多方面的使用。通过重点关注常用工具和库，你将会对Python在实际现实世界里的编程有更深的理解。你将通过一种清晰和简洁的方式——讲解大量正确用法和常见惯例的例子——学会语言的语法和编程技巧。《Python编程(影印版)(第4版)(套装共2册)》针对3.x版本做了完全的更新，它探讨了Python如何成为软件开发工具，并且特别为此设计了很多代码示例。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Preface</span><br><span class="line">Part Ⅰ.The Beginning</span><br><span class="line">1.A Sneak Preview</span><br><span class="line">“Programming Python: The Short Story”</span><br><span class="line">The Task</span><br><span class="line">Step 1: Representing Records</span><br><span class="line">Using Lists</span><br><span class="line">Using Dictionaries</span><br><span class="line">Step 2: Storing Records Persistently</span><br><span class="line">Using Formatted Files</span><br><span class="line">Using Pickle Files</span><br><span class="line">Using Per-Record Pickle Files</span><br><span class="line">Using Shelves</span><br><span class="line">Step 3: Stepping Up to OOP</span><br><span class="line">Using Classes</span><br><span class="line">Adding Behavior</span><br><span class="line">Adding Inheritance</span><br><span class="line">Refactoring Code</span><br><span class="line">Adding Persistence</span><br><span class="line">Other Database Options</span><br><span class="line">Step 4: Adding Console Interaction</span><br><span class="line">A Console Shelve Interface</span><br><span class="line">Step 5: Adding a GUI</span><br><span class="line">GUI Basics</span><br><span class="line">Using OOP for GUIs</span><br><span class="line">Getting Input from a User</span><br><span class="line">A GUI Shelve Interface</span><br><span class="line">Step 6: Adding a Web Interface</span><br><span class="line">CGI Basics</span><br><span class="line">Running a Web Server</span><br><span class="line">Using Query Strings and urllib</span><br><span class="line">Formatting Reply Text</span><br><span class="line">A Web-Based Shelve Interface</span><br><span class="line">The End of the Demo</span><br><span class="line">Part Ⅱ.System Programming</span><br><span class="line">2.System Tools</span><br><span class="line">“The os.path to Knowledge”</span><br><span class="line">Why Python Here？</span><br><span class="line">The Next Five Chapters</span><br><span class="line">System Scripting Overview</span><br><span class="line">Python System Modules</span><br><span class="line">Module Documentation Sources</span><br><span class="line">Paging Documentation Strings</span><br><span class="line">A Custom Paging Script</span><br><span class="line">String Method Basics</span><br><span class="line">Other String Concepts in Python 3.X: Unicode and bytes</span><br><span class="line">File Operation Basics</span><br><span class="line">Using P&#39;rograms in Two Ways</span><br><span class="line">Python Library Manuals</span><br><span class="line">Commercially Published References</span><br><span class="line">Inrroducing the sys Module</span><br><span class="line">Platforms and Versions</span><br><span class="line">The Module Search Path</span><br><span class="line">The Loaded Modules Table</span><br><span class="line">Exception Details</span><br><span class="line">Other sys Module Exports</span><br><span class="line">Introducing the os Module</span><br><span class="line">Tools in the os Module</span><br><span class="line">Administrative Tools</span><br><span class="line">Portability Constants</span><br><span class="line">Common os.path Tools</span><br><span class="line">Running Shell Commands from Scripts</span><br><span class="line">Other os Module Exports</span><br><span class="line">3.Script Execution Context</span><br><span class="line">“I’d Like to Have an Argument, Please”</span><br><span class="line">Current Working Directory</span><br><span class="line">CWD, Files, and Import Paths</span><br><span class="line">CWD and Command Lines</span><br><span class="line">Thread Exits and Shared State</span><br><span class="line">Interprocess Communication</span><br><span class="line">Anonymous Pipes</span><br><span class="line">Named Pipes （Fifos）</span><br><span class="line">Sockets: A First Look</span><br><span class="line">Signals</span><br><span class="line">The multiprocessing Module</span><br><span class="line">Why multiprocessing？</span><br><span class="line">The Basics: Processes and Locks</span><br><span class="line">IPC Tools: Pipes, Shared Memory, and Queues</span><br><span class="line">Starting Independent Programs</span><br><span class="line">And Much More</span><br><span class="line">Why multiprocessing？ The Conclusion</span><br><span class="line">Other Ways to Start Programs</span><br><span class="line">The os.spawn Calls</span><br><span class="line">The os.startfile call on Windows</span><br><span class="line">A Portable Program-Launch Framework</span><br><span class="line">Other System Tools Coverage</span><br><span class="line">Command-Line Arguments</span><br><span class="line">Parsing Command-Line Arguments</span><br><span class="line">Shell Environment Variables</span><br><span class="line">Fetching Shell Variables</span><br><span class="line">Changing Shell Variables</span><br><span class="line">Shell Variable Fine Points: Parents, putenv, and getenv</span><br><span class="line">Standard Streams</span><br><span class="line">Redirecting Streams to Files and Programs</span><br><span class="line">Redirected Streams and User Interaction</span><br><span class="line">Redirecting Streams to Python Objects</span><br><span class="line">The io.StringIO and io.Bytesl0 Utility Classes</span><br><span class="line">Capturing the stderr Stream</span><br><span class="line">Redirection Syntax in Print Calls</span><br><span class="line">Other Redirection Options: os.popen and subprocess Revisited</span><br><span class="line">4.File and Directory Tools</span><br><span class="line">“Erase Your Hard Drive in Five Easy Steps！”</span><br><span class="line">File Tools</span><br><span class="line">The File Object Model in Python 3,X</span><br><span class="line">Using Built-in File Objects</span><br><span class="line">Binary and Text Files</span><br><span class="line">Lower-Level File Tools in the os Module</span><br><span class="line">File Scanners</span><br><span class="line">Directory Tools</span><br><span class="line">Walking One Directory</span><br><span class="line">Walking Directory Trees</span><br><span class="line">Handling Unicode Filenames in 3.X: listdir, walk, glob</span><br><span class="line">5.Parallel System Tools</span><br><span class="line">“Telling the Monkeys What to Do”</span><br><span class="line">Forking Processes</span><br><span class="line">The fork&#x2F;exec Combination</span><br><span class="line">Threads</span><br><span class="line">The _thread Module</span><br><span class="line">The threading Module</span><br><span class="line">The queue Module</span><br><span class="line">Preview: GUIs and Threads</span><br><span class="line">More on the Globallnterpreter Lock</span><br><span class="line">Program Exits</span><br><span class="line">sys Module Exits</span><br><span class="line">os Module Exits</span><br><span class="line">Shell Command Exit Status Codes</span><br><span class="line">Process Exit Status and Shared State</span><br><span class="line">Thread Exits and Shared State</span><br><span class="line">Interprocess Communication</span><br><span class="line">Anonymous Pipes</span><br><span class="line">Named Pipes （Fifos）</span><br><span class="line">Sockets: A First Look</span><br><span class="line">Signals</span><br><span class="line">The multiprocessing Module</span><br><span class="line">Why multiprocessing？</span><br><span class="line">The Basics: Processes and Locks</span><br><span class="line">IPC Tools: Pipes, Shared Memory, and Queues</span><br><span class="line">Starting Independent Programs</span><br><span class="line">And Much More</span><br><span class="line">Why multiprocessing？ The Conclusion</span><br><span class="line">Other Ways to Start Programs</span><br><span class="line">The os.spawn Calls</span><br><span class="line">The os.startfile call on Windows</span><br><span class="line">A Portable Program-Launch Framework</span><br><span class="line">Other System Tools Coverage</span><br><span class="line">6.Complete System Programs</span><br><span class="line">“The Greps of Wrath”</span><br><span class="line">A Quick Game of “Find the Biggest Python File”</span><br><span class="line">Scanning the Standard Library Directory</span><br><span class="line">Scanning the Standard Library Tree</span><br><span class="line">Scanning the Module Search Path</span><br><span class="line">Scanning the Entire Machine</span><br><span class="line">Printing Unicode Filenames</span><br><span class="line">Splitting and Joining Files</span><br><span class="line">Splitting Files Portably</span><br><span class="line">Joining Files Portably</span><br><span class="line">Usage Variations</span><br><span class="line">Generating Redirection Web Pages</span><br><span class="line">Page Template File</span><br><span class="line">Page Generator Script</span><br><span class="line">A Regression Test Script</span><br><span class="line">Running the Test Driver</span><br><span class="line">Copying Directory Trees</span><br><span class="line">Comparing Directory Trees</span><br><span class="line">Finding Directory Differences</span><br><span class="line">Finding Tree Differences</span><br><span class="line">Running the Script</span><br><span class="line">Verifying Backups</span><br><span class="line">Reporting Differences and Other Ideas</span><br><span class="line">Searching Directory Trees</span><br><span class="line">Greps and Globs and Finds</span><br><span class="line">Rolling Your Own find Module</span><br><span class="line">Cleaning Up Bytecode Files</span><br><span class="line">A Python Tree Searcher</span><br><span class="line">Visitor: Walking Direcror&#x2F;es “++”</span><br><span class="line">Editing Files in Directory Trees （Visitor）</span><br><span class="line">Global Replacements in Directory Trees （Visitor）</span><br><span class="line">Counting Source Code Lines （Visitor）</span><br><span class="line">Recoding Copies with Classes （Visitor）</span><br><span class="line">Other Visitor Examples （External）</span><br><span class="line">Playing Media Files</span><br><span class="line">The Python webbrowser Module</span><br><span class="line">The Python mimetypes Module</span><br><span class="line">Running the Script</span><br><span class="line">Automated Program Launchers （External）</span><br><span class="line">……</span><br><span class="line">Part Ⅲ.GUI Programming</span><br><span class="line">Part Ⅳ.Internet Programming</span><br><span class="line">Part Ⅴ.Tools and Techniques</span><br><span class="line">Part Ⅵ.The End</span><br><span class="line">Index</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B005B99QK0/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B005B99QK0&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51xq1Zlrm%2BL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>网络、群体与市场 揭示高度互联世界的行为原理与效应机制</title>
    <url>/2020/04/19/B005XUJRKQ/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 网络、群体与市场 揭示高度互联世界的行为原理与效应机制<br>作者信息： 作者: 大卫·伊斯利(David Esley) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《网络、群体与市场:揭示高度互联世界的行为原理与效应机制》是由清华大学出版社出版的。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 概述</span><br><span class="line">1.1 网络的基本问题</span><br><span class="line">1.2 本书的核心内容</span><br><span class="line">第一部分 图论与社会网络</span><br><span class="line">第2章 图论</span><br><span class="line">2.1 基本定义</span><br><span class="line">2.2 路径与连通性</span><br><span class="line">2.3 距离与先宽搜索</span><br><span class="line">2.4 网络数据集概要</span><br><span class="line">2.5 练习 </span><br><span class="line"></span><br><span class="line"> 第3章 强联系和弱联系 3.1 三元闭包 3.2 弱联系的力量 3.3 在大规模数据中的联系强度与网络结构 3.4 联系强度、社会媒体和被动参与 3.5 闭包、结构洞和社会资本 3.6 深度学习材料：之间关系的度量和图的划分 3.6.1 图划分的一种方法 3.6.2 计算介数值 3.7 练习</span><br><span class="line"></span><br><span class="line"> 第4章 网络及其存在的环境 4.1 同质现象 4.2 同质现象背后的机制：选择与社会影响 4.3 归属 4.4 从在线数据中看连接的形成 4.5 隔离的一种空间模型 4.6 练习</span><br><span class="line"></span><br><span class="line"> 第5章 正关系与负关系 5.1 结构平衡 5.2 结构平衡网络的特性 5.3 结构平衡的应用 5.4 结构平衡的一种弱形式 5.5 深度学习材料：结构平衡定义的推广 5.5.1 任意（非完全）网络中的结构平衡 5.5.2 近似平衡的网络 5.6 练习</span><br><span class="line"></span><br><span class="line"> 第二部分 博弈论 第6章 博弈 6.1 何为博弈 6.2 博弈中的行为推理 6.3 最佳应对与占优策略 6.4 纳什均衡 6.5 多重均衡：协调博弈 6.6 多重均衡：鹰鸽博弈 6.7 混合策略 6.8 混合策略：案例与经验分析 6.9 帕累托最优与社会最优 6.10 深度学习材料：非优策略与动态博弈 6.10.1 多人博弈 6.10.2 非优策略及其在策略推理中的作用 6.10.3 动态博弈 6.11练习 …… 第三部分 网络中的市场与策略性互动 第四部分 信息网线与万维网 第五部分 网络动力学、总体模型 第六部分 网络动力学：结构模型 第七部分 机构及其聚合行为 参考文献</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B005XUJRKQ/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B005XUJRKQ&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51BqnEQMCYL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Shell脚本攻略</title>
    <url>/2020/04/19/B0060FSIE4/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Linux Shell脚本攻略<br>作者信息： 作者: 拉克什曼 (Sarath Lakshman) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Linux Shell脚本攻略》编辑推荐：天才程序员的独门攻略：准备，动手，一举成功!，针对110多个真实问题，展示令人难以置信的高超解法，化繁为简，几行脚本完成复杂任务。《Linux Shell脚本攻略》通过细致剖析实际应用中的110多个案例，使许多看似复杂的Linux shell脚本任务迎刃而解。作者在Linux  shell脚本方面的经验，使他能够以一种相当清晰且友好的方式有效地分享他的知识。《Linux Shell脚本攻略》会帮助读者利用少量命令的组合完成诸如文本处理、文件管理、备份等复杂的数据管理工作。《Linux Shell脚本攻略》直截了当而便于应用的写作风格，常见任务和问题的精挑细选，针对问题而精心组织的高效解法，对实际操作的细致分析，对扩展解决方案的深入探讨。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 小试牛刀</span><br><span class="line">1.1 简介</span><br><span class="line">1.2 终端打印</span><br><span class="line">1.2.1 实战演练</span><br><span class="line">1.2.2 补充内容</span><br><span class="line">1.3 玩转变量和环境变量</span><br><span class="line">1.3.1 预备知识</span><br><span class="line">1.3.2 实战演练</span><br><span class="line">1.3.3 补充内容</span><br><span class="line">1.4 通过shell进行数学运算</span><br><span class="line">1.4.1 预备知识</span><br><span class="line">1.4.2 实战演练</span><br><span class="line">1.5 玩转文件描述符和重定向</span><br><span class="line">1.5.1 预备知识</span><br><span class="line">1.5.2 实战演练</span><br><span class="line">1.5.3 补充内容</span><br><span class="line">1.6 数组和关联数组</span><br><span class="line">1.6.1 预备知识</span><br><span class="line">1.6.2 实战演练</span><br><span class="line">1.6.3 补充内容</span><br><span class="line">1.7 使用别名</span><br><span class="line">1.7.1 预备知识</span><br><span class="line">1.7.2 实战演练</span><br><span class="line">1.7.3 补充内容</span><br><span class="line">1.8 获取终端信息</span><br><span class="line">1.8.1 预备知识</span><br><span class="line">1.8.2 实战演练</span><br><span class="line">1.9 获取、设置日期和延时</span><br><span class="line">1.9.1 预备知识</span><br><span class="line">1.9.2 实战演练</span><br><span class="line">1.9.3 补充内容</span><br><span class="line">1.10 调试脚本</span><br><span class="line">1.10.1 预备知识</span><br><span class="line">1.10.2 实战演练</span><br><span class="line">1.10.3 补充内容</span><br><span class="line">1.11 函数和参数</span><br><span class="line">1.11.1 实战演练</span><br><span class="line">1.11.2 补充内容</span><br><span class="line">1.12 读取命令序列输出</span><br><span class="line">1.12.1 预备知识</span><br><span class="line">1.12.2 实战演练</span><br><span class="line">1.12.3 补充内容</span><br><span class="line">1.13 以不按回车键的方式读取字符“n”</span><br><span class="line">1.13.1 预备知识</span><br><span class="line">1.13.2 实战演练</span><br><span class="line">1.14 字段分隔符和迭代器</span><br><span class="line">1.14.1 预备知识</span><br><span class="line">1.14.2 实战演练</span><br><span class="line">1.15 比较与测试</span><br><span class="line">1.15.1 预备知识</span><br><span class="line">1.15.2 实战演练 </span><br><span class="line"></span><br><span class="line"> 第2章 命令之乐 2.1 简介 2.2 用cat进行拼接 2.2.1 预备知识 2.2.2 实战演练 2.2.3 工作原理 2.2.4 补充内容 2.3 录制与回放终端会话 2.3.1 预备知识 2.3.2 实战演练 2.3.3 工作原理 2.4 文件查找与文件列表 2.4.1 预备知识 2.4.2 实战演练 2.4.3 补充内容 2.5 玩转xargs 2.5.1 预备知识 2.5.2 实战演练 2.5.3 工作原理 2.5.4 补充内容 2.6 用tr进行转换 2.6.1 预备知识 2.6.2 实战演练 2.6.3 工作原理 2.6.4 补充内容 2.7 校验和与核实 2.7.1 预备知识 2.7.2 实战演练 2.7.3 工作原理 2.7.4 补充内容 2.8 排序、单一与重复 2.8.1 预备知识 2.8.2 实战演练 2.8.3 工作原理 2.8.4 补充内容 2.9 临时文件命名与随机数 2.9.1 实战演练 2.9.2 工作原理 2.10 分割文件和数据 2.10.1 工作原理 2.10.2 补充内容 2.11 根据扩展名切分文件名 2.11.1 实战演练 2.11.2 工作原理 2.12 批量重命名和移动 2.12.1 预备知识 2.12.2 实战演练 2.12.3 工作原理 2.13 拼写检查与词典操作 2.13.1 实战演练 2.13.2 工作原理 2.14 交互输入自动化 2.14.1 预备知识 2.14.2 实战演练 2.14.3 工作原理 2.14.4 补充内容</span><br><span class="line"></span><br><span class="line"> 第3章 以文件之名 3.1 简介 3.2 生成任意大小的文件 3.3 文本文件的交集与差集 3.3.1 预备知识 3.3.2 实战演练 3.4 查找并删除重复文件 3.4.1 预备知识 3.4.2 实战演练 3.4.3 工作原理 3.4.4 参考 3.5 创建长路径目录 3.5.1 预备知识 3.5.2 实战演练 3.6 文件权限、所有权和粘滞位 3.6.1 预备知识 3.6.2 实战演练 3.6.3 补充内容 3.7 创建不可修改文件 3.7.1 预备知识 3.7.2 实战演练 3.8 批量生成空白文件 3.8.1 预备知识 3.8.2 实战演练 3.9 查找符号链接及其指向目标 3.9.1 预备知识 3.9.2 实战演练 3.10 列举文件类型统计信息 3.10.1 预备知识 3.10.2 实战演练 3.10.3 工作原理 3.11 环回文件与挂载 3.11.1 预备知识 3.11.2 实战演练 3.11.3 补充内容 3.12 生成ISO文件及混合ISO 3.12.1 预备知识 3.12.2 实战演练 3.12.3 补充内容 3.13 查找文件差异并进行修补 3.13.1 实战演练 3.13.2 补充内容 3.14 head与tail——打印文件的前10行和后10行 3.15 只列出目录的其他方法 3.15.1 预备知识 3.15.2 实战演练 3.16 在命令行中用pushd和popd快速定位 3.16.1 预备知识 3.16.2 实战演练 3.16.3 补充内容 3.17 统计文件的行数、单词数和字符数 3.17.1 预备知识 3.17.2 实战演练 3.17.3 补充知识 3.18 打印目录树 3.18.1 预备知识 3.18.2 实战演练 3.18.3 补充内容</span><br><span class="line"></span><br><span class="line"> 第4章 让文本飞 4.1 简介 4.2 正则表达式入门 4.2.1 预备知识 4.2.2 实战演练 4.2.3 工作原理 4.2.4 补充内容 4.3 用grep在文件中搜索文本 4.3.1 预备知识 4.3.2 实战演练 4.3.3 补充内容 4.4 用cut按列切分文件 4.4.1 预备知识 4.4.2 实战演练 4.4.3 补充内容 4.5 统计特定文件中的词频 4.5.1 预备知识 4.5.2 实战演练 4.5.3 工作原理 4.5.4 参考 4.6 sed入门 4.6.1 实战演练 4.6.2 补充内容 4.7 awk入门 4.7.1 实战演练 4.7.2 工作原理 4.7.3 补充内容 4.8 替换文本或文件中的字符串 4.8.1 预备知识 4.8.2 实战演练 4.8.3 补充内容 4.8.4 参考 4.9 压缩或解压缩JavaScript 4.9.1 预备知识 4.9.2 工作原理 4.9.3 工作原理 4.9.4 参考 4.10 对文件中的行、单词和字符进行迭代 4.10.1 预备知识 4.10.2 实战演练 4.10.3 工作原理 4.10.4 参考 4.11 按列合并文件 4.11.1 工作原理 4.11.2 参考 4.12 打印文件或行中的第n个单词或列 4.12.1 预备知识 4.12.2 实战演练 4.12.3 参考 4.13 打印不同行或样式之间的文本 4.13.1 预备知识 4.13.2 实战演练 4.13.3 参考 4.14 用脚本检验回文字符串 4.14.1 预备知识 4.14.2 工作原理 4.14.3 工作原理 4.14.4 补充内容 4.14.5 参考 4.15 以逆序形式打印行 4.15.1 预备知识 4.15.2 实战演练 4.15.3 工作原理 4.15.4 参考 4.16 解析文本中的电子邮件地址和URL 4.16.1 预备知识 4.16.2 实战演练 4.16.3 工作原理 4.16.4 参考 4.17 打印文件中某个样式之前或之后的n行 4.17.1 预备知识 4.17.2 实战演练 4.17.3 参考 4.18 在文件中移除包含某个单词的句子 4.18.1 预备知识 4.18.2 实战演练 4.18.3 工作原理 4.18.4 参考 4.19 用awk实现head、tail和tac 4.19.1 预备知识 4.19.2 实战演练 4.19.3 工作原理 4.19.4 参考 4.20 文本切片与参数操作 4.20.1 实战演练 4.20.2 参考</span><br><span class="line"></span><br><span class="line"> 第5章 一团乱麻？没这回事 5.1 入门 5.2 网站下载 5.2.1 预备知识 5.2.2 实战演练 5.2.3 补充内容 5.3 以格式化纯文本形式下载网页 5.4 cURL入门 5.4.1 预备知识 5.4.2 实战演练 5.4.3 补充内容 5.4.4 参考 5.5 从命令行访问Gmail 5.5.1 实战演练 5.5.2 工作原理 5.5.3 参考 5.6 解析网站数据 5.6.1 实战演练 5.6.2 工作原理 5.6.3 参考 5.7 制作图片抓取器及下载工具 5.7.1 实战演练 5.7.2 工作原理 5.7.3 参考 5.8 网页相册生成器 5.8.1 预备知识 5.8.2 实战演练 5.8.3 工作原理 5.8.4 参考 5.9 Twitter命令行客户端 5.9.1 预备知识 5.9.2 实战演练 5.9.3 工作原理 5.9.4 参考 5.10 基于Web后端的定义查询工具 5.10.1 预备知识 5.10.2 实战演练 5.10.3 工作原理 5.10.4 参考 5.11 查找网站中的无效链接 5.11.1 预备知识 5.11.2 实战演练 5.11.3 工作原理 5.11.4 参考 5.12 跟踪网站变更 5.12.1 预备知识 5.12.2 实战演练 5.12.3 工作原理 5.12.4 参考 5.13 以POST方式发送网页并读取响应 5.13.1 预备知识 5.13.2 实战演练 5.13.3 补充内容 5.13.4 参考</span><br><span class="line"></span><br><span class="line"> 第6章 B计划 6.1 简介 6.2 用tar归档 6.2.1 预备知识 6.2.2 实战演练 6.2.3 补充知识 6.2.4 参考 6.3 用cpio归档 6.4 用gunzip或gzip压缩 6.4.1 实战演练 6.4.2 补充内容 6.4.3 参考 6.5 用bunzip或bzip压缩 6.5.1 实战演练 6.5.2 补充内容 6.5.3 参考 6.6 用lzma压缩 6.6.1 实战演练 6.6.2 补充内容 6.6.3 参考 6.7 用zip归档和压缩 6.8 超高压缩率的squashfs文件系统 6.8.1 预备知识 6.8.2 实战演练 6.8.3 补充内容 6.9 加密工具与散列 6.10 用raync备份系统快照 6.10.1 实战演练 6.10.2 补充内容 6.11 用Git备份版本控制 6.11.1 预备知识 6.11.2 实战演练 6.12 用dd克隆磁盘 6.12.1 预备知识 6.12.2 实战演练 6.12.3 补充内容 6.12.4 参考</span><br><span class="line"></span><br><span class="line"> 第7章 无网不利 7.1 简介 7.2 联网知识入门 7.2.1 新手上路 7.2.2 实战演练 7.2.3 补充内容 7.2.4 参考 7.3 使用ping 7.3.1 实战演练 7.3.2 补充内容 7.4 列出网络上所有的活动主机 7.4.1 新手上路 7.4.2 实战演练 7.4.3 工作原理 7.4.4 补充内容 7.4.5 参考 7.5 传输文件 7.5.1 新手上路 7.5.2 实战演练 7.5.3 补充内容 7.5.4 参考 7.6 用脚本设置以太网与无线LAN 7.6.1 新手上路 7.6.2 实战演练 7.6.3 工作原理 7.6.4 参考 7.7 用SSH实现无密码自动登录 7.8 用SSH在远程主机上运行命令 7.8.1 新手上路 7.8.2 实战演练 7.8.3 补充内容 7.8.4 参考 7.9 在本地挂载点上挂载远程驱动器 7.9.1 新手上路 7.9.2 实战演练 7.9.3 参考 7.10 在网络上发送多播式窗口消息 7.10.1 新手上路 7.10.2 实战演练 7.10.3 工作原理 7.10.4 参考 7.11 网络流量与端口分析 7.11.1 新手上路 7.11.2 实战演练 7.11.3 补充内容</span><br><span class="line"></span><br><span class="line"> 第8章 当个好管家 8.1 简介 8.2 统计磁盘的使用情况 8.2.1 新手上路 8.2.2 实战演练 8.2.3 补充内容 8.3 计算命令执行时间 8.4 与当前登录用户、启动日志及启动故障的相关信息 8.4.1 新手上路 8.4.2 实战演练 8.5 打印出10条最常使用的命令 8.5.1 新手上路 8.5.2 实战演练 8.5.3 工作原理 8.6 列出1小时内占用CPU最多的10个进程 8.6.1 新手上路 8.6.2 实战演练 8.6.3 工作原理 8.6.4 参考 8.7 用watch监视命令输出 8.7.1 实战演练 8.7.2 补充内容 8.8 对文件及目录访问进行记录 8.8.1 新手上路 8.8.2 实战演练 8.8.3 工作原理 8.9 用logrotate管理日志文件 8.9.1 新手上路 8.9.2 实战演练 8.10 用syslog记录日志 8.10.1 新手上路 8.10.2 实战演练 8.10.3 参考 8.11 通过监视用户登录找出入侵者 8.11.1 新手上路 8.11.2 实战演练 8.11.3 工作原理 8.12 监视远程磁盘的健康情况 8.12.1 新手上路 8.12.2 实战演练 8.12.3 工作原理 8.12.4 参考 8.13 找出系统中用户的活动时段 8.13.1 新手上路 8.13.2 实战演练 8.13.3 工作原理</span><br><span class="line"></span><br><span class="line"> 第9章 管理重任 9.1 简介 9.2 收集进程信息 9.2.1 新手上路 9.2.2 实战演练 9.2.3 补充内容 9.2.4 参考 9.3 杀死进程以及发送或响应信号 9.3.1 新手上路 9.3.2 实战演练 9.3.3 补充内容 9.4 which、whereis、file、whatis与平均负载 9.5 向用户终端发送消息 9.5.1 新手上路 9.5.2 实战演练 9.5.3 工作原理 9.6 收集系统信息 9.7 用&#x2F;proc收集信息 9.8 用cron进行调度 9.8.1 新手上路 9.8.2 实战演练 9.8.3 补充内容 9.9 从Bash中读写MySQL数据库 9.9.1 新手上路 9.9.2 实战演练 9.9.3 工作原理 9.10 用户管理脚本 9.10.1 实战演练 9.10.2 工作原理 9.11 图像文件的批量缩放及格式转换 9.11.1 新手上路 9.11.2 实战演练 9.11.3 工作原理 9.11.4 参考</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0060FSIE4/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0060FSIE4&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/514Xb1Q%2BYsL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ruby元编程</title>
    <url>/2020/04/19/B0073APSCK/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Ruby元编程<br>作者信息： 作者: Paolo Perrotta [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Ruby元编程》填补了Ruby语言参考手册和编程案例之间的空白。它不仅解释了各种元编程的技术，还展示了编写更精练、更优良代码的方法。不过要事先警告你，熟悉了新方法后，你会难以忍受目前主流的编程方法。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">致谢</span><br><span class="line">引言</span><br><span class="line">“元”这个字眼</span><br><span class="line">关于本书</span><br><span class="line">关于你</span><br><span class="line">第1部分Ruby元编程</span><br><span class="line">第1章星期一：对象模型</span><br><span class="line">1.1跟Bill在一起的星期一</span><br><span class="line">1.2打开类</span><br><span class="line">1.3类的真相</span><br><span class="line">1.4小测验：缺失的连接线</span><br><span class="line">1.5调用一个方法时发生了什么</span><br><span class="line">I.6小测验：混乱的模块</span><br><span class="line">1.7对象模型小结</span><br><span class="line">第2章星期二：方法</span><br><span class="line">2.1一个重复代码的问题</span><br><span class="line">2.2动态方法</span><br><span class="line">2.3method—mtssing（）方法</span><br><span class="line">2.4小测验：狩猎Bug</span><br><span class="line">2.5关于method—missing（）方法的更多内容</span><br><span class="line">第3章星期三：代码块</span><br><span class="line">3.1怎样度过驼峰日</span><br><span class="line">3.2小测验：Ruby的#符号</span><br><span class="line">3.3闭包</span><br><span class="line">3.4instanceeval（）</span><br><span class="line">3.5可调用对象</span><br><span class="line">3.6编写一种领域专属语</span><br><span class="line">3.7小测验：更好的领域专属语言</span><br><span class="line">第4章星期四：类定义</span><br><span class="line">4.1类定义揭秘</span><br><span class="line">4.2小测验：Taboo类</span><br><span class="line">4.3单件方法</span><br><span class="line">4.4Eigenelass</span><br><span class="line">4.5小测验：模块的麻烦</span><br><span class="line">4.6别名</span><br><span class="line">4.7小测验：打破数学规律</span><br><span class="line">第5章星期五：编写代码的代码</span><br><span class="line">5.1带路</span><br><span class="line">5.2Kernel#eval</span><br><span class="line">5.3小测验：校验过的属性（第一步）</span><br><span class="line">5.4小测验：校验过的属性（第二步）</span><br><span class="line">5.5小测验：校验过的属性（第二三步）</span><br><span class="line">5.6小测验：校验过的属性（第四步）</span><br><span class="line">5.7钩子方法</span><br><span class="line">5.8小测验：校验过的属性（第五步）</span><br><span class="line">第6章尾声</span><br><span class="line">第2部分Rails中的元编程</span><br><span class="line">第7章AcllyeRecord的设计</span><br><span class="line">7.1准备旅程</span><br><span class="line">7.2ActiveRecord的设计</span><br><span class="line">7.3经验教训</span><br><span class="line">第8章深入AcllyeRecord</span><br><span class="line">8.1动态属性</span><br><span class="line">8.2动态查找器</span><br><span class="line">8.3经验教训</span><br><span class="line">第9章安全元编程</span><br><span class="line">9.1元编程的测试</span><br><span class="line">9.2化解猴子补丁</span><br><span class="line">9.3经验教训</span><br><span class="line">第3部分附录</span><br><span class="line">附录A常见惯用法</span><br><span class="line">A.1拟态方法</span><br><span class="line">A.2空指针保护</span><br><span class="line">A.3关于方法参数的技巧</span><br><span class="line">A.4SelfYield</span><br><span class="line">A.5Symbol#to_proc（）方法</span><br><span class="line">附录B领域专属语言</span><br><span class="line">B.1关于领域专属语言</span><br><span class="line">B.2内部和外部领域专属语言</span><br><span class="line">B.3领域专属语言和元编程</span><br><span class="line">附录C法术手册</span><br><span class="line">C.1法术集</span><br><span class="line">附录D参考书目</span><br><span class="line">索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0073APSCK/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0073APSCK&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51rtdOOTHYL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>ruby</tag>
      </tags>
  </entry>
  <entry>
    <title>社交网站的数据挖掘与分析</title>
    <url>/2020/04/19/B0077K9R2I/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 社交网站的数据挖掘与分析<br>作者信息： 作者: 马修•罗塞尔 (Matthew A. Russell) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《社交网站的数据挖掘与分析》为Jolt生产效率大奖获奖图书。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">第1章 绪论：Twitter 数据的处理</span><br><span class="line">Python 开发工具的安装</span><br><span class="line">Twitter 数据的收集和处理</span><br><span class="line">小结 </span><br><span class="line"></span><br><span class="line"> 第2章 微格式：语义标记和常识碰撞 XFN 和朋友 使用XFN 来探讨社交关系 地理坐标：兴趣爱好的共同主线 （以健康的名义）对菜谱进行交叉分析 对餐厅评论的搜集 小结</span><br><span class="line"></span><br><span class="line"> 第3章 邮箱：虽然老套却很好用 mbox：Unix 的入门级邮箱 mbox+CouchDB&#x3D; 随意的Email分析 将对话线程化到一起 使用SIMILE Timeline 将邮件“事件”可视化 分析你自己的邮件数据 小结</span><br><span class="line"></span><br><span class="line"> 第4章 Twitter ：朋友、关注者和Setwise 操作 REST 风格的和OAuth-Cladded API 干练而中肯的数据采集器 友谊图的构建 小结</span><br><span class="line"></span><br><span class="line"> 第5章 Twitter：tweet ，所有的tweet ，只有tweet. 笔PK 剑：和tweet PK 机枪（？!？） 对tweet 的分析（每次一个实体） 并置潜在的社交网站（或#JustinBieber VS #TeaParty） 对大量tweet 的可视化 小结</span><br><span class="line"></span><br><span class="line"> 第6章 LinkedIn ：为了乐趣（和利润？）将职业网络聚类 聚类的动机 按职位将联系人聚类 获取补充个人信息 从地理上聚类网络 小结</span><br><span class="line"></span><br><span class="line"> 第7章 Google Buzz：TF-IDF 、余弦相似性和搭配 Buzz&#x3D;Twitter+ 博客（？？？） 使用NLTK 处理数据 文本挖掘的基本原则 查找相似文档 在二元语法中发Buzz 利用Gmail 在中断之前试着创建一个搜索引擎 小结</span><br><span class="line"></span><br><span class="line"> 第8章 博客及其他：自然语言处理（等） NLP：帕累托式介绍 使用NLTK 的典型NLP 管线 使用NLTK 检测博客中的句子 对文件的总结 以实体为中心的分析：对数据的深层了解 小结</span><br><span class="line"></span><br><span class="line"> 第9章 Facebook ：一体化的奇迹 利用社交网络数据 对Facebook 数据的可视化 小结</span><br><span class="line"></span><br><span class="line"> 第10章 语义网：简短的讨论 发展中的变革 人不可能只靠事实生活 期望</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0077K9R2I/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0077K9R2I&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec8.images-amazon.com/images/I/51Vm0aKN6OL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>重视大脑的学习指南 Head First Python(中文版)</title>
    <url>/2020/04/19/B007NB2B4M/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 重视大脑的学习指南 Head First Python(中文版)<br>作者信息： 作者: 巴里（Barry.P.） [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《重视大脑的学习指南:Head First Python(中文版)》：你想过可以通过一《重视大脑的学习指南:Head First Python(中文版)》就学会Python吗？《重视大脑的学习指南:Head First Python(中文版)》超越枯燥的语法和甩法手册，通过一种独特的方法教你学习这种语言。你会迅速掌握Python的基础知识，然后转向持久存储、异常处理、Web开发、SQLite、数据加工和lGoogle App Engine。你还将学习如何为Android编写移动应用，这都要归功于Python为你赋予的强大能力。《重视大脑的学习指南:Head First Python(中文版)》会提供充分并且完备的学习体验，帮助你成为一名真正的Python程序员。作者巴里觉得你的时间相当宝贵，不应当过多地花费在与新概念的纠缠之中。通过应用认知科学和学习理论的最新研究成果，《重视大脑的学习指南:Head First Python(中文版)》可以让你投入一个需要多感官参与的学习体验，这《重视大脑的学习指南:Head First Python(中文版)》采用丰富直观的形式使你的大脑真正开动起来，而不是长篇累牍地说教，让你昏昏欲睡。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">引子</span><br><span class="line">1  初识Python：人人都爱列表</span><br><span class="line">2  共享你的代码：函数模块</span><br><span class="line">3  文件与异常：处理错误</span><br><span class="line">4  持久存储：数据保存到文件</span><br><span class="line">5  推导数据：处理数据！</span><br><span class="line">6  定制数据对象：打包代码与数据</span><br><span class="line">7  Web开发：集成在一起</span><br><span class="line">8  移动应用开发：小设备</span><br><span class="line">9  管理你的数据：处理输入</span><br><span class="line">10  扩展你的Web应用：来真格的</span><br><span class="line">11  处理复杂性：数据加工</span><br><span class="line">i　其他：(我们没有谈到的)十大问题</span><br><span class="line">索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B007NB2B4M/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B007NB2B4M&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51gLji-xVVL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Perl语言入门(中文版)(第6版)</title>
    <url>/2020/04/19/B007VA4KDA/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Perl语言入门(中文版)(第6版)<br>作者信息： 作者: 施瓦茨 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Perl语言入门(第6版)(中文版)》从最基础的开始教起，然后逐渐深入，让你慢慢能够自行编写多至128行的程序——如今90％的Perl程序差不多都是这般大小，全书包括输入与输出；用正则表达式处理文本；字符串与排序等数章内容。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一章简介</span><br><span class="line">问题与答案</span><br><span class="line">这本书适合你吗？</span><br><span class="line">为何有这么多的脚注？</span><br><span class="line">关于习题和解答？</span><br><span class="line">习题前标的数字是什么意思？</span><br><span class="line">如果我是Perl讲师？</span><br><span class="line">“Perl”这个词表示什么意思？</span><br><span class="line">Larry为什么要创造Perl？</span><br><span class="line">Larry干吗不用其他语言？</span><br><span class="line">Perl算容易，还是算难？</span><br><span class="line">Perl怎么会这么流行？</span><br><span class="line">现在的Perl发展得怎么样了？</span><br><span class="line">哪些事情最适合用Perl来做？</span><br><span class="line">哪些事情不适合用Perl来做？</span><br><span class="line">如何取得Perl？</span><br><span class="line">CPAN是什么？</span><br><span class="line">如何得到Perl的技术支持？</span><br><span class="line">还有别的技术支持方式吗？</span><br><span class="line">如果发现Perl有bug，我该怎么办？</span><br><span class="line">我该怎么编写Perl程序？</span><br><span class="line">一个简单的程序</span><br><span class="line">程序里写的是什么？</span><br><span class="line">我该如何编译Perl程序？</span><br><span class="line">走马观花</span><br><span class="line">习题</span><br><span class="line">第二章标量数据</span><br><span class="line">数字</span><br><span class="line">所有数字的内部格式都相同</span><br><span class="line">浮点数直接量</span><br><span class="line">整数直接量</span><br><span class="line">非+进制整数的直接量</span><br><span class="line">数字操作符</span><br><span class="line">字符串</span><br><span class="line">单引号内的字符串直接量</span><br><span class="line">双引号内的字符串直接量</span><br><span class="line">字符串操作符</span><br><span class="line">数字与字符串之间的自动转换</span><br><span class="line">Perl的内置警告信息</span><br><span class="line">标量变量</span><br><span class="line">给变量取个好名字</span><br><span class="line">标量的赋值</span><br><span class="line">双目赋值操作符</span><br><span class="line">用print输出结果</span><br><span class="line">字符串中的标量变量内插</span><br><span class="line">借助代码点创建字符</span><br><span class="line">操作符的优先级与结合性</span><br><span class="line">比较操作符</span><br><span class="line">if控制结构</span><br><span class="line">布尔值</span><br><span class="line">获取用户输入</span><br><span class="line">chomp操作符</span><br><span class="line">while控制结构</span><br><span class="line">undef值</span><br><span class="line">defined函数</span><br><span class="line">习题</span><br><span class="line">第三章列表与数组</span><br><span class="line">访问数组中的元素</span><br><span class="line">特殊的数组索引</span><br><span class="line">列表直接量</span><br><span class="line">qw简写</span><br><span class="line">列表的赋值</span><br><span class="line">pop和push操作符</span><br><span class="line">shift和unshift操作符</span><br><span class="line">splice操作符</span><br><span class="line">字符串中的数组内插</span><br><span class="line">foreach控制结构</span><br><span class="line">Perl最喜欢用的默认变量：$_</span><br><span class="line">reverse操作符</span><br><span class="line">sort操作符</span><br><span class="line">each操作符</span><br><span class="line">标量上下文与列表上下文</span><br><span class="line">在标量上下文中使用产生列表的表达式</span><br><span class="line">在列表上下文中使用产生标量的表达式</span><br><span class="line">强制指定标量上下文</span><br><span class="line">列表上下文中的 习题 第四章子程序 定义子程序 调用子程序 返回值 参数 子程序中的私有变量 变长参数列表 改进的&amp;max子程序 空参数列表 关于词法（my）变量 use strict编译指令 return操作符 省略与号 非标量返回值 持久化私有变量 习题 第五章输入与输出 读取标准输入 来自钻石操作符的输入 调用参数 输出到标准输出 JNprintf格式化输出 数组和printf 文件句柄 打开文件句柄 以二进制方式读写文件句柄 有问题的文件句柄 关闭文件句柄 用die处理致命错误 用warn输出警告信息 自动检测致命错误 使用文件句柄 改变默认的文件输出句柄 重新打开标准文件句柄 用say来输出 …… 第六章哈希 第七章漫游正则表达式王国 第八章用正则表达式进行匹配 第九章用正则表达式处理文本 第十章其他控制结构 第十一章Perl模块 第十二章文件测试 第十三章目录操作 第十四章字符串与排序 第十五章智能匹配与given—when结构 第十六章进程管理 第十七章高级Perl技巧 附录   &lt;&#x2F;stdin&gt;</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B007VA4KDA/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B007VA4KDA&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51Wvo52V3yL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>perl</tag>
      </tags>
  </entry>
  <entry>
    <title>人人都是产品经理 version 1.1</title>
    <url>/2020/04/19/B0088PF1IA/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 人人都是产品经理 version 1.1<br>作者信息： 作者: 苏杰 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《人人都是产品经理 version 1.1》书名的由来是因为作者觉得过去几年在做产品的过程中学到的思维方法与做事方式对自己很有帮助，而每个人也无时无刻在思考着同样的问题：”我们为了什么，在做什么事，解决什么人的什么问题？何时，和谁一起做？需要什么能力？”这些正对应了《人人都是产品经理 version 1.1》要说的几大话题：用户、需求、项目、团队、战略、修养。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">写在正文之前</span><br><span class="line">为什么会有这本书</span><br><span class="line">本书的产品定位</span><br><span class="line">本书的风格与特色</span><br><span class="line">本书的目录与内容</span><br><span class="line">我与本书的局限性</span><br><span class="line">第1章 写给-1到3岁的产品经理</span><br><span class="line">1.1 为什么要做产品经理</span><br><span class="line">1.2 我们到底是不是产品经理</span><br><span class="line">1.3 我真的想做，怎么入行</span><br><span class="line">1.4 一个产品经理的-1到3岁</span><br><span class="line">第2章 一个需求的奋斗史</span><br><span class="line">2.1 从用户中来到用户中去</span><br><span class="line">2.1.1 用户是需求之源</span><br><span class="line">2.1.2 你真的了解用户吗</span><br><span class="line">2.2 需求采集的大生产运动</span><br><span class="line">2.2.1 定性地说：用户访谈</span><br><span class="line">2.2.2 定量地说：调查问卷</span><br><span class="line">2.2.3 定性地做：可用性测试</span><br><span class="line">2.2.4 定量地做：数据分析</span><br><span class="line">2.2.5 需求采集人人有责</span><br><span class="line">2.3 听用户的但不要照着做</span><br><span class="line">2.3.1 明确我们存在的价值</span><br><span class="line">2.3.2 给需求做一次DNA检测</span><br><span class="line">2.4 活下来的永远是少数</span><br><span class="line">2.4.1 永远忘不掉的那场战争</span><br><span class="line">2.4.2 别灰心，少做就是多做</span><br><span class="line">2.5 心急吃不了热豆腐</span><br><span class="line">第3章 项目的坎坷一生</span><br><span class="line">3.1 从产品到项目</span><br><span class="line">3.2 一切从Kick Off开始</span><br><span class="line">3.3 关键的青春期，又见需求</span><br><span class="line">3.3.1 真的要写很多文档</span><br><span class="line">3.3.2 需求活在项目中</span><br><span class="line">3.4 成长，一步一个脚印</span><br><span class="line">3.5 山寨级项目管理</span><br><span class="line">3.5.1 文档只是手段</span><br><span class="line">3.5.2 流程也是手段</span><br><span class="line">3.5.3 敏捷更是手段</span><br><span class="line">3.6 物竞天择适者生存</span><br><span class="line">3.6.1 亲历过的特色项目</span><br><span class="line">3.6.2 一路坎坷，你我同行</span><br><span class="line">第4章 我的产品，我的团队</span><br><span class="line">4.1 大产品，大设计，大团队</span><br><span class="line">4.1.1 产品之大</span><br><span class="line">4.1.2 设计之大</span><br><span class="line">4.1.3 团队之大</span><br><span class="line">4.2 游走于商业与技术之间</span><br><span class="line">4.2.1 心思缜密的规划师</span><br><span class="line">4.2.2 激情四射的设计师</span><br><span class="line">4.2.3 “阴险狡诈&quot;的运营师</span><br><span class="line">4.3 商业团队，冲锋陷阵</span><br><span class="line">4.3.1 好产品还需市场化</span><br><span class="line">4.3.2 我们还能做什么</span><br><span class="line">4.4 技术团队，坚强后盾</span><br><span class="line">4.5 容易被遗忘的角落</span><br><span class="line">4.6 大家好才是真的好</span><br><span class="line">4.6.1 所谓团队文化</span><br><span class="line">4.6.2 虚无的无授权领导</span><br><span class="line">第5章 别让灵魂跟不上脚步</span><br><span class="line">5.1 触及产品的灵魂</span><br><span class="line">5.2 可行性分析三部曲</span><br><span class="line">5.2.1 我们在哪儿</span><br><span class="line">5.2.2 我们去哪儿</span><br><span class="line">5.2.3 我们怎么去</span><br><span class="line">5.3 做吧，准备出发</span><br><span class="line">5.3.1 敢问路在何方</span><br><span class="line">5.3.2 低头走路，抬头看天</span><br><span class="line">5.4 KPI，KPI，KPI</span><br><span class="line">5.5 本书的源头活水</span><br><span class="line">第6章 产品经理的自我修养</span><br><span class="line">6.1 爱生活，才会爱产品</span><br><span class="line">6.2 有理想，就不会变咸鱼</span><br><span class="line">6.3 会思考，活到老学到老</span><br><span class="line">6.4 能沟通，在什么山头唱什么歌</span><br><span class="line">6.5 产品经理主义</span><br><span class="line">附录：它山之石 可以攻玉</span><br><span class="line">别人眼中的产品经理</span><br><span class="line">各种有用的信息</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0088PF1IA/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0088PF1IA&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41DU6P33YcL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title>爱上Processing</title>
    <url>/2020/04/19/B007V9S97O/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 爱上Processing<br>作者信息： 作者: Casey) 瑞斯 (Reas [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《爱上Processing》言简意赅，清晰、详细地介绍了Processing的各项功能和拓展的可能性，以及在计算机图形方面的主要优势和用法。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">1 简介</span><br><span class="line">草稿化和原型化</span><br><span class="line">灵活性</span><br><span class="line">巨人</span><br><span class="line">家族树</span><br><span class="line">加入我们 </span><br><span class="line"></span><br><span class="line"> 2 开始编程 第一个程序 显示(Show) 保存 分享 例子和引用</span><br><span class="line"></span><br><span class="line"> 3 画图 基本形状 绘制顺序 图形的性质 颜色 自定义图形 注释 机器人1：绘制</span><br><span class="line"></span><br><span class="line"> 4 变量 创造变量 Processing的变量 一些小小的数学问题 重复 机器人2：变量</span><br><span class="line"></span><br><span class="line"> 5 响应 跟随 映射 点击 位置 类型 机器人3：响应</span><br><span class="line"></span><br><span class="line"> 6 媒体 图像 字体 形状 机器人4：媒体</span><br><span class="line"></span><br><span class="line"> 7 运动 速度和方向 在两者之间 随机 计时器 圆环 平移、旋转和缩放 机器人5：运动</span><br><span class="line"></span><br><span class="line"> 8 函数 函数的基础 写一个函数 返回值 机器人6：函数</span><br><span class="line"></span><br><span class="line"> 9 对象 类别和对象 机器人7：对象</span><br><span class="line"></span><br><span class="line"> 10 数组 写一个数组 重复和数组 对象的数组 机器人8：数组</span><br><span class="line"></span><br><span class="line"> 11 延伸 三维 图像和导出 你好Arduino 爱好者社区 A 编程小贴士 B 数据类型 C 操作的顺序 D 变量作用域</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B007V9S97O/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B007V9S97O&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51lhVK2QvqL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>processing</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐系统实践</title>
    <url>/2020/04/19/B008AK5YJO/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 推荐系统实践<br>作者信息： 作者: 项亮 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《推荐系统实践》适合对推荐技术感兴趣的读者学习参考。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目　录 </span><br><span class="line"></span><br><span class="line"> 第1章　好的推荐系统　1 1.1　什么是推荐系统　1 1.2　个性化推荐系统的应用　4 1.2.1　电子商务　4 1.2.2　电影和视频网站　8 1.2.3　个性化音乐网络电台　10 1.2.4　社交网络　12 1.2.5　个性化阅读　15 1.2.6　基于位置的服务　16 1.2.7　个性化邮件　17 1.2.8　个性化广告　18 1.3　推荐系统评测　19 1.3.1　推荐系统实验方法　20 1.3.2　评测指标　23 1.3.3　评测维度　34</span><br><span class="line"></span><br><span class="line"> 第2章　利用用户行为数据　35 2.1　用户行为数据简介　36 2.2　用户行为分析　39 2.2.1　用户活跃度和物品流行度的分布　39 2.2.2　用户活跃度和物品流行度的关系　41 2.3　实验设计和算法评测　41 2.3.1　数据集　42 2.3.2　实验设计　42 2.3.3　评测指标　42 2.4　基于邻域的算法　44 2.4.1　基于用户的协同过滤算法　44 2.4.2　基于物品的协同过滤算法　51 2.4.3　UserCF和ItemCF的综合比较　59 2.5　隐语义模型　64 2.5.1　基础算法　64 2.5.2　基于LFM的实际系统的例子　70 2.5.3　LFM和基于邻域的方法的比较　72 2.6　基于图的模型　73 2.6.1　用户行为数据的二分图表示　73 2.6.2　基于图的推荐算法　73</span><br><span class="line"></span><br><span class="line"> 第3章　推荐系统冷启动问题　78 3.1　冷启动问题简介　78 3.2　利用用户注册信息　79 3.3　选择合适的物品启动用户的兴趣　85 3.4　利用物品的内容信息　89 3.5　发挥专家的作用　94</span><br><span class="line"></span><br><span class="line"> 第4章　利用用户标签数据　96 4.1　UGC标签系统的代表应用　97 4.1.1　Delicious　97 4.1.2　CiteULike　98 4.1.3　Last.fm　98 4.1.4　豆瓣　99 4.1.5　Hulu　99 4.2　标签系统中的推荐问题　100 4.2.1　用户为什么进行标注　100 4.2.2　用户如何打标签　101 4.2.3　用户打什么样的标签　102 4.3　基于标签的推荐系统　103 4.3.1　实验设置　104 4.3.2　一个最简单的算法　105 4.3.3　算法的改进　107 4.3.4　基于图的推荐算法　110 4.3.5　基于标签的推荐解释　112 4.4　给用户推荐标签　115 4.4.1　为什么要给用户推荐标签　115 4.4.2　如何给用户推荐标签　115 4.4.3　实验设置　116 4.4.4　基于图的标签推荐算法　119 4.5　扩展阅读　119</span><br><span class="line"></span><br><span class="line"> 第5章　利用上下文信息　121 5.1　时间上下文信息　122 5.1.1　时间效应简介　122 5.1.2　时间效应举例　123 5.1.3　系统时间特性的分析　125 5.1.4　推荐系统的实时性　127 5.1.5　推荐算法的时间多样性　128 5.1.6　时间上下文推荐算法　130 5.1.7　时间段图模型　134 5.1.8　离线实验　136 5.2　地点上下文信息　139 5.3　扩展阅读　143</span><br><span class="line"></span><br><span class="line"> 第6章　利用社交网络数据　144 6.1　获取社交网络数据的途径　144 6.1.1　电子邮件　145 6.1.2　用户注册信息　146 6.1.3　用户的位置数据　146 6.1.4　论坛和讨论组　146 6.1.5　即时聊天工具　147 6.1.6　社交网站　147 6.2　社交网络数据简介　148 　　 社交网络数据中的长尾分布　149 6.3　基于社交网络的推荐　150 6.3.1　基于邻域的社会化推荐算法　151 6.3.2　基于图的社会化推荐算法　152 6.3.3　实际系统中的社会化推荐算法　153 6.3.4　社会化推荐系统和协同过滤推荐系统　155 6.3.5　信息流推荐　156 6.4　给用户推荐好友　159 6.4.1　基于内容的匹配　161 6.4.2　基于共同兴趣的好友推荐　161 6.4.3　基于社交网络图的好友推荐　161 6.4.4　基于用户调查的好友推荐算法对比　164 6.5　扩展阅读　165</span><br><span class="line"></span><br><span class="line"> 第7章　推荐系统实例　166 7.1　外围架构　166 7.2　推荐系统架构　167 7.3　推荐引擎的架构　171 7.3.1　生成用户特征向量　172 7.3.2　特征-物品相关推荐　173 7.3.3　过滤模块　174 7.3.4　排名模块　174 7.4　扩展阅读　178</span><br><span class="line"></span><br><span class="line"> 第8章　评分预测问题　179 8.1　离线实验方法　180 8.2　评分预测算法　180 8.2.1　平均值　180 8.2.2　基于邻域的方法　184 8.2.3　隐语义模型与矩阵分解模型　186 8.2.4　加入时间信息　192 8.2.5　模型融合　193 8.2.6　Netflix Prize的相关实验结果　195</span><br><span class="line"></span><br><span class="line"> 后记　196</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B008AK5YJO/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B008AK5YJO&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51HI9UvBIyL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title>Python标准库</title>
    <url>/2020/04/19/B008BDGUC0/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Python标准库<br>作者信息： 作者: 荷尔曼 (Doug Hellmann) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Python标准库》的读者应该是中等水平的Python程序员，所以尽管书中对所有源代码都做了讨论，但只有一部分会逐行给出解释。每节会通过源代码和完全独立的示例程序的输出来重点介绍一个模块的特性。我会尽可能简洁地介绍各个特性，使读者能够把重点放在所展示的模块或函数上，而不会因支持代码而分心。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">译者序</span><br><span class="line">序</span><br><span class="line">前言</span><br><span class="line">第1章文本</span><br><span class="line">1.1string——文本常量和模板</span><br><span class="line">1.1.1函数</span><br><span class="line">1.1.2模板</span><br><span class="line">1.1.3高级模板</span><br><span class="line">1.2textwrap——格式化文本段落</span><br><span class="line">1.2.1示例数据</span><br><span class="line">1.2.2填充段落</span><br><span class="line">1.2.3去除现有缩进</span><br><span class="line">1.2.4结合dedent和fill</span><br><span class="line">1.2.5悬挂缩进</span><br><span class="line">1.3re——正则表达式</span><br><span class="line">1.3.1查找文本中的模式</span><br><span class="line">1.3.2编译表达式</span><br><span class="line">1.3.3多重匹配</span><br><span class="line">1.3.4模式语法</span><br><span class="line">1.3.5限制搜索</span><br><span class="line">1.3.6用组解析匹配</span><br><span class="line">1.3.7搜索选项</span><br><span class="line">1.3.8前向或后向</span><br><span class="line">1.3.9自引用表达式</span><br><span class="line">1.3.10用模式修改字符串</span><br><span class="line">1.3.11利用模式拆分</span><br><span class="line">1.4difflib——比较序列</span><br><span class="line">1.4.1比较文本体</span><br><span class="line">1.4.2无用数据</span><br><span class="line">1.4.3比较任意类型</span><br><span class="line">第2章数据结构</span><br><span class="line">2.1 collections——容器数据类型</span><br><span class="line">2.1.1 Counter</span><br><span class="line">2.1.2 defaultdict</span><br><span class="line">2.1.3 deque</span><br><span class="line">2.1.4 namedtuple</span><br><span class="line">2.1.5 OrderedDict</span><br><span class="line">2.2 array——固定类型数据序列</span><br><span class="line">2.2.1 初始化</span><br><span class="line">2.2.2处理数组</span><br><span class="line">2.2.3数组与文件</span><br><span class="line">2.2.4候选字节顺序</span><br><span class="line">2.3 heapq——堆排序算法</span><br><span class="line">2.3.1示例数据</span><br><span class="line">2.3.2创建堆</span><br><span class="line">2.3.3访问堆的内容</span><br><span class="line">2.3.4堆的数据极值</span><br><span class="line">2.4 bisect——维护有序列表</span><br><span class="line">2.4.1有序插入</span><br><span class="line">2.4.2处理重复</span><br><span class="line">2.5 Queue——线程安全的FIFO实现</span><br><span class="line">2.5.1基本FIFO队列</span><br><span class="line">2.5.2 LIFO队列</span><br><span class="line">2.5.3优先队列</span><br><span class="line">2.5.4构建一个多线程播客客户程序</span><br><span class="line">2.6 struct——二进制数据结构</span><br><span class="line">2.6.1 函数与Struct类</span><br><span class="line">2.6.2打包和解包</span><br><span class="line">2.6.3字节序</span><br><span class="line">2.6.4缓冲区</span><br><span class="line">2.7 weakref——对象的非永久引用</span><br><span class="line">2.7.1 引用</span><br><span class="line">2.7.2引用回调</span><br><span class="line">2.7.3代理</span><br><span class="line">2.7.4循环引用</span><br><span class="line">2.7.5缓存对象</span><br><span class="line">2.8 copy——复制对象</span><br><span class="line">2.8.1浅副本</span><br><span class="line">2.8.2深副本</span><br><span class="line">2.8.3定制复制行为</span><br><span class="line">2.8.4深副本中的递归</span><br><span class="line">2.9 pprint——美观打印数据结构</span><br><span class="line">2.9.1打印</span><br><span class="line">2.9.2格式化</span><br><span class="line">2.9.3任意类</span><br><span class="line">2.9.4递归</span><br><span class="line">2.9.5限制嵌套输出</span><br><span class="line">2.9.6控制输出宽度</span><br><span class="line">第3章 算法</span><br><span class="line">3.1 functools——管理函数的工具</span><br><span class="line">3.1.1修饰符</span><br><span class="line">3.1.2比较</span><br><span class="line">3.2 itertools——迭代器函数</span><br><span class="line">3.2.1合并和分解迭代器</span><br><span class="line">3.2.2转换输入</span><br><span class="line">3.2.3生成新值</span><br><span class="line">3.2.4过滤</span><br><span class="line">3.2.5数据分组</span><br><span class="line">3.3 operator——内置操作符的函数接口</span><br><span class="line">3.3.1逻辑操作</span><br><span class="line">3.3.2比较操作符</span><br><span class="line">3.3.3算术操作符</span><br><span class="line">3.3.4序列操作符</span><br><span class="line">3.3.5原地操作符</span><br><span class="line">3.3.6属性和元素“获取方法”</span><br><span class="line">3.3.7结合操作符和定制类</span><br><span class="line">3.3.8类型检查</span><br><span class="line">3.4 contextlib——上下文管理器工具</span><br><span class="line">3.4.1上下文管理器API</span><br><span class="line">3.4.2从生成器到上下文管理器</span><br><span class="line">3.4.3嵌套上下文</span><br><span class="line">3.4.4关闭打开的句柄</span><br><span class="line">第4章 日期和时间</span><br><span class="line">4.1 time——时钟时间</span><br><span class="line">4.1.1壁挂钟时间</span><br><span class="line">4.1.2处理器时钟时间</span><br><span class="line">4.1.3时间组成</span><br><span class="line">4.1.4处理时区</span><br><span class="line">4.1.5解析和格式化时间</span><br><span class="line">4.2 datetime——日期和时间值管理</span><br><span class="line">4.2.1 时间</span><br><span class="line">4.2.2 日期</span><br><span class="line">4.2.3 timedelta</span><br><span class="line">4.2.4日期算术运算</span><br><span class="line">4.2.5比较值</span><br><span class="line">4.2.6结合日期和时间</span><br><span class="line">4.2.7格式化和解析</span><br><span class="line">……</span><br><span class="line">第5章数学计算</span><br><span class="line">第6章文件系统</span><br><span class="line">第7章数据持久存储与交换</span><br><span class="line">第8章数据压缩与归档</span><br><span class="line">第9章加密</span><br><span class="line">第10章进程与线程</span><br><span class="line">第11章网络通信</span><br><span class="line">第12章Internet</span><br><span class="line">第113章Email</span><br><span class="line">第14章应用构建模块</span><br><span class="line">第15章国际化和本地化</span><br><span class="line">第16章开发工具</span><br><span class="line">第17章运行时特性</span><br><span class="line">第18章语言工具</span><br><span class="line">第19章模块与包</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B008BDGUC0/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B008BDGUC0&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41SC0-hwcuL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>传世经典书丛 UNIX编程艺术</title>
    <url>/2020/04/19/B008Z1IEQ8/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 传世经典书丛 UNIX编程艺术<br>作者信息： 作者: 埃瑞克•S.理曼德(Eric S. Raymond) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《传世经典书丛:UNIX编程艺术》内容涉及社群文化、软件开发设计与实现，覆盖面广、内容深邃，完全展现了作者极其深厚的经验积累和领域智慧。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">序</span><br><span class="line">PartIⅠ1</span><br><span class="line">第1章 哲学3</span><br><span class="line">1.1 文化？什么文化3</span><br><span class="line">1.2 Unix的生命力4</span><br><span class="line">1.3 反对学习Unix文化的理由5</span><br><span class="line">1.4 Unix之失6</span><br><span class="line">1.5 Unix之得7</span><br><span class="line">1.5.1 开源软件7</span><br><span class="line">1.5.2 跨平台可移植性和开放标准8</span><br><span class="line">1.5.3 Internet和万维网8</span><br><span class="line">1.5.4 开源社区9</span><br><span class="line">1.5.5 从头到脚的灵活性9</span><br><span class="line">1.5.6 UnixHack之趣10</span><br><span class="line">1.5.7 Unix的经验别处也可适用11</span><br><span class="line">1.6 Unix哲学基础11</span><br><span class="line">1.6.1 模块原则：使用简洁的接口拼合简单的部件14</span><br><span class="line">1.6.2 清晰原则：清晰胜于机巧14</span><br><span class="line">1.6.3 组合原则：设计时考虑拼接组合15</span><br><span class="line">1.6.4 分离原则：策略同机制分离，接口同引擎分离16</span><br><span class="line">1.6.5 简洁原则：设计要简洁，复杂度能低则低17</span><br><span class="line">1.6.6 吝啬原则：除非确无它法，不要编写庞大的程序18</span><br><span class="line">1.6.7 透明性原则：设计要可见，以便审查和调试18</span><br><span class="line">1.6.8 健壮原则：健壮源于透明与简洁18</span><br><span class="line">1.6.9 表示原则：把知识叠入数据以求逻辑质朴而健壮19</span><br><span class="line">1.6.10 通俗原则：接口设计避免标新立异20</span><br><span class="line">1.6.11 缄默原则：如果一个程序没什么好说的，就保持沉默20</span><br><span class="line">1.6.12 补救原则：出现异常时，马上退出并给出足量错误信息21</span><br><span class="line">1.6.13 经济原则：宁花机器一分，不花程序员一秒22</span><br><span class="line">1.6.14 生成原则：避免手工hack，尽量编写程序去生成程序22</span><br><span class="line">1.6.15 优化原则：雕琢前先得有原型，跑之前先学会走23</span><br><span class="line">1.6.16 多样原则：决不相信所谓“不二法门”的断言24</span><br><span class="line">1.6.17 扩展原则：设计着眼未来，未来总比预想快24</span><br><span class="line">1.7 Unix哲学之一言以蔽之25</span><br><span class="line">1.8 应用Unix哲学26</span><br><span class="line">1.9 态度也要紧26</span><br><span class="line">第2章 历史——双流记29</span><br><span class="line">2.1 Unix的起源及历史，1969－199529</span><br><span class="line">2.1.1 创世纪：1969－197130</span><br><span class="line">2.1.2 出埃及记：1971－198032</span><br><span class="line">2.1.3 TCP&#x2F;IP和Unix内战：1980－199035</span><br><span class="line">2.1.4 反击帝国：1991－199541</span><br><span class="line">2.2 黑客的起源和历史：1961－199543</span><br><span class="line">2.2.1 游戏在校园的林间：1961－198044</span><br><span class="line">2.2.2 互联网大融合与自由软件运动：1981－199145</span><br><span class="line">2.2.3 Linux和实用主义者的应对：1991－199848</span><br><span class="line">2.3 开源运动：1998年及之后49</span><br><span class="line">2.4 Unix的历史教训51</span><br><span class="line">第3章 对比：Unix哲学同其他哲学的比较53</span><br><span class="line">3.1 操作系统的风格元素53</span><br><span class="line">3.1.1 什么是操作系统的统一性理念54</span><br><span class="line">3.1.2 多任务能力54</span><br><span class="line">3.1.3 协作进程55</span><br><span class="line">3.1.4 内部边界57</span><br><span class="line">3.1.5 文件属性和记录结构57</span><br><span class="line">3.1.6 二进制文件格式58</span><br><span class="line">3.1.7 首选用户界面风格58</span><br><span class="line">3.1.8 目标受众59</span><br><span class="line">3.1.9 开发的门坎60</span><br><span class="line">3.2 操作系统的比较61</span><br><span class="line">3.2.1 VMS61</span><br><span class="line">3.2.2 MacOS64</span><br><span class="line">3.2.3 OS&#x2F;265</span><br><span class="line">3.2.4 WindowsNT68</span><br><span class="line">3.2.5 BeOS71</span><br><span class="line">3.2.6 MVS72</span><br><span class="line">3.2.7 VM&#x2F;CMS74</span><br><span class="line">3.2.8 Linux76</span><br><span class="line">3.3 种什么籽，得什么果78</span><br><span class="line">PartⅡ81</span><br><span class="line">第4章 模块性：保持清晰，保持简洁83</span><br><span class="line">4.1 封装和最佳模块大小85</span><br><span class="line">4.2 紧凑性和正交性87</span><br><span class="line">4.2.1 紧凑性87</span><br><span class="line">4.2.2 正交性89</span><br><span class="line">4.2.3 SPOT原则91</span><br><span class="line">4.2.4 紧凑性和强单一中心92</span><br><span class="line">4.2.5 分离的价值94</span><br><span class="line">4.3 软件是多层的95</span><br><span class="line">4.3.1 自顶向下和自底向上95</span><br><span class="line">4.3.2 胶合层97</span><br><span class="line">4.3.3 实例分析：被视为薄胶合层的C语言98</span><br><span class="line">4.4 程序库99</span><br><span class="line">4.4.1 实例分析：GIMP插件100</span><br><span class="line">4.5 Unix和面向对象语言101</span><br><span class="line">4.6 模块式编码103</span><br><span class="line">第5章 文本化：好协议产生好实践105</span><br><span class="line">5.1 文本化的重要性107</span><br><span class="line">5.1.1 实例分析：Unix口令文件格式109</span><br><span class="line">5.1.2 实例分析：newsrc格式110</span><br><span class="line">5.1.3 实例分析：PNG图形文件格式111</span><br><span class="line">5.2 数据文件元格式112</span><br><span class="line">5.2.1 DSV风格113</span><br><span class="line">5.2.2 RFC822格式114</span><br><span class="line">5.2.3 Cookie—Jar格式115</span><br><span class="line">5.2.4 Record—Jar格式116</span><br><span class="line">5.2.5 XML117</span><br><span class="line">5.2.6 WindowsINI格式119</span><br><span class="line">5.2.7 Unix文本文件格式的约定120</span><br><span class="line">5.2.8 文件压缩的利弊122</span><br><span class="line">5.3 应用协议设计123</span><br><span class="line">5.3.1 实例分析：SMTP，一个简单的套接字协议124</span><br><span class="line">5.3.2 实例分析：POP3，邮局协议124</span><br><span class="line">5.3.3 实例分析：IMAP，互联网消息访问协议126</span><br><span class="line">5.4 应用协议元格式127</span><br><span class="line">5.4.1 经典的互联网应用元协议127</span><br><span class="line">5.4.2 作为通用应用协议的HTTP128</span><br><span class="line">5.4.3 BEEP：块可扩展交换协议130</span><br><span class="line">5.4.4 XML—RPC，SOAP和Jabber131</span><br><span class="line">第6章 透明性：来点儿光133</span><br><span class="line">6.1 研究实例135</span><br><span class="line">6.1.1 实例分析：audacity135</span><br><span class="line">6.1.2 实例分析：fetchmail的–v选项136</span><br><span class="line">6.1.3 实例分析：GCC139</span><br><span class="line">6.1.4 实例分析：kmail140</span><br><span class="line">6.1.5 实例分析：SNG142</span><br><span class="line">6.1.6 实例分析：Terminfo数据库144</span><br><span class="line">6.1.7 实例分析：Freeciv数据文件146</span><br><span class="line">6.2 为透明性和可显性而设计148</span><br><span class="line">6.2.1 透明性之禅149</span><br><span class="line">6.2.2 为透明性和可显性而编码150</span><br><span class="line">6.2.3 透明性和避免过度保护151</span><br><span class="line">6.2.4 透明性和可编辑的表现形式152</span><br><span class="line">6.2.5 透明性、故障诊断和故障恢复153</span><br><span class="line">6.3 为可维护性而设计154</span><br><span class="line">第7章 多道程序设计：分离进程为独立的功能157</span><br><span class="line">7.1 从性能调整中分离复杂度控制159</span><br><span class="line">7.2 UnixIPC方法的分类160</span><br><span class="line">7.2.1 把任务转给专门程序160</span><br><span class="line">7.2.2 管道、重定向和过滤器161</span><br><span class="line">7.2.3 包装器166</span><br><span class="line">7.2.4 安全性包装器和Bernstein链167</span><br><span class="line">7.2.5 从进程168</span><br><span class="line">7.2.6 对等进程间通信169</span><br><span class="line">7.3 要避免的问题和方法176</span><br><span class="line">7.3.1 废弃的UnixIPC方法176</span><br><span class="line">7.3.2 远程过程调用178</span><br><span class="line">7.3.3 线程——恐吓或威胁180</span><br><span class="line">7.4 在设计层次上的进程划分181</span><br><span class="line">第8章 微型语言：寻找歌唱的乐符183</span><br><span class="line">8.1 理解语言分类法185</span><br><span class="line">8.2 应用微型语言187</span><br><span class="line">8.2.1 案例分析：sng187</span><br><span class="line">8.2.2 案例分析：正则表达式188</span><br><span class="line">8.2.3 案例分析：Glade191</span><br><span class="line">8.2.4 案例分析：m4193</span><br><span class="line">8.2.5 案例分析：XSLT194</span><br><span class="line">8.2.6 案例分析：TheDocumenter’s work bench Tools195</span><br><span class="line">8.2.7 案例分析：fetchmail的运行控制语法199</span><br><span class="line">8.2.8 案例分析：awk200</span><br><span class="line">8.2.9 案例分析：PostScript202</span><br><span class="line">8.2.10 案例分析：bc和dc203</span><br><span class="line">8.2.11 案例分析：EmacsLisp205</span><br><span class="line">8.2.12 案例分析：JavaScript205</span><br><span class="line">8.3 设计微型语言206</span><br><span class="line">8.3.1 选择正确的复杂度207</span><br><span class="line">8.3.2 扩展和嵌入语言209</span><br><span class="line">8.3.3 编写自定义语法210</span><br><span class="line">8.3.4 宏—慎用210</span><br><span class="line">8.3.5 语言还是应用协议212</span><br><span class="line">第9章 生成：提升规格说明的层次215</span><br><span class="line">9.1 数据驱动编程216</span><br><span class="line">9.1.1 实例分析：ascii217</span><br><span class="line">9.1.2 实例分析：统计学的垃圾邮件统计218</span><br><span class="line">9.1.3 实例分析：fetchmailconf中的元类改动219</span><br><span class="line">9.2 专用代码的生成225</span><br><span class="line">9.2.1 实例分析：生成ascii显示的代码225</span><br><span class="line">9.2.2 实例分析：为列表生成HTML代码227</span><br><span class="line">第10章 配置：迈出正确的第一步231</span><br><span class="line">10.1 什么应是可配置的231</span><br><span class="line">10.2 配置在哪里233</span><br><span class="line">10.3 运行控制文件234</span><br><span class="line">10.3.1 实例分析：.Netrc文件236</span><br><span class="line">10.3.2 到其它操作系统的可移植性238</span><br><span class="line">10.4 环境变量238</span><br><span class="line">10.4.1 系统环境变量238</span><br><span class="line">10.4.2 用户环境变量240</span><br><span class="line">10.4.3 何时使用环境变量240</span><br><span class="line">10.4.4 到其它操作系统的可移植性242</span><br><span class="line">10.5 命令行选项242</span><br><span class="line">10.5.1 从–a到–z的命令行选项243</span><br><span class="line">10.5.2 到其它操作系统的可移植性248</span><br><span class="line">10.6 如何挑选方法248</span><br><span class="line">10.6.1 实例分析：fetchmail249</span><br><span class="line">10.6.2 实例分析：XFree86服务器251</span><br><span class="line">10.7 论打破规则252</span><br><span class="line">第11章 接口：Unix环境下的用户接口设计模式253</span><br><span class="line">11.1 最小立异原则的应用254</span><br><span class="line">11.2 Unix接口设计的历史256</span><br><span class="line">11.3 接口设计评估257</span><br><span class="line">11.4 CLI和可视接口之间的权衡259</span><br><span class="line">11.4.1 实例分析：编写计算器程序的两种方式262</span><br><span class="line">11.5 透明度、表现力和可配置性264</span><br><span class="line">11.6 Unix接口设计模式266</span><br><span class="line">11.6.1 过滤器模式266</span><br><span class="line">11.6.2 Cantrip模式268</span><br><span class="line">11.6.3 源模式268</span><br><span class="line">11.6.4 接收器模式269</span><br><span class="line">11.6.5 编译器模式269</span><br><span class="line">11.6.6 ed模式270</span><br><span class="line">11.6.7 Roguelike模式270</span><br><span class="line">11.6.8 “引擎和接口分离”模式273</span><br><span class="line">11.6.9 CLI服务器模式278</span><br><span class="line">11.6.10 基于语言的接口模式279</span><br><span class="line">11.7 应用Unix接口设计模式280</span><br><span class="line">11.7.1多价程序模式</span><br><span class="line">11.8 网页浏览器作为通用前端281</span><br><span class="line">11.9 沉默是金284</span><br><span class="line">第12章 优化287</span><br><span class="line">12.1 什么也别做，就站在那儿287</span><br><span class="line">12.2 先估量，后优化288</span><br><span class="line">12.3 非定域性之害290</span><br><span class="line">12.4 吞吐量和延迟291</span><br><span class="line">12.4.1 批操作292</span><br><span class="line">12.4.2 重叠操作293</span><br><span class="line">12.4.3 缓存操作结果293</span><br><span class="line">第13章 复杂度：尽可能简单，但别简过了头295</span><br><span class="line">13.1 谈谈复杂度296</span><br><span class="line">13.1.1 复杂度的三个来源296</span><br><span class="line">13.1.2 接口复杂度和实现复杂度的折中298</span><br><span class="line">13.1.3 必然的、可能的和偶然的复杂度299</span><br><span class="line">13.1.4 映射复杂度300</span><br><span class="line">13.1.5 当简洁性不能胜任302</span><br><span class="line">13.2 五个编辑器的故事302</span><br><span class="line">13.2.1 ed304</span><br><span class="line">13.2.2 vi305</span><br><span class="line">13.2.3 Sam306</span><br><span class="line">13.2.4 Emacs307</span><br><span class="line">13.2.5 Wily308</span><br><span class="line">13.3 编辑器的适当规模309</span><br><span class="line">13.3.1 甄别复杂度问题309</span><br><span class="line">13.3.2 折衷无用312</span><br><span class="line">13.3.3 Emacs是个反Unix传统的论据吗314</span><br><span class="line">13.4 软件的适度规模316</span><br><span class="line">PartⅢ319</span><br><span class="line">第14章 语言：C还是非C321</span><br><span class="line">14.1 Unix下语言的丰饶321</span><br><span class="line">14.2 为什么不是C323</span><br><span class="line">14.3 解释型语言和混合策略325</span><br><span class="line">14.4 语言评估325</span><br><span class="line">14.4.1 C326</span><br><span class="line">14.4.2 C++327</span><br><span class="line">14.4.3 Shell330</span><br><span class="line">14.4.4 Perl332</span><br><span class="line">14.4.5 Tcl334</span><br><span class="line">14.4.6 Python336</span><br><span class="line">14.4.7 Java339</span><br><span class="line">14.4.8 EmacsLisp342</span><br><span class="line">14.5 未来趋势344</span><br><span class="line">14.6 选择X工具包346</span><br><span class="line">第15章 工具：开发的战术349</span><br><span class="line">15.1 开发者友好的操作系统349</span><br><span class="line">15.2 编辑器选择350</span><br><span class="line">15.2.1 了解vi351</span><br><span class="line">15.2.2 了解Emacs351</span><br><span class="line">15.2.3 非虔诚的选择：两者兼用352</span><br><span class="line">15.3 专用代码生成器352</span><br><span class="line">15.3.1 yacc和lex353</span><br><span class="line">15.3.2 实例分析：fetchmailrc的语法356</span><br><span class="line">15.3.3 实例分析：Glade356</span><br><span class="line">15.4 make：自动化编译357</span><br><span class="line">15.4.1 make的基本理论357</span><br><span class="line">15.4.2 非C&#x2F;C++开发中的make359</span><br><span class="line">15.4.3 通用生成目标359</span><br><span class="line">15.4.4 生成Makefile362</span><br><span class="line">15.5 版本控制系统364</span><br><span class="line">15.5.1 为什么需要版本控制364</span><br><span class="line">15.5.2 手工版本控制365</span><br><span class="line">15.5.3 自动化的版本控制366</span><br><span class="line">15.5.4 Unix的版本控制工具367</span><br><span class="line">15.6 运行期调试369</span><br><span class="line">15.7 性能分析370</span><br><span class="line">15.8 使用Emacs整合工具370</span><br><span class="line">15.8.1 Emacs和make371</span><br><span class="line">15.8.2 Emacs和运行期调试371</span><br><span class="line">15.8.3 Emacs和版本控制371</span><br><span class="line">15.8.4 Emacs和Profiling372</span><br><span class="line">15.8.5 像IDE一样，但更强373</span><br><span class="line">第16章 重用：论不要重新发明轮子375</span><br><span class="line">16.1 猪小兵的故事376</span><br><span class="line">16.2 透明性是重用的关键379</span><br><span class="line">16.3 从重用到开源380</span><br><span class="line">16.4 生命中最美好的就是“开放”381</span><br><span class="line">16.5 何处找384</span><br><span class="line">16.6 使用开源软件的问题385</span><br><span class="line">16.7 许可证问题386</span><br><span class="line">16.7.1 开放源码的资格386</span><br><span class="line">16.7.2 标准开放源码许可证388</span><br><span class="line">16.7.3 何时需要律师390</span><br><span class="line">PartⅣ391</span><br><span class="line">第17章 可移植性：软件可移植性与遵循标准393</span><br><span class="line">17.1 C语言的演化394</span><br><span class="line">17.1.1 早期的C语言395</span><br><span class="line">17.1.2 C语言标准396</span><br><span class="line">17.2 Unix标准398</span><br><span class="line">17.2.1 标准和Unix之战398</span><br><span class="line">17.2.2 庆功宴上的幽灵401</span><br><span class="line">17.2.3 开源世界的Unix标准402</span><br><span class="line">17.3 IETF和RFC标准化过程403</span><br><span class="line">17.4 规格DNA，代码RNA405</span><br><span class="line">17.5 可移植性编程408</span><br><span class="line">17.5.1 可移植性和编程语言选择409</span><br><span class="line">17.5.2 避免系统依赖性412</span><br><span class="line">17.5.3 移植工具413</span><br><span class="line">17.6 国际化413</span><br><span class="line">17.7 可移植性、开放标准以及开放源码414</span><br><span class="line">第18章 文档：向网络世界阐释代码417</span><br><span class="line">18.1 文档概念418</span><br><span class="line">18.2 Unix风格420</span><br><span class="line">18.2.1 大文档偏爱420</span><br><span class="line">18.2.2 文化风格421</span><br><span class="line">18.3 各种Unix文档格式422</span><br><span class="line">18.3.1 troff和Documenter’s Work bench Tools422</span><br><span class="line">18.3.2 TEX424</span><br><span class="line">18.3.3 Texinfo425</span><br><span class="line">18.3.4 POD425</span><br><span class="line">18.3.5 HTML426</span><br><span class="line">18.3.6 DocBook426</span><br><span class="line">18.4 当前的混乱和可能的出路426</span><br><span class="line">18.5 DocBook427</span><br><span class="line">18.5.1 文档类型定义427</span><br><span class="line">18.5.2 其它DTD428</span><br><span class="line">18.5.3 DocBook工具链429</span><br><span class="line">18.5.4 移植工具431</span><br><span class="line">18.5.5 编辑工具432</span><br><span class="line">18.5.6 相关标准和实践433</span><br><span class="line">18.5.7 SGML433</span><br><span class="line">18.5.8 XML—DocBook参考书籍433</span><br><span class="line">18.6 编写Unix文档的最佳实践434</span><br><span class="line">第19章 开放源码：在Unix新社区中编程437</span><br><span class="line">19.1 Unix和开放源码438</span><br><span class="line">19.2 与开源开发者协同工作的最佳实践440</span><br><span class="line">19.2.1 良好的修补实践440</span><br><span class="line">19.2.2 良好的项目、档案文件命名实践444</span><br><span class="line">19.2.3 良好的开发实践447</span><br><span class="line">19.2.4 良好的发行制作实践450</span><br><span class="line">19.2.5 良好的交流实践454</span><br><span class="line">19.3 许可证的逻辑：如何挑选456</span><br><span class="line">19.4 为什么应使用某个标准许可证457</span><br><span class="line">19.5 各种开源许可证457</span><br><span class="line">19.5.1 MIT或者Xconsortium许可证457</span><br><span class="line">19.5.2 经典BSD许可证457</span><br><span class="line">19.5.3 Artistic许可证458</span><br><span class="line">19.5.4 通用公共许可证458</span><br><span class="line">19.5.5 Mozilla公共许可证459</span><br><span class="line">第20章 未来：危机与机遇461</span><br><span class="line">20.1 Unix传统中的必然和偶然461</span><br><span class="line">20.2 Plang：未来之路464</span><br><span class="line">20.3 Unix设计中的问题466</span><br><span class="line">20.3.1 Unix文件就是一大袋字节466</span><br><span class="line">20.3.2 Unix对GUI的支持孱弱467</span><br><span class="line">20.3.3 文件删除不可撤销468</span><br><span class="line">20.3.4 Unix假定文件系统是静态的469</span><br><span class="line">20.3.5 作业控制设计拙劣469</span><br><span class="line">20.3.6 UnixAPI没有使用异常470</span><br><span class="line">20.3.7 ioctl（2）和fcntl（2）是个尴尬471</span><br><span class="line">20.3.8 Unix安全模型可能太过原始471</span><br><span class="line">20.3.9 Unix名字种类太多472</span><br><span class="line">20.3.10 文件系统可能有害论472</span><br><span class="line">20.3.11 朝向全局互联网地址空间472</span><br><span class="line">20.4 Unix的环境问题473</span><br><span class="line">20.5 Unix文化中的问题475</span><br><span class="line">20.6 信任的理由477</span><br><span class="line">附录A 缩写词表479</span><br><span class="line">附录B 参考文献483</span><br><span class="line">附录C 贡献者495</span><br><span class="line">附录D 无根的根：无名师的Unix心传499</span><br><span class="line">Colophon510</span><br><span class="line">索引511</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B008Z1IEQ8/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B008Z1IEQ8&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/517htLnDtsL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>unix</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript语言精粹(修订版)</title>
    <url>/2020/04/19/B0097CON2S/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： JavaScript语言精粹(修订版)<br>作者信息： 作者: 道格拉斯•克罗克福德 (Douglas Crockford) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《JavaScript语言精粹(修订版)》是介绍JavaScript语言本质的权威书籍，值得任何正在或准备从事JavaScript开发的人阅读，并且需要反复阅读。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">第1章精华1</span><br><span class="line">为什么要使用JavaScript2</span><br><span class="line">分析JavaScript2</span><br><span class="line">一个简单的试验场4</span><br><span class="line">第2章语法5</span><br><span class="line">空白5</span><br><span class="line">标识符6</span><br><span class="line">数字7</span><br><span class="line">字符串8</span><br><span class="line">语句10</span><br><span class="line">表达式15</span><br><span class="line">字面量18</span><br><span class="line">函数19</span><br><span class="line">第3章对象20</span><br><span class="line">对象字面量20</span><br><span class="line">检索21</span><br><span class="line">更新22</span><br><span class="line">引用22</span><br><span class="line">原型22</span><br><span class="line">反射23</span><br><span class="line">枚举24</span><br><span class="line">删除24</span><br><span class="line">减少全局变量污染25</span><br><span class="line">第4章函数26</span><br><span class="line">函数对象26</span><br><span class="line">函数字面量27</span><br><span class="line">调用27</span><br><span class="line">参数30</span><br><span class="line">返回31</span><br><span class="line">异常31</span><br><span class="line">扩充类型的功能32</span><br><span class="line">递归33</span><br><span class="line">作用域36</span><br><span class="line">闭包36</span><br><span class="line">回调39</span><br><span class="line">模块40</span><br><span class="line">级联42</span><br><span class="line">柯里化43</span><br><span class="line">记忆43</span><br><span class="line">第5章继承46</span><br><span class="line">伪类46</span><br><span class="line">对象说明符49</span><br><span class="line">原型50</span><br><span class="line">函数化51</span><br><span class="line">部件55</span><br><span class="line">第6章数组57</span><br><span class="line">数组字面量57</span><br><span class="line">长度58</span><br><span class="line">删除59</span><br><span class="line">枚举59</span><br><span class="line">容易混淆的地方60</span><br><span class="line">方法60</span><br><span class="line">指定初始值62</span><br><span class="line">第7章正则表达式64</span><br><span class="line">一个例子65</span><br><span class="line">结构69</span><br><span class="line">元素71</span><br><span class="line">第8章方法77</span><br><span class="line">Array77</span><br><span class="line">Function83</span><br><span class="line">Number84</span><br><span class="line">Object85</span><br><span class="line">RegExp86</span><br><span class="line">String88</span><br><span class="line">第9章代码风格94</span><br><span class="line">第10章优美的特性98</span><br><span class="line">附录A毒瘤101</span><br><span class="line">附录B糟粕109</span><br><span class="line">附录CJSLint115</span><br><span class="line">附录D语法图127</span><br><span class="line">附录EJSON138</span><br><span class="line">索引149</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0097CON2S/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0097CON2S&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51aFazQizgL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令行与shell脚本编程大全(第2版)</title>
    <url>/2020/04/19/B0096EXMS8/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Linux命令行与shell脚本编程大全(第2版)<br>作者信息： 作者: Richard Blum [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>美国Richard Blum、Christine Bresnahan编著的《Linux命令行与shell脚本编程大全(第2版)》是关于Linux命令行和shell命令的全面参考资料。秉承“大全”系列书籍的一贯优良品质，涵盖详尽的动手教程和实际应用中的实用信息，并提供相关参考信息和背景资料。书中内容共分为四部分27章，引领读者从Linux命令行基础入手，直到能写出自己的shell。    《Linux命令行与shell脚本编程大全(第2版)》内容全面，语言简练，示例丰富，适合于Linux系统管理员及Linux爱好者阅读参考。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分 Linux命令行</span><br><span class="line">第1章 初识Linuxshell</span><br><span class="line">1.1 什么是Linux</span><br><span class="line">1.1.1 深入探究Linux内核</span><br><span class="line">1.1.2 GNU工具链</span><br><span class="line">1.1.3 Linux桌面环境</span><br><span class="line">1.2 Linux发行版</span><br><span class="line">1.2.1 核心Linux发行版</span><br><span class="line">1.2.2 专业Linux发行版</span><br><span class="line">1.2.3 LinuxLiveCD</span><br><span class="line">1.3 小结</span><br><span class="line">第2章 走进shell</span><br><span class="line">2.1终端模拟</span><br><span class="line">2.1.1 图形功能</span><br><span class="line">2.1.2键盘</span><br><span class="line">2.2 terminf0数据库</span><br><span class="line">2.3 Linux控制台</span><br><span class="line">2.4 xterm终端</span><br><span class="line">2.4.1命令行参数</span><br><span class="line">2.4.2 xterm主菜单</span><br><span class="line">2.4.3 VT选项菜单</span><br><span class="line">2.4.4 VT字体菜单</span><br><span class="line">2.5 Konsole终端</span><br><span class="line">2.5.1命令行参数</span><br><span class="line">2.5.2标签式窗口会话</span><br><span class="line">2.5.3 配置文件</span><br><span class="line">2.5.4 菜单栏</span><br><span class="line">2.6 GNOME Terminal</span><br><span class="line">2.6.1命令行参数</span><br><span class="line">2.6.2标签</span><br><span class="line">2.6.3 菜单栏</span><br><span class="line">2.7小结</span><br><span class="line">第3章基本的bash shell命令</span><br><span class="line">3.1 启动shell</span><br><span class="line">3.2 shell提示符</span><br><span class="line">3.3 bash手册</span><br><span class="line">3.4浏览文件系统</span><br><span class="line">3.4.1 Linux文件系统</span><br><span class="line">3.4.2遍历目录</span><br><span class="line">3.5文件和目录列表</span><br><span class="line">3.5.1基本列表功能</span><br><span class="line">3.5.2修改输出信息</span><br><span class="line">3.5.3完整的参数列表</span><br><span class="line">3.5.4过滤输出列表</span><br><span class="line">3.6处理文件</span><br><span class="line">3.6.1 创建文件</span><br><span class="line">3.6.2 复制文件</span><br><span class="line">3.6.3链接文件</span><br><span class="line">3.6.4重命名文件</span><br><span class="line">3.6.5删除文件</span><br><span class="line">3.7处理目录</span><br><span class="line">3.7.1创建目录</span><br><span class="line">3.7.2删除目录</span><br><span class="line">3.8查看文件内容</span><br><span class="line">3.8.1 查看文件统计信息</span><br><span class="line">3.8.2查看文件类型</span><br><span class="line">3.8.3 查看整个文件</span><br><span class="line">3.8.4查看部分文件</span><br><span class="line">3.9小结</span><br><span class="line">……</span><br><span class="line">第4章 更多的bashshell命令</span><br><span class="line">第5章 使用Linux环境变量</span><br><span class="line">第6章 理解Linux文件权限</span><br><span class="line">第7章 管理文件系统</span><br><span class="line">第8章 安装软件程序</span><br><span class="line">第9章 使用编辑器</span><br><span class="line">第二部分 shell脚本编程基础</span><br><span class="line">第10章 构建基本脚本</span><br><span class="line">第11章 使用结构化命令</span><br><span class="line">第12章 更多的结构化命令</span><br><span class="line">第13章 处理用户输入</span><br><span class="line">第14章 呈现数据</span><br><span class="line">第15章 控制脚本</span><br><span class="line">第三部分 高级shell脚本编程</span><br><span class="line">第16章 创建函数</span><br><span class="line">第17章 图形化桌面上的脚本编程</span><br><span class="line">第18章 初识sed和gawk</span><br><span class="line">第19章 正则表达式</span><br><span class="line">第20章 sed进阶</span><br><span class="line">第21章 gawk进阶</span><br><span class="line">第22章 使用其他shell</span><br><span class="line">第四部分 高级shell脚本编程主题</span><br><span class="line">第23章 使用数据库</span><br><span class="line">第24章 使用Web</span><br><span class="line">第25章 使用E—mail</span><br><span class="line">第26章 编写脚本实用工具</span><br><span class="line">第27章 shell脚本编程进阶</span><br><span class="line">附录A bash命令快速指南</span><br><span class="line">附录B sed和gawk快速指南</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0096EXMS8/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0096EXMS8&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51JwarrwI%2BL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>互联网进化论</title>
    <url>/2020/04/19/B0098W2GWG/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 互联网进化论<br>作者信息： 作者: 刘锋 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《互联网进化论》可以帮助互联网爱好者全面了解互联网的发展历史、演化规律和未来趋势，也可以供云计算、物联网、移动互联网、科技哲学和神经学领域的研究者参考。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章关于互联网未来的三个疑问</span><br><span class="line">1.1互联网繁荣背后的待解之谜</span><br><span class="line">1.2互联网发展中隐含的启示</span><br><span class="line">1.3盘旋在哲学家头顶的神秘现象</span><br><span class="line">1.4各领域科学家的激烈讨论</span><br><span class="line">第2章互联网虚拟大脑</span><br><span class="line">2.1互联网虚拟大脑全景图</span><br><span class="line">2.2互联网视觉神经系统</span><br><span class="line">2.3互联网听觉神经系统</span><br><span class="line">2.4互联网躯体感觉神经系统</span><br><span class="line">2.5互联网运动神经系统</span><br><span class="line">2.6互联网自主神经系统</span><br><span class="line">2.7互联网中枢神经系统</span><br><span class="line">2.8互联网神经元</span><br><span class="line">2.9互联网神经纤维</span><br><span class="line">2.10互联网的神经反射弧</span><br><span class="line">第3章大脑中的互联网</span><br><span class="line">3.1人类研究大脑的历史</span><br><span class="line">3.2分歧的大脑研究方法</span><br><span class="line">3.3解开大脑之谜的互联网</span><br><span class="line">3.4大脑中的路由系统</span><br><span class="line">3.5大脑中的百度和谷歌</span><br><span class="line">3.6大脑中的微博</span><br><span class="line">3.7大脑中的ip地址</span><br><span class="line">3.8大脑中的维基百科</span><br><span class="line">3.9互联网神经学的提出</span><br><span class="line">第4章互联网纵览之化路线图</span><br><span class="line">4.1科技不断延长人类器官</span><br><span class="line">4.2互联网诞生前的准备工作</span><br><span class="line">4.3核战争威胁下的互联网诞生</span><br><span class="line">4.4互联网早期的应用</span><br><span class="line">4.5电子公告牌的功能分裂</span><br><span class="line">4.6互联网应用的第一次大融合</span><br><span class="line">4.7互联网类神经元的出现</span><br><span class="line">4.8互联网虚拟大脑的萌芽</span><br><span class="line">4.9从生命起源到智慧宇宙的19张图</span><br><span class="line">第5章互联网的商业模式</span><br><span class="line">5.1曾经的互联网霸主——门户网站</span><br><span class="line">5.2互联网上买卖商品——电子商务网站</span><br><span class="line">5.3互联网信息统治者——搜索引擎</span><br><span class="line">5.4在互联网上展示自我——博客</span><br><span class="line">5.5互联网的百科全书——wiki</span><br><span class="line">5.6互联网私人邮局——电子邮箱</span><br><span class="line">5.7虚拟世界的“红娘”——婚恋网站</span><br><span class="line">5.8高谈阔论的网上会场——bbs</span><br><span class="line">5.9联合起来做广告——广告联盟</span><br><span class="line">5.10互联网上以物易物——换客</span><br><span class="line">5.11互联网上的生活帮手——分类网站</span><br><span class="line">5.12共同推荐好新闻——掘客</span><br><span class="line">5.13各行业的引领者——行业门户网站</span><br><span class="line">5.14网上即时交流工具——im</span><br><span class="line">5.15帮你买便宜商品——比价网站</span><br><span class="line">5.16组团购物更省钱——团购网</span><br><span class="line">5.17维护交易安全——第三方支付</span><br><span class="line">5.18移动互联网的地理应用——lbs</span><br><span class="line">5.19捍卫互联网和平——网络安全</span><br><span class="line">5.20创新发动机——网络游戏</span><br><span class="line">5.21互联网职业中介——招聘网站</span><br><span class="line">5.22互联网中的虚拟社会——sns</span><br><span class="line">5.23智慧创造财富——威客网站</span><br><span class="line">第6章互联网纵览之技术要点</span><br><span class="line">6.1互联网的信息基础二进制</span><br><span class="line">6.2互联网的osi七层结构</span><br><span class="line">6.3互联网之父</span><br><span class="line">6.4html语言的发展史</span><br><span class="line">6.5互联网的记忆系统——数据库</span><br><span class="line">6.61p地址与mac地址的区别</span><br><span class="line">6.7互联网抗核打击的原因</span><br><span class="line">6.8物联网是互联网的一部分</span><br><span class="line">6.9云计算不是一片云</span><br><span class="line">6.10三网合一和四网合一</span><br><span class="line">6.11帮助记住网站的域名</span><br><span class="line">6.12互联网新人121——浏览器</span><br><span class="line">6.13互联网开放式平台的意义</span><br><span class="line">6.14移动互联网的巨大泡沫</span><br><span class="line">6.15黑客和病毒并不是噩梦</span><br><span class="line">6.16智慧地球与国家安全</span><br><span class="line">6.17充满争议的web2.0</span><br><span class="line">6.18互联网重要的操作系统</span><br><span class="line">6.19让互联网变慢的p2p技术</span><br><span class="line">6.20网站被用户同时访问的技术</span><br><span class="line">6.21网站建设的lamp体系</span><br><span class="line">6.22解决网站大访问量的方法</span><br><span class="line">第7章互联网进化的九条规律</span><br><span class="line">7.1连接规律：人脑离互联网越来越近</span><br><span class="line">7.2信用规律：让互联网背后的那条狗站出来</span><br><span class="line">7.3统一规律：大鱼吃小鱼的巨头世界</span><br><span class="line">7.4维度规律：从字符迈向三维虚拟世界</span><br><span class="line">7.5加速规律：我们将和互联网一起变聪明</span><br><span class="line">7.6膨胀规律：发生在互联网身上的大爆炸</span><br><span class="line">7.7消融规律：何处是虚拟，何处是真实</span><br><span class="line">7.8映射规律：互联网是现实世界的镜子</span><br><span class="line">7.9方向规律：互联网知道它的未来</span><br><span class="line">第8章互联网问答录——思考与哲学</span><br><span class="line">8.1互联网会成为人类的敌人吗</span><br><span class="line">8.2互联网与人类永生</span><br><span class="line">8.3“看不见的手”操控下的互联网进化</span><br><span class="line">8.4在互联网中诞生的新生命</span><br><span class="line">8.5黑暗森林与星际互联网</span><br><span class="line">8.6互联网带来的科学突破</span><br><span class="line">8.7互联网预示人类的未来</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0098W2GWG/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0098W2GWG&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51pDZ5TKZBL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据•互联网大规模数据挖掘与分布式处理</title>
    <url>/2020/04/19/B009HEK8SO/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 大数据•互联网大规模数据挖掘与分布式处理<br>作者信息： 作者: Anand Rajaraman [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《大数据•互联网大规模数据挖掘与分布式处理》由拉贾拉曼Anand Rajarama、厄尔曼Jeffrey David Ullman所著，主要关注极大规模数据的挖掘。由于重点强调数据的规模，所以《大数据•互联网大规模数据挖掘与分布式处理》的例子大都来自web本身或者web上导出的数据。另外，《大数据•互联网大规模数据挖掘与分布式处理》从算法的角度来看待数据挖掘，即数据挖掘是将算法应用于数据，而不是使用数据来“训练”某种类型的机器学习引擎。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章数据挖掘基本概念</span><br><span class="line">1.1数据挖掘的定义</span><br><span class="line">1.1.1统计建模</span><br><span class="line">1.1.2机器学习</span><br><span class="line">1.1.3建模的计算方法</span><br><span class="line">1.1.4数据汇总</span><br><span class="line">1.1.5特征抽取</span><br><span class="line">1.2数据挖掘的统计限制</span><br><span class="line">1.2.1整体情报预警</span><br><span class="line">1.2.2邦弗朗尼原理</span><br><span class="line">1.2.3邦弗朗尼原理的一个例子</span><br><span class="line">1.2.4习题</span><br><span class="line">1.3相关知识</span><br><span class="line">1.3.1词语在文档中的重要性</span><br><span class="line">1.3.2哈希函数</span><br><span class="line">1.3.3索引</span><br><span class="line">1,3.4二级存储器</span><br><span class="line">1.3.5自然对数的底e</span><br><span class="line">1.3.6幂定律</span><br><span class="line">1.3.7习题</span><br><span class="line">1.4本书概要</span><br><span class="line">1.5小结</span><br><span class="line">1.6参考文献</span><br><span class="line">第2章大规模文件系统及Map－RedUCe</span><br><span class="line">2.1分布式文件系统</span><br><span class="line">2.1.1计算节点的物理结构</span><br><span class="line">2.1.2大规模文件系统的结构</span><br><span class="line">2.2Map－Reduce</span><br><span class="line">2.2.1Map任务</span><br><span class="line">2.2.2分组和聚合</span><br><span class="line">2.2.3Reduce任务</span><br><span class="line">2.2.4组合器</span><br><span class="line">2.2.5Map－Reduce的执行细节</span><br><span class="line">2.2.6节点失效的处理</span><br><span class="line">2.3使用Map－Reduce的算法</span><br><span class="line">2.3.1基于Map－Reduce的矩阵－向量乘法实现</span><br><span class="line">2.3.2向量v无法放入内存时的处理</span><br><span class="line">2.3.3关系代数运算</span><br><span class="line">2.3.4基于Map－Reduce的选择运算</span><br><span class="line">2.3.5基于Map－Reduce的投影运算</span><br><span class="line">2.3.6基于Map－Reduce的并、交和差运算</span><br><span class="line">2.3.7基于Map－Reduce的自然连接运算</span><br><span class="line">2.3.8－般性的连接算法</span><br><span class="line">2.3.9基于Map－Reduce的分组和聚合运算</span><br><span class="line">2.3.10矩阵乘法</span><br><span class="line">2.3.11基于单步Map－Reduce的矩阵乘法</span><br><span class="line">2.3.12习题</span><br><span class="line">2.4Map－Reduce的扩展</span><br><span class="line">2.4.1工作流系统</span><br><span class="line">2.4.2Map－Reduce的递归扩展版本</span><br><span class="line">2.4.3Pregel系统</span><br><span class="line">2.4.4习题</span><br><span class="line">2.5集群计算算法的效率问题</span><br><span class="line">2,5.1集群计算的通信开销模型</span><br><span class="line">2.5.2实耗通信开销</span><br><span class="line">2.5.3多路连接</span><br><span class="line">2.5.4习题</span><br><span class="line">2.6小结</span><br><span class="line">2.7参考文献</span><br><span class="line">第3章相似项发现</span><br><span class="line">3.1近邻搜索的应用</span><br><span class="line">3.1.1集合的Jaccard相似度</span><br><span class="line">3.1.2文档的相似度</span><br><span class="line">3.1.3协同过滤——一个集合相似问题</span><br><span class="line">3.1.4习题</span><br><span class="line">3.2文档的shingling</span><br><span class="line">3.2.1k－Shingle</span><br><span class="line">3.2.2shingle大小的选择</span><br><span class="line">3.2.3对shingle进行哈希</span><br><span class="line">3.2.4基于词的shingle</span><br><span class="line">3.2.5习题</span><br><span class="line">3.3保持相似度的集合摘要表示</span><br><span class="line">3.3.1集合的矩阵表示</span><br><span class="line">3.3.2最小哈希</span><br><span class="line">3.3.3最小哈希及Jaccard相似度</span><br><span class="line">3.3.4最小哈希签名</span><br><span class="line">3.3.5最小哈希签名的计算</span><br><span class="line">3.3.6习题</span><br><span class="line">3.4文档的局部敏感哈希算法</span><br><span class="line">3.4.1面向最小哈希签名的LSH</span><br><span class="line">3.4.2行条化策略的分析</span><br><span class="line">3.4.3上述技术的综合</span><br><span class="line">3.4.4习题</span><br><span class="line">3.5距离测度</span><br><span class="line">3.5.1距离测度的定义</span><br><span class="line">3.5.2欧氏距离</span><br><span class="line">3.5.3Jaccard距离</span><br><span class="line">3.5.4余弦距离</span><br><span class="line">3.5.5编辑距离</span><br><span class="line">3.5.6海明距离</span><br><span class="line">3.5.7习题</span><br><span class="line">3.6局部敏感函数理论</span><br><span class="line">3.6.1局部敏感函数</span><br><span class="line">3.6.2面向Jaccard距离的局部敏感函数族</span><br><span class="line">3.6.3局部敏感函数族的放大处理</span><br><span class="line">3.6.4习题</span><br><span class="line">3.7面向其他距离测度的LSH函数族</span><br><span class="line">3.7.1面向海明距离的LSH函数族</span><br><span class="line">3.7.2随机超平面和余弦距离</span><br><span class="line">3.7.3梗概</span><br><span class="line">3.7.4面向欧氏距离的LSH函数族</span><br><span class="line">3.7.5面向欧氏空间的更多LSH函数族</span><br><span class="line">3.7.6习题</span><br><span class="line">3.8LSH函数的应用</span><br><span class="line">3.8.1实体关联</span><br><span class="line">3.8.2一个实体关联的例子</span><br><span class="line">3.8.3记录匹配的验证</span><br><span class="line">3.8.4指纹匹配</span><br><span class="line">3.8.5适用于指纹匹配的LSH函数族</span><br><span class="line">3.8.6相似新闻报道检测</span><br><span class="line">3.8.7习题</span><br><span class="line">3.9面向高相似度的方法</span><br><span class="line">3.9.1相等项发现</span><br><span class="line">3,9.2集合的字符串表示方法</span><br><span class="line">3.9.3基于长度的过滤～</span><br><span class="line">3.9.4前缀索引</span><br><span class="line">3.9.5位置信息的使用</span><br><span class="line">3.9.6使用位置和长度信息的索引</span><br><span class="line">3,9.7习题</span><br><span class="line">3.10小结</span><br><span class="line">3.11参考文献</span><br><span class="line">第4章数据流挖掘</span><br><span class="line">4.1流数据模型</span><br><span class="line">4.1.1一个数据流管理系统</span><br><span class="line">4.1.2流数据源的例子</span><br><span class="line">4.1.3流查询</span><br><span class="line">4.1.4流处理中的若干问题</span><br><span class="line">4.2流当中的数据抽样</span><br><span class="line">4.2.1一个富于启发性的例子</span><br><span class="line">4.2.2代表性样本的获取</span><br><span class="line">4.2.3一般的抽样问题</span><br><span class="line">4.2.4样本规模的变化</span><br><span class="line">4.2.5习题</span><br><span class="line">4.3流过滤</span><br><span class="line">4.3.1一个例子</span><br><span class="line">4.3,2布隆过滤器</span><br><span class="line">4.3.3布隆过滤方法的分析</span><br><span class="line">4.3.4习题</span><br><span class="line">4.4流中独立元素的数目统计</span><br><span class="line">4.4.1独立元素计数问题</span><br><span class="line">4,4.2FM算法</span><br><span class="line">4.4.3组合估计</span><br><span class="line">4.4.4空间需求</span><br><span class="line">4.4.5习题</span><br><span class="line">4.5矩估计</span><br><span class="line">4.5.1矩定义</span><br><span class="line">4.5.2二阶矩估计的AMS算法</span><br><span class="line">4.5.3AMS算法有效的原因</span><br><span class="line">4.5.4更高阶矩的估计</span><br><span class="line">4.5.5无限流的处理</span><br><span class="line">4.5.6习题</span><br><span class="line">4.6窗口内的计数问题</span><br><span class="line">4.6.1精确计数的开销</span><br><span class="line">4.6.2DGIM算法</span><br><span class="line">4.6.3DGIM算法的存储需求</span><br><span class="line">4.6.4DGIM算法中的查询应答</span><br><span class="line">4.6.5DGIM条件的保持</span><br><span class="line">4.6.6降低错误率</span><br><span class="line">4.6.7窗口内计数问题的扩展</span><br><span class="line">4.6.8习题</span><br><span class="line">4.7衰减窗口</span><br><span class="line">4.7.1最常见元素问题</span><br><span class="line">4.7.2衰减窗口的定义</span><br><span class="line">4.7.3最流行元素的发现</span><br><span class="line">4.8小结</span><br><span class="line">4.9参考文献</span><br><span class="line">第5章链接分析</span><br><span class="line">5.1PageRank</span><br><span class="line">5.1.1早期的搜索引擎及词项作弊</span><br><span class="line">5.1.2PageRank的定义</span><br><span class="line">5.1.3Web结构</span><br><span class="line">5.1.4避免终止点</span><br><span class="line">5.1.5采集器陷阱及“抽税”法</span><br><span class="line">5.1.6PageRank在搜索引擎中的使用</span><br><span class="line">5.1.7习题</span><br><span class="line">5.2PageRank的快速计算</span><br><span class="line">5.2.1转移矩阵的表示</span><br><span class="line">5.2.2基于Map－Reduce的PageRank迭代计算</span><br><span class="line">5.2.3结果向量合并时的组合器使用</span><br><span class="line">5.2.4转移矩阵中块的表示</span><br><span class="line">5.2.5其他高效的PageRank迭代方法</span><br><span class="line">5.2.6习题</span><br><span class="line">5.3面向主题的PageRank</span><br><span class="line">5.3.1动机</span><br><span class="line">5.3.2有偏的随机游走模型</span><br><span class="line">5.3.3面向主题的PageRank的使用</span><br><span class="line">5.3.4基于词汇的主题推断</span><br><span class="line">5.3.5习题</span><br><span class="line">5.4链接作弊</span><br><span class="line">5.4.1垃圾农场的架构</span><br><span class="line">5.4.2垃圾农场的分析</span><br><span class="line">5.4.3与链接作弊的斗争</span><br><span class="line">5.4.4TrustRank</span><br><span class="line">5.4.5垃圾质量</span><br><span class="line">5.4.6习题</span><br><span class="line">5.5导航页和权威页</span><br><span class="line">5.5.1HITS的直观意义</span><br><span class="line">5.5.2导航度和权威度的形式化</span><br><span class="line">5.5.3习题</span><br><span class="line">5.6小结</span><br><span class="line">5.7参考文献</span><br><span class="line">第6章频繁项集</span><br><span class="line">6.1购物篮模型</span><br><span class="line">6.1.1频繁项集的定义</span><br><span class="line">6.1.2频繁项集的应用</span><br><span class="line">6.1.3关联规则</span><br><span class="line">6.1.4高可信度关联规则的发现</span><br><span class="line">6.1.5习题</span><br><span class="line">6.2购物篮及A－Priori算法</span><br><span class="line">6.2.1购物篮数据的表示</span><br><span class="line">6.2.2项集计数中的内存使用</span><br><span class="line">6.2.3项集的单调性</span><br><span class="line">6.2.4二元组计数</span><br><span class="line">6.2.5A－Priori算法</span><br><span class="line">6.2.6所有频繁项集上的A－Priori算法</span><br><span class="line">6.2.7习题</span><br><span class="line">6.3更大数据集在内存中的处理</span><br><span class="line">6.3.1PCY算法</span><br><span class="line">6.3.2多阶段算法</span><br><span class="line">6.3.3多哈希算法</span><br><span class="line">6.3.4习题</span><br><span class="line">6.4有限扫描算法</span><br><span class="line">6.4.1简单的随机化算法</span><br><span class="line">6.4.2抽样算法中的错误规避</span><br><span class="line">6.4.3SON算法</span><br><span class="line">6.4.4SON算法和Map－Reduce</span><br><span class="line">6.4.5Toivonen算法</span><br><span class="line">6.4.6Toivonen算法的有效性分析</span><br><span class="line">6.4.7习题</span><br><span class="line">6.5流中的频繁项计数</span><br><span class="line">6.5.1流的抽样方法</span><br><span class="line">6.5.2衰减窗口中的频繁项集</span><br><span class="line">6.5.3混合方法</span><br><span class="line">6.5.4习题</span><br><span class="line">6.6小结</span><br><span class="line">6.7参考文献</span><br><span class="line">第7章聚类</span><br><span class="line">7.1聚类技术介绍</span><br><span class="line">7.1.1点、空间和距离</span><br><span class="line">7.1.2聚类策略</span><br><span class="line">7.1.3维数灾难</span><br><span class="line">7.1.4习题</span><br><span class="line">7.2层次聚类</span><br><span class="line">7.2.1欧氏空间下的层次聚类</span><br><span class="line">7.2.2层次聚类算法的效率</span><br><span class="line">7.2.3控制层次聚类的其他规则</span><br><span class="line">7.2.4非欧空间下的层次聚类</span><br><span class="line">7.2.5习题</span><br><span class="line">7.3k－均值算法</span><br><span class="line">7.3.1k－均值算法基本知识</span><br><span class="line">7.3.2k－均值算法的簇初始化</span><br><span class="line">7.3.3选择七的正确值</span><br><span class="line">7.3.4BFR算法</span><br><span class="line">7.3.5BFR算法中的数据处理</span><br><span class="line">7.3.6习题</span><br><span class="line">7.4CURE算法</span><br><span class="line">7.4.1CURE算法的初始化</span><br><span class="line">7.4.2CURE算法的完成</span><br><span class="line">7.4.3习题</span><br><span class="line">7.5非欧空间下的聚类</span><br><span class="line">7.5.1GRGPF算法中的簇表示</span><br><span class="line">7.5.2簇表示树的初始化</span><br><span class="line">7.5.3GRGPF算法中的点加入</span><br><span class="line">7.5.4簇的分裂及合并</span><br><span class="line">7.5.5习题</span><br><span class="line">7.6流聚类及并行化</span><br><span class="line">7.6.1流计算模型</span><br><span class="line">7.6.2－个流聚类算法</span><br><span class="line">7.6.3桶的初始化</span><br><span class="line">7.6.4桶合并</span><br><span class="line">7.6.5查询应答</span><br><span class="line">7.6.6并行环境下的聚类</span><br><span class="line">7.6.7习题</span><br><span class="line">7.7小结</span><br><span class="line">7.8参考文献</span><br><span class="line">第8章Web广告</span><br><span class="line">8.1在线广告相关问题</span><br><span class="line">8.1.1广告机会</span><br><span class="line">8.1.2直投广告</span><br><span class="line">8.1.3展示广告的相关问题</span><br><span class="line">8.2在线算法</span><br><span class="line">8.2.1在线和离线算法</span><br><span class="line">8.2.2贪心算法</span><br><span class="line">8.2.3竞争率</span><br><span class="line">8.2.4习题</span><br><span class="line">8.3广告匹配问题</span><br><span class="line">8.3.1匹配及完美匹配</span><br><span class="line">8.3.2最大匹配贪心算法</span><br><span class="line">8.3.3贪心匹配算法的竞争率</span><br><span class="line">8.3.4习题</span><br><span class="line">8.4Adwords问题</span><br><span class="line">8.4.1搜索广告的历史</span><br><span class="line">8.4.2Adwords问题的定义</span><br><span class="line">8.4.3Adwords问题的贪心方法</span><br><span class="line">8.4.4Balance算法</span><br><span class="line">8.4.5Balance算法竞争率的一个下界</span><br><span class="line">8.4.6多投标者的Balance算法</span><br><span class="line">8.4.7－般性的Balance算法</span><br><span class="line">8.4.8Adwords问题的最后论述</span><br><span class="line">8.4.9习题</span><br><span class="line">8.5Adwords的实现</span><br><span class="line">8.5.1投标和搜索查询的匹配</span><br><span class="line">8.5.2更复杂的匹配问题</span><br><span class="line">8.5.3文档和投标之间的匹配算法</span><br><span class="line">8.6小结</span><br><span class="line">8.7参考文献</span><br><span class="line">第9章推荐系统</span><br><span class="line">9.1一个推荐系统的模型</span><br><span class="line">9.1.1效用矩阵</span><br><span class="line">9.1.2长尾现象</span><br><span class="line">9.1.3推荐系统的应用</span><br><span class="line">9.1.4效用矩阵的填充</span><br><span class="line">9.2基于内容的推荐</span><br><span class="line">9.2.1项模型</span><br><span class="line">9.2.2文档的特征发现</span><br><span class="line">9.2.3基于Tag的项特征获取</span><br><span class="line">9.2.4项模型的表示</span><br><span class="line">9.2.5用户模型</span><br><span class="line">9.2.6基于内容的项推荐</span><br><span class="line">9.2.7分类算法</span><br><span class="line">9.2.8习题</span><br><span class="line">9.3协同过滤</span><br><span class="line">9.3.1相似度计算</span><br><span class="line">9.3.2相似度对偶性</span><br><span class="line">9.3.3用户聚类和项聚类</span><br><span class="line">9.3.4习题</span><br><span class="line">9.4降维处理</span><br><span class="line">9.4.1UrV分解</span><br><span class="line">9.4.2RMSE</span><br><span class="line">9.4.3UV分解的增量式计算</span><br><span class="line">9.4.4对任一元素的优化</span><br><span class="line">9.4.5一个完整UV分解算法的构建</span><br><span class="line">9.4.6习题</span><br><span class="line">9.5NetFlix竞赛</span><br><span class="line">9.6小结</span><br><span class="line">9.7参考文献</span><br><span class="line">索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B009HEK8SO/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B009HEK8SO&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51YAi81tuvL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据时代 生活、工作与思维的大变革}</title>
    <url>/2020/04/19/B00AIG0PGK/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 大数据时代 生活、工作与思维的大变革}<br>作者信息： 作者: 维克托•迈尔-舍恩伯格 (Viktor Mayer-Schönberger) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《大数据时代:生活、工作与思维的大变革》为迄今为止全世界最好的一本大数据专著。作者维克托•迈尔-舍恩伯格，大数据时代的预言家，《科学》《自然》等著名学术期刊最推崇的互联网研究者之一，拥有在哈佛大学、牛津大学、耶鲁大学和新加坡国立大学等多个互联网研究重镇任教的经历。《大数据时代:生活、工作与思维的大变革》的译者系我国最年轻有为的大数据专家，电子科技大学互联网科学中心主任、教授、博士生导师周涛教授。这位27岁的天才型教授，数年来一直带领我国学术界在大数据研究上向国际一流看齐。宽带资本董事长田溯宁，微软全球资深副总裁、微软亚太研发集团主席张亚勤，中国互联网发展重要参与者、知名IT评论人谢文，北京云基地首席顾问、云华时代智能科技有限公司董事长郭昕，上海交通大学长江学者特聘教授、致远学院常务副院长汪小帆，中国传媒大学教授沈浩，清华大学计算机科学与技术系副主任、教授陈文光，中国社科院信息化研究中心秘书长、《互联网周刊》主编姜奇平，《财经》杂志执行主编、《哈佛商业评论》中文版主编何刚、微软亚洲研究院主管研究员谢幸等重磅推荐。大数据将为人类的生活创造前所未有的可量化的维度。大数据已经成为了新发明和新服务的源泉，而更多的改变正蓄势待发。书中展示了谷歌、微软、亚马逊、IBM、苹果、facebook、twitter、VISA等大数据先锋们最具价值的应用案例。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">推荐序一拥抱“大数据时代”</span><br><span class="line">宽带资本董事长田溯宁</span><br><span class="line">推荐序二实实在在大数据</span><br><span class="line">中国互联网发展的重要参与者，知名IT评论人谢文</span><br><span class="line">译者序在路上·晃晃悠悠</span><br><span class="line">电子科技大学教授，互联网科学中心主任周涛</span><br><span class="line">引言一场生活、工作与思维的大变革</span><br><span class="line">大数据，变革公共卫生</span><br><span class="line">大数据，变革商业</span><br><span class="line">大数据，变革思维</span><br><span class="line">大数据，开启重大的时代转型</span><br><span class="line">预测，大数据的核心</span><br><span class="line">大数据，大挑战</span><br><span class="line">第一部分大数据时代的思维变革</span><br><span class="line">第1章更多：不是随机样本，而是全体数据</span><br><span class="line">让数据“发声”</span><br><span class="line">小数据时代的随机采样，最少的数据获得最多的信息</span><br><span class="line">全数据模式，样本&#x3D;总体</span><br><span class="line">第2章更杂：不是精确性，而是混杂性</span><br><span class="line">允许不精确</span><br><span class="line">大数据的简单算法比小数据的复杂算法更有效</span><br><span class="line">纷繁的数据越多越好</span><br><span class="line">混杂性，不是竭力避免，而是标准途径</span><br><span class="line">新的数据库设计的诞生</span><br><span class="line">第3章更好：不是因果关系，而是相关关系</span><br><span class="line">关联物，预测的关键</span><br><span class="line">“是什么”，而不是“为什么”</span><br><span class="line">改变，从操作方式开始</span><br><span class="line">大数据，改变人类探索世界的方法</span><br><span class="line">第二部分大数据时代的商业变革</span><br><span class="line">第4章数据化：一切皆可“量化”</span><br><span class="line">数据，从最不可能的地方提取出来</span><br><span class="line">数据化，不是数字化</span><br><span class="line">量化一切，数据化的核心</span><br><span class="line">当文字变成数据</span><br><span class="line">当方位变成数据</span><br><span class="line">当沟通成为数据</span><br><span class="line">一切事物的数据化</span><br><span class="line">第5章价值：“取之不尽，用之不竭”的数据创新</span><br><span class="line">数据创新1：数据的再利用</span><br><span class="line">数据创新2：重组数据</span><br><span class="line">数据创新3：可扩展数据</span><br><span class="line">数据创新4：数据的折旧值</span><br><span class="line">数据创新5：数据废气</span><br><span class="line">数据创新6：开放数据</span><br><span class="line">给数据估值</span><br><span class="line">第6章角色定位：数据、技术与思维的三足鼎立</span><br><span class="line">大数据价值链的3大构成</span><br><span class="line">大数据掌控公司</span><br><span class="line">大数据技术公司</span><br><span class="line">大数据思维公司和个人</span><br><span class="line">全新的数据中间商</span><br><span class="line">专家的消亡与数据科学家的崛起</span><br><span class="line">大数据，决定企业的竞争力</span><br><span class="line">第三部分大数据时代的管理变革</span><br><span class="line">第7章风险：让数据主宰一切的隐忧</span><br><span class="line">无处不在的“第三只眼”</span><br><span class="line">我们的隐私被二次利用了</span><br><span class="line">预测与惩罚，不是因为所做，而是因为“将做”</span><br><span class="line">数据独裁</span><br><span class="line">挣脱大数据的困境</span><br><span class="line">第8章掌控：责任与自由并举的信息管理</span><br><span class="line">管理变革1：个人隐私保护，从个人许可到让数据使用者承担责任</span><br><span class="line">管理变革2：个人动因VS预测分析</span><br><span class="line">管理变革3：击碎黑盒子，大数据程序员的崛起</span><br><span class="line">管理变革4：反数据垄断大亨</span><br><span class="line">结语正在发生的未来</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00AIG0PGK/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00AIG0PGK&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/5139zWUomYL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title>移动浪潮 移动智能如何改变世界</title>
    <url>/2020/04/19/B00ASTRHSG/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 移动浪潮 移动智能如何改变世界<br>作者信息： 作者: 迈克尔•塞勒 (Michael Saylor) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《移动浪潮:移动智能如何改变世界》的作者认为，移动技术和社交网络的合力将在未来10年提升世界50%国家的国内生产总值。它们的影响力将不断增强，并将最终改变商业、工业以及整个经济。移动浪潮来袭，如果没有做好冲浪的准备，那么你将会被一场从根本上改变世界的巨变卷走。不论你是普通个人，还是商业领袖、公众人物，《移动浪潮》都能为你提供指引，帮助你移动智能浪潮来临之时如何引领新的世界。《移动浪潮:移动智能如何改变世界》荣登亚马逊、《纽约时报》总榜前10名超级畅销书榜 ，堪比奈斯比特《大趋势》、托夫勒《未来的冲击》、《第三次浪潮》。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">推荐序</span><br><span class="line">中文版序</span><br><span class="line">1浪潮：移动的力量</span><br><span class="line">移动计算技术史无前例006</span><br><span class="line">全球通用的电脑007</span><br><span class="line">用软件代替实物产品008</span><br><span class="line">将软件植入客户010</span><br><span class="line">软件本质的改变—从固态到气态011</span><br><span class="line">颠覆性变革即将到来012</span><br><span class="line">网络空间的业务经营之道015</span><br><span class="line">加速的信息革命018</span><br><span class="line">2电脑：向移动技术演变</span><br><span class="line">第一次浪潮：大型电脑024</span><br><span class="line">第二次浪潮：小型电脑028</span><br><span class="line">第三次浪潮：台式电脑029</span><br><span class="line">第四次浪潮：互联网个人电脑031</span><br><span class="line">移动技术发展之路033</span><br><span class="line">移动电话：从蜂窝到黑莓034</span><br><span class="line">第五次浪潮：移动互联网036</span><br><span class="line">多点触控039</span><br><span class="line">3纸张：正在消失</span><br><span class="line">从黏土到纸张051</span><br><span class="line">古登堡和复制革命054</span><br><span class="line">信息时代056</span><br><span class="line">古登堡之后第一大突破创新：桌面出版057</span><br><span class="line">新的地图058</span><br><span class="line">从写字板到神奇的平板电脑060</span><br><span class="line">新型书店065</span><br><span class="line">新型图书馆068</span><br><span class="line">世界图书馆071</span><br><span class="line">新型报纸074</span><br><span class="line">新型杂志：特色出版物的黄金时代？080</span><br><span class="line">无纸化办公082</span><br><span class="line">拯救空气083</span><br><span class="line">4娱乐：如此自由自在</span><br><span class="line">相机的消失088</span><br><span class="line">游戏：开放的游乐场090</span><br><span class="line">电影：DVD的衰败096</span><br><span class="line">移动电视098</span><br><span class="line">新型的共享媒体100</span><br><span class="line">电视和广告：一个截然不同的世界101</span><br><span class="line">5钱包：智能货币就要到来了</span><br><span class="line">无线射频技术：条形码就要过时了108</span><br><span class="line">新一代身份证：天衣无缝109</span><br><span class="line">超级安全的移动钥匙113</span><br><span class="line">现金已经过时了116</span><br><span class="line">信用卡122</span><br><span class="line">新型银行：一个真正的大苹果125</span><br><span class="line">折扣卡：不仅仅是团购128</span><br><span class="line">让抢劫不再发生133</span><br><span class="line">6社交网络：一个移动的社交世界</span><br><span class="line">超大型城市的崛起144</span><br><span class="line">社交网络的崛起147</span><br><span class="line">社交网络的演变150</span><br><span class="line">7医疗：全球医疗迎来新景象</span><br><span class="line">纸质病历档案：浩如烟海170</span><br><span class="line">远程医疗175</span><br><span class="line">医院就是网络179</span><br><span class="line">聋哑人和失明者的移动帮手181</span><br><span class="line">全球医疗182</span><br><span class="line">第三世界的普罗米修斯185</span><br><span class="line">8教育：人人都可以平等地接受教育</span><br><span class="line">新型教科书199</span><br><span class="line">主动学习和虚拟世界202</span><br><span class="line">数字办公室204</span><br><span class="line">讲台上的诺贝尔奖得主206</span><br><span class="line">“平板电脑老师”207</span><br><span class="line">一对一学习模式208</span><br><span class="line">让大学学费不再增长210</span><br><span class="line">全球教育213</span><br><span class="line">9发展中世界：移动浪潮最合适的实验场</span><br><span class="line">移动互联网：即时的互联网基础设施223</span><br><span class="line">移动技术将提高市场效率224</span><br><span class="line">移动技术将削减中间成本227</span><br><span class="line">移动技术让金融服务唾手可得229</span><br><span class="line">移动技术消除腐败234</span><br><span class="line">新型全球化237</span><br><span class="line">移动技术释放后发优势239</span><br><span class="line">10新世界：解放人类能量</span><br><span class="line">农业革命：从旷野到城市246</span><br><span class="line">工业革命：从农村到工厂247</span><br><span class="line">重新分配人类能量250</span><br><span class="line">信息革命：信息无所不在253</span><br><span class="line">信息革命的经济意义258</span><br><span class="line">变化即将到来262</span><br><span class="line">新世界的隐私权263</span><br><span class="line">新世界，新规则267</span><br><span class="line">结语269</span><br><span class="line">译后记273</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00ASTRHSG/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00ASTRHSG&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/411WEerIStL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出数据分析</title>
    <url>/2020/04/19/B00A3XYY2E/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 深入浅出数据分析<br>作者信息： 作者: 迈克尔•米尔顿 (Michael Milton) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《深入浅出数据分析》构思跌宕起伏，行文妙趣横生，无论读者是职场老手，还是业界新人；无论是字斟句酌，还是信手翻阅，都能跟着文字在职场中走上几回，体味数据分析领域的乐趣与挑战。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">序言I</span><br><span class="line">1数据分析引言：分解数据1</span><br><span class="line">2实验：检验你的理论37</span><br><span class="line">3最优化：寻找最大值75</span><br><span class="line">4数据图形化：图形让你更精明111</span><br><span class="line">5假设检验：假设并非如此139</span><br><span class="line">6贝叶斯统计：穿越第一关169</span><br><span class="line">7主观概率：信念数字化191</span><br><span class="line">8启发法：凭人类的天性作分析225</span><br><span class="line">9直方图：数字的形状251</span><br><span class="line">10回归：预测279</span><br><span class="line">11误差：合理误差315</span><br><span class="line">12相关数据库：你能关联吗？359</span><br><span class="line">13整理数据：井然有序385</span><br><span class="line">附录A尾声：正文未及的十大要诀417</span><br><span class="line">附录B安装R：启动R！427</span><br><span class="line">附录C安装Excel分析工具：ToolPak431</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00A3XYY2E/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00A3XYY2E&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/516JKow5PmL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title>R和Ruby数据分析之旅</title>
    <url>/2020/04/19/B00BLZMF5Q/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： R和Ruby数据分析之旅<br>作者信息： 作者: 郑兆雄 (Sau Sheong Chang) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>如果你对万事万物的运行方式充满好奇，《R和Ruby数据分析之旅》会帮你找到日常生活中某些问题的真正答案。借助基本的数学方法，并使用Ruby和R语言做一些简单的编程工作，你就能学会如何对问题建模，并找出解决方案。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 握住探险之鞭—认识Ruby</span><br><span class="line">1.1 Ruby</span><br><span class="line">1.1.1 为什么用Ruby</span><br><span class="line">1.1.2 安装Ruby</span><br><span class="line">1.1.3 运行Ruby</span><br><span class="line">1.1.4 引用外部库</span><br><span class="line">1.1.5 Ruby基础</span><br><span class="line">1.1.6 一切皆对象</span><br><span class="line">1.2 Shoes</span><br><span class="line">1.2.1 何为Shoes</span><br><span class="line">1.2.2 五彩的“鞋子”（Shoes）</span><br><span class="line">1.2.3 安装Shoes</span><br><span class="line">1.2.4 编写Shoes程序</span><br><span class="line">1.3 小结</span><br><span class="line">第2章 走进《黑客帝国》—认识R</span><br><span class="line">2.1 R的简介</span><br><span class="line">2.2 使用R</span><br><span class="line">2.2.1 R控制台</span><br><span class="line">2.2.2 源文件与命令行</span><br><span class="line">2.2.3 程序包</span><br><span class="line">2.3 R编程</span><br><span class="line">2.3.1 变量和函数</span><br><span class="line">2.3.2 条件语句与循环</span><br><span class="line">2.3.3 数据结构</span><br><span class="line">2.3.4 导入数据</span><br><span class="line">2.4 作图</span><br><span class="line">2.4.1 基本绘图</span><br><span class="line">2.4.2 ggplot2简介</span><br><span class="line">2.5 小结</span><br><span class="line">第3章 探讨办公室与卫生间问题</span><br><span class="line">3.1 简单的情形</span><br><span class="line">3.2 表示卫生间等事物</span><br><span class="line">3.3 初次模拟</span><br><span class="line">3.4 解释数据</span><br><span class="line">3.5 第二次模拟</span><br><span class="line">3.6 第三次模拟</span><br><span class="line">3.7 最后一个模拟</span><br><span class="line">3.8 小结</span><br><span class="line">第4章 当一回经济学家</span><br><span class="line">4.1 看不见的手</span><br><span class="line">4.2 一个简单的市场经济体系</span><br><span class="line">4.2.1 生产者</span><br><span class="line">4.2.2 消费者</span><br><span class="line">4.2.3 一些使程序简化的方法</span><br><span class="line">4.2.4 模拟</span><br><span class="line">4.2.5 分析模拟结果</span><br><span class="line">4.3 价格决定的资源分配</span><br><span class="line">4.3.1 生产者</span><br><span class="line">4.3.2 消费者</span><br><span class="line">4.3.3 市场</span><br><span class="line">4.3.4 模拟</span><br><span class="line">4.3.5 分析第二个模拟的结果</span><br><span class="line">4.3.6 价格控制</span><br><span class="line">4.4 小结</span><br><span class="line">第5章 对自己的电子邮件进行挖掘</span><br><span class="line">5.1 思想</span><br><span class="line">5.2 抓取和解析</span><br><span class="line">5.3 对电子邮件进行挖掘</span><br><span class="line">5.3.1 每月同一天的邮件数量</span><br><span class="line">5.3.2 邮件挖掘者</span><br><span class="line">5.3.3 每周同一天的邮件数量</span><br><span class="line">5.3.4 每月的邮件数量</span><br><span class="line">5.3.5 一天各小时的邮件数量</span><br><span class="line">5.3.6 交互</span><br><span class="line">5.3.7 交互中的比较</span><br><span class="line">5.4 文本挖掘</span><br><span class="line">5.5 小结</span><br><span class="line">第6章 测一测我们的心脏</span><br><span class="line">6.1 跳动的心脏</span><br><span class="line">6.2 听诊</span><br><span class="line">6.2.1 自制数字听诊器</span><br><span class="line">6.2.2 从声音中提取数据</span><br><span class="line">6.2.3 生成心音波形</span><br><span class="line">6.2.4 找出心率</span><br><span class="line">6.3 血氧定量法</span><br><span class="line">6.3.1 自制脉搏血氧计</span><br><span class="line">6.3.2 从视频中提取信息</span><br><span class="line">6.3.3 生成心跳波形并计算心率</span><br><span class="line">6.4 小结</span><br><span class="line">第7章 模拟结群飞行的鸟</span><br><span class="line">7.1 Boids的由来</span><br><span class="line">7.2 模拟</span><br><span class="line">7.3 Roid</span><br><span class="line">7.4 boid群的规则</span><br><span class="line">7.5 辅助规则</span><br><span class="line">7.6 规则的变更</span><br><span class="line">7.7 绕圈</span><br><span class="line">7.8 加入障碍物</span><br><span class="line">7.9 小结</span><br><span class="line">第8章 是什么让世界运行不止</span><br><span class="line">8.1 生活很美好</span><br><span class="line">8.2 金钱</span><br><span class="line">8.3 性别</span><br><span class="line">8.3.1 生与死</span><br><span class="line">8.3.2 变化</span><br><span class="line">8.4 进化</span><br><span class="line">8.4.1 我们将做哪些改变</span><br><span class="line">8.4.2 实现</span><br><span class="line">8.5 小结</span><br><span class="line">关于作者</span><br><span class="line">封面介绍</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00BLZMF5Q/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00BLZMF5Q&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51%2BzgyqCV7L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>ruby</tag>
      </tags>
  </entry>
  <entry>
    <title>腾云 云计算和大数据时代网络技术揭秘</title>
    <url>/2020/04/19/B00C0ZBWD2/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 腾云 云计算和大数据时代网络技术揭秘<br>作者信息： 作者: 徐立冰 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>国内第一本云计算网络书云计算与大数据时代，网络技术人员必看！“弯曲评论”网站“拨云见日”系列热文加量10倍的强烈之书首次完整呈现。云计算时代，网络面临怎样的挑战？大数据之下，网络设计应着眼何处？虚拟化的最后1000米你该如何冲刺？OpenFlow、FCoE、LISP、FabricPath、VN-Tag、VPLS、VXLAN……当所有这一切结合到一起，你将面临怎样的情形？是时候，重新设计互联网亚嵌特聘首席科学家、“弯曲评论”创办人陈怀临、Net130大版主、重磅畅销书《大话存储》作者冬瓜头、《网络世界》总编辑张群英合力推荐！</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分 缘起篇</span><br><span class="line">第1章 云计算的兴起 2</span><br><span class="line">1.1 云计算的身世 2</span><br><span class="line">1.1.1 “上古”时期，摩尔定律刚起步 2</span><br><span class="line">1.1.2 从互联网大爆炸中诞生 4</span><br><span class="line">1.1.3 接棒Amazon 6</span><br><span class="line">1.1.4 百花齐放的年代 7</span><br><span class="line">1.2 云计算的DNA 8</span><br><span class="line">1.3 云计算的五大特征 10</span><br><span class="line">1.3.1 自助式服务 10</span><br><span class="line">1.3.2 通过网络分发服务 11</span><br><span class="line">1.3.3 资源池化 12</span><br><span class="line">1.3.4 资源的灵活调度 12</span><br><span class="line">1.3.5 可衡量的服务 13</span><br><span class="line">1.4 IaaS&#x2F;PaaS&#x2F;SaaS，它们都是什么 13</span><br><span class="line">1.4.1 位于最底层，基础架构即服务——IaaS 14</span><br><span class="line">1.4.2 IaaS之上，平台即服务——PaaS 15</span><br><span class="line">1.4.3 最上层，软件即服务——SaaS 15</span><br><span class="line">1.5 各种云——私有云／社区云／公有云／混合云 15</span><br><span class="line">1.5.1 私有云 16</span><br><span class="line">1.5.2 公有云 16</span><br><span class="line">1.5.3 社区云 16</span><br><span class="line">1.5.4 混合云 17</span><br><span class="line">1.6 云计算的独有优势 18</span><br><span class="line">1.6.1 降低成本 18</span><br><span class="line">1.6.2 扩展性 18</span><br><span class="line">1.6.3 高可靠性 19</span><br><span class="line">1.6.4 远程访问 20</span><br><span class="line">1.6.5 模块化 20</span><br><span class="line">1.6.6 高等级服务 21</span><br><span class="line">第2章 云与网的关系 22</span><br><span class="line">2.1 以数据中心为界，云计算网络的外延与内涵 22</span><br><span class="line">2.2 外延——关注用户体验 24</span><br><span class="line">2.2.1 可靠的网络 24</span><br><span class="line">2.2.2 安全的网络 25</span><br><span class="line">2.2.3 灵活的网络 25</span><br><span class="line">2.3 内涵——关注系统效率，下一代数据中心的网络平台 25</span><br><span class="line">第二部分 外延篇</span><br><span class="line">第3章 安全的网络通道（一）——网络准入 28</span><br><span class="line">3.1 为什么安全是云计算的基础 28</span><br><span class="line">3.2 云计算安全的发展现状 29</span><br><span class="line">3.3 网络在云计算安全防护中扮演的角色 30</span><br><span class="line">3.4 网络准入的技术分类 31</span><br><span class="line">3.4.1 二层准入 33</span><br><span class="line">3.4.2 三层准入 36</span><br><span class="line">3.4.3 客户端方式 39</span><br><span class="line">3.5 二层准入vs.三层准入vs.客户端方式 40</span><br><span class="line">3.5.1 二层准入的特点——成熟、实用 40</span><br><span class="line">3.5.2 三层准入的特点——轻便、简单 42</span><br><span class="line">3.5.3 客户端方式的特点——功能全面、无统一标准 44</span><br><span class="line">3.6 最终用户需要什么样的方案 45</span><br><span class="line">3.7 IT部门需要什么样的方案 46</span><br><span class="line">3.8 什么是完美的产品 46</span><br><span class="line">3.9 虚拟桌面的机会 47</span><br><span class="line">第4章 安全的网络通道（二）——网络加密 48</span><br><span class="line">4.1 通过VPN隧道保证云计算的数据安全 48</span><br><span class="line">4.2 VPN技术选择——SSLPKIPsec 49</span><br><span class="line">4.3 让SSL胜出的独门绝技 51</span><br><span class="line">4.4 SSL的技术实现 51</span><br><span class="line">4.4.1 SSL握手协议 52</span><br><span class="line">4.4.2 SSL记录协议 53</span><br><span class="line">4.5 几种SSLVPN类型 54</span><br><span class="line">4.6 SSL的后续发展——DTLS&#x2F;TLS 55</span><br><span class="line">第5章 可靠的网络通道 57</span><br><span class="line">5.1 云服务的用户体验与网络服务质量 57</span><br><span class="line">5.2 为更好服务，先对云计算流量进行分类 58</span><br><span class="line">5.3 不同流量分类不同服务质量的设计方法 59</span><br><span class="line">5.3.1 流量识别 60</span><br><span class="line">5.3.2 流量标记 61</span><br><span class="line">5.3.3 流量处理 65</span><br><span class="line">第6章 灵活的网络通道 66</span><br><span class="line">6.1 移动性是云计算网络的基本特征 66</span><br><span class="line">6.2 现有解决方案一——DNS重定向 67</span><br><span class="line">6.3 现有解决方案二——健康路由注入 70</span><br><span class="line">6.4 对现有方案的改进——用LISP将位置与身份分离 71</span><br><span class="line">6.5 LISP的核心思想——Map—and—encap 72</span><br><span class="line">6.6 LISP的基本架构 73</span><br><span class="line">6.7 LISP的新包头 74</span><br><span class="line">6.8 通过LISP—ALT实现可扩展网络 75</span><br><span class="line">6.9 一个LISP转发实例 76</span><br><span class="line">6.10 LISP的应用场景 77</span><br><span class="line">6.10.1 IP终端的灵活移动 77</span><br><span class="line">6.10.2 IPv6—IPv4混合部署 79</span><br><span class="line">6.10.3 多租户VPN环境 80</span><br><span class="line">6.11 我们真的需要LISP吗 81</span><br><span class="line">第三部分 内涵篇</span><br><span class="line">第7章 支持虚拟化数据中心的扩张——TRILL&#x2F;FabricPath和SPB 84</span><br><span class="line">7.1 二层网络的困境 84</span><br><span class="line">7.2 为什么传统二层网络不给力 87</span><br><span class="line">7.3 FabricPath的目标 89</span><br><span class="line">7.4 FabricPath的实现：新的控制平面 89</span><br><span class="line">7.4.1 新增一个二层帧头 89</span><br><span class="line">7.4.2 增加一套简化的IS—IS路由协议 90</span><br><span class="line">7.5 第一个问题——为什么需要新的地址空间 90</span><br><span class="line">7.6 FabricPath的工作模式 91</span><br><span class="line">7.7 第二个问题——现有技术不足够吗 92</span><br><span class="line">7.8 TRILL——FabricPath的公开标准 93</span><br><span class="line">7.9 另一个TRILL——SPB 95</span><br><span class="line">7.10 TRILLvs.SPB 98</span><br><span class="line">第8章 利用以太传输存储流量——FCoE 102</span><br><span class="line">8.1 存储与网络的关系 102</span><br><span class="line">8.2 传统存储网络面临的挑战——布线与能耗 103</span><br><span class="line">8.3 融合！FCoE给出的解决方案 105</span><br><span class="line">8.4 FCoE的基本面 105</span><br><span class="line">8.5 给以太网动手术——FCoE的数据平面 107</span><br><span class="line">8.5.1 PFC——不丢包以太网 107</span><br><span class="line">8.5.2 ETS——灵活带宽调度 110</span><br><span class="line">8.5.3 DCBX——与现有环境的兼容性 112</span><br><span class="line">8.6 连接两个世界的FIP——FCoE的控制平面 113</span><br><span class="line">8.6.1 FCoEVLAN发现 115</span><br><span class="line">8.6.2 FLOGI注册和FPMA 115</span><br><span class="line">8.7 典型的FCoE网络架构 117</span><br><span class="line">8.8 FCoE架构中的两种设备类型 118</span><br><span class="line">8.8.1 终结FCoE流量的设备——ENode 118</span><br><span class="line">8.8.2 转发FCoE流量的交换机——FCF 119</span><br><span class="line">8.9 FCoE的演化——四种多跳FCoE方案 120</span><br><span class="line">8.9.1 纯以太网模式 120</span><br><span class="line">8.9.2 FIPSnooping模式 122</span><br><span class="line">8.9.3 NPV模式 125</span><br><span class="line">8.9.4 VE_Port互联模式 126</span><br><span class="line">8.10 一个FCoE数据帧的转发过程 127</span><br><span class="line">8.11 FCoE的标准化与市场化进程 129</span><br><span class="line">8.12 iSCSI行不行？非FCoE不可吗 130</span><br><span class="line">第9章 连接虚拟机的交换机 133</span><br><span class="line">9.1 为什么虚拟化数据中心需要一台新的交换机 133</span><br><span class="line">9.2 仅仅在服务器内部实现简单交换是不够的 136</span><br><span class="line">9.2.1 软件VEB 136</span><br><span class="line">9.2.2 硬件VEB 137</span><br><span class="line">9.3 识别特定虚拟机的流量——用VN—Tag为虚拟机打上网络标签 138</span><br><span class="line">9.4 一个VN—Tag交换实例 142</span><br><span class="line">9.5 基于VN—Tag的新一代网络设备 145</span><br><span class="line">9.5.1 VN—Tag网卡 145</span><br><span class="line">9.5.2 VN—Tag交换机 147</span><br><span class="line">9.5.3 操作系统支持 148</span><br><span class="line">9.6 VN—Tag之外的选择——VEPA 148</span><br><span class="line">9.6.1 标准版VEPA 148</span><br><span class="line">9.6.2 增强版VEPA 149</span><br><span class="line">9.7 VEPA交换机扫描 151</span><br><span class="line">9.7.1 HP5900 151</span><br><span class="line">9.7.2 JuniperQFabric 152</span><br><span class="line">9.7.3 JuniperEX4500和EX8200 152</span><br><span class="line">9.7.4 ExtremeSummitX670 153</span><br><span class="line">9.8 VN—Tag与VEPA的交锋 154</span><br><span class="line">第10章 虚拟化的最后一公里——虚拟化网卡 158</span><br><span class="line">10.1 补齐虚拟化的最后一公里 158</span><br><span class="line">10.2 什么是虚拟化网卡 161</span><br><span class="line">10.2.1 什么是虚拟接入 161</span><br><span class="line">10.2.2 什么是虚拟通道 161</span><br><span class="line">10.3 利用SR—IOV实现虚拟化网卡 162</span><br><span class="line">10.4 SR—IOV的实践者——Palo 163</span><br><span class="line">10.5 将SR—IOV带入现实的辅助技术 165</span><br><span class="line">10.6 更加彻底的虚拟化——MR—IOV 166</span><br><span class="line">10.7 后面的故事 168</span><br><span class="line">第11章 数据中心互联设计——更广泛的二层网络 169</span><br><span class="line">11.1 数据中心二层互联的需求 169</span><br><span class="line">11.2 通过VPLS实现互联 171</span><br><span class="line">11.3 一个VPLS转发实例 173</span><br><span class="line">11.4 VPLS的限制 175</span><br><span class="line">11.4.1 缺乏对局域网的优化 175</span><br><span class="line">11.4.2 依赖运营商资源 176</span><br><span class="line">11.4.3 配置复杂 176</span><br><span class="line">11.5 通过OTV（上层传输虚拟化）实现互联 176</span><br><span class="line">11.5.1 OTV的数据平面 177</span><br><span class="line">11.5.2 OTV的控制平面 177</span><br><span class="line">11.6 OTV对二层协议的优化 179</span><br><span class="line">11.7 OTV对三层网关的优化 180</span><br><span class="line">11.8 OTV环境下的多接入和流量负载均衡 180</span><br><span class="line">11.9 LISPvs.VPLS 181</span><br><span class="line">11.10 LISP与OTV的关系 183</span><br><span class="line">第12章 自定义网络——OpenFlow与SDN 184</span><br><span class="line">12.1 通过软件定义网络——SDN 184</span><br><span class="line">12.2 实验室中走出的OpenFlow 186</span><br><span class="line">12.3 OpenFlow的系统模型 189</span><br><span class="line">12.4 OpenFlow交换机基本组成 192</span><br><span class="line">12.5 两种OpenFlow交换机 193</span><br><span class="line">12.5.1 OpenFlow专用交换机 193</span><br><span class="line">12.5.2 OpenFlow兼容型交换机 194</span><br><span class="line">12.6 OpenFlow中央控制器 195</span><br><span class="line">12.6.1 控制器的主动工作模式 196</span><br><span class="line">12.6.2 控制器的被动工作模式 197</span><br><span class="line">12.7 一个OpenFlow实例 197</span><br><span class="line">12.8 构建标准化的网络设计标准——OF—Config 199</span><br><span class="line">12.8.1 OF—Config解决的问题 199</span><br><span class="line">12.8.2 OF—Config的功能描述 199</span><br><span class="line">12.9 认识一下OpenFlow的近亲 201</span><br><span class="line">12.9.1 分布式转发模块化交换机 201</span><br><span class="line">12.9.2 远端板卡 202</span><br><span class="line">12.9.3 Nexus1000v 203</span><br><span class="line">12.9.4 OpenvSwitch 204</span><br><span class="line">12.9.5 EEM 204</span><br><span class="line">12.10 Google的OpenFlow实践 206</span><br><span class="line">12.11 网络厂家的SDN战略 208</span><br><span class="line">12.11.1 NEC的OpenFlow战略 209</span><br><span class="line">12.11.2 HP的OpenFlow战略 209</span><br><span class="line">12.11.3 Juniper的OpenFlow战略 210</span><br><span class="line">12.11.4 Nicira的OpenFlow战略 210</span><br><span class="line">12.11.5 Cisco的OpenFlow战略 211</span><br><span class="line">12.12 SDN&#x2F;OpenFlow的前景 213</span><br><span class="line">第13章 更大的云——VXLAN 217</span><br><span class="line">13.1 VXLAN要解决的问题 217</span><br><span class="line">13.2 VXLAN的新头部 219</span><br><span class="line">13.3 VXLAN的数据平面——隧道机制 220</span><br><span class="line">13.3.1 隧道机制减小对现网的改动 221</span><br><span class="line">13.3.2 隧道机制对快速变更的支持 221</span><br><span class="line">13.4 VXLAN的控制平面——改进的二层协议 221</span><br><span class="line">13.5 纯VXLAN部署场景 223</span><br><span class="line">13.6 VXLAN与非VXLAN混合部署 224</span><br><span class="line">13.7 一个VXLAN转发实例 225</span><br><span class="line">13.7.1 第一阶段——ARP请求 226</span><br><span class="line">13.7.2 第二阶段——数据传输 226</span><br><span class="line">13.8 VXLAN、OTV、LISP，它们都有什么关系 227</span><br><span class="line">13.9 Microsoft的算盘——NVGRE 228</span><br><span class="line">第14章 桌面虚拟化网络漫谈 230</span><br><span class="line">14.1 桌面虚拟化的前身——远程桌面 230</span><br><span class="line">14.2 虚拟桌面的诞生 231</span><br><span class="line">14.3 虚拟桌面是怎样工作的 232</span><br><span class="line">14.3.1 集中托管方式 232</span><br><span class="line">14.3.2 远程同步方式 233</span><br><span class="line">14.4 虚拟桌面的客户端类型 234</span><br><span class="line">14.4.1 零客户端虚拟桌面 234</span><br><span class="line">14.4.2 瘦客户端虚拟桌面 235</span><br><span class="line">14.4.3 胖客户端虚拟桌面 235</span><br><span class="line">14.5 一个典型的虚拟桌面后台架构 235</span><br><span class="line">14.6 决定虚拟桌面的成败——用网络替代VGA线缆 237</span><br><span class="line">14.7 虚拟桌面的核心网络技术——网络显示协议 238</span><br><span class="line">14.8 网络显示协议三大要素 239</span><br><span class="line">14.8.1 网络资源 239</span><br><span class="line">14.8.2 用户体验 240</span><br><span class="line">14.8.3 CPU占用率 240</span><br><span class="line">14.9 显示协议——兵家必争之地 240</span><br><span class="line">14.10 老牌显示协议——RDP 241</span><br><span class="line">14.11 显示协议的王者——HDX&#x2F;ICA 244</span><br><span class="line">14.12 后起之秀——PCoIP 245</span><br><span class="line">14.13 HDXvs.RDPvs.PCoIP，谁主沉浮 248</span><br><span class="line">第15章 大数据网络设计要点 251</span><br><span class="line">15.1 大数据的产生 251</span><br><span class="line">15.2 全新的大数据 253</span><br><span class="line">15.3 MapReduce的原理 254</span><br><span class="line">15.4 MapReduce的业务流程 254</span><br><span class="line">15.5 写入数据过程中的网络流量模型 255</span><br><span class="line">15.6 MapReduce算法过程中的网络流量模型 255</span><br><span class="line">15.6.1 Map过程 256</span><br><span class="line">15.6.2 Shuffle过程 256</span><br><span class="line">15.6.3 Reduce过程 257</span><br><span class="line">15.6.4 OutPut过程 257</span><br><span class="line">15.7 读取数据过程中的网络流量模型 257</span><br><span class="line">15.8 MapReduce网络模型综述 257</span><br><span class="line">第四部分 基石篇</span><br><span class="line">第16章 怎样将服务器接入网络 260</span><br><span class="line">16.1 ToR（柜顶接入）和EoR（列头接入） 260</span><br><span class="line">16.2 从增加一台服务器到增加一个机柜的服务器 262</span><br><span class="line">16.3 鱼与熊掌不可兼得？ 263</span><br><span class="line">16.4 Cisco的提案——FEX远端板卡 265</span><br><span class="line">16.5 Juniper的尝试——QFabric 267</span><br><span class="line">第17章 VOQ解密 270</span><br><span class="line">17.1 头端阻塞是实现DCE交换机的障碍 270</span><br><span class="line">17.2 利用VOQ防止头端阻塞 271</span><br><span class="line">17.3 针对组播的VOQ设计 273</span><br><span class="line">17.4 VOQ的产业化发展 273</span><br><span class="line">第18章 刀片服务器网络 275</span><br><span class="line">18.1 刀片服务器渊源 275</span><br><span class="line">18.2 刀片服务器同传统ToR接入的区别 276</span><br><span class="line">18.3 把握刀片服务器的网络设计 278</span><br><span class="line">18.3.1 直通模块 278</span><br><span class="line">18.3.2 交换模块 279</span><br><span class="line">18.3.3 集中接入模式 281</span><br><span class="line">第19章 千兆不够，要万兆！ 283</span><br><span class="line">19.1 千兆到万兆的质变 283</span><br><span class="line">19.1.1 万兆网络是FCoE的基础 283</span><br><span class="line">19.1.2 更高的传输效率 285</span><br><span class="line">19.1.3 助推虚拟化 287</span><br><span class="line">19.2 万兆以太网标准现状 288</span><br><span class="line">19.3 盘点万兆以太网交换机 289</span><br><span class="line">19.3.1 CiscoCatalyst6500 289</span><br><span class="line">19.3.2 CiscoNexus7000 290</span><br><span class="line">19.3.3 H3C12500 291</span><br><span class="line">19.3.4 H3C10500 291</span><br><span class="line">19.3.5 JuniperQFabric 292</span><br><span class="line">19.3.6 华为CloudEngine12800 292</span><br><span class="line">19.3.7 DELLForce10E1200i 293</span><br><span class="line">19.3.8 BrocadeBigIronRX 294</span><br><span class="line">19.3.9 ExtremeX8 294</span><br><span class="line">19.3.10 Arista7500 295</span><br><span class="line">19.3.11 AVAYA8800 295</span><br><span class="line">19.3.12 Alcatel—LucentOmniSwitch10K 296</span><br><span class="line">19.3.13 锐捷RG—S12000 297</span><br><span class="line">后记 298</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00C0ZBWD2/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00C0ZBWD2&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51UOyne98DL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>3D打印 从想象到现实</title>
    <url>/2020/04/19/B00BTCPBUC/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 3D打印 从想象到现实<br>作者信息： 作者: 胡迪•利普森 (Hod Lipson) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《3D打印:从想象到现实》向你揭开了3D打印神秘面纱：让传统制造瞬间过时，规模经济的铁律从此被打破跨越虚拟世界与实体世界的鸿沟，一场产品制造和设计的革命即将开始，它将颠覆我们的物理世界。一场产品制造的革命、设计的革命、材料的革命、生物的革命、知识产权的革命即将由3D打印引爆。3D打印技术的远大前景即将展开：跨越虚拟世界与实体世界的鸿沟；规模经济的铁律从此被打破；3D打印将把人工智能从计算机拓展到现实世界，机器人将成为过去时……在中国：3D打印概念股横空出世，万众瞩目；各大媒体集中、热烈报道；工信部、科技部纷纷制定政策推动3D打印产业化。3D打印机与当今发达的数字技术相结合，再加上互联网的普及以及微小而成本低廉的电子电路的广泛使用，技术和社会革新由此爆发。全球第一本全面讲述3D打印的作品，3D打印风靡全球，第三次工业革命的序幕拉开了！</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">推荐序一 XI</span><br><span class="line">推荐序二 XIII</span><br><span class="line">推荐序三 XVII</span><br><span class="line">前言 XXI</span><br><span class="line">第1章 这是科幻吗，不，它将成为现实 001</span><br><span class="line">第2章 一台几乎可造万物的机器 009</span><br><span class="line">打印三维物体：哈利•波特的魔杖复活了 014</span><br><span class="line">走向数字化和模拟化：跨越虚拟世界和实体世界的鸿沟 017</span><br><span class="line">“请把我的鞋子传真过来”：3D打印机能做到 021</span><br><span class="line">3D打印的十大优势 023</span><br><span class="line">第3章 灵活制造：既好，又快，还省 029</span><br><span class="line">兼具大规模生产和手工生产的特征 033</span><br><span class="line">更快：从设计到产品交付的时间缩短了 036</span><br><span class="line">更便宜：降低产品开发成本 038</span><br><span class="line">更好：生产出最佳的定制部件 039</span><br><span class="line">按大小对市场进行排列：中国仅占8.5% 040</span><br><span class="line">21世纪的空白画布 041</span><br><span class="line">研究杀手级应用程序 045</span><br><span class="line">轮胎也可以打印了 046</span><br><span class="line">第4章 3D打印的赚钱之道 051</span><br><span class="line">云制造：像蚂蚁工厂 054</span><br><span class="line">创客运动 056</span><br><span class="line">体验经济 058</span><br><span class="line">MakerBot公司 059</span><br><span class="line">Shapeways公司 061</span><br><span class="line">100kGarages公司 063</span><br><span class="line">打印产品有经济效益吗 064</span><br><span class="line">从零起点到规模化生产：3D打印兼职也可做到 065</span><br><span class="line">FabApp：就像iPhone应用程序一样 066</span><br><span class="line">连续定制和产品多样性 067</span><br><span class="line">性和娱乐 068</span><br><span class="line">微型金融和微型工厂 069</span><br><span class="line">第5章 3D打印机是如何打印的 071</span><br><span class="line">基本打印制造过程 073</span><br><span class="line">3D打印机的两大家族 076</span><br><span class="line">喷射、挤压或喷雾打印机 076</span><br><span class="line">融合、凝固、黏合式打印机 080</span><br><span class="line">整理设计文件 085</span><br><span class="line">后处理：3D打印的最后工序 088</span><br><span class="line">3D打印催生原材料革命 089</span><br><span class="line">第6章 设计软件：只要你能想到，就能设计和打印 093</span><br><span class="line">从绘图文字处理器到AutoCAD 095</span><br><span class="line">设计软件：以数字化的方式呈现物理世界 097</span><br><span class="line">让一切皆为可能：设计软件与3D打印的结合 100</span><br><span class="line">设计机器零件：实体建模CAD 102</span><br><span class="line">绘制屏幕上的字符：3D计算机图形软件 103</span><br><span class="line">编辑物理世界就像编辑照片一样 104</span><br><span class="line">设计软件的未来 106</span><br><span class="line">把设计的东西完美打印出来 108</span><br><span class="line">STL：目前的标准 109</span><br><span class="line">增材制造：新标准 109</span><br><span class="line">下一代的设计软件：数字化捕捉 110</span><br><span class="line">第7章 “活墨”生物打印：人体器官可以打印了 113</span><br><span class="line">3D打印：让你一夜之间年轻20岁 115</span><br><span class="line">3D打印生命阶梯 117</span><br><span class="line">组织工程学：3D打印干细胞 121</span><br><span class="line">干细胞、生物墨与生物纸：3D打印活细胞 123</span><br><span class="line">打印活性软骨 125</span><br><span class="line">打印心脏瓣膜 127</span><br><span class="line">我们能设计、打印自己的身体吗 130</span><br><span class="line">打印人造身体部位 133</span><br><span class="line">生物打印的未来 134</span><br><span class="line">第8章 3D打印时代的数字厨房 139</span><br><span class="line">数字烹饪：一场烹饪革命 142</span><br><span class="line">打印汉堡包、肉饼和番茄酱 146</span><br><span class="line">食品打印关键在分辨率 148</span><br><span class="line">打印的饼干里面竟然有图案 150</span><br><span class="line">疯狂科学家公司：他们成功了 152</span><br><span class="line">自身量化饮食：你再也不用担心糖尿病和肥胖症了 154</span><br><span class="line">打印的食品不仅仅是加工食品 156</span><br><span class="line">从加工食品到合成食品 159</span><br><span class="line">3D打印杀手级应用程序 162</span><br><span class="line">第9章 教室里的工厂：3D打印颠覆传统教育方式 163</span><br><span class="line">边做边学：孩子们的工程学 166</span><br><span class="line">从高中阶段说开去 170</span><br><span class="line">学习应该是令人愉快的 173</span><br><span class="line">考试分数与动手能力 175</span><br><span class="line">忘记学习方式 176</span><br><span class="line">3D打印让学生不再遗忘 177</span><br><span class="line">触觉教学：课堂教育的新革命 179</span><br><span class="line">课堂教育如何应用3D打印 182</span><br><span class="line">3D打印未来的课堂 184</span><br><span class="line">第10章 美好的世界：3D打印时代的审美标准 187</span><br><span class="line">计算机：如同大自然造物者 190</span><br><span class="line">3D打印：让你脚上的鞋子舒适无比 195</span><br><span class="line">获取生物数据：打印最优化产品 199</span><br><span class="line">响应智能设计 202</span><br><span class="line">用3D打印机打印建筑物 205</span><br><span class="line">机器人设计师 209</span><br><span class="line">第11章 3D打印：让制造业不再有污染 211</span><br><span class="line">两个塑料玩具的故事 216</span><br><span class="line">更绿色环保的制造 218</span><br><span class="line">低碳制造：3D打印能做到 218</span><br><span class="line">高效能零部件打印：喷气式客机也能打印 220</span><br><span class="line">制造过程清洁化 221</span><br><span class="line">3D打印的垃圾站更清洁、更美妙 222</span><br><span class="line">变废为宝：绿色环保打印 224</span><br><span class="line">3D打印如何既环保又不浪费 228</span><br><span class="line">第12章 当武器和毒品也能打印、知识产权彻底失效时 231</span><br><span class="line">打印武器、毒品和假冒伪劣产品 234</span><br><span class="line">打印特制药物 236</span><br><span class="line">3D打印时代消费者如何保护自身安全 238</span><br><span class="line">3D打印时代的知识产权 239</span><br><span class="line">商标 242</span><br><span class="line">著作权 242</span><br><span class="line">专利 244</span><br><span class="line">数字版权 245</span><br><span class="line">难道知识产权和专利保护过时了 246</span><br><span class="line">RepRap打印机：改变商业模式 246</span><br><span class="line">开源硬件：21世纪的专利制度 250</span><br><span class="line">微专利 252</span><br><span class="line">3D打印迫切需要法律保护 253</span><br><span class="line">第13章 用3D打印设计你的未来 255</span><br><span class="line">格雷伯爵茶 257</span><br><span class="line">史蒂夫•乔布斯：“计算机是我们大脑中的自行车” 259</span><br><span class="line">3D打印视觉设计：从游戏中获得灵感 259</span><br><span class="line">物质编译器：让3D打印设计变得如此简单 263</span><br><span class="line">交互式设计：和计算机交流设计想法 265</span><br><span class="line">形式语言：设计师与计算机无缝协同工作 268</span><br><span class="line">食谱式设计 270</span><br><span class="line">生长式设计 271</span><br><span class="line">反应蓝图：复杂形状的自动化生产 272</span><br><span class="line">一种设计生产多种定制产品 273</span><br><span class="line">会思考的打印机 274</span><br><span class="line">改变设计工具的形状 275</span><br><span class="line">第14章 3D打印的下一篇章 277</span><br><span class="line">3D打印的三个篇章 281</span><br><span class="line">多元材料的混合制造 282</span><br><span class="line">活性系统打印：打印完整的机器人 286</span><br><span class="line">最后的篇章：从模拟到数字 290</span><br><span class="line">模拟—数字混合打印 294</span><br><span class="line">机器制造机器的时代 295</span><br><span class="line">译后记 297</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00BTCPBUC/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00BTCPBUC&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/519pRgyFAhL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘与R语言</title>
    <url>/2020/04/19/B00CFCNEJ0/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 数据挖掘与R语言<br>作者信息： 作者: 托尔戈 (Luis Torgo) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《计算机科学丛书:数据挖掘与R语言》的支持网站给出了案例研究的所有代码、数据集以及R函数包，不要求读者具有R、数据挖掘或统计技术的基础知识。《计算机科学丛书:数据挖掘与R语言》利用大量给出必要步骤、代码和数据的具体案例，详细描述了数据挖掘的主要过程和技术。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">出版者的话</span><br><span class="line">推荐序</span><br><span class="line">中文版序</span><br><span class="line">译者序</span><br><span class="line">前言</span><br><span class="line">致谢</span><br><span class="line">第1章简介</span><br><span class="line">1.1如何阅读本书</span><br><span class="line">1.2R简介</span><br><span class="line">1.2.1R起步</span><br><span class="line">1.2.2R对象</span><br><span class="line">1.2.3向量</span><br><span class="line">1.2.4向量化</span><br><span class="line">1.2.5因子</span><br><span class="line">1.2.6生成序列</span><br><span class="line">1.2.7数据子集</span><br><span class="line">1.2.8矩阵和数组</span><br><span class="line">1.2.9列表</span><br><span class="line">1.2.10数据框</span><br><span class="line">1.2.11构建新函数</span><br><span class="line">1.2.12对象、类和方法</span><br><span class="line">1.2.13管理R会话</span><br><span class="line">1.3MySQL简介</span><br><span class="line">第2章预测海藻数量</span><br><span class="line">2.1问题描述与目标</span><br><span class="line">2.2数据说明</span><br><span class="line">2.3数据加载到R</span><br><span class="line">2.4数据可视化和摘要</span><br><span class="line">2.5数据缺失</span><br><span class="line">2.5.1将缺失部分剔除</span><br><span class="line">2.5.2用最高频率值来填补缺失值</span><br><span class="line">2.5.3通过变量的相关关系来填补缺失值</span><br><span class="line">2.5.4通过探索案例之间的相似性来填补缺失值</span><br><span class="line">2.6获取预测模型</span><br><span class="line">2.6.1多元线性回归</span><br><span class="line">2.6.2回归树</span><br><span class="line">2.7模型的评价和选择</span><br><span class="line">2.8预测7类海藻的频率</span><br><span class="line">2.9小结</span><br><span class="line">第3章预测股票市场收益</span><br><span class="line">3.1问题描述与目标</span><br><span class="line">3.2可用的数据</span><br><span class="line">3.21在R中处理与时间有关的数据</span><br><span class="line">3.22从CSV文件读取数据</span><br><span class="line">3.23从网站上获取数据</span><br><span class="line">3.24从MySQL数据库读取数据</span><br><span class="line">3.3定义预测任务</span><br><span class="line">3.3.1预测什么</span><br><span class="line">3.3.2预测变量是什么</span><br><span class="line">3.3.3预测任务</span><br><span class="line">3.3.4模型评价准则</span><br><span class="line">3.4预测模型</span><br><span class="line">3.4.1如何应用训练集数据来建模</span><br><span class="line">3.4.2建模工具</span><br><span class="line">3.5从预测到实践</span><br><span class="line">3.5.1如何应用预测模型</span><br><span class="line">3.5.2与交易相关的评价准则</span><br><span class="line">3.5.3模型集成：仿真交易</span><br><span class="line">3.6模型评价和选择</span><br><span class="line">3.6.1蒙特卡罗估计</span><br><span class="line">3.6.2实验比较</span><br><span class="line">3.6.3结果分析</span><br><span class="line">3.7交易系统</span><br><span class="line">3.7.1评估最终测试数据</span><br><span class="line">3.7.2在线交易系统</span><br><span class="line">3.8小结</span><br><span class="line">第4章侦测欺诈交易</span><br><span class="line">4.1问题描述与目标</span><br><span class="line">4.2可用的数据</span><br><span class="line">4.2.1加载数据至R</span><br><span class="line">4.2.2探索数据集</span><br><span class="line">4.2.3数据问题</span><br><span class="line">4.3定义数据挖掘任务</span><br><span class="line">4.3.1问题的不同解决方法</span><br><span class="line">4.3.2评价准则</span><br><span class="line">4.3.3实验方法</span><br><span class="line">4.4计算离群值的排序</span><br><span class="line">4.4.1无监督方法</span><br><span class="line">4.4.2有监督方法</span><br><span class="line">4.4.3半监督方法</span><br><span class="line">4.5小结</span><br><span class="line">第5章微阵列样本分类</span><br><span class="line">5.1问题描述与目标</span><br><span class="line">5.1.1微阵列实验背景简介</span><br><span class="line">5.1.2数据集ALL</span><br><span class="line">5.2可用的数据</span><br><span class="line">5.3基因（特征）选择</span><br><span class="line">5.3.1基于分布特征的简单过滤方法</span><br><span class="line">5.3.2 ANOVA过滤</span><br><span class="line">5.3.3用随机森林进行过滤</span><br><span class="line">5.3.4用特征聚类的组合进行过滤</span><br><span class="line">5.4遗传学异常的预测</span><br><span class="line">5.4.1定义预测任务</span><br><span class="line">5.4.2模型评价标准</span><br><span class="line">5.4.3实验过程</span><br><span class="line">5.4.4建模技术</span><br><span class="line">5.4.5模型比较</span><br><span class="line">5.5小结</span><br><span class="line">参考文献</span><br><span class="line">主题索引</span><br><span class="line">数据挖掘术语索引</span><br><span class="line">R函数索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00CFCNEJ0/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00CFCNEJ0&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51BfRlqoCuL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>r语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows内核原理与实现</title>
    <url>/2020/04/19/B00CRKN9T0/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Windows内核原理与实现<br>作者信息： 作者: 潘爱民 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>潘爱民编著的《Windows内核原理与实现》从操作系统原理角度组织材料，深度解析了Windows内核如何实现现代操作系统的各个关键部件，并直接以Windows核源代码(WRK， Windows Research Kernel)为参照。在内容选取方面，侧重Windows核中基本的系统部件，同时也兼顾作为一个操作系统的完整性。在讲解代码实现的同时并未局限于代码本身，而是着重阐述了Windows内核中运用的算法和机制。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章  概述 1</span><br><span class="line">1.1  操作系统基础 2</span><br><span class="line">1.1.1  计算机系统的硬件资源管理 2</span><br><span class="line">1.1.2  为应用程序提供执行环境 5</span><br><span class="line">1.2  学习操作系统之必备知识 7</span><br><span class="line">1.3  Windows操作系统发展历史 9</span><br><span class="line">1.4  Windows内核的版本 11</span><br><span class="line">1.5  操作系统的研究与发展 13</span><br><span class="line">1.6  本章总结 16</span><br><span class="line">第2章  Windows系统总述 17</span><br><span class="line">2.1  现代操作系统的基本结构 17</span><br><span class="line">2.2  Windows系统结构 18</span><br><span class="line">2.2.1  Windows内核结构 20</span><br><span class="line">2.2.2  Windows内核中的关键组件 22</span><br><span class="line">2.2.3  Windows子系统 29</span><br><span class="line">2.2.4  系统线程和系统进程 32</span><br><span class="line">2.3  关于Windows研究内核 34</span><br><span class="line">2.3.1  WRK包含了什么 35</span><br><span class="line">2.3.2  WRK源代码说明 36</span><br><span class="line">2.3.3  本书对WRK源代码的引用 38</span><br><span class="line">2.4  Windows内核的基本概念 39</span><br><span class="line">2.4.1  处理器模式 40</span><br><span class="line">2.4.2  内存管理 41</span><br><span class="line">2.4.3  进程和线程管理 43</span><br><span class="line">2.4.4  中断和异常 45</span><br><span class="line">2.4.5  同步 48</span><br><span class="line">2.5  Windows内核中的公共管理设施 50</span><br><span class="line">2.5.1  Windows内核中的对象管理 50</span><br><span class="line">2.5.2  注册表和配置管理器 58</span><br><span class="line">2.5.3  事件追踪（ETW） 69</span><br><span class="line">2.5.4  安全性管理 72</span><br><span class="line">2.6  Windows引导过程 79</span><br><span class="line">2.6.1  内核加载 79</span><br><span class="line">2.6.2  内核初始化 86</span><br><span class="line">2.6.3  建立用户登录会话 91</span><br><span class="line">2.7  本章总结 97</span><br><span class="line">第3章  Windows进程和线程 99</span><br><span class="line">3.1  进程基本概念 99</span><br><span class="line">3.1.1  多进程模型 99</span><br><span class="line">3.1.2  进程和程序 101</span><br><span class="line">3.2  线程基本概念 104</span><br><span class="line">3.2.1  线程模型 104</span><br><span class="line">3.2.2  线程调度算法 106</span><br><span class="line">3.2.3  线程和进程的关系 108</span><br><span class="line">3.3  Windows中进程和线程数据结构 108</span><br><span class="line">3.3.1  内核层的进程和线程对象 108</span><br><span class="line">3.3.2  执行体层的进程和线程对象 120</span><br><span class="line">3.4  Windows的进程和线程管理 131</span><br><span class="line">3.4.1  Windows进程中的句柄表 131</span><br><span class="line">3.4.2  获得当前线程和进程 136</span><br><span class="line">3.4.3  进程和线程的创建过程 137</span><br><span class="line">3.4.4  进程和线程的结束 147</span><br><span class="line">3.4.5  系统初始进程和线程 149</span><br><span class="line">3.5  Windows中的线程调度 151</span><br><span class="line">3.5.1  线程优先级 152</span><br><span class="line">3.5.2  线程状态转移 154</span><br><span class="line">3.5.3  时限管理 164</span><br><span class="line">3.5.4  优先级调度和环境切换 166</span><br><span class="line">3.6  进程和线程状态监视工具 172</span><br><span class="line">3.6.1  ProcMon使用示例 172</span><br><span class="line">3.6.2  ProcMon实现原理 174</span><br><span class="line">3.7  本章总结 174</span><br><span class="line">第4章  Windows内存管理 175</span><br><span class="line">4.1  内存管理概述 176</span><br><span class="line">4.1.1  页式内存管理 177</span><br><span class="line">4.1.2  段式内存管理 181</span><br><span class="line">4.1.3  内存管理算法介绍 184</span><br><span class="line">4.1.4  Windows内存管理概述 192</span><br><span class="line">4.2  Windows系统内存管理 194</span><br><span class="line">4.2.1  系统地址空间初始化 194</span><br><span class="line">4.2.2  系统地址空间内存管理 209</span><br><span class="line">4.2.3  系统PTE区域的管理 224</span><br><span class="line">4.3  进程虚拟内存管理 229</span><br><span class="line">4.3.1  地址空间的创建和初始化 229</span><br><span class="line">4.3.2  地址空间切换 234</span><br><span class="line">4.3.3  虚拟地址空间的管理 235</span><br><span class="line">4.3.4  内存区对象 241</span><br><span class="line">4.4  内存页面交换 249</span><br><span class="line">4.4.1  x86中的PTE 250</span><br><span class="line">4.4.2  软件PTE：无效PTE和原型PTE 253</span><br><span class="line">4.4.3  页面错误处理 257</span><br><span class="line">4.4.4  Windows的写时复制 263</span><br><span class="line">4.5  物理内存管理 265</span><br><span class="line">4.5.1  PFN数据库 265</span><br><span class="line">4.5.2  物理页面的状态变化 270</span><br><span class="line">4.5.3  物理页面链表的管理和操作 274</span><br><span class="line">4.5.4  修改页面写出器 279</span><br><span class="line">4.5.5  进程&#x2F;栈交换器 281</span><br><span class="line">4.5.6  低内存通知和高内存通知 284</span><br><span class="line">4.6  工作集管理 285</span><br><span class="line">4.6.1  Windows工作集管理器 285</span><br><span class="line">4.6.2  平衡集管理器 291</span><br><span class="line">4.7  内存监视工具Mem_Mon 292</span><br><span class="line">4.7.1  Mem_Mon使用介绍 292</span><br><span class="line">4.7.2  Mem_Mon实现原理 293</span><br><span class="line">4.8  本章总结 294</span><br><span class="line">第5章  Windows中的并发和同步 295</span><br><span class="line">5.1  进程和线程同步基础 295</span><br><span class="line">5.1.1  并发性基础 296</span><br><span class="line">5.1.2  进程或线程之间的通讯 299</span><br><span class="line">5.1.3  经典的同步问题 303</span><br><span class="line">5.2  Windows中断与异常 308</span><br><span class="line">5.2.1  硬件中断的发生和处理 308</span><br><span class="line">5.2.2  中断请求级别（IRQL） 314</span><br><span class="line">5.2.3  中断对象 317</span><br><span class="line">5.2.4  DPC（延迟过程调用） 320</span><br><span class="line">5.2.5  时钟中断和定时器管理 324</span><br><span class="line">5.2.6  APC（异步过程调用） 328</span><br><span class="line">5.2.7  异常分发 333</span><br><span class="line">5.3  不依赖于线程调度的同步机制 340</span><br><span class="line">5.3.1  提升IRQL实现数据同步 340</span><br><span class="line">5.3.2  互锁操作 342</span><br><span class="line">5.3.3  无锁的单链表实现 343</span><br><span class="line">5.3.4  自旋锁 345</span><br><span class="line">5.4  基于线程调度的同步机制 351</span><br><span class="line">5.4.1  线程进入等待 351</span><br><span class="line">5.4.2  分发器对象 358</span><br><span class="line">5.4.3  门等待 365</span><br><span class="line">5.4.4  执行体资源（executive resource） 367</span><br><span class="line">5.4.5  推锁（push lock） 370</span><br><span class="line">5.4.6  死锁 375</span><br><span class="line">5.5  使用工具DPerfLite 376</span><br><span class="line">5.5.1  DPerfLite使用示例 376</span><br><span class="line">5.5.2  DPerfLite实现原理 378</span><br><span class="line">5.6  本章总结 379</span><br><span class="line">第6章  Windows I&#x2F;O系统 381</span><br><span class="line">6.1  I&#x2F;O概述 382</span><br><span class="line">6.1.1  现代计算机系统的I&#x2F;O 382</span><br><span class="line">6.1.2  I&#x2F;O软件技术 386</span><br><span class="line">6.1.3  Windows的I&#x2F;O系统结构 388</span><br><span class="line">6.2  I&#x2F;O管理器 390</span><br><span class="line">6.2.1  驱动程序初始化 390</span><br><span class="line">6.2.2  驱动程序对象和设备对象 397</span><br><span class="line">6.2.3  文件对象 401</span><br><span class="line">6.2.4  对象生命周期管理 405</span><br><span class="line">6.3  即插即用管理器 406</span><br><span class="line">6.3.1  即插即用的基本要求 407</span><br><span class="line">6.3.2  Windows中驱动程序的即插即用支持 408</span><br><span class="line">6.3.3  设备列举与设备树 409</span><br><span class="line">6.4  电源管理器 411</span><br><span class="line">6.4.1  电源管理概述 412</span><br><span class="line">6.4.2  Windows中的电源管理 415</span><br><span class="line">6.5  设备驱动程序 420</span><br><span class="line">6.5.1  驱动程序分类 420</span><br><span class="line">6.5.2  例子驱动程序toaster 423</span><br><span class="line">6.5.3  驱动程序的代码结构 425</span><br><span class="line">6.5.4  toaster设备的设备栈 430</span><br><span class="line">6.5.5  过滤驱动程序的配置和加载 431</span><br><span class="line">6.5.6  非即插即用驱动程序 435</span><br><span class="line">6.6  I&#x2F;O处理 437</span><br><span class="line">6.6.1  I&#x2F;O请求包（IRP） 438</span><br><span class="line">6.6.2  针对独立设备对象的I&#x2F;O处理 444</span><br><span class="line">6.6.3  处理I&#x2F;O请求过程中的事项 449</span><br><span class="line">6.6.4  针对设备栈的I&#x2F;O处理 459</span><br><span class="line">6.6.5  I&#x2F;O完成端口 463</span><br><span class="line">6.7  I&#x2F;O监视工具IRPMon 466</span><br><span class="line">6.7.1  IRPMon使用介绍 466</span><br><span class="line">6.7.2  IRPMon实现原理 467</span><br><span class="line">6.8  本章总结 468</span><br><span class="line">第7章  Windows存储管理 469</span><br><span class="line">7.1  存储管理概述 469</span><br><span class="line">7.1.1  硬件存储体系（Memory hierarchy） 470</span><br><span class="line">7.1.2  Windows的存储管理结构 472</span><br><span class="line">7.2  Windows缓存管理 474</span><br><span class="line">7.2.1  Windows缓存空间的内存管理 474</span><br><span class="line">7.2.2  缓存管理器的数据访问路径 481</span><br><span class="line">7.2.3  直接使用缓存中的数据 484</span><br><span class="line">7.2.4  缓存管理器的预读处理 491</span><br><span class="line">7.2.5  缓存管理器的延迟写 494</span><br><span class="line">7.3  Windows卷管理 497</span><br><span class="line">7.3.1  Windows中存储栈结构 497</span><br><span class="line">7.3.2  卷的挂载 501</span><br><span class="line">7.3.3  卷与文件系统 504</span><br><span class="line">7.3.4  文件对象的I&#x2F;O处理 508</span><br><span class="line">7.4  Windows文件系统 510</span><br><span class="line">7.4.1  文件系统驱动程序结构 511</span><br><span class="line">7.4.2  RAW文件系统和FsRtl 516</span><br><span class="line">7.4.3  文件系统的过滤 520</span><br><span class="line">7.4.4  FAT文件系统 527</span><br><span class="line">7.4.5  NTFS文件系统 532</span><br><span class="line">7.5  本章总结 540</span><br><span class="line">第8章  Windows系统服务 541</span><br><span class="line">8.1  Windows系统服务原理 541</span><br><span class="line">8.1.1  Intel x86的用户模式-内核模式切换 541</span><br><span class="line">8.1.2  Windows的用户模式-内核模式切换 546</span><br><span class="line">8.1.3  Windows中的系统服务分发 550</span><br><span class="line">8.1.4  增加系统服务表或表项 557</span><br><span class="line">8.2  LPC（本地过程调用）服务 561</span><br><span class="line">8.2.1  LPC结构模型 561</span><br><span class="line">8.2.2  LPC端口和LPC消息 563</span><br><span class="line">8.2.3  LPC通讯模型的实现 565</span><br><span class="line">8.2.4  LPC应用 571</span><br><span class="line">8.3  命名管道（Named Pipe）服务 573</span><br><span class="line">8.3.1  命名管道的名称解析 573</span><br><span class="line">8.3.2  命名管道的通讯模型 575</span><br><span class="line">8.3.3  命名管道的实现 577</span><br><span class="line">8.4  邮件槽（Mailslot）服务 580</span><br><span class="line">8.4.1  邮件槽的名称解析 580</span><br><span class="line">8.4.2  邮件槽的通讯模型 581</span><br><span class="line">8.4.3  邮件槽的实现 581</span><br><span class="line">8.5  SDT显示工具SDTViewer 583</span><br><span class="line">8.5.1  SDTViewer使用介绍 583</span><br><span class="line">8.5.2  SDTViewer实现原理 584</span><br><span class="line">8.6  本章总结 585</span><br><span class="line">第9章  Windows内核高级话题 587</span><br><span class="line">9.1  网络 587</span><br><span class="line">9.1.1  Windows网络体系结构 587</span><br><span class="line">9.1.2  TDI（传输驱动程序接口） 591</span><br><span class="line">9.1.3  NDSI（网络驱动程序接口规范） 594</span><br><span class="line">9.1.4  Windows Vista以后的网络结构 597</span><br><span class="line">9.2  Windows子系统 599</span><br><span class="line">9.2.1  Windows子系统结构 599</span><br><span class="line">9.2.2  Windows子系统初始化与GUI线程 602</span><br><span class="line">9.2.3  窗口管理 606</span><br><span class="line">9.2.4  GDI（图形设备接口） 616</span><br><span class="line">9.2.5  Windows Vista以后的子系统变化 622</span><br><span class="line">9.3  内核日志 625</span><br><span class="line">9.3.1  WRK中的内核记录器 625</span><br><span class="line">9.3.2  利用ETW信息诊断性能问题 628</span><br><span class="line">9.4  Windows Vista&#x2F;Server 2008&#x2F;7的重要变化 636</span><br><span class="line">9.4.1  MinWin工程 636</span><br><span class="line">9.4.2  ？？ 639</span><br><span class="line">附录A  建立编译和调试WRK环境 641</span><br><span class="line">A.1  编译WRK 641</span><br><span class="line">A.2  启动WRK 645</span><br><span class="line">A.3  调试WRK 648</span><br><span class="line">附录B  内核代码插入工具KInjectToolKit 657</span><br><span class="line">B.1  KInjectToolKit功能介绍 658</span><br><span class="line">B.2  KInjectToolKit的代码实现 659</span><br><span class="line">B.3  KInjectToolKit的限制 663</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00CRKN9T0/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00CRKN9T0&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/515yY2vRxxL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>世界是数字的</title>
    <url>/2020/04/19/B00DSQZBDE/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 世界是数字的<br>作者信息： 作者: 柯林汉 (Brian W.Kernighan) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>盖茨和扎克伯格导师刘易斯、谷歌常务董事长施密特联袂推荐面对这个时代最伟大的技术，无论你是谁，都很难置身事外请跟随他，请跟随普林斯顿大学，开启一次华美的计算机旅行</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开篇语 1</span><br><span class="line">任何足够先进的技术都与魔术无异。</span><br><span class="line">——阿瑟·C.克拉克，“技术及未来前景”，《三号行星的报告》，1972年</span><br><span class="line">第一部分 硬件</span><br><span class="line">第1章 计算机里有什么 11</span><br><span class="line">1.1 逻辑构造 13</span><br><span class="line">1.2 物理构造 18</span><br><span class="line">1.3 摩尔定律 21</span><br><span class="line">第2章 比特、字节与信息表示 23</span><br><span class="line">2.1 模拟与数字 23</span><br><span class="line">2.2 模数转换 25</span><br><span class="line">2.3 比特、字节与二进制 30</span><br><span class="line">2.4 小结 37</span><br><span class="line">第3章 深入了解CPU 39</span><br><span class="line">3.1 玩具计算机 40</span><br><span class="line">3.2 真正的CPU 45</span><br><span class="line">3.3 缓存 47</span><br><span class="line">3.4 其他计算机 49</span><br><span class="line">硬件部分小结 51</span><br><span class="line">第二部分 软件</span><br><span class="line">第4章 算法 57</span><br><span class="line">4.1 线性算法 58</span><br><span class="line">4.2 二分搜索 60</span><br><span class="line">4.3 排序 62</span><br><span class="line">4.4 难题与复杂性 66</span><br><span class="line">4.5 小结 68</span><br><span class="line">第5章 编程与编程语言 71</span><br><span class="line">5.1 汇编语言 72</span><br><span class="line">5.2 高级语言 73</span><br><span class="line">5.3 软件开发 79</span><br><span class="line">5.4 软件资产 84</span><br><span class="line">第6章 软件系统 93</span><br><span class="line">6.1 操作系统 94</span><br><span class="line">6.2 操作系统怎么工作 98</span><br><span class="line">6.3 其他操作系统 101</span><br><span class="line">6.4 文件系统 102</span><br><span class="line">6.5 应用程序 108</span><br><span class="line">6.6 软件分层 111</span><br><span class="line">第7章 学习编程 115</span><br><span class="line">7.1 编程语言的基本概念 116</span><br><span class="line">7.2 第一个JavaScript程序 117</span><br><span class="line">7.3 第二个JavaScript程序 119</span><br><span class="line">7.4 循环 121</span><br><span class="line">7.5 条件 122</span><br><span class="line">7.6 库和接口 124</span><br><span class="line">7.7 JavaScript怎么工作 125</span><br><span class="line">软件部分小结 127</span><br><span class="line">第三部分 通信</span><br><span class="line">第8章 网络 135</span><br><span class="line">电话网作为一个覆盖全球的大型网络，从一开始只传送语音，到后来同时传输语音和可观的数据，为人类做出了贡献。大约有近20年的时间，人们都是通过电话网把家用计算机接入互联网的。</span><br><span class="line">8.1 电话与调制解调器 136</span><br><span class="line">8.2 有线和DSL 136</span><br><span class="line">8.3 局域网和以太网 138</span><br><span class="line">8.4 无线网络 141</span><br><span class="line">8.5 手机 144</span><br><span class="line">8.6 小结 147</span><br><span class="line">第9章 互联网 149</span><br><span class="line">9.1 互联网概述 150</span><br><span class="line">9.2 域名和地址 153</span><br><span class="line">9.3 路由 157</span><br><span class="line">9.4 协议 159</span><br><span class="line">9.5 高层协议 162</span><br><span class="line">9.6 带宽 172</span><br><span class="line">9.7 压缩 173</span><br><span class="line">9.8 错误检测和校正 176</span><br><span class="line">9.9 小结 177</span><br><span class="line">第10章 万维网 179</span><br><span class="line">10.1 万维网如何工作 180</span><br><span class="line">10.2 HTML 182</span><br><span class="line">10.3 表单 183</span><br><span class="line">10.4 cookie 184</span><br><span class="line">10.5 动态网页 186</span><br><span class="line">10.6 网页之外的动态内容 189</span><br><span class="line">10.7 病毒和蠕虫 190</span><br><span class="line">10.8 万维网安全 192</span><br><span class="line">10.9 密码术 201</span><br><span class="line">10.10 小结 208</span><br><span class="line">第11章 数据、信息和隐私 211</span><br><span class="line">11.1 搜索 212</span><br><span class="line">11.2 跟踪 216</span><br><span class="line">11.3 数据库、信息与聚合 221</span><br><span class="line">11.4 隐私失控 224</span><br><span class="line">11.5 云计算 225</span><br><span class="line">11.6 小结 230</span><br><span class="line">第12章 结束语 231</span><br><span class="line">注解 236</span><br><span class="line">词汇表 242</span><br><span class="line">索引 253</span><br><span class="line">版权声明 256</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00DSQZBDE/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00DSQZBDE&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51wwiyeZ5AL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title>大型网站技术架构:核心原理与案例分析</title>
    <url>/2020/04/19/B00F3Z26G8/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 大型网站技术架构:核心原理与案例分析<br>作者信息： 作者: 李智慧 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>本书作者是拥有核心技术部门的一线工作经验，直接体验了大型网站构建与发展过程中的种种生与死，蜕与变，见证了一个网站架构从幼稚走向成熟稳定的历程。<br>没有晦涩难懂的术语，没有诘屈聱牙的文句，没有故弄玄虚的观点……<br>明明白白的语句，清清楚楚的文法，干净利落的建议——让读者直接体会网站架构的紧要处，不容马虎的关键点——这恰好是一个优秀的网站架构所必备的要素。<br>如果说“水不在深，有龙则灵”，那么对于想了解网站架构的读者而言，这本书恰好是“书不在多，有它则行！”<br>还犹豫什么呢？</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1篇概述</span><br><span class="line">1大型网站架构演化2</span><br><span class="line">1.1大型网站软件系统的特点3</span><br><span class="line">1.2大型网站架构演化发展历程4</span><br><span class="line">1.2.1初始阶段的网站架构4</span><br><span class="line">1.2.2应用服务和数据服务分离4</span><br><span class="line">1.2.3使用缓存改善网站性能5</span><br><span class="line">1.2.4使用应用服务器集群改善网站的并发处理能力6</span><br><span class="line">1.2.5数据库读写分离7</span><br><span class="line">1.2.6使用反向代理和CDN加速网站响应8</span><br><span class="line">1.2.7使用分布式文件系统和分布式数据库系统9</span><br><span class="line">1.2.8使用NoSQL和搜索引擎10</span><br><span class="line">1.2.9业务拆分11</span><br><span class="line">1.2.10分布式服务11</span><br><span class="line">1.3大型网站架构演化的价值观13</span><br><span class="line">1.3.1大型网站架构技术的核心价值是随网站所需灵活应对13</span><br><span class="line">1.3.2驱动大型网站技术发展的主要力量是网站的业务发展13</span><br><span class="line">1.4网站架构设计误区14</span><br><span class="line">1.4.1一味追随大公司的解决方案14</span><br><span class="line">1.4.2为了技术而技术14</span><br><span class="line">1.4.3企图用技术解决所有问题14</span><br><span class="line">1.5小结15</span><br><span class="line">2大型网站架构模式16</span><br><span class="line">2.1网站架构模式16</span><br><span class="line">2.1.1分层17</span><br><span class="line">2.1.2分割18</span><br><span class="line">2.1.3分布式18</span><br><span class="line">2.1.4集群19</span><br><span class="line">2.1.5缓存20</span><br><span class="line">2.1.6异步20</span><br><span class="line">2.1.7冗余21</span><br><span class="line">2.1.8自动化22</span><br><span class="line">2.1.9安全23</span><br><span class="line">2.2架构模式在新浪微博的应用23</span><br><span class="line">2.3小结25</span><br><span class="line">3大型网站核心架构要素26</span><br><span class="line">3.1性能27</span><br><span class="line">3.2可用性28</span><br><span class="line">3.3伸缩性29</span><br><span class="line">3.4扩展性30</span><br><span class="line">3.5安全性30</span><br><span class="line">3.6小结31</span><br><span class="line">第2篇架构</span><br><span class="line">4瞬时响应：网站的高性能架构34</span><br><span class="line">4.1网站性能测试35</span><br><span class="line">4.1.1不同视角下的网站性能35</span><br><span class="line">4.1.2性能测试指标36</span><br><span class="line">4.1.3性能测试方法39</span><br><span class="line">4.1.4性能测试报告41</span><br><span class="line">4.1.5性能优化策略41</span><br><span class="line">4.2Web前端性能优化42</span><br><span class="line">4.2.1浏览器访问优化42</span><br><span class="line">4.2.2CDN加速43</span><br><span class="line">4.2.3反向代理44</span><br><span class="line">4.3应用服务器性能优化45</span><br><span class="line">4.3.1分布式缓存45</span><br><span class="line">4.3.2异步操作52</span><br><span class="line">4.3.3使用集群53</span><br><span class="line">4.3.4代码优化54</span><br><span class="line">4.4存储性能优化58</span><br><span class="line">4.4.1机械硬盘vs.固态硬盘58</span><br><span class="line">4.4.2B+树vs.LSM树59</span><br><span class="line">4.4.3RAIDvs.HDFS61</span><br><span class="line">4.5小结64</span><br><span class="line">5万无一失：网站的高可用架构66</span><br><span class="line">5.1网站可用性的度量与考核67</span><br><span class="line">5.1.1网站可用性度量67</span><br><span class="line">5.1.2网站可用性考核67</span><br><span class="line">5.2高可用的网站架构69</span><br><span class="line">5.3高可用的应用71</span><br><span class="line">5.3.1通过负载均衡进行无状态服务的失效转移72</span><br><span class="line">5.3.2应用服务器集群的Session管理73</span><br><span class="line">5.4高可用的服务76</span><br><span class="line">5.5高可用的数据78</span><br><span class="line">5.5.1CAP原理79</span><br><span class="line">5.5.2数据备份82</span><br><span class="line">5.5.3失效转移84</span><br><span class="line">5.6高可用网站的软件质量保证85</span><br><span class="line">5.6.1网站发布85</span><br><span class="line">5.6.2自动化测试86</span><br><span class="line">5.6.3预发布验证87</span><br><span class="line">5.6.4代码控制88</span><br><span class="line">5.6.5自动化发布90</span><br><span class="line">5.6.6灰度发布91</span><br><span class="line">5.7网站运行监控91</span><br><span class="line">5.7.1监控数据采集92</span><br><span class="line">5.7.2监控管理93</span><br><span class="line">5.8小结94</span><br><span class="line">6永无止境：网站的伸缩性架构95</span><br><span class="line">6.1网站架构的伸缩性设计97</span><br><span class="line">6.1.1不同功能进行物理分离实现伸缩97</span><br><span class="line">6.1.2单一功能通过集群规模实现伸缩98</span><br><span class="line">6.2应用服务器集群的伸缩性设计99</span><br><span class="line">6.2.1HTTP重定向负载均衡100</span><br><span class="line">6.2.2DNS域名解析负载均衡101</span><br><span class="line">6.2.3反向代理负载均衡102</span><br><span class="line">6.2.4IP负载均衡103</span><br><span class="line">6.2.5数据链路层负载均衡104</span><br><span class="line">6.2.6负载均衡算法105</span><br><span class="line">6.3分布式缓存集群的伸缩性设计106</span><br><span class="line">6.3.1Memcached分布式缓存集群的访问模型107</span><br><span class="line">6.3.2Memcached分布式缓存集群的伸缩性挑战107</span><br><span class="line">6.3.3分布式缓存的一致性Hash算法109</span><br><span class="line">6.4数据存储服务器集群的伸缩性设计112</span><br><span class="line">6.4.1关系数据库集群的伸缩性设计113</span><br><span class="line">6.4.2NoSQL数据库的伸缩性设计117</span><br><span class="line">6.5小结119</span><br><span class="line">7随需应变：网站的可扩展架构121</span><br><span class="line">7.1构建可扩展的网站架构122</span><br><span class="line">7.2利用分布式消息队列降低系统耦合性123</span><br><span class="line">7.2.1事件驱动架构123</span><br><span class="line">7.2.2分布式消息队列124</span><br><span class="line">7.3利用分布式服务打造可复用的业务平台126</span><br><span class="line">7.3.1WebService与企业级分布式服务128</span><br><span class="line">7.3.2大型网站分布式服务的需求与特点129</span><br><span class="line">7.3.3分布式服务框架设计130</span><br><span class="line">7.4可扩展的数据结构131</span><br><span class="line">7.5利用开放平台建设网站生态圈132</span><br><span class="line">7.6小结134</span><br><span class="line">8固若金汤：网站的安全架构135</span><br><span class="line">8.1道高一尺魔高一丈的网站应用攻击与防御136</span><br><span class="line">8.1.1XSS攻击136</span><br><span class="line">8.1.2注入攻击138</span><br><span class="line">8.1.3CSRF攻击139</span><br><span class="line">8.1.4其他攻击和漏洞140</span><br><span class="line">8.1.5Web应用防火墙141</span><br><span class="line">8.1.6网站安全漏洞扫描142</span><br><span class="line">8.2信息加密技术及密钥安全管理142</span><br><span class="line">8.2.1单向散列加密143</span><br><span class="line">8.2.2对称加密144</span><br><span class="line">8.2.3非对称加密144</span><br><span class="line">8.2.4密钥安全管理145</span><br><span class="line">8.3信息过滤与反垃圾146</span><br><span class="line">8.3.1文本匹配147</span><br><span class="line">8.3.2分类算法148</span><br><span class="line">8.3.3黑名单149</span><br><span class="line">8.4电子商务风险控制150</span><br><span class="line">8.4.1风险151</span><br><span class="line">8.4.2风控151</span><br><span class="line">8.5小结153</span><br><span class="line">第3篇案例</span><br><span class="line">9淘宝网的架构演化案例分析156</span><br><span class="line">9.1淘宝网的业务发展历程157</span><br><span class="line">9.2淘宝网技术架构演化158</span><br><span class="line">9.3小结162</span><br><span class="line">10维基百科的高性能架构设计分析163</span><br><span class="line">10.1Wikipedia网站整体架构163</span><br><span class="line">10.2Wikipedia性能优化策略165</span><br><span class="line">10.2.1Wikipedia前端性能优化165</span><br><span class="line">10.2.2Wikipedia服务端性能优化166</span><br><span class="line">10.2.3Wikipedia后端性能优化167</span><br><span class="line">11海量分布式存储系统Doris的高可用架构设计分析169</span><br><span class="line">11.1分布式存储系统的高可用架构170</span><br><span class="line">11.2不同故障情况下的高可用解决方案171</span><br><span class="line">11.2.1分布式存储系统的故障分类172</span><br><span class="line">11.2.2正常情况下系统访问结构172</span><br><span class="line">11.2.3瞬时故障的高可用解决方案173</span><br><span class="line">11.2.4临时故障的高可用解决方案174</span><br><span class="line">11.2.5永久故障的高可用解决方案175</span><br><span class="line">12网购秒杀系统架构设计案例分析176</span><br><span class="line">12.1秒杀活动的技术挑战177</span><br><span class="line">12.2秒杀系统的应对策略177</span><br><span class="line">12.3秒杀系统架构设计178</span><br><span class="line">12.4小结182</span><br><span class="line">13大型网站典型故障案例分析183</span><br><span class="line">13.1写日志也会引发故障184</span><br><span class="line">13.2高并发访问数据库引发的故障184</span><br><span class="line">13.3高并发情况下锁引发的故障185</span><br><span class="line">13.4缓存引发的故障185</span><br><span class="line">13.5应用启动不同步引发的故障186</span><br><span class="line">13.6大文件读写独占磁盘引发的故障186</span><br><span class="line">13.7滥用生产环境引发的故障187</span><br><span class="line">13.8不规范的流程引发的故障187</span><br><span class="line">13.9不好的编程习惯引发的故障188</span><br><span class="line">13.10小结188</span><br><span class="line">第4篇架构师</span><br><span class="line">14架构师领导艺术190</span><br><span class="line">14.1关注人而不是产品191</span><br><span class="line">14.2发掘人的优秀191</span><br><span class="line">14.3共享美好蓝图192</span><br><span class="line">14.4共同参与架构193</span><br><span class="line">14.5学会妥协194</span><br><span class="line">14.6成就他人194</span><br><span class="line">15网站架构师职场攻略196</span><br><span class="line">15.1发现问题，寻找突破197</span><br><span class="line">15.2提出问题，寻求支持199</span><br><span class="line">15.3解决问题，达成绩效201</span><br><span class="line">16漫话网站架构师203</span><br><span class="line">16.1按作用划分架构师203</span><br><span class="line">16.2按效果划分架构师204</span><br><span class="line">16.3按职责角色划分架构师205</span><br><span class="line">16.4按关注层次划分架构师205</span><br><span class="line">16.5按口碑划分架构师206</span><br><span class="line">16.6非主流方式划分架构师207</span><br><span class="line">附录A大型网站架构技术一览208</span><br><span class="line">附录BWeb开发技术发展历程215</span><br><span class="line">后记218</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00F3Z26G8/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00F3Z26G8&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41ywlt1rlCL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>Processing语言权威指南</title>
    <url>/2020/04/19/B00FEMKN7Y/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Processing语言权威指南<br>作者信息： 作者: 瑞斯 (Casey Reas) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Processing语言是麻省理工大学的Casey Reas和Ben Fry两人原创，如今已经风靡世界。随着学习的人越来越多，简单的代码教程已经无法满足大家的需要。本书是Casey Reas和Ben Fry关于Processing的集大成之作，加入了更多实践案例，让读者学习得更加深入。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">序</span><br><span class="line">前言</span><br><span class="line">Processing</span><br><span class="line">使用Processing</span><br><span class="line">结构一：代码要素</span><br><span class="line">形状一：坐标与基本图形</span><br><span class="line">数据一：变量</span><br><span class="line">数学一：算术与函数</span><br><span class="line">控制一：判断</span><br><span class="line">控制二：重复</span><br><span class="line">形状二：顶点</span><br><span class="line">数学二：曲线</span><br><span class="line">色彩一：用数字定义颜色</span><br><span class="line">图像一：显示与染色</span><br><span class="line">数据二：文本</span><br><span class="line">数据三：转换与对象</span><br><span class="line">字体设计一：显示</span><br><span class="line">数学三：三角学</span><br><span class="line">数学四：随机</span><br><span class="line">变换一：平移与矩阵</span><br><span class="line">变换二：旋转与缩放</span><br><span class="line">开发一：草图与技术</span><br><span class="line">综合一：形式与代码</span><br><span class="line">访谈一：印刷</span><br><span class="line">结构二：连续运行</span><br><span class="line">结构三：函数</span><br><span class="line">形状三：参数与递归</span><br><span class="line">输入一：鼠标一</span><br><span class="line">绘图一：静态形式</span><br><span class="line">输入二：键盘</span><br><span class="line">输入三：事件</span><br><span class="line">输入四：鼠标二</span><br><span class="line">输入五：时间与日期</span><br><span class="line">开发二：迭代与调试</span><br><span class="line">综合二：输入与响应</span><br><span class="line">访谈二：软件与网页</span><br><span class="line">运动一：直线与曲线</span><br><span class="line">运动二：机械与有机体</span><br><span class="line">数据四：数组</span><br><span class="line">图像二：动画</span><br><span class="line">图像三：像素</span><br><span class="line">字体设计二：运动</span><br><span class="line">字体设计三：响应</span><br><span class="line">色彩二：分量</span><br><span class="line">图像四：滤波、融合、复制与蒙板</span><br><span class="line">图像五：图像处理</span><br><span class="line">输出一：图像</span><br><span class="line">综合三：运动与数组</span><br><span class="line">访谈三：动画与录像</span><br><span class="line">结构四：对象一</span><br><span class="line">绘图二：动态形式</span><br><span class="line">输出二：文件导出</span><br><span class="line">输入六：文件导入</span><br><span class="line">输入七：界面</span><br><span class="line">结构五：对象二</span><br><span class="line">模拟一：生物</span><br><span class="line">模拟二：物理</span><br><span class="line">综合四：结构与接口</span><br><span class="line">访谈四：演出与装置</span><br><span class="line">扩展一：继续</span><br><span class="line">扩展二：三维</span><br><span class="line">扩展三：视觉</span><br><span class="line">扩展四：网络</span><br><span class="line">扩展五：声音</span><br><span class="line">扩展六：印刷品</span><br><span class="line">扩展七：移动平台</span><br><span class="line">扩展八：电子器件</span><br><span class="line">附录A：运算顺序</span><br><span class="line">附录B：保留字</span><br><span class="line">附录C：ASCII与Unicode</span><br><span class="line">附录D：比特、二进制与十六进制</span><br><span class="line">附录E：优化</span><br><span class="line">附录F：编程语言</span><br><span class="line">附录G：代码对比</span><br><span class="line">相关媒介</span><br><span class="line">术语表</span><br><span class="line">代码索引</span><br><span class="line">索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00FEMKN7Y/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00FEMKN7Y&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51O1Y7MScvL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>processing</tag>
      </tags>
  </entry>
  <entry>
    <title>像计算机科学家一样思考Python</title>
    <url>/2020/04/19/B00EEDI2X6/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 像计算机科学家一样思考Python<br>作者信息： 作者: 唐尼 (Allen B.Downey) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>以“像计算机科学家一样思考”的方式，学习和掌握Python语言！如果你想学习如何编程，使用Python语言是一个极佳的开始。这本实践指南会带你一步一个脚印地学习Python语言，从最基本的编程概念，到函数、递归、数据结构和面向对象设计。计算机科学家自有一套解决问题的方法，而且这种方法是独特的、通用的和强大的。将引领你去感知这样的方法，按照“像计算机科学家一样思考”的方式，学习和掌握Python语言。从基础开始，包括语言的语法和语义。每个编程概念都有清晰的定义。进度合理地学习值、变量、语句、函数和数据结构。了解如何处理文件和数据库。理解对象、方法和面向对象编程。使用调试技巧来修正语法错误、运行时错误和语义错误。通过案例分析来探索接口设计、数据结构和基于GUI的程序。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 程序之道 1</span><br><span class="line">1.1 Python编程语言 1</span><br><span class="line">1.2 什么是程序 3</span><br><span class="line">1.3 什么是调试 3</span><br><span class="line">1.4 语法错误 3</span><br><span class="line">1.5 运行时错误 4</span><br><span class="line">1.6 语义错误 4</span><br><span class="line">1.7 实验型调试 4</span><br><span class="line">1.8 形式语言和自然语言 5</span><br><span class="line">1.9 第一个程序 6</span><br><span class="line">1.10 调试 7</span><br><span class="line">1.11 术语表 7</span><br><span class="line">1.12 练习 9</span><br><span class="line">第2章 变量、表达式和语句 10</span><br><span class="line">2.1 值和类型 10</span><br><span class="line">2.2 变量 11</span><br><span class="line">2.3 变量名称和关键字 12</span><br><span class="line">2.4 操作符和操作对象 13</span><br><span class="line">2.5 表达式和语句 13</span><br><span class="line">2.6 交互模式和脚本模式 14</span><br><span class="line">2.7 操作顺序 15</span><br><span class="line">2.8 字符串操作 15</span><br><span class="line">2.9 注释 16</span><br><span class="line">2.10 调试 16</span><br><span class="line">2.11 术语表 17</span><br><span class="line">2.12 练习 18</span><br><span class="line">第3章 函数 19</span><br><span class="line">3.1 函数调用 19</span><br><span class="line">3.2 类型转换函数 19</span><br><span class="line">3.3 数学函数 20</span><br><span class="line">3.4 组合 21</span><br><span class="line">3.5 添加新函数 21</span><br><span class="line">3.6 定义和使用 23</span><br><span class="line">3.7 执行流程 23</span><br><span class="line">3.8 形参和实参 24</span><br><span class="line">3.9 变量和形参是局部的 25</span><br><span class="line">3.10 栈图 25</span><br><span class="line">3.11 有返回值函数和无返回值函数 26</span><br><span class="line">3.12 为什么要有函数 27</span><br><span class="line">3.13 使用from导入模块 28</span><br><span class="line">3.14 调试 28</span><br><span class="line">3.15 术语表 29</span><br><span class="line">3.16 练习 30</span><br><span class="line">第4章 案例研究：接口设计 32</span><br><span class="line">4.1 乌龟世界 32</span><br><span class="line">4.2 简单重复 33</span><br><span class="line">4.3 练习 34</span><br><span class="line">4.4 封装 35</span><br><span class="line">4.5 泛化 36</span><br><span class="line">4.6 接口设计 36</span><br><span class="line">4.7 重构 37</span><br><span class="line">4.8 一个开发计划 38</span><br><span class="line">4.9 文档字符串 39</span><br><span class="line">4.10 调试 39</span><br><span class="line">4.11 术语表 40</span><br><span class="line">4.12 练习 40</span><br><span class="line">第5章 条件和递归 43</span><br><span class="line">5.1 求模操作符 43</span><br><span class="line">5.2 布尔表达式 43</span><br><span class="line">5.3 逻辑操作符 44</span><br><span class="line">5.4 条件执行 44</span><br><span class="line">5.5 选择执行 45</span><br><span class="line">5.6 条件链 45</span><br><span class="line">5.7 嵌套条件 46</span><br><span class="line">5.8 递归 46</span><br><span class="line">5.9 递归函数的栈图 48</span><br><span class="line">5.10 无限递归 48</span><br><span class="line">5.11 键盘输入 49</span><br><span class="line">5.12 调试 50</span><br><span class="line">5.13 术语表 51</span><br><span class="line">5.14 练习 52</span><br><span class="line">第6章 有返回函数 54</span><br><span class="line">6.1 返回值 54</span><br><span class="line">6.2 增量开发 55</span><br><span class="line">6.3 组合 57</span><br><span class="line">6.4 布尔函数 58</span><br><span class="line">6.5 再谈递归 59</span><br><span class="line">6.6 坚持信念 60</span><br><span class="line">6.7 另一个示例 61</span><br><span class="line">6.8 检查类型 61</span><br><span class="line">6.9 调试 63</span><br><span class="line">6.10 术语表 64</span><br><span class="line">6.11 练习 64</span><br><span class="line">第7章 迭代 67</span><br><span class="line">7.1 多重赋值 67</span><br><span class="line">7.2 更新变量 68</span><br><span class="line">7.3 while语句 68</span><br><span class="line">7.4 break语句 70</span><br><span class="line">7.5 平方根 70</span><br><span class="line">7.6 算法 72</span><br><span class="line">7.7 调试 72</span><br><span class="line">7.8 术语表 73</span><br><span class="line">7.9 练习 73</span><br><span class="line">第8章 字符串 75</span><br><span class="line">8.1 字符串是一个序列 75</span><br><span class="line">8.2 len 76</span><br><span class="line">8.3 使用for循环进行遍历 76</span><br><span class="line">8.4 字符串切片 77</span><br><span class="line">8.5 字符串是不可变的 78</span><br><span class="line">8.6 搜索 79</span><br><span class="line">8.7 循环和计数 79</span><br><span class="line">8.8 字符串方法 80</span><br><span class="line">8.9 操作符in 81</span><br><span class="line">8.10 字符串比较 81</span><br><span class="line">8.11 调试 82</span><br><span class="line">8.12 术语表 84</span><br><span class="line">8.13 练习 84</span><br><span class="line">第9章 案例分析：文字游戏 86</span><br><span class="line">9.1 读取单词列表 86</span><br><span class="line">9.2 练习 87</span><br><span class="line">9.3 搜索 88</span><br><span class="line">9.4 使用下标循环 89</span><br><span class="line">9.5 调试 91</span><br><span class="line">9.6 术语表 91</span><br><span class="line">9.7 练习 91</span><br><span class="line">第10章 列表 93</span><br><span class="line">10.1 列表是一个序列 93</span><br><span class="line">10.2 列表是可变的 93</span><br><span class="line">10.3 遍历一个列表 95</span><br><span class="line">10.4 列表操作 95</span><br><span class="line">10.5 列表切片 96</span><br><span class="line">10.6 列表方法 96</span><br><span class="line">10.7 映射、过滤和化简 97</span><br><span class="line">10.8 删除元素 98</span><br><span class="line">10.9 列表和字符串 99</span><br><span class="line">10.10 对象和值 100</span><br><span class="line">10.11 别名 101</span><br><span class="line">10.12 列表参数 102</span><br><span class="line">10.13 调试 103</span><br><span class="line">10.14 术语表 105</span><br><span class="line">10.15 练习 105</span><br><span class="line">第11章 字典 108</span><br><span class="line">11.1 使用字典作为计数器集合 110</span><br><span class="line">11.2 循环和字典 111</span><br><span class="line">11.3 反向查找 111</span><br><span class="line">11.4 字典和列表 113</span><br><span class="line">11.5 备忘 114</span><br><span class="line">11.6 全局变量 116</span><br><span class="line">11.7 长整数 117</span><br><span class="line">11.8 调试 118</span><br><span class="line">11.9 术语表 118</span><br><span class="line">11.10 练习 119</span><br><span class="line">第12章 元组 121</span><br><span class="line">12.1 元组是不可变的 121</span><br><span class="line">12.2 元组赋值 122</span><br><span class="line">12.3 作为返回值的元组 123</span><br><span class="line">12.4 可变长参数元组 123</span><br><span class="line">12.5 列表和元组 124</span><br><span class="line">12.6 字典和元组 125</span><br><span class="line">12.7 比较元组 127</span><br><span class="line">12.8 序列的序列 128</span><br><span class="line">12.9 调试 128</span><br><span class="line">12.10 术语表 129</span><br><span class="line">12.11 练习 130</span><br><span class="line">第13章 案例研究：选择数据结构 132</span><br><span class="line">13.1 单词频率分析 132</span><br><span class="line">13.2 随机数 133</span><br><span class="line">13.3 单词直方图 134</span><br><span class="line">13.4 最常用的单词 135</span><br><span class="line">13.5 可选形参 136</span><br><span class="line">13.6 字典减法 136</span><br><span class="line">13.7 随机单词 137</span><br><span class="line">13.8 马尔可夫分析 138</span><br><span class="line">13.9 数据结构 139</span><br><span class="line">13.10 调试 141</span><br><span class="line">13.11 术语表 142</span><br><span class="line">13.12 练习 142</span><br><span class="line">第14章 文件 143</span><br><span class="line">14.1 持久化 143</span><br><span class="line">14.2 读和写 143</span><br><span class="line">14.3 格式操作符 144</span><br><span class="line">14.4 文件名和路径 145</span><br><span class="line">14.5 捕获异常 146</span><br><span class="line">14.6 数据库 147</span><br><span class="line">14.7 封存 148</span><br><span class="line">14.8 管道 149</span><br><span class="line">14.9 编写模块 150</span><br><span class="line">14.10 调试 151</span><br><span class="line">14.11 术语表 152</span><br><span class="line">14.12 练习 153</span><br><span class="line">第15章 类和对象 154</span><br><span class="line">15.1 用户定义类型 154</span><br><span class="line">15.2 属性 155</span><br><span class="line">15.3 矩形 156</span><br><span class="line">15.4 作为返回值的实例 157</span><br><span class="line">15.5 对象是可变的 158</span><br><span class="line">15.6 复制 158</span><br><span class="line">15.7 调试 160</span><br><span class="line">15.8 术语表 160</span><br><span class="line">15.9 练习 161</span><br><span class="line">第16章 类和函数 163</span><br><span class="line">16.1 时间 163</span><br><span class="line">16.2 纯函数 164</span><br><span class="line">16.3 修改器 165</span><br><span class="line">16.4 原型和计划 166</span><br><span class="line">16.5 调试 167</span><br><span class="line">16.6 术语表 168</span><br><span class="line">16.7 练习 168</span><br><span class="line">第17章 类和方法 170</span><br><span class="line">17.1 面向对象特性 170</span><br><span class="line">17.2 打印对象 171</span><br><span class="line">17.3 另一个示例 172</span><br><span class="line">17.4 一个更复杂的示例 173</span><br><span class="line">17.5 init方法 173</span><br><span class="line">17.6 str方法 174</span><br><span class="line">17.7 操作符重载 174</span><br><span class="line">17.8 基于类型的分发 175</span><br><span class="line">17.9 多态 176</span><br><span class="line">17.10 调试 177</span><br><span class="line">17.11 接口和实现 178</span><br><span class="line">17.12 术语表 179</span><br><span class="line">17.13 练习 179</span><br><span class="line">第18章 继承 181</span><br><span class="line">18.1 卡片对象 181</span><br><span class="line">18.2 类属性 182</span><br><span class="line">18.3 对比卡牌 183</span><br><span class="line">18.4 牌组 184</span><br><span class="line">18.5 打印牌组 185</span><br><span class="line">18.6 添加、删除、洗牌和排序 186</span><br><span class="line">18.7 继承 186</span><br><span class="line">18.8 类图 188</span><br><span class="line">18.9 调试 189</span><br><span class="line">18.10 数据封装 190</span><br><span class="line">18.11 术语表 191</span><br><span class="line">18.12 练习 192</span><br><span class="line">第19章 案例研究：Tkinter 195</span><br><span class="line">19.1 GUI 195</span><br><span class="line">19.2 按钮和回调 196</span><br><span class="line">19.3 画布部件 197</span><br><span class="line">19.4 坐标序列 198</span><br><span class="line">19.5 更多部件 198</span><br><span class="line">19.6 包装部件 200</span><br><span class="line">19.7 菜单与Callable 202</span><br><span class="line">19.8 绑定 203</span><br><span class="line">19.9 调试 205</span><br><span class="line">19.10 术语表 206</span><br><span class="line">19.11 练习 206</span><br><span class="line">附录A 调试 209</span><br><span class="line">附录B 算法分析 217</span><br><span class="line">附录C Lumpy 227</span><br><span class="line">译后记 236</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00EEDI2X6/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00EEDI2X6&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/515meRyWaUL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Python进行数据分析</title>
    <url>/2020/04/19/B00GHGZLWS/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 利用Python进行数据分析<br>作者信息： 作者: 麦金尼 (Wes McKinney) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《利用Python进行数据分析》适合刚刚接触Python的分析人员以及刚刚接触科学计算的Python程序员。将IPython这个交互式Shell作为你的首要开发环境。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言1</span><br><span class="line">第1章准备工作5</span><br><span class="line">本书主要内容5</span><br><span class="line">为什么要使用Python进行数据分析6</span><br><span class="line">重要的Python库7</span><br><span class="line">安装和设置10</span><br><span class="line">社区和研讨会16</span><br><span class="line">使用本书16</span><br><span class="line">致谢18</span><br><span class="line">第2章引言20</span><br><span class="line">来自bit.ly的1.usa.gov数据21</span><br><span class="line">MovieLens1M数据集29</span><br><span class="line">1880—2010年间全美婴儿姓名35</span><br><span class="line">小结及展望47</span><br><span class="line">第3章IPython：一种交互式计算和开发环境48</span><br><span class="line">IPython基础49</span><br><span class="line">内省51</span><br><span class="line">使用命令历史60</span><br><span class="line">与操作系统交互63</span><br><span class="line">软件开发工具66</span><br><span class="line">IPythonHTMLNotebook75</span><br><span class="line">利用IPython提高代码开发效率的几点提示77</span><br><span class="line">高级IPython功能79</span><br><span class="line">致谢81</span><br><span class="line">第4章NumPy基础：数组和矢量计算82</span><br><span class="line">NumPy的ndarray：一种多维数组对象83</span><br><span class="line">通用函数：快速的元素级数组函数98</span><br><span class="line">利用数组进行数据处理100</span><br><span class="line">用于数组的文件输入输出107</span><br><span class="line">线性代数109</span><br><span class="line">随机数生成111</span><br><span class="line">范例：随机漫步112</span><br><span class="line">第5章pandas入门115</span><br><span class="line">pandas的数据结构介绍116</span><br><span class="line">基本功能126</span><br><span class="line">汇总和计算描述统计142</span><br><span class="line">处理缺失数据148</span><br><span class="line">层次化索引153</span><br><span class="line">其他有关pandas的话题158</span><br><span class="line">第6章数据加载、存储与文件格式162</span><br><span class="line">读写文本格式的数据162</span><br><span class="line">二进制数据格式179</span><br><span class="line">使用HTML和WebAPI181</span><br><span class="line">使用数据库182</span><br><span class="line">第7章数据规整化：清理、转换、合并、重塑186</span><br><span class="line">合并数据集186</span><br><span class="line">重塑和轴向旋转200</span><br><span class="line">数据转换204</span><br><span class="line">字符串操作217</span><br><span class="line">示例：USDA食品数据库224</span><br><span class="line">第8章绘图和可视化231</span><br><span class="line">matplotlibAPI入门231</span><br><span class="line">pandas中的绘图函数244</span><br><span class="line">绘制地图：图形化显示海地地震危机数据254</span><br><span class="line">Python图形化工具生态系统260</span><br><span class="line">第9章数据聚合与分组运算263</span><br><span class="line">GroupBy技术264</span><br><span class="line">数据聚合271</span><br><span class="line">分组级运算和转换276</span><br><span class="line">透视表和交叉表288</span><br><span class="line">示例：2012联邦选举委员会数据库291</span><br><span class="line">第10章时间序列302</span><br><span class="line">日期和时间数据类型及工具303</span><br><span class="line">时间序列基础307</span><br><span class="line">日期的范围、频率以及移动311</span><br><span class="line">时区处理317</span><br><span class="line">时期及其算术运算322</span><br><span class="line">重采样及频率转换327</span><br><span class="line">时间序列绘图334</span><br><span class="line">移动窗口函数337</span><br><span class="line">性能和内存使用方面的注意事项342</span><br><span class="line">第11章金融和经济数据应用344</span><br><span class="line">数据规整化方面的话题344</span><br><span class="line">分组变换和分析355</span><br><span class="line">更多示例应用361</span><br><span class="line">第12章NumPy高级应用368</span><br><span class="line">ndarray对象的内部机理368</span><br><span class="line">高级数组操作370</span><br><span class="line">广播378</span><br><span class="line">ufunc高级应用383</span><br><span class="line">结构化和记录式数组386</span><br><span class="line">更多有关排序的话题388</span><br><span class="line">NumPy的matrix类393</span><br><span class="line">高级数组输入输出395</span><br><span class="line">性能建议397</span><br><span class="line">附录APython语言精要401</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00GHGZLWS/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00GHGZLWS&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51Ylp2prV-L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Azure实战</title>
    <url>/2020/04/19/B00GHGZT6G/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Windows Azure实战<br>作者信息： 作者: 白海石 [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>内容权威，微软官方资深云计算专家撰写，英文版将在海外发行    全面深入，完整覆盖Windows Azure所有关键技术和理论，详细讲解云计算开发流程、云服务架构（可用性、可靠性和高性能）、云设备整合、系统整合，以及云计算项目的管理    注重实战，68个精心策划的针对特定实际应用场景的真实案例，详细呈现案例的设计思路和完整实现步骤</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目    录</span><br><span class="line">Preface</span><br><span class="line">序</span><br><span class="line">前言</span><br><span class="line">第一部分　基础篇</span><br><span class="line">第1章　 云计算概览   2</span><br><span class="line">1.1　 云计算历史   2</span><br><span class="line">1.2　 云计算的本质   4</span><br><span class="line">1.2.1　 弹性   5</span><br><span class="line">1.2.2　 可用性   7</span><br><span class="line">1.2.3　 缩放性   8</span><br><span class="line">1.3　 Windows Azure概览   9</span><br><span class="line">1.3.1　 设施即服务   10</span><br><span class="line">1.3.2　 平台即服务   11</span><br><span class="line">1.3.3　 软件即服务   12</span><br><span class="line">1.3.4　 成本计算   14</span><br><span class="line">1.4　 准备Windows Azure的开发</span><br><span class="line">环境   14</span><br><span class="line">1.4.1　 订阅Windows Azure   15</span><br><span class="line">1.4.2　 安装软件开发工具包   15</span><br><span class="line">1.5　 熟悉Windows Azure管理门户   15</span><br><span class="line">1.5.1　 登录   16</span><br><span class="line">1.5.2　 界面结构   16</span><br><span class="line">1.6　 本章小结   18</span><br><span class="line">第2章　创建云端网站   19</span><br><span class="line">2.1　 Windows Azure WebSites   19</span><br><span class="line">2.2　 网站的发布与更新   24</span><br><span class="line">2.3　 与源代码管理系统的整合   32</span><br><span class="line">2.4　 网站的缩放   36</span><br><span class="line">2.4.1　 垂直缩放   36</span><br><span class="line">2.4.2　 水平缩放   38</span><br><span class="line">2.4.3　 自动缩放   39</span><br><span class="line">2.5　 移植现有的ASP.NET网站   39</span><br><span class="line">2.6　 使用网站模板   40</span><br><span class="line">2.7　 网站设置   44</span><br><span class="line">2.8　 网站的诊断和监视   48</span><br><span class="line">2.8.1　 网站诊断   48</span><br><span class="line">2.8.2　 网站监视   50</span><br><span class="line">2.8.3　 自定义域名   53</span><br><span class="line">2.9　 本章小结   54</span><br><span class="line">第3章　云服务入门   55</span><br><span class="line">3.1　 Windows Azure Cloud Service   55</span><br><span class="line">3.2　 角色和云服务   59</span><br><span class="line">3.2.1　 角色   60</span><br><span class="line">3.2.2　 云服务   60</span><br><span class="line">3.3　 云服务部署的基本步骤   61</span><br><span class="line">3.4　 云服务的部署和更新   67</span><br><span class="line">3.4.1　 增量更新（按更新域</span><br><span class="line">更新）   67</span><br><span class="line">3.4.2　 同时更新   67</span><br><span class="line">3.4.3　 多个部署环境   68</span><br><span class="line">3.5　 实例和负载平衡   73</span><br><span class="line">3.5.1　 实例   73</span><br><span class="line">3.5.2　 负载平衡   73</span><br><span class="line">3.6　 配置文件和定义文件   76</span><br><span class="line">3.6.1　 云服务定义文件   76</span><br><span class="line">3.6.2　 云服务配置文件   77</span><br><span class="line">3.7　 本章小结   80</span><br><span class="line">第4章　高级云服务   81</span><br><span class="line">4.1　 端点类型   81</span><br><span class="line">4.1.1　 输入端点   81</span><br><span class="line">4.1.2　 内部端点   82</span><br><span class="line">4.1.3　 实例输入端点   82</span><br><span class="line">4.2　 辅助角色   86</span><br><span class="line">4.3　 角色间通信   92</span><br><span class="line">4.4　 角色的生命周期   96</span><br><span class="line">4.4.1　 角色在虚拟机上部署和运行的过程   97</span><br><span class="line">4.4.2　 角色实例的状态   97</span><br><span class="line">4.5　 启动任务   98</span><br><span class="line">4.5.1　 定义启动任务   98</span><br><span class="line">4.5.2　 启动任务的属性   99</span><br><span class="line">4.6　 诊断与调试   104</span><br><span class="line">4.6.1　 本机开发与调试   104</span><br><span class="line">4.6.2　 Windows Azure诊断   105</span><br><span class="line">4.6.3　 IntelliTrace   111</span><br><span class="line">4.6.4　 监视云服务   117</span><br><span class="line">4.7　 开发者社区   120</span><br><span class="line">4.8　 本章小结   121</span><br><span class="line">第5章　 数据存储——关系型数据库   122</span><br><span class="line">5.1　 Windows Azure数据存储方案   122</span><br><span class="line">5.2　 SQL Database概览   123</span><br><span class="line">5.3　 管理与优化SQL Database   136</span><br><span class="line">5.3.1　 SQL Server Management Studio   136</span><br><span class="line">5.3.2　 Microsoft SQL Server Data Tools   138</span><br><span class="line">5.3.3　 动态管理视图   139</span><br><span class="line">5.3.4　 查询优化   140</span><br><span class="line">5.4　 数据的同步和复制   142</span><br><span class="line">5.4.1　 数据层应用程序   143</span><br><span class="line">5.4.2　 数据同步   147</span><br><span class="line">5.5　 使用MySQL数据库   152</span><br><span class="line">5.5.1　 Windows Azure商店   152</span><br><span class="line">5.5.2　 查看MySQL连接信息   153</span><br><span class="line">5.5.3　 自己搭建MySQL环境   154</span><br><span class="line">5.6　 本章小结   154</span><br><span class="line">第6章　 数据存储——非结构化数据   155</span><br><span class="line">6.1　 使用本地存储   155</span><br><span class="line">6.2　 Windows Azure存储服务概览   158</span><br><span class="line">6.2.1　 Windows Azure存储账户   159</span><br><span class="line">6.2.2　 创建Windows Azure存储账户   160</span><br><span class="line">6.2.3　 存储账户的密钥   160</span><br><span class="line">6.3　 使用BLOB存储   161</span><br><span class="line">6.3.1　 BLOB存储概览   161</span><br><span class="line">6.3.2　 块BLOB和页BLOB   177</span><br><span class="line">6.3.3　 ETag和快照   178</span><br><span class="line">6.3.4　 REST风格调用   178</span><br><span class="line">6.3.5　 分享访问签名和库访问策略   179</span><br><span class="line">6.3.6　 BLOB的更新、复制和租约   180</span><br><span class="line">6.3.7　 错误处理   181</span><br><span class="line">6.4　 使用表存储   181</span><br><span class="line">6.4.1　 表存储概览   181</span><br><span class="line">6.4.2　 优化数据分区   181</span><br><span class="line">6.4.3　 查询表数据   192</span><br><span class="line">6.4.4　 批处理   193</span><br><span class="line">6.4.5　 动态表实体   194</span><br><span class="line">6.4.6　 分享访问签名   194</span><br><span class="line">6.5　 使用队列存储   194</span><br><span class="line">6.5.1　 队列储概览   194</span><br><span class="line">6.5.2　 在代码中使用队列服务   195</span><br><span class="line">6.6　 监视存储账户   196</span><br><span class="line">6.6.1　 配置监视存储服务   197</span><br><span class="line">6.6.2　 监视服务的收费   198</span><br><span class="line">6.7　 本章小结   198</span><br><span class="line">第7章　虚拟机和虚拟网络   199</span><br><span class="line">7.1　 Windows Azure IaaS   199</span><br><span class="line">7.2　 映像和虚拟磁盘   206</span><br><span class="line">7.3　 虚拟机的通信   212</span><br><span class="line">7.3.1　 虚拟机的端点   212</span><br><span class="line">7.3.2　 同一个云服务下的</span><br><span class="line">虚拟机   214</span><br><span class="line">7.4　 虚拟网络   218</span><br><span class="line">7.4.1　 虚拟网络简介   218</span><br><span class="line">7.4.2　 点到站点虚拟网络   220</span><br><span class="line">7.4.3　 站点到站点虚拟网络   225</span><br><span class="line">7.5　 本章小结   226</span><br><span class="line">第二部分　架构篇</span><br><span class="line">第8章　云解决方案系统架构   228</span><br><span class="line">8.1　 服务器&#x2F;客户端   228</span><br><span class="line">8.1.1　 服务器&#x2F;客户端架构的特点   228</span><br><span class="line">8.1.2　 云平台上的服务器&#x2F;客户端架构   230</span><br><span class="line">8.1.3　 多租户系统设计   231</span><br><span class="line">8.1.4　 服务器&#x2F;客户端系统到云平台的移植   233</span><br><span class="line">8.1.5　 在Windows Azure上实现服务器&#x2F;客户端系统   234</span><br><span class="line">8.1.6　 移动客户端   234</span><br><span class="line">8.2　 服务器&#x2F;浏览器   235</span><br><span class="line">8.2.1　 服务器&#x2F;浏览器架构的特点   235</span><br><span class="line">8.2.2　 云平台上的服务器&#x2F;浏览器架构   236</span><br><span class="line">8.2.3　 将服务器&#x2F;浏览器系统移植到云平台的难点   244</span><br><span class="line">8.2.4　 在Windows Azure上实施服务器&#x2F;浏览器系统   246</span><br><span class="line">8.3　 n层体系   247</span><br><span class="line">8.3.1　 n层体系的特点   248</span><br><span class="line">8.3.2　 n层体系、MVC和MVVM   249</span><br><span class="line">8.3.3　 Windows Azure服务总线队列服务简介   252</span><br><span class="line">8.3.4　 在Windows Azure上实现n层体系结构   255</span><br><span class="line">8.4　 分布式系统   264</span><br><span class="line">8.4.1　 基于消息的连接   264</span><br><span class="line">8.4.2　 中继连接   268</span><br><span class="line">8.5　 本章小结   274</span><br><span class="line">第9章　高可用性设计   275</span><br><span class="line">9.1　 高可用性设计的策略   275</span><br><span class="line">9.1.1　 冗余   275</span><br><span class="line">9.1.2　 负载平衡   276</span><br><span class="line">9.1.3　 容错转移   276</span><br><span class="line">9.2　 负载平衡与健康检测器   281</span><br><span class="line">9.3　 竞争消费者模式   283</span><br><span class="line">9.3.1　 松散耦合   283</span><br><span class="line">9.3.2　 动态负载平衡   283</span><br><span class="line">9.3.3　 动态缩放   284</span><br><span class="line">9.3.4　 容错转移   284</span><br><span class="line">9.4　 本章小结   287</span><br><span class="line">第10章　高可靠性设计   288</span><br><span class="line">10.1　 可靠性、可维护性与可用性   288</span><br><span class="line">10.1.1　 可用性   288</span><br><span class="line">10.1.2　 可靠性   288</span><br><span class="line">10.1.3　 可维护性   289</span><br><span class="line">10.1.4　 相互关系   289</span><br><span class="line">10.2　 错误类型   289</span><br><span class="line">10.2.1　 运营中的错误   290</span><br><span class="line">10.2.2　 系统状态错误   290</span><br><span class="line">10.2.3　 系统设计与实施错误   290</span><br><span class="line">10.3　 瞬时错误   291</span><br><span class="line">10.4　 可靠性设计   294</span><br><span class="line">10.4.1　 单一失效点   294</span><br><span class="line">10.4.2　 可靠性编程原则   296</span><br><span class="line">10.5　 本章小结   298</span><br><span class="line">第11章　高性能设计   299</span><br><span class="line">11.1　 Windows Azure缓存服务   299</span><br><span class="line">11.1.1　 缓存服务简介   299</span><br><span class="line">11.1.2　 缓存的部署方式   300</span><br><span class="line">11.1.3　 缓存功能介绍   303</span><br><span class="line">11.1.4　 并发模式   305</span><br><span class="line">11.1.5　 本地缓存   305</span><br><span class="line">11.1.6　 会话状态   306</span><br><span class="line">11.2　 Windows Azure CDN服务   310</span><br><span class="line">11.3　 异步操作和并发操作   313</span><br><span class="line">11.4　 本章小结   314</span><br><span class="line">第12章　基于声明的体系架构   315</span><br><span class="line">12.1　 基于声明的验证和授权   316</span><br><span class="line">12.1.1　 基本流程   317</span><br><span class="line">12.1.2　 身份验证协议与WIF   318</span><br><span class="line">12.1.3　 身份验证代理   318</span><br><span class="line">12.2　 Windows Azure AD基础   320</span><br><span class="line">12.2.1　 管理Windows Azure租户和用户   321</span><br><span class="line">12.2.2　 Graph API   332</span><br><span class="line">12.3　 Windows Azure AD新增功能   337</span><br><span class="line">12.4　 本章小结   338</span><br><span class="line">第三部分　设备篇</span><br><span class="line">第13章　移动服务   340</span><br><span class="line">13.1　 移动服务概览   340</span><br><span class="line">13.2　 消息推送   348</span><br><span class="line">13.3　 计划程序与API   354</span><br><span class="line">13.4　 本章小结   356</span><br><span class="line">第14章　物联网   357</span><br><span class="line">14.1　 物联网概览   357</span><br><span class="line">14.1.1　 射频识别   358</span><br><span class="line">14.1.2　 人工智能设备   358</span><br><span class="line">14.1.3　 可穿戴设备   358</span><br><span class="line">14.1.4　 无线传感器网络   359</span><br><span class="line">14.2　 设备与云服务   359</span><br><span class="line">14.2.1　 设备对云的意义   359</span><br><span class="line">14.2.2　 云对设备的意义   360</span><br><span class="line">14.3　 物联网的挑战   361</span><br><span class="line">14.4　 .NET Micro Framework   362</span><br><span class="line">14.4.1　 .NET Micro Framework概览   362</span><br><span class="line">14.4.2　 .NET Gadgeteer简介   364</span><br><span class="line">14.4.3　 设备的整合案例   368</span><br><span class="line">14.5　 本章小结   373</span><br><span class="line">第四部分　企业篇</span><br><span class="line">第15章　基于消息整合   376</span><br><span class="line">15.1　 系统整合   376</span><br><span class="line">15.1.1　 通过数据整合   376</span><br><span class="line">15.1.2　 共享业务功能   377</span><br><span class="line">15.1.3　 企业服务总线   377</span><br><span class="line">15.2　 基于消息的系统整合模式   378</span><br><span class="line">15.2.1　 基于内容的消息路由（Content-based Routing）   379</span><br><span class="line">15.2.2　 优先级队列   382</span><br><span class="line">15.2.3　 请求&#x2F;响应   382</span><br><span class="line">15.2.4　 死信队列   385</span><br><span class="line">15.2.5　 事件驱动的消费者   388</span><br><span class="line">15.3　 高级消息队列协议   390</span><br><span class="line">15.3.1　 AMQP简介   390</span><br><span class="line">15.3.2　 业界对AMQP的支持   391</span><br><span class="line">15.4　 基于消息集成的优势   397</span><br><span class="line">15.5　 本章小结   398</span><br><span class="line">第16章　源代码和项目管理   399</span><br><span class="line">16.1　 创建TFS账户   399</span><br><span class="line">16.2　 使用TFS管理源代码   400</span><br><span class="line">16.3　 创建和使用单元测试   405</span><br><span class="line">16.4　 本章小结   410</span><br><span class="line">第17章　脚本和自动化   411</span><br><span class="line">17.1　 Windows Azure PowerShell命令集   411</span><br><span class="line">17.1.1　 准备Windows Azure PowerShell命令集环境   411</span><br><span class="line">17.1.2　 管理虚拟机   412</span><br><span class="line">17.1.3　 管理云服务   415</span><br><span class="line">17.1.4　 管理网站   416</span><br><span class="line">17.1.5　 其他管理命令   417</span><br><span class="line">17.2　 Windows Azure 命令行工具  417</span><br><span class="line">17.2.1　 安装命令行工具   417</span><br><span class="line">17.2.2　 使用命令行工具   418</span><br><span class="line">17.3　 Windows Azure管理应用程序接口   418</span><br><span class="line">17.4　 本章小结   421</span><br><span class="line">结语　云之禅   422</span><br><span class="line">附录A　 云计算术语中英文对照表   424</span><br><span class="line">附录B　英文缩写对照表   429</span><br><span class="line">附录C　扩展概念   432</span><br><span class="line">参考文献   442 </span><br><span class="line"></span><br><span class="line"> 实例目录 实例1： 您好，Windows Azure网站！ 19 实例2： 使用WebMatrix更新网站 25 实例3： 使用FTP发布和更新PHP 网站 28 实例4： 使用Git发布和更新网站 32 实例5： 创建基于Drupal的网站 40 实例6： 网站应用设置实例——描绘用 户输入函数的图像 44 实例7： 您好，Windows Azure云服务！ 55 实例8： 部署云服务 62 实例9： 通过管理门户部署云服务与VIP交换 69 实例10： 云服务的水平缩放 74 实例11： 配置网站服务的HTTPS 端点 82 实例12： 使用UDP端口的辅助角色 87 实例13： 使用Web前端和后台服务 93 实例14： 启动任务——将图片转化成文本网页 99 实例15： 配置Windows Azure诊断 106 实例16： 使用IntelliTrace求最大公约数 112 实例17： 使用SQL Database创建在线订单系统 125 实例18： 使用SSMSE创建订单视图 136 实例19： 使用动态管理视图（DMV） 139 实例20： 使用SQL Database管理界面 141 实例21： 使用.bacpac和.dacpac 143 实例22： SQL Server和SQL Database的数据同步 147 实例23： 本地存储——数据文件生成服务 155 实例24： 通过Visual Studio管理BLOB服务 162 实例25： BLOB服务——在线照片管理 164 实例26： 通过Visual Studio 管理表服务 182 实例27： 使用表服务——猜动物游戏 183 实例28： 通过Visual Studio 管理队列服务 195 实例28： 您好，Windows虚拟机！ 199 实例29： 您好，Linux虚拟机！ 204 实例30： 使用数据磁盘 206 实例31： 创建和使用虚拟机映像 210 实例32： 在Linux虚拟机上配置和运行Node.js 212 实例33： 同一云服务内虚拟机的通信 214 实例34： 虚拟机间负载平衡 215 实例35： 创建Windows Azure虚拟 网络 218 实例36： 创建点到站点虚拟网络——本地与云端的文件共享 221 实例37： 多网站与租户限流 236 实例38： ASP.NET Web API和MVVM 249 实例39： 管理服务总线命名空间和消息队列 253 实例40： 使用服务总线队列服务实现异步通信——翻译服务 256 实例41： 服务总线的主题&#x2F;订阅——简单的聊天程序 264 实例42： 中继服务——WCF Mastermind游戏 269 实例43： 交通管理服务——跨地域容错转移 276 实例44： 竞争消费者模式演示 284 实例45： 使用瞬时错误处理应用 程序库 292 实例46： 使用缓存服务 300 实例47： 使用外部会话状态提供者 307 实例48： 使用CDN发布存储账户中的内容 311 实例49： 使用Windows Azure AD验证用户身份 323 实例50： 使用Graph API 332 实例51： 使用移动服务支持Windows商店应用 341 实例52： 移动服务后台编程 344 实例53： 推送到Windows设备 349 实例54： 计划程序 354 实例55： API 355 实例56： 您好，嵌入式设备！ 362 实例57： 简易摄像机 365 实例58： 入侵者报警系统 368 实例59： 基于内容的消息路由 380 实例60： 请求&#x2F;响应模式 383 实例61： 死信队列 386 实例62： 事件驱动消费者 388 实例63： 通过AMQP实现系统整合 392 实例64： 使用TFS管理源代码 401 实例65： 创建和使用单元测试 406 实例66： 封闭签入 408 实例67： 用Windows Azure PowerShell管理虚拟机 413 实例68： 使用Windows Azure管理应用程序接口 419</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00GHGZT6G/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00GHGZT6G&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41qdex8oX7L._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>如何创造思维 人类思想所揭示出的奥秘</title>
    <url>/2020/04/19/B00GZGVIPO/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 如何创造思维 人类思想所揭示出的奥秘<br>作者信息： 作者: 雷•库兹韦尔 (Ray Kurzweil) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《如何创造思维》作者雷·库兹韦尔是21世纪最具洞察力的思想家和未来学家、“库兹韦尔定律”创立者，美国发明家名人堂获奖者、美国国家技术奖获得者、奇点大学校长、谷歌公司工程总监雷•库兹韦尔最新力作。 这是一部洞悉未来思维模式的颠覆之作。库兹韦尔对于大脑和人工智能的理解，将对我们生活的方方面面，地球上的各行各异，以及我们有关未来的设想产生巨大的影响。库兹韦尔通过一系列推理告诉我们，我们有能力创造超越人类智能的非生物智能。财讯传媒集团首席战略官段永超，跨界物理学家李淼，中国当代最知名的科幻作家、畅销书《三体》作者刘慈欣联袂推荐。湛庐文化出品。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">各方赞誉</span><br><span class="line">推荐序 解放思想</span><br><span class="line">段永朝.跨界思想家财讯传媒集团首席战略官</span><br><span class="line">前言 揭开人脑思维的奥秘</span><br><span class="line">第1章 自然界的思想实验</span><br><span class="line">历史上出现过很多著名的思想实验，特别是关于自然界的思想实验，爱因斯坦的“驾乘光束”实验就是其一。研究大脑，也可以采用同样的办法。通过简单的思想实验，我们就能很好地理解人类智慧是怎么一回事儿。</span><br><span class="line">思想实验1：大峡谷和大洞穴的形成</span><br><span class="line">思想实验2：驾乘光束</span><br><span class="line">大脑新皮质的统一模式 </span><br><span class="line"></span><br><span class="line"> 第2章 思考的思想实验 大脑和计算机都能存储和处理信息，但是，大脑和计算机之间的相似性可不只是看上去那么简单。大脑的记忆是层级结构和连贯有序的。记忆奇妙地出现在你的脑海里，一定是某些事物触发了它们。 思考，人脑不同于计算机 记忆是连贯有序的 联想因触发而生 记忆的结构是层级的</span><br><span class="line"></span><br><span class="line"> 第3章 大脑新皮质模型 大脑新皮质分 6层，共包含 300亿个神经元，它们又组成了 3亿个模式识别器。这些模式识别器按层级关系组织，它们是思想的语言和思维模式识别理论的基础。只有具备自联想能力和特征恒常性能力，大脑新皮质才能识别模式。思维模式分两种：无目标思维和导向式思维，做梦就是无目标思维实例。 分层模式 模式结构 流向大脑新皮质模式识别器的数据本质 自联想和恒常性 学习 思想的语言 梦的语言 模型的根源 第4章 人类的大脑新皮质 尽管进化带来的改变并不总是朝着更高的智力水平前进，但是，智力仍是一个重要的进化分支。大脑新皮质的分层学习能力如此重要，以至于它在进化过程中体积越来越大，并最终成为大脑的主体。大脑运转时，并不以神经元为基础，而是神经元集合。 智力，一个重要的进化分支 新皮质的分层学习能力 积木式神经元集合 视觉皮质与通用算法</span><br><span class="line"></span><br><span class="line"> 第5章 旧脑 虽然大脑新皮质已成为大脑的主体，但我们的旧脑并未消失，仍在帮助我们寻求满足和躲避危险。丘脑的突出作用是与新皮质持续联络，海马体存储最新记忆，而小脑则负责人体动作的协调。 感觉传导路 丘脑 海马体 小脑 快乐与恐惧</span><br><span class="line"></span><br><span class="line"> 第6章 卓越的能力 人类的卓越能力，主要归功于大脑脑岛中的纺锤体细胞。大脑新皮质某些区域的优化，使其更善于处理联合模式，这就是天分的由来。跨领域合作和非生物大脑新皮质的云端存储，将让我们更富有创造力。从进化观点看，爱情的存在就缘于大脑新皮质的需求。 天分 创造力 爱情</span><br><span class="line"></span><br><span class="line"> 第7章 仿生数码新皮质 我们现在已能模拟包含 160万个视觉神经元的人脑视觉新皮质，模拟完整人类大脑的目标，预计 2023年就可实现。“矢量量化”方法既能高效利用计算机资源，又能保留重要的语言识别特征。“隐马尔可夫模型”让语音识别系统能同时完成识别和学习两项任务。 脑模拟 神经网络 矢量量化 用隐马尔可夫模型解读你的思维 进化（遗传）算法 列表处理语言LISP 分层储存系统 人工智能的前沿：登上能力层级顶端 创造思维的策略 第8章 计算机思维的4大基础 尽管人脑的思维模式极为精巧，我们仍可通过软件对人脑进行模拟。要想做到这一点，计算机必须要具备准确的沟通、记忆和计算能力，具有计算的通用性和冯 •诺依曼结构，并且能够按大脑核心算法进行创造性思维。 基础1：准确的沟通、记忆和计算能力 基础2：计算的通用性 基础3：冯•诺依曼结构 基础4：按大脑核心算法进行创造性思考</span><br><span class="line"></span><br><span class="line"> 第9章 思维的思想实验3 意识来源于复杂物理系统的“涌现特性”（emergent property），“感受性”（qualia）是其突出特征。成功模拟人脑的计算机也是有意识的。思维就是有意识大脑所进行的活动。非生物学意义上的“人”将于 2029年出现。将非生物系统引入人脑，不会改变我们的身份，但却产生了另外一个“我”。把我们的大部分思想储存在云端，人类就能实现“永生”。 谁是有意识的 你必须有信仰 我们能够意识到什么呢 东方是东方，西方是西方自由 意志身份 第10章 有关思维的库兹韦尔定律 信息技术的发展，都遵循着库兹韦尔定律，与思维相关的技术也不例外。随着人类基因组计划的实施，生物医学已成为一项信息技术，并呈指数型发展。在互联网上，每秒比特的传递量每 16个月就翻一番。磁共振成像技术，也以指数级速度稳定发展，目前的空间分辨率已接近 100微米。 生物医学 信息传输 大脑研究</span><br><span class="line"></span><br><span class="line"> 第11章 反对的声音 库兹韦尔定律及其在人类智能提高方面的应用，也招致了不少批评。保罗 • 艾伦对“指数发展”说完全持否定态度。罗杰斯 • 彭罗斯认为，计算机无法像人脑那样进行量子计算。约翰 • 赛尔说，计算机即便能够通过图灵测试，它也不知道自己在做些什么。 “奇点遥远”论 “量子计算能力缺失”论 “无意识”论 后记 拥抱“奇点” 注释 译者后记</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00GZGVIPO/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00GZGVIPO&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51yhxDwyqjL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js高级编程</title>
    <url>/2020/04/19/B00H7V7O90/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Node.js高级编程<br>作者信息： 作者: 特谢拉 (Teixeira P.) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Node.js是一种主流框架，它允许你使用JavaScript快速构建具有高度可伸缩性的网络程序。可是，它有自己的学习曲线，特谢拉编著的《Node.js高级编程》这本较为深入的指南性图书首先介绍了Node.js平台的安装，然后重点关注：创建和加载模块；使用缓冲区对二进制数据进行处理、编码和编码；用事件发射器模式简化事件绑定等。本书还涵盖了从使用定时器制定函数执行计划到创建和控制外部进程等内容，可以让你为运行、构建和测试自定义模块做好准备。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第Ⅰ部分  概述和安装</span><br><span class="line">第1章  安装Node 3</span><br><span class="line">1.1  在Windows上安装Node 4</span><br><span class="line">1.2  在MAC OS X上安装Node 6</span><br><span class="line">1.3  使用源代码安装Node 7</span><br><span class="line">1.3.1  选择Node的版本 7</span><br><span class="line">1.3.2  下载Node源代码 7</span><br><span class="line">1.3.3  编译Node 8</span><br><span class="line">1.3.4  安装Node 8</span><br><span class="line">1.3.5  运行Node 8</span><br><span class="line">1.4  安装和应用Node包管理器 9</span><br><span class="line">1.5  本章小结 14</span><br><span class="line">第2章  Node简介 15</span><br><span class="line">2.1  事件驱动编程风格介绍 16</span><br><span class="line">2.2  Node和JavaScript如何简化异步应用程序的编写 17</span><br><span class="line">2.2.1  什么是闭包 17</span><br><span class="line">2.2.2  闭包如何辅助异步编程 18</span><br><span class="line">2.3  本章小结 19</span><br><span class="line">第Ⅱ部分  Node核心API基础</span><br><span class="line">第3章  加载模块 23</span><br><span class="line">3.1  理解Node如何加载模块 24</span><br><span class="line">3.2  导出模块 24</span><br><span class="line">3.3  加载模块 25</span><br><span class="line">3.3.1  加载核心模块 25</span><br><span class="line">3.3.2  加载文件模块 26</span><br><span class="line">3.3.3  加载文件夹模块 26</span><br><span class="line">3.3.4  从node_modules文件夹加载 26</span><br><span class="line">3.3.5  缓存模块 27</span><br><span class="line">3.4  本章小结 28</span><br><span class="line">第4章  应用缓冲区处理、编码和解码二进制数据 29</span><br><span class="line">4.1  创建缓冲区 30</span><br><span class="line">4.2  在缓冲区中获取和设置数据 30</span><br><span class="line">4.3  切分缓冲区 31</span><br><span class="line">4.4  复制缓冲区 32</span><br><span class="line">4.5  缓冲区解码 32</span><br><span class="line">4.6  本章小结 33</span><br><span class="line">第5章  使用事件发射器模式简化事件绑定 35</span><br><span class="line">5.1  理解标准回调模式 35</span><br><span class="line">5.2  理解事件发射器模式 36</span><br><span class="line">5.3  理解事件类型 37</span><br><span class="line">5.4  应用事件发生器API 38</span><br><span class="line">5.4.1  使用.addListener( )或.on( )绑定回调函数 38</span><br><span class="line">5.4.2  绑定多个事件监听器 39</span><br><span class="line">5.4.3  使用.removeListener( )从事件发射器中删除一个事件监听器 40</span><br><span class="line">5.4.4  使用.once()使回调函数最多执行一次 40</span><br><span class="line">5.4.5  使用.removeAllListeners()从事件发射器删除所有事件监听器 41</span><br><span class="line">5.5  创建事件发射器 41</span><br><span class="line">5.5.1  从Node事件发射器继承 41</span><br><span class="line">5.5.2  发射事件 42</span><br><span class="line">5.6  本章小结 42</span><br><span class="line">第6章  使用定时器制定函数执行计划 45</span><br><span class="line">6.1  使用setTimeout推迟函数执行 46</span><br><span class="line">6.2  使用clearTimeout取消函数执行 46</span><br><span class="line">6.3  制定和取消函数的重复执行计划 47</span><br><span class="line">6.4  使用process.nextTick将函数执行推迟到下一轮事件循环 47</span><br><span class="line">6.5  阻塞事件循环 48</span><br><span class="line">6.6  退出事件循环 49</span><br><span class="line">6.7  使用setTimeout代替setInterval强制函数串行执行 49</span><br><span class="line">6.8  本章小结 50</span><br><span class="line">第Ⅲ部分  文件、进程、流和网络</span><br><span class="line">第7章  查询和读写文件 53</span><br><span class="line">7.1  处理文件路径 54</span><br><span class="line">7.1.1  规范化路径 54</span><br><span class="line">7.1.2  连接路径 54</span><br><span class="line">7.1.3  解析路径 55</span><br><span class="line">7.1.4  查找两个绝对路径之间的相对路径 55</span><br><span class="line">7.1.5  提取路径的组成部分 55</span><br><span class="line">7.1.6  确定路径是否存在 56</span><br><span class="line">7.2  fs模块简介 57</span><br><span class="line">7.3  打开文件 58</span><br><span class="line">7.4  读取文件 58</span><br><span class="line">7.4.1  写入文件 59</span><br><span class="line">7.4.2  关闭文件 60</span><br><span class="line">7.5  本章小结 62</span><br><span class="line">第8章  创建和控制外部进程 63</span><br><span class="line">8.1  执行外部命令 63</span><br><span class="line">8.2  生成子进程 68</span><br><span class="line">8.2.1  创建子进程 68</span><br><span class="line">8.2.2  监听子进程的输出数据 69</span><br><span class="line">8.2.3  向子进程发送数据 69</span><br><span class="line">8.2.4  当子进程退出时获得通知 71</span><br><span class="line">8.3  向进程发送信号并终止进程 72</span><br><span class="line">8.4  本章小结 73</span><br><span class="line">第9章  读写数据流 75</span><br><span class="line">9.1  使用可读流 76</span><br><span class="line">9.1.1  等待数据 76</span><br><span class="line">9.1.2  暂停与恢复流 76</span><br><span class="line">9.1.3  了解流何时终止 77</span><br><span class="line">9.2  使用可写流 77</span><br><span class="line">9.2.1  将数据写入流 77</span><br><span class="line">9.2.2  等待流被清空 78</span><br><span class="line">9.3  考虑几个流的例子 78</span><br><span class="line">9.3.1  创建文件系统流 78</span><br><span class="line">9.3.2  理解网络流 80</span><br><span class="line">9.4  避免慢客户端问题以及挽救服务器 80</span><br><span class="line">9.4.1  理解慢客户端问题 80</span><br><span class="line">9.4.2  避免慢客户端问题 81</span><br><span class="line">9.4.3  应用stream.pipe()避免慢客户端问题与使用pipe()集成可读流和可写流 81</span><br><span class="line">9.5  本章小结 82</span><br><span class="line">第10章  构建TCP服务器 83</span><br><span class="line">10.1  创建TCP服务器 83</span><br><span class="line">10.1.1  应用套接字对象 85</span><br><span class="line">10.1.2  理解空闲套接字 86</span><br><span class="line">10.1.3  设置保持运行 87</span><br><span class="line">10.1.4  应用延时或非延时 87</span><br><span class="line">10.1.5  监听连接 88</span><br><span class="line">10.1.6  关闭服务器 88</span><br><span class="line">10.1.7  处理错误 88</span><br><span class="line">10.2  构建一个简单的TCP聊天服务器 89</span><br><span class="line">10.2.1  接受连接 89</span><br><span class="line">10.2.2  从连接中读取数据 89</span><br><span class="line">10.2.3  聚合所有客户端 90</span><br><span class="line">10.2.4  广播数据 91</span><br><span class="line">10.2.5  删除被关闭的连接 91</span><br><span class="line">10.2.6  使用TCP聊天服务器 92</span><br><span class="line">10.3  本章小结 93</span><br><span class="line">第11章  构建HTTP服务器 95</span><br><span class="line">11.1  理解http.ServerRequest对象 96</span><br><span class="line">11.2  理解http.ServerResponse对象 98</span><br><span class="line">11.2.1  写入响应头 98</span><br><span class="line">11.2.2  修改或设置响应头 98</span><br><span class="line">11.2.3  删除响应头 99</span><br><span class="line">11.2.4  写入一块响应主体 99</span><br><span class="line">11.3  以流的形式传送HTTP分块响应 99</span><br><span class="line">11.3.1  传送文件 99</span><br><span class="line">11.3.2  传送其他进程的输出 100</span><br><span class="line">11.4  关闭服务器 100</span><br><span class="line">11.5  示例1：构建提交静态文件的服务器 101</span><br><span class="line">11.6  示例2：使用HTTP分块响应和定时器 102</span><br><span class="line">11.7  本章小结 102</span><br><span class="line">第12章  构建TCP客户端 103</span><br><span class="line">12.1  连接服务器 104</span><br><span class="line">12.2  发送和接收数据 104</span><br><span class="line">12.3  终止连接 105</span><br><span class="line">12.4  处理错误 106</span><br><span class="line">12.5  创建命令行TCP客户端的示例 106</span><br><span class="line">12.5.1  连接服务器 107</span><br><span class="line">12.5.2  向服务器发送命令行 107</span><br><span class="line">12.5.3  打印服务器消息 107</span><br><span class="line">12.5.4  在连接终止时重新连接 108</span><br><span class="line">12.5.5  关闭连接 110</span><br><span class="line">12.5.6  前述内容综合 111</span><br><span class="line">12.6  本章小结 112</span><br><span class="line">第13章  创建HTTP请求 113</span><br><span class="line">13.1  创建GET请求 113</span><br><span class="line">13.2  使用其他HTTP动词 114</span><br><span class="line">13.2.1  查看响应对象 115</span><br><span class="line">13.2.2  获取响应主体 116</span><br><span class="line">13.2.3  以流的方式传送响应主体 116</span><br><span class="line">13.3  使用HTTP.Agent维护套接字池 116</span><br><span class="line">13.4  应用第三方请求模块简化HTTP请求 118</span><br><span class="line">13.4.1  安装和应用request模块 118</span><br><span class="line">13.4.2  创建测试服务器 119</span><br><span class="line">13.4.3  跟随重定向 121</span><br><span class="line">13.4.4  设置请求选项 122</span><br><span class="line">13.4.5  对请求体进行编码 125</span><br><span class="line">13.4.6  流式传送 126</span><br><span class="line">13.4.7  使用Cookie Jar 127</span><br><span class="line">13.5  本章小结 127</span><br><span class="line">第14章  使用用户数据报 129</span><br><span class="line">14.1  理解用户数据报 129</span><br><span class="line">14.2  理解用户数据报的使用 130</span><br><span class="line">14.3  构建数据报服务器 130</span><br><span class="line">14.3.1  监听消息 130</span><br><span class="line">14.3.2  测试服务器 131</span><br><span class="line">14.3.3  查看附加的消息信息 132</span><br><span class="line">14.4  创建简单的数据报回送服务器 132</span><br><span class="line">14.4.1  等待消息 132</span><br><span class="line">14.4.2  向发送端发回消息 132</span><br><span class="line">14.4.3  前述内容综合 133</span><br><span class="line">14.5  构建数据报客户端 133</span><br><span class="line">14.5.1  创建客户端 134</span><br><span class="line">14.5.2  发送消息 134</span><br><span class="line">14.5.3  关闭套接字 134</span><br><span class="line">14.6  创建一个简单的数据报命令行客户端 134</span><br><span class="line">14.6.1  读取命令行 135</span><br><span class="line">14.6.2  向服务器发送数据 135</span><br><span class="line">14.6.3  从服务器接收数据 135</span><br><span class="line">14.6.4  前述内容综合 136</span><br><span class="line">14.7  理解和使用数据报多播 136</span><br><span class="line">14.7.1  接收多播消息 137</span><br><span class="line">14.7.2  发送多播消息 137</span><br><span class="line">14.7.3  理解数据报最大容量 138</span><br><span class="line">14.8  本章小结 138</span><br><span class="line">第15章  用TLS&#x2F;SSL保证服务器的安全性 139</span><br><span class="line">15.1  理解私钥和公钥 139</span><br><span class="line">15.1.1  产生私钥 140</span><br><span class="line">15.1.2  产生公钥 140</span><br><span class="line">15.2  构建TLS服务器 140</span><br><span class="line">15.2.1  初始化服务器 141</span><br><span class="line">15.2.2  监听连接 141</span><br><span class="line">15.2.3  从客户端读取数据 142</span><br><span class="line">15.2.4  向客户端发送数据 142</span><br><span class="line">15.2.5  终止连接 142</span><br><span class="line">15.3  构建TLS客户端 142</span><br><span class="line">15.3.1  初始化客户端 143</span><br><span class="line">15.3.2  连接服务器 143</span><br><span class="line">15.3.3  验证服务器证书 143</span><br><span class="line">15.3.4  向服务器发送数据 144</span><br><span class="line">15.3.5  从服务器读取数据 144</span><br><span class="line">15.3.6  终止连接 144</span><br><span class="line">15.4  创建几个示例 144</span><br><span class="line">15.4.1  创建TLS聊天服务器 145</span><br><span class="line">15.4.2  创建TLS命令行聊天客户端 146</span><br><span class="line">15.4.3  验证客户端证书 147</span><br><span class="line">15.5  本章小结 148</span><br><span class="line">第16章  用HTTPS保证HTTP服务器的安全性 149</span><br><span class="line">16.1  构建安全的HTTP服务器 149</span><br><span class="line">16.1.1  设置服务器选项 150</span><br><span class="line">16.1.2  监听连接 150</span><br><span class="line">16.1.3  验证HTTPS客户端证书 151</span><br><span class="line">16.2  创建HTTPS客户端 152</span><br><span class="line">16.2.1  初始化客户端 152</span><br><span class="line">16.2.2  创建请求 152</span><br><span class="line">16.2.3  验证HTTPS服务器证书 153</span><br><span class="line">16.3  本章小结 154</span><br><span class="line">第Ⅳ部分  构建与调试模块及应用程序</span><br><span class="line">第17章  测试模块及应用程序 157</span><br><span class="line">17.1  应用测试运行工具 157</span><br><span class="line">17.1.1  编写测试 158</span><br><span class="line">17.1.2  运行测试 159</span><br><span class="line">17.2  使用断言测试模块 159</span><br><span class="line">17.2.1  使用断言模块 159</span><br><span class="line">17.2.2  使用Node-Tap中的内置断言函数 161</span><br><span class="line">17.3  测试异步模块 163</span><br><span class="line">17.4  本章小结 166</span><br><span class="line">第18章  调试模块及应用程序 167</span><br><span class="line">18.1  使用console.log 167</span><br><span class="line">18.2  使用Node内置调试器 169</span><br><span class="line">18.3  使用Node检查器 173</span><br><span class="line">18.4  本章小结 175</span><br><span class="line">第19章  控制回调流程 177</span><br><span class="line">19.1  理解飞去来器效应 177</span><br><span class="line">19.2  通过声明函数避免飞去来器效应 179</span><br><span class="line">19.3  使用ASYNC流程控制库 183</span><br><span class="line">19.3.1  串行执行 184</span><br><span class="line">19.3.2  并行执行 185</span><br><span class="line">19.3.3  连续传递 186</span><br><span class="line">19.3.4  排队 187</span><br><span class="line">19.3.5  迭代 189</span><br><span class="line">19.3.6  映射 190</span><br><span class="line">19.3.7  规约 191</span><br><span class="line">19.3.8  过滤 192</span><br><span class="line">19.3.9  检测 193</span><br><span class="line">19.4  本章小结 194</span><br><span class="line">第Ⅴ部分  构建Web应用程序</span><br><span class="line">第20章  构建和使用HTTP中间件 197</span><br><span class="line">20.1  理解Connect HTTP中间件框架 198</span><br><span class="line">20.2  构建自定义HTTP中间件 198</span><br><span class="line">20.2.1  创建异步中间件 199</span><br><span class="line">20.2.2  在中间件内部注册回调函数 201</span><br><span class="line">20.2.3  在中间件内处理错误 202</span><br><span class="line">20.3  使用捆绑在Connect中的HTTP中间件 206</span><br><span class="line">20.3.1  记录请求 206</span><br><span class="line">20.3.2  处理错误 208</span><br><span class="line">20.3.3  提交静态文件 209</span><br><span class="line">20.3.4  解析查询字符串 210</span><br><span class="line">20.3.5  解析请求主体 211</span><br><span class="line">20.3.6  解析Cookies 212</span><br><span class="line">20.3.7  使用会话 213</span><br><span class="line">20.3.8  其他可用的中间件 216</span><br><span class="line">20.4  本章小结 216</span><br><span class="line">第21章  用Express.js创建Web应用程序 217</span><br><span class="line">21.1  初始化Express.js应用程序 218</span><br><span class="line">21.2  在应用程序中设置中间件 220</span><br><span class="line">21.3  路由请求 222</span><br><span class="line">21.3.1  处理路由 222</span><br><span class="line">21.3.2  使用会话 229</span><br><span class="line">21.3.3  使用路由中间件 234</span><br><span class="line">21.4  本章小结 238</span><br><span class="line">第22章  使用Socket.IO创建通用的实时Web应用程序 241</span><br><span class="line">22.1  理解WebSockets如何工作 242</span><br><span class="line">22.2  使用Socket.IO创建WebSocket应用程序 243</span><br><span class="line">22.2.1  在服务器上安装和运行Socket.IO 243</span><br><span class="line">22.2.2  使用Socket.IO创建实时网络聊天应用程序 245</span><br><span class="line">22.2.3  扩展聊天应用程序 250</span><br><span class="line">22.2.4  检测连接断开 253</span><br><span class="line">22.2.5  将用户分隔到聊天室中 255</span><br><span class="line">22.2.6  使用名称空间 259</span><br><span class="line">22.2.7  使用Redis分布运行服务器端应用程序 260</span><br><span class="line">22.3  本章小结 263</span><br><span class="line">第Ⅵ部分  连接数据库</span><br><span class="line">第23章  使用node-mysql连接MySQL数据库 267</span><br><span class="line">23.1  应用库与MySQL数据库进行连接和通信 267</span><br><span class="line">23.2  向数据库添加数据时请记住安全性 269</span><br><span class="line">23.3  高效读取数据 272</span><br><span class="line">23.4  本章小结 276</span><br><span class="line">第24章  使用Nano连接CouchDB数据库 277</span><br><span class="line">24.1  安装Nano 278</span><br><span class="line">24.2  连接和创建数据库 281</span><br><span class="line">24.3  存储文档 285</span><br><span class="line">24.4  创建和使用CouchDB视图 286</span><br><span class="line">24.5  将文件附加到CouchDB文档上 299</span><br><span class="line">24.6  本章小结 312</span><br><span class="line">第25章  使用Mongoose连接MongoDB 数据库 313</span><br><span class="line">25.1  安装Mongoose 315</span><br><span class="line">25.2  理解Mongoose如何使用模型封装对数据库的访问 315</span><br><span class="line">25.3  连接MongoDB数据库 316</span><br><span class="line">25.4  定义模式 316</span><br><span class="line">25.5  定义模型 316</span><br><span class="line">25.5.1  使用验证器 326</span><br><span class="line">25.5.2  使用修改器 332</span><br><span class="line">25.5.3  使用取值器 333</span><br><span class="line">25.5.4  使用虚拟属性 334</span><br><span class="line">25.5.5  使用默认值 340</span><br><span class="line">25.5.6  定义索引 341</span><br><span class="line">25.5.7  使用DB Refs引用其他文档 343</span><br><span class="line">25.5.8  定义实例方法 349</span><br><span class="line">25.5.9  定义静态方法 350</span><br><span class="line">25.6  本章小结 351</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00H7V7O90/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00H7V7O90&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51XuMD05HiL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言技术手册(第2版)</title>
    <url>/2020/04/19/B00H93EFGG/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： R语言技术手册(第2版)<br>作者信息： 作者: Joseph Adler [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>如果你选择R语言用于统计计算和数据可视化，那么《R语言技术手册(影印版第2版)》将可以为你提供开源R语言及其软件环境的快速实用指南。你将学习如何编写R函数和使用R包来帮助你准备、可视化和分析数据。本书作者Joseph Adler(艾德勒)讲解了来自医药、商业和体育方面大量实例的处理过程。    本次第二版更新基于R语言2.14和2.15版本，包括了这样一些新的扩展章节：R性能、ggplot2数据可视化包和基于Hadoop的并行R计算。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Preface</span><br><span class="line">Part Ⅰ. R Basics</span><br><span class="line">  1. Getting and Installing R</span><br><span class="line">  R Versions</span><br><span class="line">  Getting and Installing Interactive R Binaries</span><br><span class="line">  Windows</span><br><span class="line">  Mac OS X</span><br><span class="line">  Linux and Unix Systems</span><br><span class="line">  2. The R Userlnterface</span><br><span class="line">  The R Graphical User Interface</span><br><span class="line">  Windows</span><br><span class="line">  Mac OS X</span><br><span class="line">  Linux and Unix</span><br><span class="line">  The R Console</span><br><span class="line">  Command-Line Editing</span><br><span class="line">  Batch Mode</span><br><span class="line">  Using R Inside Microsoft Excel</span><br><span class="line">  RStudio</span><br><span class="line">  Other Ways to Run R</span><br><span class="line">  3. AShort RTutorial</span><br><span class="line">  Basic Operations in R</span><br><span class="line">  Functions</span><br><span class="line">  Variables</span><br><span class="line">  Introduction to Data Structures</span><br><span class="line">  Objects and Classes</span><br><span class="line">  Models and Formulas</span><br><span class="line">  Charts and Graphics</span><br><span class="line">  Getting Help</span><br><span class="line">4. R Packages</span><br><span class="line">  An Overview of Packages</span><br><span class="line">  Listing Packages in Local Libraries</span><br><span class="line">  Loading Packages</span><br><span class="line">  Loading Packages on Windows and Linux</span><br><span class="line">  Loading Packages on Mac OS X</span><br><span class="line">  Exploring Package Repositories</span><br><span class="line">  Exploring R Package Repositories on the Web</span><br><span class="line">  Finding and Installing Packages Inside R</span><br><span class="line">  Installing Packages From Other Repositories</span><br><span class="line">  Custom Packages</span><br><span class="line">  Creating a Package Directory</span><br><span class="line">  Building the Package</span><br><span class="line">Part Ⅱ. The R Language</span><br><span class="line">5. An Overview of the R Language</span><br><span class="line">  Expressions</span><br><span class="line">  Objects</span><br><span class="line">  Symbols</span><br><span class="line">  Functions</span><br><span class="line">  Objects Are Copied in Assignment Statements</span><br><span class="line">  Everything in R Is an Object</span><br><span class="line">  Special Values</span><br><span class="line">  NA</span><br><span class="line">  Inf and -Inf</span><br><span class="line">  NaN</span><br><span class="line">  NULL</span><br><span class="line">  Coercion</span><br><span class="line">  The R Interpreter</span><br><span class="line">  Seeing How R Works</span><br><span class="line">6. R Syntax</span><br><span class="line">  Constants</span><br><span class="line">  Numeric Vectors</span><br><span class="line">  Character Vectors</span><br><span class="line">  Symbols</span><br><span class="line">  Operators</span><br><span class="line">  Order of Operations</span><br><span class="line">……</span><br><span class="line">7. R Objects</span><br><span class="line">8. Symbols and Environments</span><br><span class="line">9. Functions.</span><br><span class="line">10. Object-Oriented Programming</span><br><span class="line">Part Ⅲ. Working with Data</span><br><span class="line">11. Saving, Loading, and Editing Data</span><br><span class="line">12. Preparing Data</span><br><span class="line">Part Ⅳ. Data Visualization</span><br><span class="line">13. Graphics</span><br><span class="line">14. Lattice Graphics</span><br><span class="line">15. ggplot2</span><br><span class="line">Part Ⅴ. Statistics with R</span><br><span class="line">16. Analyzing Data</span><br><span class="line">17. Probability Distributions</span><br><span class="line">18. Statistical Tests</span><br><span class="line">19. Power Tests</span><br><span class="line">20. Regression Models</span><br><span class="line">21. Classification Models</span><br><span class="line">22. Machine Learning</span><br><span class="line">23. Time Series Analysis</span><br><span class="line">Part Ⅵ. Additional Topics</span><br><span class="line">24. Optimizing R Programs</span><br><span class="line">25. Bioconductor</span><br><span class="line">26. Rand Hadoop</span><br><span class="line">Appendix: R Reference</span><br><span class="line">Bibliography</span><br><span class="line">Index</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00H93EFGG/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00H93EFGG&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51nBzoeP6lL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>r语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux/UNIX系统编程手册</title>
    <url>/2020/04/19/B00HLA8TYG/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Linux/UNIX系统编程手册<br>作者信息： 作者: 凯利斯克 (Michael Kerrisk) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Linux/UNIX系统编程接口权威巨著，无出其右；涵盖500多个系统调用和库函数；示例清晰完整，解释巨细靡遗；涵盖当前UNIX标准（POSI X.1-2001/SUS v3和POSI X.1-2008/SUS v4）；众多业内专家人士联袂推荐；Linux/UNIX开发人员的案头必备，注定成为新的经典；</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">《Linux&#x2F;UNIX系统编程手册（上册）》目录：</span><br><span class="line">第1章 历史和标准 1</span><br><span class="line">1.1 UNIX和C语言简史 1</span><br><span class="line">1.2 Linux简史 4</span><br><span class="line">1.2.1 GNU项目 4</span><br><span class="line">1.2.2 Linux内核 5</span><br><span class="line">1.3 标准化 8</span><br><span class="line">1.3.1 C编程语言 8</span><br><span class="line">1.3.2 首个POSIX标准 9</span><br><span class="line">1.3.3 X&#x2F;Open公司和TheOpenGroup 10</span><br><span class="line">1.3.4 SUSv3和POSIX.1—2001 10</span><br><span class="line">1.3.5 SUSv4和POSIX.1—2008 12</span><br><span class="line">1.3.6 UNIX标准时间表 12</span><br><span class="line">1.3.7 实现标准 14</span><br><span class="line">1.3.8 Linux、标准、Linux标准规范（LinuxStandardBase） 14</span><br><span class="line">1.4 总结 15</span><br><span class="line">第2章 基本概念 17</span><br><span class="line">2.1 操作系统的核心—内核 17</span><br><span class="line">2.2 shell 19</span><br><span class="line">2.3 用户和组 20</span><br><span class="line">2.4 单根目录层级、目录、链接及文件 21</span><br><span class="line">2.5 文件I&#x2F;O模型 23</span><br><span class="line">2.6 程序 24</span><br><span class="line">2.7 进程 25</span><br><span class="line">2.8 内存映射 27</span><br><span class="line">2.9 静态库和共享库 28</span><br><span class="line">2.10 进程间通信及同步 28</span><br><span class="line">2.11 信号 29</span><br><span class="line">2.12 线程 30</span><br><span class="line">2.13 进程组和shell任务控制 30</span><br><span class="line">2.14 会话、控制终端和控制进程 30</span><br><span class="line">2.15 伪终端 31</span><br><span class="line">2.16 日期和时间 31</span><br><span class="line">2.17 客户端服务器架构 32</span><br><span class="line">2.18 实时性 32</span><br><span class="line">2.19 proc文件系统 33</span><br><span class="line">2.20 总结 33</span><br><span class="line">第3章 系统编程概念 34</span><br><span class="line">3.1 系统调用 34</span><br><span class="line">3.2 库函数 36</span><br><span class="line">3.3 标准C语言函数库；GNUC语言函数库（glibc） 37</span><br><span class="line">3.4 处理来自系统调用和库函数的错误 38</span><br><span class="line">3.5 关于本书示例程序的注意事项 40</span><br><span class="line">3.5.1 命令行选项及参数 40</span><br><span class="line">3.5.2 常用的函数及头文件 40</span><br><span class="line">3.6 可移植性问题 49</span><br><span class="line">3.6.1 特性测试宏 49</span><br><span class="line">3.6.2 系统数据类型 51</span><br><span class="line">3.6.3 其他的可移植性问题 53</span><br><span class="line">3.7 总结 54</span><br><span class="line">3.8 练习 55</span><br><span class="line">第4章 文件I&#x2F;O：通用的I&#x2F;O模型 56</span><br><span class="line">4.1 概述 56</span><br><span class="line">4.2 通用I&#x2F;O 58</span><br><span class="line">4.3 打开一个文件：open（） 58</span><br><span class="line">4.3.1 open（）调用中的flags参数 60</span><br><span class="line">4.3.2 open（）函数的错误 63</span><br><span class="line">4.3.3 creat（）系统调用 64</span><br><span class="line">4.4 读取文件内容：read（） 64</span><br><span class="line">4.5 数据写入文件：write（） 65</span><br><span class="line">4.6 关闭文件：close（） 66</span><br><span class="line">4.7 改变文件偏移量：lseek（） 66</span><br><span class="line">4.8 通用I&#x2F;O模型以外的操作：ioctl（） 70</span><br><span class="line">4.9 总结 71</span><br><span class="line">4.10 练习 71</span><br><span class="line">第5章 深入探究文件I&#x2F;O 72</span><br><span class="line">5.1 原子操作和竞争条件 72</span><br><span class="line">5.2 文件控制操作：fcntl（） 75</span><br><span class="line">5.3 打开文件的状态标志 75</span><br><span class="line">5.4 文件描述符和打开文件之间的关系 76</span><br><span class="line">5.5 复制文件描述符 78</span><br><span class="line">5.6 在文件特定偏移量处的I&#x2F;O：pread（）和pwrite（） 80</span><br><span class="line">5.7 分散输入和集中输出（Scatter—GatherI&#x2F;O）：readv（）和writev（） 81</span><br><span class="line">5.8 截断文件：truncate（）和ftruncate（）系统调用 84</span><br><span class="line">5.9 非阻塞I&#x2F;O 84</span><br><span class="line">5.10 大文件I&#x2F;O 85</span><br><span class="line">5.11 &#x2F;dev&#x2F;fd目录 88</span><br><span class="line">5.12 创建临时文件 88</span><br><span class="line">5.13 总结 90</span><br><span class="line">5.14 练习 90</span><br><span class="line">第6章 进程 92</span><br><span class="line">6.1 进程和程序 92</span><br><span class="line">6.2 进程号和父进程号 93</span><br><span class="line">6.3 进程内存布局 94</span><br><span class="line">6.4 虚拟内存管理 97</span><br><span class="line">6.5 栈和栈帧 99</span><br><span class="line">6.6 命令行参数（argc，argv） 99</span><br><span class="line">6.7 环境列表 101</span><br><span class="line">6.8 执行非局部跳转：setjmp（）和longjmp（） 106</span><br><span class="line">6.9 总结 111</span><br><span class="line">6.9 练习 112</span><br><span class="line">第7章 内存分配 113</span><br><span class="line">7.1 在堆上分配内存 113</span><br><span class="line">7.1.1 调整programbreak：brk（）和sbrk（） 113</span><br><span class="line">7.1.2 在堆上分配内存：malloc（）和free（） 114</span><br><span class="line">7.1.3 malloc（）和free（）的实现 117</span><br><span class="line">7.1.4 在堆上分配内存的其他方法 120</span><br><span class="line">7.2 在堆栈上分配内存：alloca（） 122</span><br><span class="line">7.3 总结 123</span><br><span class="line">7.4 练习 123</span><br><span class="line">第8章 用户和组 124</span><br><span class="line">8.1 密码文件：&#x2F;etc&#x2F;passwd 124</span><br><span class="line">8.2 shadow密码文件：&#x2F;etc&#x2F;shadow 125</span><br><span class="line">8.3 组文件：&#x2F;etc&#x2F;group 126</span><br><span class="line">8.4 获取用户和组的信息 127</span><br><span class="line">8.5 密码加密和用户认证 132</span><br><span class="line">8.6 总结 135</span><br><span class="line">8.7 练习 135</span><br><span class="line">第9章 进程凭证 136</span><br><span class="line">9.1 实际用户ID和实际组ID 136</span><br><span class="line">9.2 有效用户ID和有效组ID 136</span><br><span class="line">9.3 Set—User—ID和Set—Group—ID程序 137</span><br><span class="line">9.4 保存set—user—ID和保存set—group—ID 138</span><br><span class="line">9.5 文件系统用户ID和组ID 139</span><br><span class="line">9.6 辅助组ID 140</span><br><span class="line">9.7 获取和修改进程凭证 140</span><br><span class="line">9.7.1 获取和修改实际、有效和保存设置标识 140</span><br><span class="line">9.7.2 获取和修改文件系统ID 145</span><br><span class="line">9.7.3 获取和修改辅助组ID 145</span><br><span class="line">9.7.4 修改进程凭证的系统调用总结 146</span><br><span class="line">9.7.5 示例：显示进程凭证 148</span><br><span class="line">9.8 总结 149</span><br><span class="line">9.9 习题 150</span><br><span class="line">第10章 时间 151</span><br><span class="line">10.1 日历时间（CalendarTime） 151</span><br><span class="line">10.2 时间转换函数 153</span><br><span class="line">10.2.1 将time_t转换为可打印格式 153</span><br><span class="line">10.2.2 time_t和分解时间之间的转换 154</span><br><span class="line">10.2.3 分解时间和打印格式之间的转换 155</span><br><span class="line">10.3 时区 161</span><br><span class="line">10.4 地区（Locale） 163</span><br><span class="line">10.5 更新系统时钟 167</span><br><span class="line">10.6 软件时钟（jiffies） 168</span><br><span class="line">10.7 进程时间 168</span><br><span class="line">10.8 总结 171</span><br><span class="line">10.9 练习 172</span><br><span class="line">第11章 系统限制和选项 173</span><br><span class="line">11.1 系统限制 174</span><br><span class="line">11.2 在运行时获取系统限制（和选项） 176</span><br><span class="line">11.3 运行时获取与文件相关的限制（和选项） 178</span><br><span class="line">11.4 不确定的限制 179</span><br><span class="line">11.5 系统选项 180</span><br><span class="line">11.6 总结 181</span><br><span class="line">11.7 练习 182</span><br><span class="line">第12章 系统和进程信息 183</span><br><span class="line">12.1 &#x2F;proc文件系统 183</span><br><span class="line">12.1.1 获取与进程有关的信息：&#x2F;proc&#x2F;PID 183</span><br><span class="line">12.1.2 &#x2F;proc目录下的系统信息 185</span><br><span class="line">12.1.3 访问&#x2F;proc文件 186</span><br><span class="line">12.2 系统标识：uname（） 188</span><br><span class="line">12.3 总结 190</span><br><span class="line">12.4 练习 190</span><br><span class="line">第13章 文件I&#x2F;O缓冲 191</span><br><span class="line">13.1 文件I&#x2F;O的内核缓冲：缓冲区高速缓存 191</span><br><span class="line">13.2 stdio库的缓冲 194</span><br><span class="line">13.3 控制文件I&#x2F;O的内核缓冲 196</span><br><span class="line">13.4 I&#x2F;O缓冲小结 200</span><br><span class="line">13.5 就I&#x2F;O模式向内核提出建议 201</span><br><span class="line">13.6 绕过缓冲区高速缓存：直接I&#x2F;O 202</span><br><span class="line">13.7 混合使用库函数和系统调用进行文件I&#x2F;O 204</span><br><span class="line">13.8 总结 205</span><br><span class="line">13.9 练习 205</span><br><span class="line">第14章 系统编程概念 207</span><br><span class="line">14.1 设备专用文件（设备文件） 207</span><br><span class="line">14.2 磁盘和分区 208</span><br><span class="line">14.3 文件系统 209</span><br><span class="line">14.4 i节点 211</span><br><span class="line">14.5 虚拟文件系统（VFS） 213</span><br><span class="line">14.6 日志文件系统 214</span><br><span class="line">14.7 单根目录层级和挂载点 215</span><br><span class="line">14.8 文件系统的挂载和卸载 216</span><br><span class="line">14.8.1 挂载文件系统：mount（） 217</span><br><span class="line">14.8.2 卸载文件系统：umount（）和umount2（） 222</span><br><span class="line">14.9 高级挂载特性 223</span><br><span class="line">14.9.1 在多个挂载点挂载文件系统 224</span><br><span class="line">14.9.2 多次挂载同一挂载点 224</span><br><span class="line">14.9.3 基于每次挂载的挂载标志 225</span><br><span class="line">14.9.4 绑定挂载 225</span><br><span class="line">14.9.5 递归绑定挂载 226</span><br><span class="line">14.10 虚拟内存文件系统：tmpfs 227</span><br><span class="line">14.11 获得与文件系统有关的信息：statvfs（） 228</span><br><span class="line">14.12 总结 229</span><br><span class="line">14.13 练习 230</span><br><span class="line">第15章 文件属性 231</span><br><span class="line">15.1 获取文件信息：stat（） 231</span><br><span class="line">15.2 文件时间戳 236</span><br><span class="line">15.2.1 使用utime（）和utimes（）来改变文件时间戳 238</span><br><span class="line">15.2.2 使用utimensat（）和futimens（）改变文件时间戳 239</span><br><span class="line">15.3 文件属主 241</span><br><span class="line">15.3.1 新建文件的属主 241</span><br><span class="line">15.3.2 改变文件属主：chown（）、fchown（）和lchown（） 241</span><br><span class="line">15.4 文件权限 244</span><br><span class="line">15.4.1 普通文件的权限 244</span><br><span class="line">15.4.2 目录权限 246</span><br><span class="line">15.4.3 权限检查算法 246</span><br><span class="line">15.4.4 检查对文件的访问权限：access（） 248</span><br><span class="line">15.4.5 Set—User—ID、Set—Group—ID和Sticky位 249</span><br><span class="line">15.4.6 进程的文件模式创建掩码：umask（） 249</span><br><span class="line">15.4.7 更改文件权限：chmod（）和fchmod（） 251</span><br><span class="line">15.5 I节点标志（ext2扩展文件属性） 252</span><br><span class="line">15.6 总结 256</span><br><span class="line">15.7 练习 256</span><br><span class="line">第16章 扩展属性 258</span><br><span class="line">16.1 概述 258</span><br><span class="line">16.2 扩展属性的实现细节 260</span><br><span class="line">16.3 操控扩展属性的系统调用 260</span><br><span class="line">16.4 总结 264</span><br><span class="line">16.5 练习 264</span><br><span class="line">第17章 访问控制列表 265</span><br><span class="line">17.1 概述 265</span><br><span class="line">17.2 ACL权限检查算法 267</span><br><span class="line">17.3 ACL的长、短文本格式 268</span><br><span class="line">17.4 ACL_mask型ACE和ACL组分类 269</span><br><span class="line">17.5 getfacl和setfacl命令 270</span><br><span class="line">17.6 默认ACL与文件创建 271</span><br><span class="line">17.7 ACL在实现方面的限制 272</span><br><span class="line">17.8 ACLAPI 273</span><br><span class="line">17.9 总结 280</span><br><span class="line">17.10 练习 280</span><br><span class="line">第18章 目录与链接 281</span><br><span class="line">18.1 目录和（硬）链接 281</span><br><span class="line">18.2 符号（软）链接 283</span><br><span class="line">18.3 创建和移除（硬）链接：link（）和unlink（） 286</span><br><span class="line">18.4 更改文件名：rename（） 289</span><br><span class="line">18.5 使用符号链接：symlink（）和readlink（） 290</span><br><span class="line">18.6 创建和移除目录：mkdir（）和rmdir（） 291</span><br><span class="line">18.7 移除一个文件或目录：remove（） 292</span><br><span class="line">18.8 读目录：opendir（）和readdir（） 292</span><br><span class="line">18.9 文件树遍历：nftw（） 297</span><br><span class="line">18.10 进程的当前工作目录 301</span><br><span class="line">18.11 针对目录文件描述符的相关操作 303</span><br><span class="line">18.12 改变进程的根目录：chroot（） 304</span><br><span class="line">18.13 解析路径名：realpath（） 306</span><br><span class="line">18.14 解析路径名字符串：dirname（）和basename（） 307</span><br><span class="line">18.15 总结 309</span><br><span class="line">18.16 练习 309</span><br><span class="line">第19章 监控文件事件 311</span><br><span class="line">19.1 概述 311</span><br><span class="line">19.2 inotifyAPI 312</span><br><span class="line">19.3 inotify事件 313</span><br><span class="line">19.4 读取inotify事件 315</span><br><span class="line">19.5 队列限制和&#x2F;proc文件 319</span><br><span class="line">19.6 监控文件的旧有系统：dnotify 320</span><br><span class="line">19.7 总结 320</span><br><span class="line">19.8 练习 320</span><br><span class="line">第20章 信号：基本概念 321</span><br><span class="line">20.1 概念和概述 321</span><br><span class="line">20.2 信号类型和默认行为 323</span><br><span class="line">20.3 改变信号处置：signal（） 329</span><br><span class="line">20.4 信号处理器简介 330</span><br><span class="line">20.5 发送信号：kill（） 333</span><br><span class="line">20.6 检查进程的存在 334</span><br><span class="line">20.7 发送信号的其他方式：raise（）和killpg（） 335</span><br><span class="line">20.8 显示信号描述 336</span><br><span class="line">20.9 信号集 337</span><br><span class="line">20.10 信号掩码（阻塞信号传递） 339</span><br><span class="line">20.11 处于等待状态的信号 341</span><br><span class="line">20.12 不对信号进行排队处理 341</span><br><span class="line">20.13 改变信号处置：sigaction（） 345</span><br><span class="line">20.14 等待信号：pause（） 346</span><br><span class="line">20.15 总结 347</span><br><span class="line">20.16 练习 347</span><br><span class="line">第21章 信号：信号处理器函数 348</span><br><span class="line">21.1 设计信号处理器函数 348</span><br><span class="line">21.1.1 再论信号的非队列化处理 348</span><br><span class="line">21.1.2 可重入函数和异步信号安全函数 349</span><br><span class="line">21.1.3 全局变量和sig_atomic_t数据类型 353</span><br><span class="line">21.2 终止信号处理器函数的其他方法 354</span><br><span class="line">21.2.1 在信号处理器函数中执行非本地跳转 354</span><br><span class="line">21.2.2 异常终止进程：abort（） 358</span><br><span class="line">21.3 在备选栈中处理信号：sigaltstack（） 358</span><br><span class="line">21.4 SA_SIGINFO标志 361</span><br><span class="line">21.5 系统调用的中断和重启 366</span><br><span class="line">21.6 总结 368</span><br><span class="line">21.7 练习 369</span><br><span class="line">第22章 信号：高级特性 370</span><br><span class="line">22.1 核心转储文件 370</span><br><span class="line">22.2 传递、处置及处理的特殊情况 372</span><br><span class="line">22.3 可中断和不可中断的进程睡眠状态 373</span><br><span class="line">22.4 硬件产生的信号 374</span><br><span class="line">22.5 信号的同步生成和异步生成 374</span><br><span class="line">22.6 信号传递的时机与顺序 375</span><br><span class="line">22.7 signal（）的实现及可移植性 376</span><br><span class="line">22.8 实时信号 378</span><br><span class="line">22.8.1 发送实时信号 379</span><br><span class="line">22.8.2 处理实时信号 380</span><br><span class="line">22.9 使用掩码来等待信号：sigsuspend（） 384</span><br><span class="line">22.10 以同步方式等待信号 387</span><br><span class="line">22.11 通过文件描述符来获取信号 390</span><br><span class="line">22.12 利用信号进行进程间通信 393</span><br><span class="line">22.13 早期的信号API（SystemV和BSD） 393</span><br><span class="line">22.14 总结 395</span><br><span class="line">22.15 练习 396</span><br><span class="line">……</span><br><span class="line">第23章 定时器与休眠 397</span><br><span class="line">第24章 进程的创建 425</span><br><span class="line">第25章 进程的终止 440</span><br><span class="line">第26章 监控子进程 447</span><br><span class="line">第27章 程序的执行 465</span><br><span class="line">第28章 详述进程创建和程序执行 487</span><br><span class="line">第29章 线程：介绍 509</span><br><span class="line">第30章 线程：线程同步 521</span><br><span class="line">第31章 线程：线程安全和每线程存储 539</span><br><span class="line">第32章 线程：线程取消 552</span><br><span class="line">第33章 线程：更多细节 561</span><br><span class="line">……</span><br><span class="line">《Linux&#x2F;UNIX系统编程手册（下册）》</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00HLA8TYG/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00HLA8TYG&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51EUI039ySL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>数据之美：一本书学会可视化设计</title>
    <url>/2020/04/19/B00HV4DPWS/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 数据之美：一本书学会可视化设计<br>作者信息： 作者: 邱南森 [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>邱南森（Nathan Yau），加州大学洛杉矶分校统计学博士，痴迷于数据可视化和个人数据收集。2007年创建了一个设计、可视化和统计方面的博客flowingdata.com。他认为可视化不仅是表达数据的最有效工具，同时更是一种媒介，可以用来讲述数据背后的故事。著有畅销书《鲜活的数据：数据可视化指南》。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">引言  可视化是一种媒介</span><br><span class="line">第1章 你真的理解数据了吗 </span><br><span class="line"></span><br><span class="line"> 数据表达了什么 &#x2F;6 数据的可变性 &#x2F;20 数据的不确定性 &#x2F;29 数据所依存的背景信息 &#x2F;36</span><br><span class="line"></span><br><span class="line"> 第2章 数据引导可视化设计 新数据研究需要新工具 &#x2F;45 信息图形和展示 &#x2F;57 可视化的娱乐性 &#x2F;66 走进数据艺术的世界 &#x2F;72 日常生活中的可视化 &#x2F;80</span><br><span class="line"></span><br><span class="line"> 第3章 掌握可视化设计的原材料 各种可视化组件 &#x2F;89 整合可视化组件 &#x2F;108</span><br><span class="line"></span><br><span class="line"> 第4章 不了解数据，一切皆是空谈 数据可视化的过程 &#x2F;128 分类数据的可视化 &#x2F;134 时序数据的可视化 &#x2F;144 空间数据的可视化 &#x2F;156 多元变量 &#x2F;166 数据的分布 &#x2F;179</span><br><span class="line"></span><br><span class="line"> 第5章 让可视化设计更为清晰 建立视觉层次 &#x2F;192 增强图表的可读性 &#x2F;195 高亮显示重点内容 &#x2F;211 注解可视化表达了什么 &#x2F;217 从不同角度做一些计算 &#x2F;223</span><br><span class="line"></span><br><span class="line"> 第6章 别忘了，你是为读者进行可视化设计 可视化时常见的错误 &#x2F;230 读者不同，数据展示方式不同 &#x2F;242 需要注意的事项 &#x2F;245 可视化步骤的整合 &#x2F;255</span><br><span class="line"></span><br><span class="line"> 第7章 将可视化进行到底 可视化工具 &#x2F;264 编程工具 &#x2F;268 插图工具 &#x2F;274 数据统计 &#x2F;274</span><br><span class="line"></span><br><span class="line"> 结语 可视化设计，若烹小鲜 译者后记</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00HV4DPWS/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00HV4DPWS&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51qVxF6aRhL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title>Learning PHP设计模式</title>
    <url>/2020/04/19/B00IJR2O9Q/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Learning PHP设计模式<br>作者信息： 作者: 桑德 (William Sanders) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Learning PHP设计模式》由中国电力出版社出版。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1部分轻松掌握设计模式基础</span><br><span class="line">第1章PHP与面向对象编程</span><br><span class="line">1.1中级和高级编程初探</span><br><span class="line">1.2为什么采用面向对象编程</span><br><span class="line">1.2.1解决问题更容易</span><br><span class="line">1.2.2模块化</span><br><span class="line">1.3类与对象</span><br><span class="line">1.3.1单一职责原则</span><br><span class="line">1.3.2PHP中的构造函数</span><br><span class="line">1.4客户类作为请求者</span><br><span class="line">1.5速度如何</span><br><span class="line">1.5.1开发和修改速度</span><br><span class="line">1.5.2团队速度</span><br><span class="line">1.6顺序和过程式编程有什么问题</span><br><span class="line">1.6.1顺序编程</span><br><span class="line">1.6.2过程编程</span><br><span class="line">1.6.3即时回报还是长期回报</span><br><span class="line">第2章OOP基本概念</span><br><span class="line">第3章基本设计模式概念</span><br><span class="line">第4章结合使用设计模式和UML</span><br><span class="line">第2部分创建型设计模式</span><br><span class="line">第5章工厂方法设计模式</span><br><span class="line">第6章原型设计模式</span><br><span class="line">第3部分结构型设计模式</span><br><span class="line">第7章适配器模式</span><br><span class="line">第8章装饰器设计模式</span><br><span class="line">第4部分行为型设计模式</span><br><span class="line">第9章模板方法模式</span><br><span class="line">第10章状态设计模式</span><br><span class="line">第5部分MySQL和PHP设计模式</span><br><span class="line">第11章通用类负责连接，代理模式保证安全</span><br><span class="line">第12章策略设计模式的灵活性</span><br><span class="line">第13章职责链设计模式</span><br><span class="line">第14章利用观察者模式构建多设备CMS</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00IJR2O9Q/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00IJR2O9Q&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec8.images-amazon.com/images/I/51v7TkuRHOL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>趣学Python编程</title>
    <url>/2020/04/19/B00IM56I5Q/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 趣学Python编程<br>作者信息： 作者: Jason Briggs [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Python是一种强大并通俗易懂的编程语言，而且它易学又好用！但是关于学习Python语言的书大多很枯燥无趣，读起来没什么乐趣。本书把你带入一个鲜活的Python编程世界。作者Jason R. Briggs将带领你用独特的（往往很好玩的）示例程序带你学习基础知识。每章后面都配有编程练习来帮助训练思维并加强理解。在本书的最后部分，你将编写两个完整的游戏：一个经典弹球游戏的复制品，以及一个能在平台上跳跃、有动画及更多效果的《火柴人逃生》游戏。当你完成这个编程之旅后，你将学到：● 使用列表、元组和字典等基本数据结构；● 用函数和模块来组织以并重用代码；● 使用循环和条件语句等控制结构；● 用Python 的海龟模块来画形状和图案；● 用tkinter 来创建游戏、动画以及其他画面效果。为什么这本书也能给读者带来乐趣？因为本书是你进入神奇的计算机编程世界的门票。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目　录 </span><br><span class="line"></span><br><span class="line"> 第1部分　学习编程</span><br><span class="line"></span><br><span class="line"> 第1章　Python不是大蟒蛇　3 1.1　关于计算机语言　3 1.2　安装Python　4 1.2.1　在Windows 7上安装Python　4 1.2.2　在苹果OS X上安装Python　6 1.2.3　在Ubuntu上安装Python　8 1.3　当你安装好Python以后　9 1.4　保存Python程序　10 1.5　你学到了什么　12</span><br><span class="line"></span><br><span class="line"> 第2章　计算与变量　13 2.1　用Python来做计算　13 2.1.1　Python的运算符　14 2.1.2　运算的顺序　15 2.2　变量就像是标签　16 2.3　使用变量　17 2.4　你学到了什么　20</span><br><span class="line"></span><br><span class="line"> 第3章　字符串、列表、元组和字典　21 3.1　字符串　21 3.1.1　创建字符串　21 3.1.2　处理字符串相关的问题　23 3.1.3　在字符串里嵌入值　25 3.1.4　字符串乘法　26 3.2　列表比字符串还强大　27 3.2.1　添加元素到列表　29 3.2.2　从列表中删除元素　30 3.2.3　列表上的算术　31 3.3　元组　32 3.4　Python里的map不是用来指路的　33 3.5　你学到了什么　35 3.6　编程小测验　36</span><br><span class="line"></span><br><span class="line"> 第4章　用海龟画图　37 4.1　使用Python的turtle(海龟)模块　37 4.1.1　创建画布　38 4.1.2　移动海龟　39 4.2　你学到了什么　43 4.3　编程小测验　43</span><br><span class="line"></span><br><span class="line"> 第5章　用if和else来提问　45 5.1　if语句　45 5.2　语句块就是一组程序语句　45 5.3　条件语句帮助我们做比较　48 5.4　if-then-else语句　49 5.5　if和elif语句　50 5.6　组合条件　51 5.7　没有值的变量——None　52 5.8　字符串与数字之间的不同　52 5.9　你学到了什么　55 5.10　编程小测验　55</span><br><span class="line"></span><br><span class="line"> 第6章　循环　57 6.1　使用for循环　57 6.2　还有一种叫while的循环　64 6.3　你学到了什么　67 6.4　编程小测验　67</span><br><span class="line"></span><br><span class="line"> 第7章　使用函数和模块来重用你的代码　69 7.1　使用函数　69 7.1.1　函数的组成部分　70 7.1.2　变量和作用域　71 7.2　使用模块　73 7.3　你学到了什么　75 7.4　编程小测验　76</span><br><span class="line"></span><br><span class="line"> 第8章　如何使用类和对象　78 8.1　把事物拆分成类　78 8.1.1　父母与孩子　79 8.1.2　增加属于类的对象　80 8.1.3　定义类中的函数　81 8.1.4　用函数来表示类的特征　81 8.1.5　为什么使要用类和对象　82 8.1.6　画图中的对象与类　84 8.2　对象和类的另一些实用功能　86 8.2.1　函数继承　87 8.2.2　从函数里调用其他函数　88 8.3　初始化对象　89 8.4　你学到了什么　90 8.5　编程小测验　90</span><br><span class="line"></span><br><span class="line"> 第9章　Python的内建函数　92 9.1　使用内建函数　92 9.1.1　abs函数　92 9.1.2　bool函数　93 9.1.3　dir函数　94 9.1.4　eval函数　96 9.1.5　exec函数　97 9.1.6　float函数　98 9.1.7　int函数　98 9.1.8　len函数　99 9.1.9　max和min函数　100 9.1.10　range函数　101 9.1.11　sum函数　102 9.2　使用文件　103 9.2.1　创建测试文件　103 9.2.2　在Python中打开文件　106 9.2.3　写入到文件　107 9.3　你学到了什么　108 9.4　编程小测验　108</span><br><span class="line"></span><br><span class="line"> 第10章　常用的Python模块　109 10.1　使用copy模块来复制　109 10.2　keyword模块记录了所有的关键字　112 10.3　用random模块获得随机数　112 10.3.1　用randint来随机挑选一个数字　112 10.3.2　用choice从列表中随机选取一个元素　114 10.3.3　用shuffle来给列表洗牌　115 10.4　用sys模块来控制Shell程序　115 10.4.1　用exit函数来退出Shell程序　115 10.4.2　从stdin对象读取　115 10.4.3　用stdout对象来写入　116 10.4.4　我用的Python是什么版本的　116 10.5用time模块来得到时间　117 10.5.1　用asctime来转换日期　118 10.5.2　用localtime来得到日期和时间　119 10.5.3　用sleep来休息一会儿吧　120 10.6　用pickle模块来保存信息　120 10.7　你学到了什么　122 10.8　编程小测验　122</span><br><span class="line"></span><br><span class="line"> 第11章　高级海龟作图　124 11.1　从基本的正方形开始　124 11.2　画星星　125 11.3　画汽车　128 11.4　填色　130 11.4.1　用来画填色圆形的函数　131 11.4.2　使用纯白和纯黑　132 11.5　画方形的函数　133 11.6　画填色正方形　134 11.7　画填好色的星星　135 11.8　你学到了什么　137 11.9　编程小测验　137</span><br><span class="line"></span><br><span class="line"> 第12章　用tkinter画高级图形　139 12.1　创造一个可以点的按钮　140 12.2　使用具名参数　142 12.3　创建一个画图用的画布　142 12.4　画线　143 12.5　画盒子　144 12.5.1　画许多矩形　146 12.5.2　设置颜色　148 12.6　画圆弧　151 12.7　画多边形　153 12.8　显示文字　154 12.9　显示图片　155 12.10　创建基本的动画　157 12.11　让对象对操作有反应　159 12.12　更多使用ID的方法　161 12.13　你学到了什么　163 12.14　编程小测验　163</span><br><span class="line"></span><br><span class="line"> 第2部分　弹球实例</span><br><span class="line"></span><br><span class="line"> 第13章　你的第一个游戏：弹球　167 13.1　击打反弹球　167 13.2　创建游戏的画布　168 13.3　创建Ball类　169 13.4　增加几个动作　171 13.4.1　让小球移动　171 13.4.2　让小球来回反弹　172 13.4.3　改变小球的起始方向　174 13.5　你学到了什么　176</span><br><span class="line"></span><br><span class="line"> 第14章　完成你的第一个游戏：反弹吧，小球！　177 14.1　加上球拍　177 14.2　让球拍移动　179 判断小球是否击中球拍　180 14.3　增加输赢因素　183 14.4　你学到了什么　187 14.5　编程小测验　187</span><br><span class="line"></span><br><span class="line"> 第3部分　火柴人实例</span><br><span class="line"></span><br><span class="line"> 第15章　火柴小人游戏的图形　191 15.1　火柴小人游戏计划　191 15.2　得到GIMP　192 15.3　创建游戏中的元素　193 15.3.1　准备一个有透明背景的图形　194 15.3.2　画火柴人　195 15.3.3　画平台　197 15.3.4　画门　197 15.3.5　画背景　198 15.3.6　透明　199 15.4　你学到了什么　200</span><br><span class="line"></span><br><span class="line"> 第16章　开发火柴人游戏　201 16.1　创建Game类　201 16.1.1　设置窗口标题以及创建画布　201 16.1.2　完成init函数　202 16.1.3　创建主循环函数　203 16.2　创建坐标类　205 16.3　冲突检测　205 16.3.1　精灵在水平方向上冲突　206 16.3.2　精灵在垂直方向上冲突　208 16.3.3　把它们放在一起：最终的冲突检测代码　208 16.4　创建精灵类　210 16.5　添加平台类　211 16.5.1　加入平台对象　212 16.5.2　添加很多平台　213 16.6　你学到了什么　215 16.7　编程小测验　215</span><br><span class="line"></span><br><span class="line"> 第17章　创建火柴人　217 17.1　初始化火柴人　217 17.1.1　装入火柴人图形　217 17.1.2　设置变量　218 17.1.3　与键盘按键绑定　219 17.2　让火柴人向左转和向右转　220 17.3　让火柴人跳跃　221 17.4　我们都做了什么　221 17.5　你学到了什么　222</span><br><span class="line"></span><br><span class="line"> 第18章　完成火柴人逃生游戏　223 18.1　让火柴人动起来　223 18.1.1　创建动画函数　223 18.1.2　得到火柴人的位置　226 18.1.3　让火柴人移动　227 18.2　测试我们的火柴人精灵　235 18.3　门　235 18.3.1　创建DoorSprite类　236 18.3.2　门的检测　237 18.3.3　加入门对象　237 18.4　最终的游戏　238 18.5　你学到了什么　244 18.6　编程小测验　245</span><br><span class="line"></span><br><span class="line"> 结束语　接下来学什么　246 附录　Python的关键字　253 术语表　265</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00IM56I5Q/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00IM56I5Q&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51crCpqVt7L._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Mahout实战</title>
    <url>/2020/04/19/B00IWYN9KO/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Mahout实战<br>作者信息： 作者: Sean Owen　Robin Anil　Ted Dunning　Ellen Friedman [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Apache基金会官方推荐Mahout核心团队权威力作大数据时代机器学习的实战经典</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目　录 </span><br><span class="line"></span><br><span class="line"> 第1章　初识Mahout　1 1.1　Mahout的故事　1 1.2　Mahout的机器学习主题　2 1.2.1　推荐引擎　2 1.2.2　聚类　3 1.2.3　分类　4 1.3　利用Mahout和Hadoop处理大规模数据　4 1.4　安装Mahout　6 1.4.1　Java和IDE　6 1.4.2　安装Maven　7 1.4.3　安装Mahout　7 1.4.4　安装Hadoop　8 1.5　小结　8</span><br><span class="line"></span><br><span class="line"> 第一部分　推荐</span><br><span class="line"></span><br><span class="line"> 第2章　推荐系统　10 2.1　推荐的定义　10 2.2　运行第一个推荐引擎　11 2.2.1　创建输入　11 2.2.2　创建一个推荐程序　13 2.2.3　分析输出　14 2.3　评估一个推荐程序　14 2.3.1　训练数据与评分　15 2.3.2　运行RecommenderEvaluator　15 2.3.3　评估结果　16 2.4　评估查准率与查全率　17 2.4.1　运行RecommenderIRStats-Evaluator　17 2.4.2　查准率和查全率的问题　19 2.5　评估GroupLens数据集　19 2.5.1　提取推荐程序的输入　19 2.5.2　体验其他推荐程序　20 2.6　小结　20</span><br><span class="line"></span><br><span class="line"> 第3章　推荐数据的表示　21 3.1　偏好数据的表示　21 3.1.1　Preference对象　21 3.1.2　PreferenceArray及其实现　22 3.1.3　改善聚合的性能　23 3.1.4　FastByIDMap和FastIDSet　23 3.2　内存级DataModel　24 3.2.1　GenericDataModel　24 3.2.2　基于文件的数据　25 3.2.3　可刷新组件　25 3.2.4　更新文件　26 3.2.5　基于数据库的数据　26 3.2.6　JDBC和MySQL　27 3.2.7　通过JNDI进行配置　27 3.2.8　利用程序进行配置　28 3.3　无偏好值的处理　29 3.3.1　何时忽略值　29 3.3.2　无偏好值时的内存级表示　30 3.3.3　选择兼容的实现　31 3.4　小结　33</span><br><span class="line"></span><br><span class="line"> 第4章　进行推荐　34 4.1　理解基于用户的推荐　34 4.1.1　推荐何时会出错　34 4.1.2　推荐何时是正确的　35 4.2　探索基于用户的推荐程序　36 4.2.1　算法　36 4.2.2　基于GenericUserBased-Recommender实现算法　36 4.2.3　尝试GroupLens数据集　37 4.2.4　探究用户邻域　38 4.2.5　固定大小的邻域　39 4.2.6　基于阈值的邻域　39 4.3　探索相似性度量　40 4.3.1　基于皮尔逊相关系数的相似度　40 4.3.2　皮尔逊相关系数存在的问题　42 4.3.3　引入权重　42 4.3.4　基于欧氏距离定义相似度　43 4.3.5　采用余弦相似性度量　43 4.3.6　采用斯皮尔曼相关系数基于相对排名定义相似度　44 4.3.7　忽略偏好值基于谷本系数计算相似度　45 4.3.8　基于对数似然比更好地计算相似度　46 4.3.9　推测偏好值　47 4.4　基于物品的推荐　47 4.4.1　算法　48 4.4.2　探究基于物品的推荐程序　49 4.5　Slope-one推荐算法　50 4.5.1　算法　50 4.5.2　Slope-one实践　51 4.5.3　DiffStorage和内存考虑　52 4.5.4　离线计算量的分配　53 4.6　最新以及试验性质的推荐算法　53 4.6.1　基于奇异值分解的推荐算法　53 4.6.2　基于线性插值物品的推荐算法　54 4.6.3　基于聚类的推荐算法　55 4.7　对比其他推荐算法　56 4.7.1　为Mahout引入基于内容的技术　56 4.7.2　深入理解基于内容的推荐算法　57 4.8　对比基于模型的推荐算法　57 4.9　小结　57</span><br><span class="line"></span><br><span class="line"> 第5章　让推荐程序实用化　59 5.1　分析来自约会网站的样本数据　59 5.2　找到一个有效的推荐程序　61 5.2.1　基于用户的推荐程序　61 5.2.2　基于物品的推荐程序　62 5.2.3　slope-one推荐程序　63 5.2.4　评估查准率和查全率　63 5.2.5　评估性能　64 5.3　引入特定域的信息　65 5.3.1　采用一个定制的物品相似性度量　65 5.3.2　基于内容进行推荐　66 5.3.3　利用IDRescorer修改推荐结果　66 5.3.4　在IDRescorer中引入性别　67 5.3.5　封装一个定制的推荐程序　69 5.4　为匿名用户做推荐　71 5.4.1　利用PlusAnonymousUser-DataModel处理临时用户　71 5.4.2　聚合匿名用户　73 5.5　创建一个支持Web访问的推荐程序　73 5.5.1　封装WAR文件　74 5.5.2　测试部署　74 5.6　更新和监控推荐程序　75 5.7　小结　76</span><br><span class="line"></span><br><span class="line"> 第6章　分布式推荐　78 6.1　分析Wikipedia数据集　78 6.1.1　挑战规模　79 6.1.2　分布式计算的优缺点　80 6.2　设计一个基于物品的分布式推荐算法　81 6.2.1　构建共现矩阵　81 6.2.2　计算用户向量　82 6.2.3　生成推荐结果　82 6.2.4　解读结果　83 6.2.5　分布式实现　83 6.3　基于MapReduce实现分布式算法　83 6.3.1　MapReduce简介　84 6.3.2　向MapReduce转换：生成用户向量　84 6.3.3　向MapReduce转换：计算共现关系　85 6.3.4　向MapReduce转换：重新思考矩阵乘　87 6.3.5　向MapReduce转换：通过部分乘积计算矩阵乘　87 6.3.6　向MapReduce转换：形成推荐　90 6.4　在Hadoop上运行MapReduce　91 6.4.1　安装Hadoop　92 6.4.2　在Hadoop上执行推荐　92 6.4.3　配置mapper和reducer　94 6.5　伪分布式推荐程序　94 6.6　深入理解推荐　95 6.6.1　在云上运行程序　95 6.6.2　考虑推荐的非传统用法　97 6.7　小结　97</span><br><span class="line"></span><br><span class="line"> 第二部分　聚类</span><br><span class="line"></span><br><span class="line"> 第7章　聚类介绍　100 7.1　聚类的基本概念　100 7.2　项目相似性度量　102 7.3　Hello World：运行一个简单的聚类示例　103 7.3.1　生成输入数据　103 7.3.2　使用Mahout聚类　104 7.3.3　分析输出结果　107 7.4　探究距离测度　108 7.4.1　欧氏距离测度　108 7.4.2　平方欧氏距离测度　108 7.4.3　曼哈顿距离测度　108 7.4.4　余弦距离测度　109 7.4.5　谷本距离测度　110 7.4.6　加权距离测度　110 7.5　在简单示例上使用各种距离测度　111 7.6　小结　111</span><br><span class="line"></span><br><span class="line"> 第8章　聚类数据的表示　112 8.1　向量可视化　113 8.1.1　将数据转换为向量　113 8.1.2　准备Mahout所用的向量　115 8.2　将文本文档表示为向量　116 8.2.1　使用TF-IDF改进加权　117 8.2.2　通过n-gram搭配词考察单词的依赖性　118 8.3　从文档中生成向量　119 8.4　基于归一化改善向量的质量　123 8.5　小结　124</span><br><span class="line"></span><br><span class="line"> 第9章　Mahout中的聚类算法　125 9.1　k-means聚类　125 9.1.1　关于k-means你需要了解的　126 9.1.2　运行k-means聚类　127 9.1.3　通过canopy聚类寻找最佳k值　134 9.1.4　案例学习：使用k-means对新闻聚类　138 9.2　超越k-means: 聚类技术概览　141 9.2.1　不同类型的聚类问题　141 9.2.2　不同的聚类方法　143 9.3　模糊k-means聚类　145 9.3.1　运行模糊k-means聚类　145 9.3.2　多模糊会过度吗　147 9.3.3　案例学习：用模糊k-means对新闻进行聚类　148 9.4　基于模型的聚类　149 9.4.1　k-means的不足　149 9.4.2　狄利克雷聚类　150 9.4.3　基于模型的聚类示例　151 9.5　用LDA进行话题建模　154 9.5.1　理解LDA　155 9.5.2　对比TF-IDF与LDA　156 9.5.3　LDA参数调优　156 9.5.4　案例学习：寻找新闻文档中的话题　156 9.5.5　话题模型的应用　158 9.6　小结　158</span><br><span class="line"></span><br><span class="line"> 第10章　评估并改善聚类质量　160 10.1　检查聚类输出　160 10.2　分析聚类输出　162 10.2.1　距离测度与特征选择　163 10.2.2　簇间与簇内距离　163 10.2.3　簇的混合与重叠　166 10.3　改善聚类质量　166 10.3.1　改进文档向量生成过程　166 10.3.2　编写自定义距离测度　169 10.4　小结　171</span><br><span class="line"></span><br><span class="line"> 第11章　将聚类用于生产环境　172 11.1　Hadoop下运行聚类算法的快速入门　172 11.1.1　在本地Hadoop集群上运行聚类算法　173 11.1.2　定制Hadoop配置　174 11.2　聚类性能调优　176 11.2.1　在计算密集型操作中避免性能缺陷　176 11.2.2　在I&#x2F;O密集型操作中避免性能缺陷　178 11.3　批聚类及在线聚类　178 11.3.1　案例分析：在线新闻聚类　179 11.3.2　案例分析：对维基百科文章聚类　180 11.4　小结　181</span><br><span class="line"></span><br><span class="line"> 第12章　聚类的实际应用　182 12.1　发现Twitter上的相似用户　182 12.1.1　数据预处理及特征加权　183 12.1.2　避免特征选择中的常见陷阱　184 12.2　为Last.fm上的艺术家推荐标签　187 12.2.1　利用共现信息进行标签推荐　187 12.2.2　构建Last.fm艺术家词典　188 12.2.3　将Last.fm标签转换成以艺术家为特征的向量　190 12.2.4　在Last.fm数据上运行k-means算法　191 12.3　分析Stack Overflow数据集　193 12.3.1　解析Stack Overflow数据集　193 12.3.2　在Stack Overflow中发现聚类问题　193 12.4　小结　194</span><br><span class="line"></span><br><span class="line"> 第三部分　分类</span><br><span class="line"></span><br><span class="line"> 第13章　分类　198 13.1　为什么用Mahout做分类　198 13.2　分类系统基础　199 13.2.1　分类、推荐和聚类的区别　201 13.2.2　分类的应用　201 13.3　分类的工作原理　202 13.3.1　模型　203 13.3.2　训练、测试与生产　203 13.3.3　预测变量与目标变量　204 13.3.4　记录、字段和值　205 13.3.5　预测变量值的4种类型　205 13.3.6　有监督学习与无监督学习　207 13.4　典型分类项目的工作流　207 13.4.1　第一阶段工作流：训练分类模型　208 13.4.2　第二阶段工作流：评估分类模型　212 13.4.3　第三阶段工作流：在生产中使用模型　212 13.5　循序渐进的简单分类示例　213 13.5.1　数据和挑战　213 13.5.2　训练一个模型来寻找颜色填充：初步设想　214 13.5.3　选择一个学习算法来训练模型　215 13.5.4　改进填充颜色分类器的性能　217 13.6　小结　221</span><br><span class="line"></span><br><span class="line"> 第14章　训练分类器　222 14.1　提取特征以构建分类器　222 14.2　原始数据的预处理　224 14.2.1　原始数据的转换　224 14.2.2　一个计算营销的例子　225 14.3　将可分类数据转换为向量　226 14.3.1　用向量表示数据　226 14.3.2　用Mahout API做特征散列　228 14.4　用SGD对20 Newsgroups数据集进行分类　231 14.4.1　开始：数据集预览　231 14.4.2　20 Newsgroups数据特征的解析和词条化　234 14.4.3　20 Newsgroups数据的训练代码　234 14.5　选择训练分类器的算法　238 14.5.1　非并行但仍很强大的算法：SGD和SVM　239 14.5.2　朴素分类器的力量：朴素贝叶斯及补充朴素贝叶斯　239 14.5.3　精密结构的力量：随机森林算法　240 14.6　用朴素贝叶斯对20 Newsgroups数据分类　241 14.6.1　开始：为朴素贝叶斯提取数据　241 14.6.2　训练朴素贝叶斯分类器　242 14.6.3　 测试朴素贝叶斯模型　242 14.7　小结　244</span><br><span class="line"></span><br><span class="line"> 第15章　分类器评估及调优　245 15.1　Mahout中的分类器评估　245 15.1.1　获取即时反馈　246 15.1.2　确定分类“好”的含义　246 15.1.3　认识不同的错误代价　247 15.2　分类器评估API　247 15.2.1　计算AUC　248 15.2.2　计算混淆矩阵和熵矩阵　250 15.2.3　计算平均对数似然　252 15.2.4　模型剖析　253 15.2.5　20 Newsgroups语料上SGD分类器的性能指标计算　254 15.3　分类器性能下降时的处理　257 15.3.1　目标泄漏　258 15.3.2　特征提取崩溃　260 15.4　分类器性能调优　262 15.4.1　问题调整　262 15.4.2　分类器调优　265 15.5　小结　267</span><br><span class="line"></span><br><span class="line"> 第16章　分类器部署　268 16.1　巨型分类系统的部署过程　268 16.1.1　理解问题　269 16.1.2　根据需要优化特征提取过程　269 16.1.3　根据需要优化向量编码　269 16.1.4　部署可扩展的分类器服务　270 16.2　确定规模和速度需求　270 16.2.1　多大才算大　270 16.2.2　在规模和速度之间折中　272 16.3　对大型系统构建训练流水线　273 16.3.1　获取并保留大规模数据　274 16.3.2　非规范化及下采样　275 16.3.3　训练中的陷阱　276 16.3.4　快速读取数据并对其进行编码　278 16.4　集成Mahout分类器　282 16.4.1　提前计划：集成中的关键问题　283 16.4.2　模型序列化　287 16.5　案例：一个基于Thrift的分类服务器　288 16.5.1　运行分类服务器　292 16.5.2　访问分类器服务　294 16.6　小结　296</span><br><span class="line"></span><br><span class="line"> 第17章　案例分析——Shop It To Me　297 17.1　Shop It To Me选择Mahout的原因　297 17.1.1　Shop It To Me公司简介　298 17.1.2　Shop It To Me需要分类系统的原因　298 17.1.3　对Mahout向外扩展　298 17.2　邮件交易系统的一般结构　299 17.3　训练模型　301 17.3.1　定义分类项目的目标　301 17.3.2　按时间划分　303 17.3.3　避免目标泄漏　303 17.3.4　调整学习算法　303 17.3.5　特征向量编码　304 17.4　加速分类过程　306 17.4.1　特征向量的线性组合　307 17.4.2　模型得分的线性扩展　308 17.5　小结　310</span><br><span class="line"></span><br><span class="line"> 附录A　JVM调优　311 附录B　Mahout数学基础　313 附录C　相关资源　318</span><br><span class="line"></span><br><span class="line"> 索引　320</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00IWYN9KO/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00IWYN9KO&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51sUA9JGl0L._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX环境高级编程(第3版)(英文版)</title>
    <url>/2020/04/19/B00KMR129E/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： UNIX环境高级编程(第3版)(英文版)<br>作者信息： 作者: 史蒂文斯 (W.Richard Stevens) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>20多年来，严谨的C程序员都是依靠一本书来深入了解驱动UNIX和Linux内核的编程接口的实用知识的，这本书就是W. Richard Stevens所著的《UNIX高级环境编程》。现在，Stevens的同事Steve Rago彻底更新了这本经典著作。新的第3版支持当今领先的系统平台，反映了最新技术进展和最佳实践，并且符合最新的Single UNIX Specification第4版（SUSv4）。<br>Rago保留了使本书前版成为经典之作的精髓和方法。他在Stevens原著的基础上，从基础的文件、目录和进程讲起，并给诸如信号处理和终端I/O之类的先进技术保留较大的篇幅。他还深入讨论了线程和多线程编程、使用套接字接口驱动进程间通信（IPC）等方面的内容。<br>这一版涵盖了70多个最新版POSIX.1标准的新增接口，包括POSIX异步I/O、旋转锁、屏障（barrier）和POSIX信号量。此外，这一版删除了许多过时的接口，保留了一些广泛使用的接口。书中几乎所有实例都已经在目前最主流的4个平台上测试过，包括Solaris 10、Mac OS X 10.6.8（Darwin 10.8.0）、FressBSD 8.0、Ubuntu 12.04（基于Linux 3.2内核）。<br>与前两版一样，读者仍可以通过实例学习，这些实例包括了1万多行可下载的ISO C源代码，书中通过简明但完整的程序阐述了400多个系统调用和函数，清楚地说明它们的用法、参数和返回值。为了使读者能融会贯通，书中还提供了几个贯穿整章的案例，每个案例都根据现在的技术环境进行了全面更新。<br>本书帮助了几代程序员写出强大、高性能、可靠的代码。第3版根据当今主流系统进行更新，更具实用价值。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章UNIX基础知识1</span><br><span class="line">1.1引言1</span><br><span class="line">1.2UNIX体系结构1</span><br><span class="line">1.3登录1</span><br><span class="line">1.4文件和目录3</span><br><span class="line">1.5输入和输出6</span><br><span class="line">1.6程序和进程8</span><br><span class="line">1.7出错处理11</span><br><span class="line">1.8用户标识13</span><br><span class="line">1.9信号14</span><br><span class="line">1.10时间值16</span><br><span class="line">1.11系统调用和库函数17</span><br><span class="line">1.12小结18</span><br><span class="line">习题18</span><br><span class="line">第2章UNIX标准及实现20</span><br><span class="line">2.1引言20</span><br><span class="line">2.2UNIX标准化20</span><br><span class="line">2.2.1ISOC20</span><br><span class="line">2.2.2IEEEPOSIX21</span><br><span class="line">2.2.3SingleUNIXSpecification25</span><br><span class="line">2.2.4FIPS26</span><br><span class="line">2.3UNIX系统实现26</span><br><span class="line">2.3.1SVR427</span><br><span class="line">2.3.24.4BSD27</span><br><span class="line">2.3.3FreeBSD28</span><br><span class="line">2.3.4Linux28</span><br><span class="line">2.3.5MacOSX28</span><br><span class="line">2.3.6Solaris28</span><br><span class="line">2.3.7其他UNIX系统29</span><br><span class="line">2.4标准和实现的关系29</span><br><span class="line">2.5限制29</span><br><span class="line">2.5.1ISOC限制30</span><br><span class="line">2.5.2POSIX限制31</span><br><span class="line">2.5.3XSI限制33</span><br><span class="line">2.5.4函数sysconf、pathconf和fpathconf33</span><br><span class="line">2.5.5不确定的运行时限制40</span><br><span class="line">2.6选项43</span><br><span class="line">2.7功能测试宏46</span><br><span class="line">2.8基本系统数据类型47</span><br><span class="line">2.9标准之间的冲突48</span><br><span class="line">2.10小结48</span><br><span class="line">习题48</span><br><span class="line">第3章文件I&#x2F;O49</span><br><span class="line">3.1引言49</span><br><span class="line">3.2文件描述符49</span><br><span class="line">3.3函数open和openat50</span><br><span class="line">3.4函数creat52</span><br><span class="line">3.5函数close53</span><br><span class="line">3.6函数lseek53</span><br><span class="line">3.7函数read57</span><br><span class="line">3.8函数write57</span><br><span class="line">3.9I&#x2F;O的效率58</span><br><span class="line">3.10文件共享59</span><br><span class="line">3.11原子操作62</span><br><span class="line">3.12函数dup和dup263</span><br><span class="line">3.13函数sync、fsync和fdatasync65</span><br><span class="line">3.14函数fcntl65</span><br><span class="line">3.15函数ioctl70</span><br><span class="line">3.16&#x2F;dev&#x2F;fd71</span><br><span class="line">3.17小结72</span><br><span class="line">习题72</span><br><span class="line">第4章文件和目录74</span><br><span class="line">4.1引言74</span><br><span class="line">4.2函数stat、fstat、fstatat和lstat74</span><br><span class="line">4.3文件类型75</span><br><span class="line">4.4设置用户ID和设置组ID78</span><br><span class="line">4.5文件访问权限79</span><br><span class="line">4.6新文件和目录的所有权80</span><br><span class="line">4.7函数access和faccessat81</span><br><span class="line">4.8函数umask82</span><br><span class="line">4.9函数chmod、fchmod和fchmodat84</span><br><span class="line">4.10粘着位87</span><br><span class="line">4.11函数chown、fchown、fchownat和lchown87</span><br><span class="line">4.12文件长度89</span><br><span class="line">4.13文件截断90</span><br><span class="line">4.14文件系统90</span><br><span class="line">4.15函数link、linkat、unlink、unlinkat和remove93</span><br><span class="line">4.16函数rename和renameat95</span><br><span class="line">4.17符号链接96</span><br><span class="line">4.18创建和读取符号链接99</span><br><span class="line">4.19文件的时间99</span><br><span class="line">4.20函数futimens、utimensat和utimes101</span><br><span class="line">4.21函数mkdir、mkdirat和rmdir103</span><br><span class="line">4.22读目录104</span><br><span class="line">4.23函数chdir、fchdir和getcwd108</span><br><span class="line">4.24设备特殊文件110</span><br><span class="line">4.25文件访问权限位小结112</span><br><span class="line">4.26小结113</span><br><span class="line">习题113</span><br><span class="line">第5章标准I&#x2F;O库115</span><br><span class="line">5.1引言115</span><br><span class="line">5.2流和FILE对象115</span><br><span class="line">5.3标准输入、标准输出和标准错误116</span><br><span class="line">5.4缓冲116</span><br><span class="line">5.5打开流118</span><br><span class="line">5.6读和写流120</span><br><span class="line">5.7每次一行I&#x2F;O122</span><br><span class="line">5.8标准I&#x2F;O的效率123</span><br><span class="line">5.9二进制I&#x2F;O125</span><br><span class="line">5.10定位流126</span><br><span class="line">5.11格式化I&#x2F;O127</span><br><span class="line">5.12实现细节131</span><br><span class="line">5.13临时文件134</span><br><span class="line">5.14内存流137</span><br><span class="line">5.15标准I&#x2F;O的替代软件140</span><br><span class="line">5.16小结140</span><br><span class="line">习题140</span><br><span class="line">第6章系统数据文件和信息142</span><br><span class="line">6.1引言142</span><br><span class="line">6.2口令文件142</span><br><span class="line">6.3阴影口令145</span><br><span class="line">6.4组文件146</span><br><span class="line">6.5附属组ID147</span><br><span class="line">6.6实现区别148</span><br><span class="line">6.7其他数据文件148</span><br><span class="line">6.8登录账户记录149</span><br><span class="line">6.9系统标识150</span><br><span class="line">6.10时间和日期例程151</span><br><span class="line">6.11小结157</span><br><span class="line">习题157</span><br><span class="line">第7章进程环境158</span><br><span class="line">7.1引言158</span><br><span class="line">7.2main函数158</span><br><span class="line">7.3进程终止158</span><br><span class="line">7.4命令行参数162</span><br><span class="line">7.5环境表163</span><br><span class="line">7.6C程序的存储空间布局163</span><br><span class="line">7.7共享库165</span><br><span class="line">7.8存储空间分配165</span><br><span class="line">7.9环境变量168</span><br><span class="line">7.10函数setjmp和longjmp170</span><br><span class="line">7.11函数getrlimit和setrlimit175</span><br><span class="line">7.12小结180</span><br><span class="line">习题180</span><br><span class="line">第8章进程控制181</span><br><span class="line">8.1引言181</span><br><span class="line">8.2进程标识181</span><br><span class="line">8.3函数fork182</span><br><span class="line">8.4函数vfork187</span><br><span class="line">8.5函数exit188</span><br><span class="line">8.6函数wait和waitpid190</span><br><span class="line">8.7函数waitid194</span><br><span class="line">8.8函数wait3和wait4195</span><br><span class="line">8.9竞争条件196</span><br><span class="line">8.10函数exec199</span><br><span class="line">8.11更改用户ID和更改组ID204</span><br><span class="line">8.12解释器文件207</span><br><span class="line">8.13函数system211</span><br><span class="line">8.14进程会计215</span><br><span class="line">8.15用户标识220</span><br><span class="line">8.16进程调度221</span><br><span class="line">8.17进程时间224</span><br><span class="line">8.18小结226</span><br><span class="line">习题226</span><br><span class="line">第9章进程关系228</span><br><span class="line">9.1引言228</span><br><span class="line">9.2终端登录228</span><br><span class="line">9.3网络登录231</span><br><span class="line">9.4进程组233</span><br><span class="line">9.5会话234</span><br><span class="line">9.6控制终端235</span><br><span class="line">9.7函数tcgetpgrp、tcsetpgrp和tcgetsid237</span><br><span class="line">9.8作业控制237</span><br><span class="line">9.9shell执行程序240</span><br><span class="line">9.10孤儿进程组244</span><br><span class="line">9.11FreeBSD实现246</span><br><span class="line">9.12小结248</span><br><span class="line">习题248</span><br><span class="line">第10章信号249</span><br><span class="line">10.1引言249</span><br><span class="line">10.2信号概念249</span><br><span class="line">10.3函数signal256</span><br><span class="line">10.4不可靠的信号259</span><br><span class="line">10.5中断的系统调用260</span><br><span class="line">10.6可重入函数262</span><br><span class="line">10.7SIGCLD语义264</span><br><span class="line">10.8可靠信号术语和语义266</span><br><span class="line">10.9函数kill和raise267</span><br><span class="line">10.10函数alarm和pause268</span><br><span class="line">10.11信号集273</span><br><span class="line">10.12函数sigprocmask275</span><br><span class="line">10.13函数sigpending276</span><br><span class="line">10.14函数sigaction278</span><br><span class="line">10.15函数sigsetjmp和siglongjmp283</span><br><span class="line">10.16函数sigsuspend286</span><br><span class="line">10.17函数abort291</span><br><span class="line">10.18函数system293</span><br><span class="line">10.19函数sleep、nanosleep和clock_nanosleep298</span><br><span class="line">10.20函数sigqueue300</span><br><span class="line">10.21作业控制信号301</span><br><span class="line">10.22信号名和编号303</span><br><span class="line">10.23小结305</span><br><span class="line">习题305</span><br><span class="line">第11章线程307</span><br><span class="line">11.1引言307</span><br><span class="line">11.2线程概念307</span><br><span class="line">11.3线程标识308</span><br><span class="line">11.4线程创建309</span><br><span class="line">11.5线程终止311</span><br><span class="line">11.6线程同步318</span><br><span class="line">11.6.1互斥量320</span><br><span class="line">11.6.2避免死锁322</span><br><span class="line">11.6.3函数pthread_mutex_timedlock327</span><br><span class="line">11.6.4读写锁328</span><br><span class="line">11.6.5带有超时的读写锁332</span><br><span class="line">11.6.6条件变量332</span><br><span class="line">11.6.7自旋锁335</span><br><span class="line">11.6.8屏障336</span><br><span class="line">11.7小结340</span><br><span class="line">习题340</span><br><span class="line">第12章线程控制341</span><br><span class="line">12.1引言341</span><br><span class="line">12.2线程限制341</span><br><span class="line">12.3线程属性342</span><br><span class="line">12.4同步属性345</span><br><span class="line">12.4.1互斥量属性345</span><br><span class="line">12.4.2读写锁属性352</span><br><span class="line">12.4.3条件变量属性353</span><br><span class="line">12.4.4屏障属性353</span><br><span class="line">12.5重入354</span><br><span class="line">12.6线程特定数据358</span><br><span class="line">12.7取消选项361</span><br><span class="line">12.8线程和信号364</span><br><span class="line">12.9线程和fork367</span><br><span class="line">12.10线程和I&#x2F;O370</span><br><span class="line">12.11小结371</span><br><span class="line">习题371</span><br><span class="line">第13章守护进程372</span><br><span class="line">13.1引言372</span><br><span class="line">13.2守护进程的特征372</span><br><span class="line">13.3编程规则374</span><br><span class="line">13.4出错记录377</span><br><span class="line">13.5单实例守护进程380</span><br><span class="line">13.6守护进程的惯例381</span><br><span class="line">13.7客户进程—服务器进程模型386</span><br><span class="line">13.8小结386</span><br><span class="line">习题387</span><br><span class="line">第14章高级I&#x2F;O388</span><br><span class="line">14.1引言388</span><br><span class="line">14.2非阻塞I&#x2F;O388</span><br><span class="line">14.3记录锁391</span><br><span class="line">14.4I&#x2F;O多路转接403</span><br><span class="line">14.4.1函数select和pselect404</span><br><span class="line">14.4.2函数poll408</span><br><span class="line">14.5异步I&#x2F;O410</span><br><span class="line">14.5.1SystemV异步I&#x2F;O410</span><br><span class="line">14.5.2BSD异步I&#x2F;O411</span><br><span class="line">14.5.3POSIX异步I&#x2F;O411</span><br><span class="line">14.6函数readv和writev419</span><br><span class="line">14.7函数readn和writen421</span><br><span class="line">14.8存储映射I&#x2F;O422</span><br><span class="line">14.9小结428</span><br><span class="line">习题428</span><br><span class="line">第15章进程间通信429</span><br><span class="line">15.1 引言429</span><br><span class="line">15.2 管道430</span><br><span class="line">15.3函数popen和pclose436</span><br><span class="line">15.4 协同进程441</span><br><span class="line">15.5 FIFO445</span><br><span class="line">15.6 XSIIPC448</span><br><span class="line">15.6.1标识符和键448</span><br><span class="line">15.6.2权限结构449</span><br><span class="line">15.6.3结构限制450</span><br><span class="line">15.6.4优点和缺点450</span><br><span class="line">15.7 消息队列451</span><br><span class="line">15.8 信号量455</span><br><span class="line">15.9 共享存储459</span><br><span class="line">15.10 POSIX信号量465</span><br><span class="line">15.11 客户进程—服务器进程属性470</span><br><span class="line">15.11小结472</span><br><span class="line">习题472</span><br><span class="line">第16章网络IPC：套接字474</span><br><span class="line">16.1引言474</span><br><span class="line">16.2套接字描述符474</span><br><span class="line">16.3寻址477</span><br><span class="line">16.3.1字节序477</span><br><span class="line">16.3.2地址格式478</span><br><span class="line">16.3.3 地址查询480</span><br><span class="line">16.3.4 将套接字与地址关联486</span><br><span class="line">16.4建立连接487</span><br><span class="line">16.5数据传输491</span><br><span class="line">16.6套接字选项502</span><br><span class="line">16.7带外数据504</span><br><span class="line">16.8非阻塞和异步I&#x2F;O505</span><br><span class="line">16.9小结506</span><br><span class="line">习题506</span><br><span class="line">第17章高级进程间通信507</span><br><span class="line">17.1 引言507</span><br><span class="line">17.2 UNIX域套接字507</span><br><span class="line">17.3 唯一连接512</span><br><span class="line">17.4 传送文件描述符518</span><br><span class="line">17.5 open服务器进程第1版527</span><br><span class="line">17.6 open服务器进程第2版533</span><br><span class="line">17.7小结542</span><br><span class="line">习题542</span><br><span class="line">第18章终端I&#x2F;O544</span><br><span class="line">18.1引言544</span><br><span class="line">18.2综述544</span><br><span class="line">18.3特殊输入字符549</span><br><span class="line">18.4获得和设置终端属性553</span><br><span class="line">18.5终端选项标志554</span><br><span class="line">18.6stty命令560</span><br><span class="line">18.7波特率函数560</span><br><span class="line">18.8行控制函数561</span><br><span class="line">18.9终端标识562</span><br><span class="line">18.10规范模式567</span><br><span class="line">18.11非规范模式570</span><br><span class="line">18.12终端窗口大小576</span><br><span class="line">18.13termcap、terminfo和curses578</span><br><span class="line">18.14小结578</span><br><span class="line">习题579</span><br><span class="line">第19章伪终端580</span><br><span class="line">19.1引言580</span><br><span class="line">19.2概述580</span><br><span class="line">19.3打开伪终端设备585</span><br><span class="line">19.4函数pty_fork588</span><br><span class="line">19.5pty程序590</span><br><span class="line">19.6使用pty程序595</span><br><span class="line">19.7高级特性600</span><br><span class="line">19.8小结601</span><br><span class="line">习题601</span><br><span class="line">第20章数据库函数库603</span><br><span class="line">20.1 引言603</span><br><span class="line">20.2 历史603</span><br><span class="line">20.3函数库604</span><br><span class="line">20.4 实现概述605</span><br><span class="line">20.5集中式或非集中式608</span><br><span class="line">20.6并发610</span><br><span class="line">20.7构造函数库610</span><br><span class="line">20.8源代码611</span><br><span class="line">20.9性能635</span><br><span class="line">20.10小结639</span><br><span class="line">习题639</span><br><span class="line">第21章与网络打印机通信640</span><br><span class="line">21.1引言640</span><br><span class="line">21.2网络打印协议640</span><br><span class="line">21.3超文本传输协议HTTP642</span><br><span class="line">21.4打印假脱机技术643</span><br><span class="line">21.5源代码644</span><br><span class="line">21.6小结684</span><br><span class="line">习题684</span><br><span class="line">附录A函数原型685</span><br><span class="line">附录A函数原型附录B其他源代码721</span><br><span class="line">附录C部分习题答案730</span><br><span class="line">附录参考书目730</span><br><span class="line">索引770</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00KMR129E/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00KMR129E&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51-yjqb7oHL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>unix</tag>
      </tags>
  </entry>
  <entry>
    <title>易学Python</title>
    <url>/2020/04/19/B00IXB6MF0/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 易学Python<br>作者信息： 作者: Anthony Briggs [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Python凭借其迅速和高效的特点虏获了程序员的芳心，Python编程语言的学习也应该具备迅速和高效的特点。《易学Python》正是以这样一种方式，通过让读者自行编写程序来学习Python的基本概念，以及一些高级概念和编程新风格的简单介绍。简单易学  即使读者之前没有写过一行代码，也可以迅速写出真正的Python应用程序。案例优秀  本书每章都有新花样，其中包括游戏、Django Web开发、数据库等。图文并茂  使用大量的卡通插图和平实的写作风格，来引导读者学习Python。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目　录 </span><br><span class="line"></span><br><span class="line"> 第1章　为何学习Python　1 1.1　学习编程　2 1.1.1　告诉计算机做什么　2 1.1.2　编程是创意　4 1.1.3　编程是设计　4 1.2　是什么让Python如此杰出　5 1.2.1　Python简单易学　5 1.2.2　Python是真正的语言　5 1.2.3　Python“开箱即用”　6 1.2.4　Python社区规模庞大　6 1.3　在Windows系统上安装Python　7 1.3.1　安装Python　7 1.3.2　在Windows系统上运行Python程序　9 1.3.3　从命令行运行Python程序　11 1.4　Linux　14 1.4.1　在Linux系统上安装Python　14 1.4.2　Linux GUI　14 1.4.3　Linux命令行　16 1.5　Macintosh　16 1.5.1　更新Shell配置文件　17 1.5.2　设置默认应用程序　17 1.6　排除故障　18 1.6.1　语法错误　18 1.6.2　文件扩展名不对(Windows)　19 1.6.3　Python的安装位置不对(Linux)　19 1.7　文本编辑器和IDE　19 1.8　总结　20</span><br><span class="line"></span><br><span class="line"> 第2章　Hunt the Wumpus　21 2.1　程序是什么　22 2.1.1　在屏幕上显示　23 2.1.2　使用变量存储信息　23 2.1.3　询问玩家想做什么　24 2.1.4　做出决策　24 2.1.5　循环　25 2.1.6　函数　26 2.2　您的第一个程序　27 2.2.1　Hunt the Wumpus的第一个版本　27 2.2.2　调试　29 2.3　捣鼓程序　29 2.3.1　调整洞穴数量　30 2.3.2　更友好的wumpus　30 2.3.3　多个wumpus　30 2.4　创建洞穴　31 2.4.1　列表　31 2.4.2　for循环　33 2.4.3　构造洞穴网络　33 2.5　修复微妙的错误　35 2.5.1　问题　36 2.5.2　解决方案　36 2.5.3　打造连通的洞穴网络　36 2.6　使用函数让代码更整洁　39 2.6.1　函数的基本知识　39 2.6.2　变量作用域　40 2.6.3　共享状态　41 2.7　使用函数组织游戏Hunt the Wumpus　42 2.7.1　与洞穴交互　42 2.7.2　创建洞穴　43 2.7.3　与玩家交互　44 2.7.4　程序的其他部分　45 2.8　弓和箭　47 2.9　进一步美化　49 2.10　接下来如何做　51 2.10.1　蝙蝠和深渊　52 2.10.2　让Wumpus移动　52 2.10.3　不同的洞穴网络　52 2.11　总结　52</span><br><span class="line"></span><br><span class="line"> 第3章　与外部交互　53 3.1　开箱即用：Python库　54 3.1.1　Python标准库　54 3.1.2　其他库　54 3.1.3　使用库　55 3.1.4　库到底是什么　55 3.2　另一种提问方式　58 3.2.1　使用命令行参数　58 3.2.2　使用模块sys　58 3.3　读写文件　59 3.3.1　路径和目录(我的文件在哪里)　59 3.3.2　路径　61 3.3.3　打开文件　61 3.4　比较文件　63 3.4.1　采集文件的指纹　63 3.4.2　将文件的指纹存储到字典中　64 3.5　综合应用　65 3.6　测试程序　68 3.7　改进脚本　70 3.7.1　按顺序排列结果　70 3.7.2　比较目录　72 3.8　接下来如何做　73 3.9　总结　73</span><br><span class="line"></span><br><span class="line"> 第4章　组织有序　74 4.1　规范程序　74 4.2　如何确定程序是正确的　75 4.2.1　手工测试太烦　75 4.2.2　功能测试　76 4.2.3　单元测试：让计算机去做　76 4.2.4　测试驱动的开发　76 4.3　编写程序　77 4.4　整合程序　80 4.4.1　测试用户界面　80 4.4.2　用输入做什么　81 4.4.3　执行命令　82 4.4.4　运行程序　85 4.5　状况评估　85 4.5.1　接下来做什么　86 4.5.2　我既繁忙又重要　88 4.5.3　列表解析　89 4.5.4　发现bug　92 4.6　存储待办事项清单　95 4.7　编辑和删除　98 4.7.1　修复一个小问题　99 4.7.2　删除待办事项　101 4.7.3　编辑待办事项　103 4.8　接下来如何做　106 4.8.1　帮助命令　106 4.8.2　撤销　106 4.8.3　不同的界面　107 4.8.4　时间管理和估算　107 4.8.5　研究一个单元测试框架　107 4.9　总结　107</span><br><span class="line"></span><br><span class="line"> 第5章　面向业务的编程　109 5.1　让程序相互交流　110 5.1.1　CSV来救场　110 5.1.2　其他格式　111 5.2　准备工作　112 5.2.1　安装Beautiful Soup　112 5.2.2　安装Firefox和Firebug　113 5.2.3　查看网页　113 5.3　使用Python下载网页　115 5.3.1　提取想要的数据　116 5.3.2　进一步提取数据　117 5.3.3　网页抓取的注意事项　119 5.4　写入CSV文件　119 5.5　通过电子邮件发送CSV文件　121 5.5.1　电子邮件的结构　121 5.5.2　创建电子邮件　122 5.5.3　发送电子邮件　123 5.5.4　其他电子邮件模块　124 5.6　一个简单脚本——哪些地方可能出问题　125 5.6.1　未连接到网络　126 5.6.2　数据无效　126 5.6.3　数据出乎意料　126 5.6.4　无法写入数据　126 5.6.5　无法访问邮件服务器　126 5.6.6　您不必修复这些问题　127 5.7　如何处理有问题的脚本　127 5.7.1　交流　127 5.7.2　对故障的承受力　127 5.7.3　一开始就做好　128 5.7.4　失败要赶早，还要大张旗鼓　128 5.7.5　双保险　128 5.7.6　压力测试和性能测试　129 5.7.7　以后再试　129 5.8　异常　131 5.8.1　为何使用异常　131 5.8.2　程序崩溃是什么意思　131 5.8.3　捕获异常　134 5.8.4　模块traceback　135 5.9　接下来如何做　136 5.10　总结　136</span><br><span class="line"></span><br><span class="line"> 第6章　类与面向对象编程　137 6.1　类是什么　137 6.1.1　类包含数据　138 6.1.2　类是类型　138 6.1.3　类的工作原理　138 6.1.4　您的第一个类　138 6.2　面向对象设计　140 6.3　玩家输入　143 6.4　财宝　146 6.4.1　方法该放在什么地方　146 6.4.2　寻宝　147 6.4.3　捡宝　148 6.5　在洞穴迷宫中漫步　151 6.6　怪物出没　156 6.6.1　创建怪物　156 6.6.2　一些面向对象的技巧　157 6.6.3　组合起来　158 6.7　危险与刺激　161 6.8　接下来如何做　163 6.8.1　增加怪物和财宝　164 6.8.2　扩展格斗方式和物品　164 6.8.3　添加更多冒险元素　164 6.8.4　尝试动词和名词　164 6.8.5　研究类的高级功能　164 6.9　总结　164</span><br><span class="line"></span><br><span class="line"> 第7章　高级技术　166 7.1　面向对象　166 7.1.1　混合类　166 7.1.2　super()及注意事项　169 7.2　定制类　169 7.2.1　getattr　170 7.2.2　setattr　170 7.2.3　getattribute　172 7.2.4　特性(property)　173 7.2.5　模拟其他类型　175 7.3　生成器和迭代器　177 7.3.1　迭代器　177 7.3.2　生成器　179 7.3.3　生成器表达式　180 7.4　使用迭代器　180 7.4.1　读文件　181 7.4.2　处理日志行　183 7.4.3　提取字段　184 7.5　函数式编程　188 7.5.1　副作用　188 7.5.2　map和filter　188 7.5.3　传递和返回函数　189 7.6　接下来如何做　191 7.7　总结　191</span><br><span class="line"></span><br><span class="line"> 第8章　Django　192 8.1　使用Django编写Web应用　193 8.1.1　安装Django　193 8.1.2　设置Django　193 8.2　编写应用　197 8.2.1　最简单的待办事项清单　197 8.2.2　使用模板　198 8.3　使用模型　201 8.3.1　设置数据库　201 8.3.2　创建模型　201 8.3.3　Django模块admin　203 8.3.4　添加管理界面　204 8.4　使用数据　206 8.4.1　使用模型　206 8.4.2　设计URL　208 8.4.3　提交表单　210 8.4.4　处理待办事项　213 8.5　最后的优化　216 8.6　接下来如何做　217 8.7　总结　217</span><br><span class="line"></span><br><span class="line"> 第9章　使用Pyglet开发游戏　218 9.1　安装Pyglet　218 9.2　起步　220 9.3　简单的宇宙飞船　222 9.3.1　让事情发生　224 9.3.2　回到学校：牛顿第一定律及矢量　226 9.4　引力　229 9.4.1　计算引力　229 9.4.2　小心行星　232 9.5　不能缺了枪炮　234 9.6　邪恶的外星人　237 9.7　接下来如何做　242 9.7.1　添加新元素　242 9.7.2　改成别的类型　242 9.7.3　重构　243 9.7.4　获取反馈　243 9.8　总结　243</span><br><span class="line"></span><br><span class="line"> 第10章　Twisted网络编程　244 10.1　安装Twisted　244 10.2　第一个应用程序　245 10.3　MUD初步　249 10.4　让游戏更有趣　254 10.4.1　可恨的怪物　254 10.4.2　回到聊天服务器　256 10.5　要求玩家登录　260 10.5.1　探索不熟悉的代码　260 10.5.2　整合　261 10.5.3　编写自定义状态机　265 10.6　保存玩家状态　269 10.7　接下来如何做　273 10.8　总结　273</span><br><span class="line"></span><br><span class="line"> 第11章　再谈Django　274 11.1　身份验证　274 11.1.1　登录　275 11.1.2　添加用户　277 11.2　只列出当前用户的待办事项　278 11.2.1　修复数据库　279 11.2.2　言归正传　282 11.2.3　滴水不漏　283 11.2.4　更新接口　284 11.3　测试　285 11.3.1　单元测试　285 11.3.2　功能测试　287 11.3.3　运行测试　288 11.4　图像和样式　289 11.4.1　使用Django提供媒体内容　289 11.4.2　由另一个服务器提供媒体　291 11.4.3　最后一步　292 11.5　接下来如何做　292 11.6　总结　293</span><br><span class="line"></span><br><span class="line"> 第12章　接下来如何做　294 12.1　再阅读一些代码　294 12.1.1　Python标准库　295 12.1.2　Python秘诀　295 12.1.3　开源项目　295 12.1.4　加入Python社区　295 12.1.5　加入邮件列表　295 12.1.6　寻找当地用户组　296 12.1.7　给开源项目帮忙　296 12.2　解决自己遇到的问题　296 12.3　其他Python库　297 12.3.1　代码剖析　297 12.3.2　日志　297 12.3.3　子进程和多任务　297 12.3.4　更复杂的分析　297 12.3.5　PIL和图像处理　298 12.3.6　XML、ElementTree和JSON　298 12.4　总结　298</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00IXB6MF0/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00IXB6MF0&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/519JRseVEBL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>周鸿祎自述:我的互联网方法论</title>
    <url>/2020/04/19/B00LO3SVSA/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 周鸿祎自述:我的互联网方法论<br>作者信息： 作者: 周鸿祎 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《周鸿祎自述:我的互联网方法论》编辑推荐：《周鸿祎自述:我的互联网方法论》是中国安全之父、颠覆式创新家、360 掌门人周鸿祎唯一一部亲笔著作。在《周鸿祎自述:我的互联网方法论》中，第一代互联网老兵，分享独家成功秘籍。系统阐述十几年互联网观、产品观和管理思想，解密360的产品策略、商业战略和成长逻辑。周鸿祎首次面向传统企业，讲述独家转型方法论。<br>如果你致力于成为史上最牛叉的产品经理，如果你是渴求成功却陷于困境的互联网创业者，如果你是曾经叱咤风云如今却看不清互联网大势的传统行业从业者。<br>或者，你仅仅是一位刚刚走出校园的学生，却相信自己可以改变世界……来听听第一代互联网老兵周鸿祎的互联网方法论<br>本书聚焦企业最关注的热点问题：互联网时代的大趋势是什么？传统行业如何面对互联网的挑战？360为什么奉行“用户至上”？互联网产品的本质是什么？为什么互联网可以真免费？为什么说口碑是衡量创新的标准？<br>本书为企业提供最有效的互联网转型指南：360的赚钱之道；互联网产品秘籍；好产品是让用户离不开；<br>互联网时代的“扁平化”管理和“小而美”组织；企业创新土壤的培养方法。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一章 欢迎来到互联网时代</span><br><span class="line">任何企业都可以找最强的竞争对手，但有一个对手你是打不过的，那就是趋势。趋势一旦爆发，就不会是一个线性的发展。它会积蓄力量于无形，最后突然爆发出雪崩效应，任何不愿意改变的力量都会在雪崩面前被毁灭，被市场边缘化。</span><br><span class="line">没有人能打败趋势</span><br><span class="line">互联网里的黑天鹅</span><br><span class="line">火鸡的悲剧</span><br><span class="line">互联网思维就是一层纸</span><br><span class="line">消费者变了，营销要玩新手法</span><br><span class="line">核心是产品体验</span><br><span class="line">商业模式不是赚钱模式</span><br><span class="line">第二章 互联网里的用户至上</span><br><span class="line">为什么说360是一个互联网公司，而不是单纯的杀毒软件公司？因为360不是靠卖杀毒软件挣钱，而是通过免费杀毒得到了海量的用户基数。直到今天，360杀毒依然不赚钱，但因为我们向海量用户推荐使用360浏览器，通过导航、搜索、网页游戏等业务获得了丰厚利润。这就是用户的力量。</span><br><span class="line">是用户，而不是客户</span><br><span class="line">用户是互联网商业模式的基础</span><br><span class="line">360为什么要“用户至上”？</span><br><span class="line">互联网产品的本质是为用户服务</span><br><span class="line">第三章 颠覆式创新</span><br><span class="line">颠覆式创新都不是敲锣打鼓来的，而是隐藏在一片噪声里，它是代表了未来趋势的一个讯号，但你却通常看不到、看不懂、看不清。所以，一定不能以一种藐视的态度来看一个新生事物，它可能满身缺点，但是颠覆你的东西，不需要做成十项全能，它只要在一个点上追求极致，远远超过你，这就足够了。</span><br><span class="line">颠覆式创新是人性的表达</span><br><span class="line">颠覆式创新是屌丝的逆袭</span><br><span class="line">360是如何颠覆传统杀毒市场的？</span><br><span class="line">颠覆和破坏不是贬义词</span><br><span class="line">颠覆式创新为什么总是发源于小企业</span><br><span class="line">颠覆不是敲锣打鼓来的</span><br><span class="line">颠覆式创新，需要逆向思维</span><br><span class="line">乔布斯是如何苹果进行颠覆的？</span><br><span class="line">乔布斯的拿来主义</span><br><span class="line">《创新者的窘境》、《柔道战略》和《定位》</span><br><span class="line">《创新者的窘境》之引言</span><br><span class="line">第四章 免费时代</span><br><span class="line">传统经济的本质，就是低买高卖。但互联网最激动人心的地方，在于你能给亿万用户提供一个非常好的产品，免费用，最后你还能因此获得巨额的财富。这种模式在传统的商业世界中是无法解释的。</span><br><span class="line">免费开启我的互联网之旅</span><br><span class="line">真免费和假免费</span><br><span class="line">为什么互联网可以真免费？</span><br><span class="line">免费是一种商业模式</span><br><span class="line">免费不仅是商业模式</span><br><span class="line">企鹅的秘密</span><br><span class="line">360为什么要免费？</span><br><span class="line">都是免费惹得祸</span><br><span class="line">硬件也免费</span><br><span class="line">什么是互联网化？</span><br><span class="line">免费是一种颠覆性的力量</span><br><span class="line">互联网的转型与跨界</span><br><span class="line">为什么我不看好智能手表？</span><br><span class="line">特写：360是如何赚钱的？</span><br><span class="line">特写：免费VS收费的三次战争</span><br><span class="line">第五章 体验为王</span><br><span class="line">在拉斯维加斯有一个酒店，客人离开酒店的时候，门童会塞上两瓶冰镇矿泉水，免费给客人在路上喝的。这两瓶水给客人的感觉是无微不至的关怀，也是预料之外的贴心服务。这就是超出预期的体验，才是真正的客户体验。</span><br><span class="line">一个百亿美元的教训</span><br><span class="line">超出预期的才叫用户体验。</span><br><span class="line">亚马逊的“飞轮”</span><br><span class="line">苹果的像素</span><br><span class="line">体验需要追求极致</span><br><span class="line">体验的基础是用户需求</span><br><span class="line">细节，还是细节</span><br><span class="line">一定要聚焦</span><br><span class="line">大道至简</span><br><span class="line">商业秀节选</span><br><span class="line">第六章 互联网方法论</span><br><span class="line">在微创新的时候，很重要一点就是不要老想着做平台。无论是创业公司，还是转型互联网的传统企业，最忌讳的就是一上来就冲着宏大的平台化思维做，因为用户不会因为你做了一个平台就接受你的产品。</span><br><span class="line">什么是微创新？</span><br><span class="line">小处着眼</span><br><span class="line">小步快跑</span><br><span class="line">不要平台化思维</span><br><span class="line">口碑是衡量创新的标准</span><br><span class="line">创新需要土壤</span><br><span class="line">容忍失败</span><br><span class="line">硅谷创业者的启示</span><br><span class="line">think Different</span><br><span class="line">战略必须要落地到产品</span><br><span class="line">互联网产品秘籍</span><br><span class="line">好的产品：让用户离不开</span><br><span class="line">好的体验需要处处留心</span><br><span class="line">做产品需要“现场力”</span><br><span class="line">强需求与弱需求</span><br><span class="line">像小白一样思考</span><br><span class="line">做产品要有一颗粗糙的心</span><br><span class="line">360如何做产品</span><br><span class="line">如何建立一个“铁打的营盘”？</span><br><span class="line">“扁平化”与“小而美”</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00LO3SVSA/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00LO3SVSA&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51MfBv%2BwToL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title>Python黑帽子:黑客与渗透测试编程之道</title>
    <url>/2020/04/19/B013KKCLE4/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Python黑帽子:黑客与渗透测试编程之道<br>作者信息： 作者: 塞茨 (Justin Seitz) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Python黑帽子:黑客与渗透测试编程之道》适合有一定编程基础的安全爱好者、计算机从业人员阅读，特别是对正在学习计算机安全专业，立志从事计算机安全行业，成为渗透测试人员的人来说，这本书更是不可多得的参考。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章设置Python环境</span><br><span class="line">安装Kali Linux虚拟机</span><br><span class="line">WingIDE</span><br><span class="line">第2章网络基础</span><br><span class="line">Python网络编程简介</span><br><span class="line">TCP客户端</span><br><span class="line">UDP客户端</span><br><span class="line">TCP服务器</span><br><span class="line">取代netcat</span><br><span class="line">小试牛刀</span><br><span class="line">创建一个TCP代理</span><br><span class="line">小试牛刀</span><br><span class="line">通过Paramiko使用SSH</span><br><span class="line">小试牛刀</span><br><span class="line">SSH隧道</span><br><span class="line">小试牛刀</span><br><span class="line">第3章网络：原始套接字和流量嗅探</span><br><span class="line">开发UDP主机发现工具</span><br><span class="line">Windows和Linux上的包嗅探</span><br><span class="line">小试牛刀</span><br><span class="line">解码IP层</span><br><span class="line">小试牛刀</span><br><span class="line">解码ICMP</span><br><span class="line">小试牛刀</span><br><span class="line">第4章Scapy：网络的掌控者</span><br><span class="line">窃取Email认证</span><br><span class="line">小试牛刀</span><br><span class="line">利用Scapy进行ARP缓存投毒</span><br><span class="line">小试牛刀</span><br><span class="line">处理PCAP文件</span><br><span class="line">小试牛刀</span><br><span class="line">第5章Web攻击</span><br><span class="line">Web的套接字函数库：urlli2</span><br><span class="line">开源Web应用安装</span><br><span class="line">小试牛刀</span><br><span class="line">暴力破解目录和文件位置</span><br><span class="line">小试牛刀</span><br><span class="line">暴力破解HTML表格认证</span><br><span class="line">小试牛刀</span><br><span class="line">第6章扩展Burp代理</span><br><span class="line">配置</span><br><span class="line">Burp模糊测试</span><br><span class="line">小试牛刀</span><br><span class="line">在Burp中利用Bing服务</span><br><span class="line">小试牛刀</span><br><span class="line">利用网站内容生成密码字典</span><br><span class="line">小试牛刀</span><br><span class="line">第7章基于GitHub的命令和控制</span><br><span class="line">GitHub账号设置</span><br><span class="line">创建模块</span><br><span class="line">木马配置</span><br><span class="line">编写基于GitHub通信的木马</span><br><span class="line">Python模块导入功能的破解</span><br><span class="line">小试牛刀</span><br><span class="line">第8章Windows下木马的常用功能</span><br><span class="line">有趣的键盘记录</span><br><span class="line">小试牛刀</span><br><span class="line">截取屏幕快照</span><br><span class="line">Python方式的shellcode执行</span><br><span class="line">小试牛刀</span><br><span class="line">沙盒检测</span><br><span class="line">第9章玩转浏览器</span><br><span class="line">基于浏览器的中间人攻击</span><br><span class="line">创建接收服务器</span><br><span class="line">小试牛刀</span><br><span class="line">利用IE的COM组件自动化技术窃取数据</span><br><span class="line">小试牛刀</span><br><span class="line">第10章Windows系统提权</span><br><span class="line">环境准备</span><br><span class="line">创建进程监视器</span><br><span class="line">利用WMI监视进程</span><br><span class="line">小试牛刀</span><br><span class="line">Windows系统的令牌权限</span><br><span class="line">赢得竞争</span><br><span class="line">小试牛刀</span><br><span class="line">代码插入</span><br><span class="line">小试牛刀</span><br><span class="line">第11章自动化攻击取证</span><br><span class="line">工具安装</span><br><span class="line">工具配置</span><br><span class="line">抓取口令的哈希值</span><br><span class="line">直接代码注入</span><br><span class="line">小试牛刀</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B013KKCLE4/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B013KKCLE4&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/6100LpSqTbL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>编写可维护的JavaScript</title>
    <url>/2020/04/19/bian-xie-ke-wei-hu-de-javascript/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 编写可维护的JavaScript<br>作者信息： 作者: 扎卡斯 [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《编写可维护的JavaScript》中强调：任何语言都需要强调编码风格的一致性。只要是团队开发，每个人都以相同方式编写代码就是至关重要的。这样大家才能方便地互相看懂和维护对方的代码。运用《编写可维护的JavaScript》中讲述的技巧和技术，可以使JavaScript团队编程从侠义的个人偏好的阴霾走出来，走向真正的高可维护性、高效能和高水准。它是一本构建编码风格手册，帮助开发团队从“游击队”走向“正规军”。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分 编程风格</span><br><span class="line">第1章 基本的格式化</span><br><span class="line">1.1 缩进层级</span><br><span class="line">1.2 语句结尾</span><br><span class="line">1.3 行的长度</span><br><span class="line">1.4 换行</span><br><span class="line">1.5 空行</span><br><span class="line">1.6 命名</span><br><span class="line">1.6.1 变量和函数</span><br><span class="line">1.6.2 常量</span><br><span class="line">1.6.3 构造函数</span><br><span class="line">1.7 直接量</span><br><span class="line">1.7.1 字符串</span><br><span class="line">1.7.2 数字</span><br><span class="line">1.7.3 null</span><br><span class="line">1.7.4 undefined</span><br><span class="line">1.7.5 对象直接量</span><br><span class="line">1.7.6 数组直接量</span><br><span class="line">第2章 注释</span><br><span class="line">2.1 单行注释</span><br><span class="line">2.2 多行注释</span><br><span class="line">2.3 使用注释</span><br><span class="line">2.3.1 难于理解的代码</span><br><span class="line">2.3.2 可能被误认为错误的代码</span><br><span class="line">2.3.3 浏览器特性hack</span><br><span class="line">2.4 文档注释</span><br><span class="line">第3章 语句和表达式</span><br><span class="line">3.1 花括号的对齐方式</span><br><span class="line">3.2 块语句间隔</span><br><span class="line">3.3 switch语句</span><br><span class="line">3.3.1 缩进</span><br><span class="line">3.3.2 case语句的“连续执行”</span><br><span class="line">3.3.3 default</span><br><span class="line">3.4 with语句</span><br><span class="line">3.5 for循环</span><br><span class="line">3.6 for－in循环</span><br><span class="line">第4章 变量、函数和运算符</span><br><span class="line">4.1 变量声明</span><br><span class="line">4.2 函数声明</span><br><span class="line">4.3 函数调用间隔</span><br><span class="line">4.4 立即调用的函数</span><br><span class="line">4.5 严格模式</span><br><span class="line">4.6 相等</span><br><span class="line">4.6.1 eval（）</span><br><span class="line">4.6.2 原始包装类型</span><br><span class="line">第二部分 编程实践</span><br><span class="line">第5章 UI层的松耦合</span><br><span class="line">5.1 什么是松耦合</span><br><span class="line">5.2 将JavaScript从CSS中抽离</span><br><span class="line">5.3 将CSS从JavaScript中抽离</span><br><span class="line">5.4 将JavaScript从HTML中抽离</span><br><span class="line">5.5 将HTML从JavaScript中抽离</span><br><span class="line">5.5.1 方法1：从服务器加载</span><br><span class="line">5.5.2 方法2：简单客户端模板</span><br><span class="line">5.5.3 方法3：复杂客户端模板</span><br><span class="line">第6章 避免使用全局变量</span><br><span class="line">6.1 全局变量带来的问题</span><br><span class="line">6.1.1 命名冲突</span><br><span class="line">6.1.2 代码的脆弱性</span><br><span class="line">6.1.3 难以测试</span><br><span class="line">6.2 意外的全局变量</span><br><span class="line">避免意外的全局变量</span><br><span class="line">6.3 单全局变量方式</span><br><span class="line">6.3.1 命名空间</span><br><span class="line">6.3.2 模块</span><br><span class="line">6.4 零全局变量</span><br><span class="line">第7章 事件处理</span><br><span class="line">7.1 典型用法</span><br><span class="line">7.2 规则1：隔离应用逻辑</span><br><span class="line">7.3 规则2：不要分发事件对象</span><br><span class="line">第8章 避免“空比较”</span><br><span class="line">8.1 检测原始值</span><br><span class="line">8.2 检测引用值</span><br><span class="line">8.2.1 检测函数</span><br><span class="line">8.2.2 检测数组</span><br><span class="line">8.3 检测属性</span><br><span class="line">第9章 将配置数据从代码中分离出来</span><br><span class="line">9.1 什么是配置数据</span><br><span class="line">9.2 抽离配置数据</span><br><span class="line">9.3 保存配置数据</span><br><span class="line">第10章 抛出自定义错误</span><br><span class="line">10.1 错误的本质</span><br><span class="line">10.2 在JavaScript中抛出错误</span><br><span class="line">10.3 抛出错误的好处</span><br><span class="line">10.4 何时抛出错误</span><br><span class="line">10.5 try－catch语句</span><br><span class="line">10.6 错误类型</span><br><span class="line">第11章 不是你的对象不要动</span><br><span class="line">11.1 什么是你的</span><br><span class="line">11.2 原则</span><br><span class="line">11.2.1 不覆盖方法</span><br><span class="line">11.2.2 不新增方法</span><br><span class="line">11.2.3 不删除方法</span><br><span class="line">11.3 更好的途径</span><br><span class="line">11.3.1 基于对象的继承</span><br><span class="line">11.3.2 基于类型的继承</span><br><span class="line">11.3.3 门面模式</span><br><span class="line">11.4 关于Polyfill的注解</span><br><span class="line">11.5 阻止修改</span><br><span class="line">第12章 浏览器嗅探</span><br><span class="line">12.1 User－Agent检测</span><br><span class="line">12.2 特性检测</span><br><span class="line">12.3 避免特性推断</span><br><span class="line">12.4 避免浏览器推断</span><br><span class="line">12.5 应当如何取舍</span><br><span class="line">第三部分 自动化</span><br><span class="line">第13章 文件和目录结构</span><br><span class="line">13.1 最佳实践</span><br><span class="line">13.2 基本结构</span><br><span class="line">第14章 Ant</span><br><span class="line">14.1 安装</span><br><span class="line">14.2 配置文件</span><br><span class="line">14.3 执行构建</span><br><span class="line">14.4 目标操作的依赖</span><br><span class="line">14.5 属性</span><br><span class="line">14.6 Buildr项目</span><br><span class="line">第15章 校验</span><br><span class="line">15.1 查找文件</span><br><span class="line">15.2 任务</span><br><span class="line">15.3 增强的目标操作</span><br><span class="line">15.4 其他方面的改进</span><br><span class="line">15.5 Buildr任务</span><br><span class="line">第16章 文件合并和加工</span><br><span class="line">16.1 任务</span><br><span class="line">16.2 行尾结束符</span><br><span class="line">16.3 文件头和文件尾</span><br><span class="line">16.4 加工文件</span><br><span class="line">第17章 文件精简和压缩</span><br><span class="line">17.1 文件精简</span><br><span class="line">17.1.1 使用YUI Compressor精简代码</span><br><span class="line">17.1.2 用Closure Compiler精简</span><br><span class="line">17.1.3 使用UglifyJS精简</span><br><span class="line">17.2 压缩</span><br><span class="line">17.2.1 运行时压缩</span><br><span class="line">17.2.2 构建时压缩</span><br><span class="line">第18章 文档化</span><br><span class="line">18.1 JSDoc Toolkit</span><br><span class="line">18.2 YUI Doc</span><br><span class="line">第19章 自动化测试</span><br><span class="line">19.1 YUI Test Selenium引擎</span><br><span class="line">19.1.1 配置一台Selenium服务器</span><br><span class="line">19.1.2 配置YUI Test Selenium引擎</span><br><span class="line">19.1.3 使用YUI Test Selenium引擎</span><br><span class="line">19.1.4 Ant的配置写法</span><br><span class="line">19.2 Yeti</span><br><span class="line">19.3 PhantomJS</span><br><span class="line">19.3.1 安装及使用</span><br><span class="line">19.3.2 Ant的配置写法</span><br><span class="line">19.4 JsTestDriver</span><br><span class="line">19.4.1 安装及使用</span><br><span class="line">19.4.2 Ant的配置写法</span><br><span class="line">第20章 组装到一起</span><br><span class="line">20.1 被忽略的细节</span><br><span class="line">20.2 编制打包计划</span><br><span class="line">20.2.1 开发版本的构建</span><br><span class="line">20.2.2 集成版本的构建</span><br><span class="line">20.2.3 发布版本的构建</span><br><span class="line">20.3 使用CI系统</span><br><span class="line">20.3.1 Jenkins</span><br><span class="line">20.3.2 其他CI系统</span><br><span class="line">附录A JavaScript编码风格指南</span><br><span class="line">附录B JavaScript工具集</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00BQ7RMW0/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00BQ7RMW0&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51V3g6KWOnL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员的自我修养</title>
    <url>/2020/04/19/cheng-xu-yuan-de-zi-wo-xiu-yang/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 程序员的自我修养<br>作者信息： 作者: 潘爱民 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《程序员的自我修养:链接、装载与库》主要介绍系统软件的运行机制和原理，涉及在Windows和Linux两个系统平台上，一个应用程序在编译、链接和运行时刻所发生的各种事项，包括：代码指令是如何保存的，库文件如何与应用程序代码静态链接，应用程序如何被装载到内存中并开始运行，动态链接如何实现，C/C++运行库的工作原理，以及操作系统提供的系统服务是如何被调用的。每个技术专题都配备了大量图、表和代码实例，力求将复杂的机制以简洁的形式表达出来。本书最后还提供了一个小巧且跨平台的C/C++运行库MiniCRT，综合展示了与运行库相关的各种技术。<br>《程序员的自我修养:链接、装载与库》对装载、链接和库进行了深入浅出的剖析，并且辅以大量的例子和图表，可以作为计算机软件专业和其他相关专业大学本科高年级学生深入学习系统软件的参考书。同时，还可作为各行业从事软件开发的工程师、研究人员以及其他对系统软件实现机制和技术感兴趣者的自学教材。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1部分 简介</span><br><span class="line">　第1章 温故而知新</span><br><span class="line">　　1.1 从HELLO WORLD 说起</span><br><span class="line">　 1.2 万变不离其宗</span><br><span class="line">　　1.3 站得高，望得远</span><br><span class="line">　　1.4 操作系统做什么</span><br><span class="line">　　1.5 内存不够怎么办</span><br><span class="line">　　1.6 众人拾柴火焰高</span><br><span class="line">　　1.7 本章小结</span><br><span class="line">第2部分 静态链接</span><br><span class="line">　第2章 编译和链接</span><br><span class="line">　　2.1 被隐藏了的过程</span><br><span class="line">　　2.2 编译器做了什么</span><br><span class="line">　　2.3 链接器年龄比编译器长</span><br><span class="line">　　2.4 模块拼装——静态链接</span><br><span class="line">　　2.5 本章小结</span><br><span class="line">　第3章 目标文件里有什么</span><br><span class="line">　　3.1 目标文件的格式</span><br><span class="line">　　3.2 目标文件是什么样的</span><br><span class="line">　　3.3 挖掘SIMPLESECTION.O</span><br><span class="line">　　3.4 ELF 文件结构描述</span><br><span class="line">　　3.5 链接的接口——符号</span><br><span class="line">　　3.6 调试信息</span><br><span class="line">　　3.7 本章小结</span><br><span class="line">　第4章 静态链接</span><br><span class="line">　　4.1 空间与地址分配</span><br><span class="line">　　4.2 符号解析与重定位</span><br><span class="line">　　4.3 COMMON 块</span><br><span class="line">　　4.4 C++相关问题</span><br><span class="line">　　4.5 静态库链接</span><br><span class="line">　　4.6 链接过程控制</span><br><span class="line">　　4.7 BFD 库</span><br><span class="line">　　4.8 本章小结</span><br><span class="line">　第5章 WINDOWS PE&#x2F;COFF</span><br><span class="line">　　5.1 WINDOWS 的二进制文件格式PE&#x2F;COFF 134</span><br><span class="line">　　5.2 PE 的前身——COFF</span><br><span class="line">　　5.3 链接指示信息</span><br><span class="line">　　5.4 调试信息</span><br><span class="line">　　5.5 大家都有符号表</span><br><span class="line">　　5.6 WINDOWS 下的ELF——PE</span><br><span class="line">　　5.7 本章小结</span><br><span class="line">第3部分 装载与动态链接</span><br><span class="line">　第6章 可执行文件的装载与进程</span><br><span class="line">　　6.1 进程虚拟地址空间</span><br><span class="line">　　6.2 装载的方式</span><br><span class="line">　　6.3 从操作系统角度看可执行文件的装载</span><br><span class="line">　　6.4 进程虚存空间分布</span><br><span class="line">　　6.5 LINUX 内核装载ELF 过程简介</span><br><span class="line">　　6.6 WINDOWS PE 的装载</span><br><span class="line">　　6.7 本章小结</span><br><span class="line">　第7章 动态链接</span><br><span class="line">　　7.1 为什么要动态链接</span><br><span class="line">　　7.2 简单的动态链接例子</span><br><span class="line">　　7.3 地址无关代码</span><br><span class="line">　　7.4 延迟绑定（PLT）</span><br><span class="line">　　7.5 动态链接相关结构</span><br><span class="line">　　7.6 动态链接的步骤和实现</span><br><span class="line">　　7.7 显式运行时链接</span><br><span class="line">　　7.8 本章小结</span><br><span class="line">　第8章 LINUX 共享库的组织</span><br><span class="line">　　8.1 共享库版本</span><br><span class="line">　　8.2 符号版本</span><br><span class="line">　　8.3 共享库系统路径</span><br><span class="line">　　8.4 共享库查找过程</span><br><span class="line">　　8.5 环境变量</span><br><span class="line">　　8.6 共享库的创建和安装</span><br><span class="line">　　8.7 本章小结</span><br><span class="line">　第9章 WINDOWS 下的动态链接</span><br><span class="line">　　9.1 DLL 简介</span><br><span class="line">　　9.2 符号导出导入表</span><br><span class="line">　　9.3 DLL 优化</span><br><span class="line">　　9.4 C++与动态链接</span><br><span class="line">　　9.5 DLL HELL</span><br><span class="line">　　9.6 本章小结</span><br><span class="line">第4部分 库与运行库</span><br><span class="line">　第10章 内存</span><br><span class="line">　　10.1 程序的内存布局</span><br><span class="line">　　10.2 栈与调用惯例</span><br><span class="line">　　10.3 堆与内存管理</span><br><span class="line">　　10.4 本章小结</span><br><span class="line">　第11章 运行库</span><br><span class="line">　　11.1 入口函数和程序初始化</span><br><span class="line">　　11.2 C&#x2F;C++运行库</span><br><span class="line">　　11.3 运行库与多线程</span><br><span class="line">　　11.4 C++全局构造与析构</span><br><span class="line">　　11.5 FREAD 实现</span><br><span class="line">　　11.6 本章小结</span><br><span class="line">　第12章 系统调用与API</span><br><span class="line">　　12.1 系统调用介绍</span><br><span class="line">　　12.2 系统调用原理</span><br><span class="line">　　12.3 WINDOWS API</span><br><span class="line">　　12.4 本章小结</span><br><span class="line">　第13章 运行库实现</span><br><span class="line">　　13.1 C 语言运行库</span><br><span class="line">　　13.2 如何使用MINI CRT</span><br><span class="line">　　13.3 C++运行库实现</span><br><span class="line">　　13.4 如何使用MINI CRT++</span><br><span class="line">　　13.5 本章小结</span><br><span class="line">附录A</span><br><span class="line">　A.1 字节序（BYTE ORDER）</span><br><span class="line">　A.2 ELF 常见段</span><br><span class="line">　A.3 常用开发工具命令行参考</span><br><span class="line">索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0027VSA7U/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0027VSA7U&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51DWO8hbBfL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>COM技术内幕</title>
    <url>/2020/04/19/comji-zhu-nei-mu/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： COM技术内幕<br>作者信息： 作者: Dale Rogerson [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>微软公司的组件对象模型(COM)作为一种重要的工具已崭露头角，它是微软迈向分布式计算的基础。不论现在还是将来，它都是定制应用程序的一种强大的方法。并且它是OLE和ActiveX的基础。COM帮助你理解未来的程序开发技术，而这本书帮助你理解COM。在本书中你将发现：构建优美的COM组件的清晰、简单、实用的规则；COM是如何易学易用，特虽是对那些熟练掌握C++的人；循序渐进地介绍COM设计；以代码形式给出的大量实例。<br>　　 《COM技术内幕》适合于中、高级C++程序员；COM、ActiveX和OLE程序员；对组件设计感兴趣的研究人员；以及那些当COM移植到UNIX、MVS和其他环境时想要使用到COM的程序员</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">引言</span><br><span class="line">第1章 组件</span><br><span class="line">1.1 使用组件的优点</span><br><span class="line">1.1.1 应用程序定制</span><br><span class="line">1.1.2 组件库</span><br><span class="line">1.1.3 分布式组件</span><br><span class="line">1.2 对组件的需求</span><br><span class="line">1.2.1 动态链接</span><br><span class="line">1.2.2 信息封装</span><br><span class="line">1.3 com</span><br><span class="line">1.3.1 com组件是</span><br><span class="line">1.3.2 com不是</span><br><span class="line">1.3.3 com库</span><br><span class="line">1.3.4 com方法</span><br><span class="line">1.3.5 com超越了用户的需要</span><br><span class="line">1.4 本章小结</span><br><span class="line">第2章 接口</span><br><span class="line">2.1 接口的作用</span><br><span class="line">2.1.1 可复用应用程序架构</span><br><span class="line">2.1.2 com接口的其他优点</span><br><span class="line">.2.2 com接口的实现</span><br><span class="line">2.2.1 编码约定</span><br><span class="line">2.2.2 一个完整的例子</span><br><span class="line">2.2.3 非接口通信</span><br><span class="line">2.2.4 实现细节</span><br><span class="line">2.3 接口理论：第二部分</span><br><span class="line">2.3.1 接口的不变性</span><br><span class="line">2.3.2 多态</span><br><span class="line">2.4 接口的背后</span><br><span class="line">2.4.1 虚拟函数表</span><br><span class="line">2.4.2 vtbl指针及实例数据</span><br><span class="line">2.4.3 多重实例</span><br><span class="line">2.4.4 不同的类，相同的vtbl</span><br><span class="line">2.5 本章小结</span><br><span class="line">第3章 queryinterface函数</span><br><span class="line">3.1 接口查询</span><br><span class="line">3.1.1 关于iunknown</span><br><span class="line">3.1.2 iunknown指针的获取</span><br><span class="line">3.1.3 关于querinterface</span><br><span class="line">3.1.4 querinterface的使用</span><br><span class="line">3.1.5 querinterface的实现</span><br><span class="line">3.1.6 关于类型转换</span><br><span class="line">3.1.7 一个完整的例子</span><br><span class="line">3.2 关于querinterface的实现规则</span><br><span class="line">3.2.1 同一iunknown</span><br><span class="line">3.2.2 客户可以获取曾经得到过的接口</span><br><span class="line">3.2.3 可以再次获取已经拥有的接口</span><br><span class="line">3.2.4 客户可以从任何接口返回到起始接口</span><br><span class="line">3.2.5 若能够从某接口获取某特定接口，则从任意接口都将能够获取此接口</span><br><span class="line">3.3 querinterface定义了组件</span><br><span class="line">3.3.1 接口集</span><br><span class="line">3.4 新版本组件的处理</span><br><span class="line">3.4.1 何时需要建立一个新版本</span><br><span class="line">3.4.2 不同版本接口的命名</span><br><span class="line">3.4.3 隐含合约</span><br><span class="line">3.5 本章小结</span><br><span class="line">第4章 引用计数</span><br><span class="line">4.1 生命期控制</span><br><span class="line">4.2 引用计数简介</span><br><span class="line">4.2.1 引用计数简介</span><br><span class="line">4.2.2 addref和release的实现</span><br><span class="line">4.3 何时进行引用计数</span><br><span class="line">4.3.1 引用计数的优化</span><br><span class="line">4.3.2 引用计数规则</span><br><span class="line">4.4 本章小结</span><br><span class="line">第5章 动态链接</span><br><span class="line">5.1 组件的创建</span><br><span class="line">5.1.1 从dli中输出函数</span><br><span class="line">5.1.2 dll的装载</span><br><span class="line">5.2 客户和组件的划分</span><br><span class="line">5.2.1 程序清单</span><br><span class="line">5.3 对象串</span><br><span class="line">5.4 本章小结</span><br><span class="line">第6章 关于hresult、guid、注册表及其他细节</span><br><span class="line">6.1 hresult</span><br><span class="line">6.1.1 hresult值的查找</span><br><span class="line">6.1.2 hresult值的使用</span><br><span class="line">6.1.3 用户自己代码的定义</span><br><span class="line">6.2 guid</span><br><span class="line">6.2.1 为什么要使用guid</span><br><span class="line">6.2.2 guid的声明和定义</span><br><span class="line">6.2.3 guid的比较</span><br><span class="line">6.2.4 将guid作为组件标识符</span><br><span class="line">6.2.5 通过引用传递guid值</span><br><span class="line">6.3 windows注册表</span><br><span class="line">6.3.1 注册表的组织</span><br><span class="line">6.3.2 注册表编辑器</span><br><span class="line">6.3.3 clsid关键字结构</span><br><span class="line">6.3.4 关于注册表的其他细节</span><br><span class="line">6.3.5 progid</span><br><span class="line">6.3.6 自注册</span><br><span class="line">6.3.7 组件类别</span><br><span class="line">6.3.8 oleview</span><br><span class="line">6.4 com库函数</span><br><span class="line">6.4.1 com库的初始化</span><br><span class="line">6.4.2 内存管理</span><br><span class="line">6.4.3 将字符串转化成guid</span><br><span class="line">6.5 本章小结</span><br><span class="line">第7章 类厂</span><br><span class="line">7.1 cocreateinstance</span><br><span class="line">7.1.1 cocreateinstance的声明</span><br><span class="line">7.1.2 cocreateinstance的使用</span><br><span class="line">7.1.3 类上下文</span><br><span class="line">7.1.4 客户程序清单</span><br><span class="line">7.1.5 cocreateinstance的不灵活性</span><br><span class="line">7.2 类厂</span><br><span class="line">7.2.1 cocetclassobject</span><br><span class="line">7.2.2 iclassfactory</span><br><span class="line">7.2.3 cocreateinstance与cogetclassobject的比较</span><br><span class="line">7.2.4 类厂的若干特性</span><br><span class="line">7.3 类厂的实现</span><br><span class="line">7.3.1 dllgetclassobject的使用</span><br><span class="line">7.3.2 组件的创建过程</span><br><span class="line">7.3.3 组件代码清单</span><br><span class="line">7.3.4 流程控制</span><br><span class="line">7.3.5 组件的注册</span><br><span class="line">7.4 同一dll中的多个组件</span><br><span class="line">7.4.1 类厂实现的复用</span><br><span class="line">7.5 dll的卸载</span><br><span class="line">7.5.1 dllcanunloadnow的使用</span><br><span class="line">7.5.2 lockserver</span><br><span class="line">7.6 本章小结</span><br><span class="line">第8章 组件复用：包容与聚合</span><br><span class="line">8.1 包容和聚合</span><br><span class="line">8.1.1 包容简介</span><br><span class="line">8.1.2 聚合简介</span><br><span class="line">8.1.3 包容与聚合的比较</span><br><span class="line">8.2 包容的实现</span><br><span class="line">8.2.1 接口扩展</span><br><span class="line">8.3 聚合的实现</span><br><span class="line">8.3.1 queryinterface的实现</span><br><span class="line">8.3.2 不正确的iunknown</span><br><span class="line">8.3.3 聚合的未知接口</span><br><span class="line">8.3.4 内部组件的创建</span><br><span class="line">8.3.5 外部组件中指向内部组件接口的指针</span><br><span class="line">8.4 一个完整的例子</span><br><span class="line">8.4.1 盲目聚合</span><br><span class="line">8.5 现实世界中的聚合和包容</span><br><span class="line">8.5.1 组件的内部状态信息</span><br><span class="line">8.5.2 虚拟函数的模拟</span><br><span class="line">8.6 本章小结</span><br><span class="line">第9章 编程工作的简化</span><br><span class="line">9.1 客户端的简化</span><br><span class="line">9.1.1 智能接口指针</span><br><span class="line">9.1.2 c++包装类</span><br><span class="line">9.2 服务器端的简化</span><br><span class="line">9.2.1 未知接口基类</span><br><span class="line">9.2.2 类厂基类</span><br><span class="line">9.2.3 cunknown和cfactory的使用</span><br><span class="line">9.2.4 集成步骤</span><br><span class="line">9.3 本章小结</span><br><span class="line">第10章 exe中的服务器</span><br><span class="line">10.1 不同的进程</span><br><span class="line">10.1.1 本地过程调用</span><br><span class="line">10.1.2 调整</span><br><span class="line">10.1.3 代理&#x2F;残根dll</span><br><span class="line">10.2 idl&#x2F;midl简介</span><br><span class="line">10.2.1 关于idl</span><br><span class="line">10.2.2 idl接口描述举例</span><br><span class="line">10.2.3 midl编译器</span><br><span class="line">10.3 本地服务器的实现</span><br><span class="line">10.3.1 示例程序的运行</span><br><span class="line">10.3.2 去掉入口点函数</span><br><span class="line">10.3.3 类厂的启动</span><br><span class="line">10.3.4 对lockserver的修改</span><br><span class="line">10.4 远程访问能力</span><br><span class="line">10.4.1 dcomcnfg.exe所完成的工作</span><br><span class="line">10.4.2 工作机理</span><br><span class="line">10.4.3 其他dcom信息</span><br><span class="line">10.5 本章小结</span><br><span class="line">第11章 调度接口与自动化</span><br><span class="line">11.1 一种新的通信方式</span><br><span class="line">11.1.1 旧的通信方式</span><br><span class="line">11.1.2 idispatch接口</span><br><span class="line">11.2 idispatch的使用</span><br><span class="line">11.2.1 inuoke函数的参数</span><br><span class="line">11.2.2 示例</span><br><span class="line">11.2.3 variant类型</span><br><span class="line">11.2.4 bstr数据类型</span><br><span class="line">11.2.5 safearray类型</span><br><span class="line">11.3 类型库</span><br><span class="line">11.3.1 类型库的创建</span><br><span class="line">11.3.2 类型库的使用</span><br><span class="line">11.3.3 注册表中的类型库</span><br><span class="line">11.4 idispatch接口的实现</span><br><span class="line">11.4.1 异常的引发</span><br><span class="line">11.4.2 参数调整</span><br><span class="line">11.5 本章小结</span><br><span class="line">第12章 多线程</span><br><span class="line">12.1 com线程模型</span><br><span class="line">12.1.1 win32线程</span><br><span class="line">12.1.2 com线程</span><br><span class="line">12.1.3 套间</span><br><span class="line">12.1.4 套间线程</span><br><span class="line">12.1.5 自由线程</span><br><span class="line">12.1.6 调整与同步</span><br><span class="line">12.2 套间线程的实现</span><br><span class="line">12.2.1 自动调整</span><br><span class="line">12.2.2 手工调整</span><br><span class="line">12.2.3 编码</span><br><span class="line">12.2.4 对套间线程例子的说明</span><br><span class="line">12.3 自由线程的实现</span><br><span class="line">12.3.1 对自由线程例子的说明</span><br><span class="line">12.3.2 自由线程参数调整的优化</span><br><span class="line">12.4 关于线程模型的注册表关键字</span><br><span class="line">12.5 本章小结</span><br><span class="line">第13章 一个完整的例子</span><br><span class="line">13.1 tangram程序</span><br><span class="line">13.1.1 tangram的运行</span><br><span class="line">13.1.2 所用的组件</span><br><span class="line">13.1.3 客户程序</span><br><span class="line">13.1.4 tangrammodel组件</span><br><span class="line">13.1.5 tangramgdivisual和tangramglvisual组件</span><br><span class="line">13.1.6 tangramgdiworld和tangramglworld组件</span><br><span class="line">13.2 展示</span><br><span class="line">13.3 idl文件</span><br><span class="line">13.3.1 dlidata.c文件</span><br><span class="line">13.4 循环引用计数</span><br><span class="line">13.4.1 不调用addref</span><br><span class="line">13.4.2 使用显示终止</span><br><span class="line">13.4.3 使用一个单独的组件</span><br><span class="line">13.5 事件和连接点</span><br><span class="line">13.5.1 ienumxxx</span><br><span class="line">13.6 本章小结</span><br><span class="line">结束语</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B009Y63RS8/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B009Y63RS8&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://g-ec4.images-amazon.com/images/G/28/nav2/dp/no-image-no-ciu._V192234541_AA300_.gif"/></a></p>
]]></content>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>天书夜读:从汇编语言到Windows内核编程</title>
    <url>/2020/04/19/cong-hui-bian-yu-yan-dao-windowsnei-he-bian-cheng/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 天书夜读:从汇编语言到Windows内核编程<br>作者信息： 作者: 谭文 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《天书夜读:从汇编语言到Windows内核编程》适合使用C/C++在Windows 上编程的读者，尤其适合希望加深自己技术功底的Windows应用程序员、训算机专业的有志于软件开发的大中院校学生：专业的Windows内核程序员，亦可丛本书得到超越一般内核程序开。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">入手篇 熟悉汇编</span><br><span class="line">第1章 汇编指令与C语言</span><br><span class="line">1.1 上机建立第一个工程</span><br><span class="line">1.1.1 用Visual Studio创建工程</span><br><span class="line">1.1.2 用Visual Studio查看汇编代码</span><br><span class="line">1.2 简要复习常用的汇编指令</span><br><span class="line">1.2.1 堆栈相关指令</span><br><span class="line">1.2.2 数据传送指令</span><br><span class="line">1.2.3 跳转与比较指令</span><br><span class="line">1.3 C函数的参数传递过程 </span><br><span class="line"></span><br><span class="line"> 第2章 C语言的流程和处理 2.1 C语言的循环反汇编 2.1.1 for循环 2.1.2 do循环 2.1.3 while循环 2.2 C语言判断与分支的反汇编 2.2.1 if-else判断分支 2.2.2 switch-case判断分支 2.3 C语言的数组与结构 2.4 C语言的共用体和枚举类型</span><br><span class="line"></span><br><span class="line"> 第3章 练习反汇编C语言程序 3.1 算法的反汇编 3.1.1 算法反汇编代码分析 3.1.2 算法反汇编阅读技巧 3.2 发行版的反汇编 3.3 汇编反C语言练习</span><br><span class="line"></span><br><span class="line"> 基础篇 内核编程 第4章 内核字符串与内存 4.1 字符串的处理 4.1.1 使用字符串结构 4.1.2 字符串的初始化 4.1.3 字符串的拷贝 4.1.4 字符串的连接 4.1.5 字符串的打印 4.2 内存与链表 4.2.1 内存的分配与释放 4.2.2 使用LIST_ENTRY 4.2.3 使用长长整型数据 4.2.4 使用自选锁</span><br><span class="line"></span><br><span class="line"> 第5章 文件与注册表操作 5.1 文件操作 5.1.1 使用OBJECT_ATTRIBUTES 5.1.2 打开和关闭文件 5.1.3 文件读&#x2F;写操作 5.2 注册表操作 5.2.1 注册表键的打开 5.2.2 注册表值的读 5.2.3 注册表值的写</span><br><span class="line"></span><br><span class="line"> 第6章 时间与线程 6.1 时间与定时器 6.1.1 获得当前滴答数 6.1.2 获得当前系统时间 6.1.3 使用定时器 6.2 线程与事件 6.2.1 使用系统线程 6.2.2 在线程中睡眠 6.2.3 使用同步事件</span><br><span class="line"></span><br><span class="line"> 第7章 驱动、设备与请求 7.1 驱动与设备 7.1.1 驱动入口与驱动对象 7.1.2 分发函数和卸载函数 7.1.3 设备与符号链接 7.1.4 设备的安全创建 7.1.5 设备与符号链接的用户相关性 7.2 请求处理 7.2.1 IRP与IO_STACK_LOCATION 7.2.2 打开与关闭请求的处理 7.2.3 应用层信息传入 7.2.4 驱动层信息传出</span><br><span class="line"></span><br><span class="line"> 探索篇 研究内核 第8章 进入Windows内核 8.1 开始Windows内核编程 8.1.1 内核编程的环境准备 8.1.2 用C语言写一个内核程序 8.2 学习用WinDbg进行调试 8.2.1 软件的准备 8.2.2 设置Windows XP调试执行 8.2.3 设置VMWare虚拟机调试 8.2.4 设置被调试机为Vista的情况 8.2.5 设置Windows内核符号表 8.2.6 调试例子diskperf 8.3 认识内核代码函数调用方式 8.4 尝试反写C内核代码 8.5 如何在代码中寻找需要的信息</span><br><span class="line"></span><br><span class="line"> 第9章 用C++编写的内核程序 9.1 用C++开发内核程序 9.1.1 建立一个C++的内核工程 9.1.2 使用C接口标准声明 9.1.3 使用类静态成员函数 9.1.4 实现new操作符 9.2 开始阅读一个反汇编的类 9.2.1 new操作符的实现 9.2.2 构造函数的实现 9.3 了解更多的C++特性</span><br><span class="line"></span><br><span class="line"> 第10章 继续探索Windows内核 10.1 探索Windows已有内核调用 10.2 自己实现XP的新调用 10.2.1 对照调试结果和数据结构 10.2.2 写出C语言的对应代码 10.3 没有符号表的情况 10.4 64位操作系统下的情况 10.4.1 分析64位操作系统的调用 10.4.2 深入了解64位内核调用参数传递</span><br><span class="line"></span><br><span class="line"> 深入篇 修改内核 第11章 机器码与反汇编引擎 11.1 了解Intel的机器码 11.1.1 可执行指令与数据 11.1.2 单条指令的组成 11.1.3 MOD-REG-R&#x2F;M的组成 11.1.4 其他的组成部分 11.2 反汇编引擎XDE32基本数据结构 11.3 反汇编引擎XDE32具体实现</span><br><span class="line"></span><br><span class="line"> 第12章 CPU权限级与分页机制 12.1 Ring0和Ring3权限级 12.2 保护模式下的分页内存保护 12.3 分页内存不可执行保护 12.3.1 不可执行保护原理 12.3.2 不可执行保护的漏洞 12.4 权限级别的切换 12.4.1 调用门及其漏洞 12.4.2 sysenter和sysexit指令</span><br><span class="line"></span><br><span class="line"> 第13章 开发Windows内核Hook 13.1 XP下Hook系统调用IoCallDriver 13.2 Vista下IofCallDriver的跟踪 13.3 Vista下inline hook 13.3.1 写入跳转指令并拷贝代码 13.3.2 实现中继函数</span><br><span class="line"></span><br><span class="line"> 实战篇 实际开发 第14章 反病毒、木马实例开发 14.1 反病毒、木马的设想 14.2 开发内核驱动 14.2.1 在内核中检查可执行文件 14.2.2 在内核中生成设备接口 14.2.3 在内核中等待监控进程的响应 14.3 开发监控进程 14.4 本软件进一步展望</span><br><span class="line"></span><br><span class="line"> 第15章 Rootkit与HIPS 15.1 Rootkit为何很重要 15.2 Rootkit如何逃过检测 15.3 HIPS如何检测Rootkit</span><br><span class="line"></span><br><span class="line"> 第16章 手写指令保护代码 16.1 混淆字符串 16.2 隐藏内核函数 16.3 混淆流程与数据操作 16.3.1 混淆函数出口 16.3.2 插入有意义的花指令</span><br><span class="line"></span><br><span class="line"> 第17章 用VMProtect保护代码 17.1 安装VMProtect 17.2 使用VMProtect 17.3 查看VMProtect效果 参考文献</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001ISJZVI/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001ISJZVI&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51-0jOoAFiL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>黑客攻防技术宝典 Web实战篇 第2版</title>
    <url>/2020/04/19/hei-ke-gong-fang-ji-zhu-bao-dian-webshi-zhan-pian-di-2ban/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 黑客攻防技术宝典 Web实战篇 第2版<br>作者信息： 作者: Dafydd Stuttard [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《黑客攻防技术宝典:Web实战篇(第2版)》新增了Web应用程序安全领域近年来的发展变化新情况，并以尝试访问的链接形式提供了几百个互动式“漏洞实验室”，便于读者迅速掌握各种攻防知识与技能。《黑客攻防技术宝典:Web实战篇(第2版)》适合各层次计算机安全人士和Web开发与管理领域的技术人员阅读。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章Web应用程序安全与风险</span><br><span class="line">1.1Web应用程序的发展历程</span><br><span class="line">1.1.1Web应用程序的常见功能</span><br><span class="line">1.1.2Web应用程序的优点</span><br><span class="line">1.2Web应用程序安全</span><br><span class="line">1.2.1“本站点是安全的”</span><br><span class="line">1.2.2核心安全问题：用户可提交任意输入</span><br><span class="line">1.2.3关键问题因素</span><br><span class="line">1.2.4新的安全边界</span><br><span class="line">1.2.5Web应用程序安全的未来</span><br><span class="line">1.3小结</span><br><span class="line">第2章核心防御机制</span><br><span class="line">2.1处理用户访问</span><br><span class="line">2.1.1身份验证</span><br><span class="line">2.1.2会话管理</span><br><span class="line">2.1.3访问控制</span><br><span class="line">2.2处理用户输入</span><br><span class="line">2.2.1输入的多样性</span><br><span class="line">2.2.2输入处理方法</span><br><span class="line">2.2.3边界确认</span><br><span class="line">2.2.4多步确认与规范化</span><br><span class="line">2.3处理攻击者</span><br><span class="line">2.3.1处理错误</span><br><span class="line">2.3.2维护审计日志</span><br><span class="line">2.3.3向管理员发出警报</span><br><span class="line">2.3.4应对攻击</span><br><span class="line">2.4管理应用程序</span><br><span class="line">2.5小结</span><br><span class="line">2.6问题</span><br><span class="line">第3章Web应用程序技术</span><br><span class="line">3.1HTTP</span><br><span class="line">3.1.1HTTP请求</span><br><span class="line">3.1.2HTTP响应</span><br><span class="line">3.1.3HTTP方法</span><br><span class="line">3.1.4URL</span><br><span class="line">3.1.5REST</span><br><span class="line">3.1.6HTTP消息头</span><br><span class="line">3.1.7cookie</span><br><span class="line">3.1.8状态码</span><br><span class="line">3.1.9HTTPS</span><br><span class="line">3.1.10HTTP代理</span><br><span class="line">3.1.11HTTP身份验证</span><br><span class="line">3.2Web功能</span><br><span class="line">3.2.1服务器端功能</span><br><span class="line">3.2.2客户端功能</span><br><span class="line">3.2.3状态与会话</span><br><span class="line">3.3编码方案</span><br><span class="line">3.3.1URL编码</span><br><span class="line">3.3.2Unicode编码</span><br><span class="line">3.3.3HTML编码</span><br><span class="line">3.3.4Basc64编码</span><br><span class="line">3.3.5十六进制编码</span><br><span class="line">3.3.6远程和序列化框架</span><br><span class="line">3.4下一步</span><br><span class="line">3.5问题</span><br><span class="line">第4章解析应用程序</span><br><span class="line">4.1枚举内容与功能</span><br><span class="line">4.1.1Web抓取</span><br><span class="line">……</span><br><span class="line">第5章避开客户端控件</span><br><span class="line">第6章攻击验证机制</span><br><span class="line">第7章攻击会话管理</span><br><span class="line">第8章攻击访问控制</span><br><span class="line">第9章攻击数据存储区</span><br><span class="line">第10章测试后端组件</span><br><span class="line">第11章攻击应用程序逻辑</span><br><span class="line">第12章攻击其他用户</span><br><span class="line">第13章攻击用户：其他技巧</span><br><span class="line">第14章定制攻击自动化</span><br><span class="line">第15章利用信息泄露</span><br><span class="line">第16章攻击本地编译型应用程序</span><br><span class="line">第17章攻击应用程序架构</span><br><span class="line">第18章攻击Web服务器</span><br><span class="line">第19章查找源代码中的漏洞</span><br><span class="line">第20章Web应用程序黑客工具包</span><br><span class="line">第21章Web应用程序渗透测试方法论</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B008FNO9GK/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B008FNO9GK&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51bQdRTv8eL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript DOM编程艺术 第2版</title>
    <url>/2020/04/19/javascript-dombian-cheng-yi-zhu-di-2ban/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： JavaScript DOM编程艺术 第2版<br>作者信息： 作者: 基思 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>本书不愧为经典。文笔清新,深入浅出,不知不觉让你掌握优秀的编程原则,明白为什么要遵守标准。<br>　　——Slashdot<br>我要隆重推荐本书。它前所未有地演示了DOM脚本编程的真正潜力。无论你是JavaScript新手还是专家,本书都绝对值得你拥有。<br>　　——Garrett Dimon,Digital-Web.com杂志专栏作家</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 JavaScript简史 1</span><br><span class="line">1.1 JavaScript的起源 1</span><br><span class="line">1.2 DOM 2</span><br><span class="line">1.3 浏览器战争 3</span><br><span class="line">1.3.1 DHTML 3</span><br><span class="line">1.3.2 浏览器之间的冲突 3</span><br><span class="line">1.4 制定标准 4</span><br><span class="line">1.4.1 浏览器以外的考虑 4</span><br><span class="line">1.4.2 浏览器战争的结局 5</span><br><span class="line">1.4.3 崭新的起点 5</span><br><span class="line">1.5 小结 6 </span><br><span class="line"></span><br><span class="line"> 第2章 JavaScript语法 8 2.1 准备工作 8 2.2 语法 10 2.2.1 语句 10 2.2.2 注释 10 2.2.3 变量 11 2.2.4 数据类型 14 2.2.5 数组 16 2.2.6 对象 18 2.3 操作 19 2.4 条件语句 21 2.4.1 比较操作符 22 2.4.2 逻辑操作符 23 2.5 循环语句 24 2.5.1 while循环 24 2.5.2 for循环 25 2.6 函数 26 2.7 对象 29 2.7.1 内建对象 30 2.7.2 宿主对象 31 2.8 小结 31</span><br><span class="line"></span><br><span class="line"> 第3章 DOM 32 3.1 文档:DOM中的“D” 32 3.2 对象:DOM中的“O” 32 3.3 模型:DOM中的“M” 33 3.4 节点 35 3.4.1 元素节点 35 3.4.2 文本节点 35 3.4.3 属性节点 36 3.4.4 CSS 36 3.4.5 获取元素 38 3.4.6 盘点知识点 42 3.5 获取和设置属性 43 3.5.1 get Attribute 43 3.5.2 set Attribute 44 3.6 小结 45</span><br><span class="line"></span><br><span class="line"> 第4章 案例研究:JavaScript图片库 46 4.1 标记 46 4.2 JavaScript 48 4.2.1 非DOM解决方案 49 4.2.2 最终的函数代码清单 50 4.3 应用这个JavaScript函数 50 4.4 对这个函数进行扩展 52 4.4.1 child Nodes属性 53 4.4.2 node Type属性 54 4.4.3 在标记里增加一段描述 54 4.4.4 用JavaScript改变这段描述 55 4.4.5 node Value属性 56 4.4.6 first Child和last Child属性 56 4.4.7 利用node Value属性刷新这段描述 57 4.5 小结 60</span><br><span class="line"></span><br><span class="line"> 第5章 最佳实践 61 5.1 过去的错误 61 5.1.1 不要怪罪JavaScript 61 5.1.2 Flash的遭遇 62 5.1.3 质疑一切 63 5.2 平稳退化 63 5.2.1 “javascript:”伪协议 64 5.2.2 内嵌的事件处理函数 65 5.2.3 谁关心这个 65 5.3 向CSS学习 66 5.3.1 结构与样式的分离 66 5.3.2 渐进增强 67 5.4 分离JavaScript 68 5.5 向后兼容 70 5.5.1 对象检测 70 5.5.2 浏览器嗅探技术 71 5.6 性能考虑 72 5.6.1 尽量少访问DOM和尽量减少标记 72 5.6.2 合并和放置脚本 73 5.6.3 压缩脚本 73 5.7 小结 74</span><br><span class="line"></span><br><span class="line"> 第6章 案例研究:图片库改进版 75 6.1 快速回顾 75 6.2 它支持平稳退化吗 76 6.3 它的JavaScript与HTML标记是分的吗 77 6.3.1 添加事件处理函数 77 6.3.2 共享onload事件 82 6.4 不要做太多的假设 84 6.5 优化 86 6.6 键盘访问 88 6.7 把JavaScript与CSS结合起来 90 6.8 DOM Core和HTML-DOM 93 6.9 小结 94</span><br><span class="line"></span><br><span class="line"> 第7章 动态创建标记 96 7.1 一些传统方法 96 7.1.1 document. write 96 7.1.2 inner HTML属性 98 7.2 DOM方法 101 7.2.1 create Element方法 101 7.2.2 append Child方法 102 7.2.3 create Text Node方法 103 7.2.4 一个更复杂的组合 105 7.3 重回图片库 107 7.3.1 在已有元素前插入一个新元素 108 7.3.2 在现有方法后插入一个新元素 109 7.3.3 图片库二次改进版 111 7.4 Ajax 114 7.4.1 XML Http Request对象 115 7.4.2 渐进增强与Ajax 119 7.4.3 Hijax 120 7.5 小结 121</span><br><span class="line"></span><br><span class="line"> 第8章 充实文档的内容 122 8.1 不应该做什么 122 8.2 把“不可见”变成“可见” 123 8.3 内容 123 8.3.1 选用HTML、XHTML还是HTML5 124 8.3.2 CSS 126 8.3.3 JavaScript 127 8.4 显示“缩略语列表” 127 8.4.1 编写display Abbreviations函数 128 8.4.2 创建标记 130 8.4.3 一个浏览器“地雷” 135 8.5 显示“文献来源链接表” 138 8.6 显示“快捷键清单” 143 8.7 检索和添加信息 146 8.8 小结 147</span><br><span class="line"></span><br><span class="line"> 第9章 CSS-DOM 148 9.1 三位一体的网页 148 9.1.1 结构层 148 9.1.2 表示层 148 9.1.3 行为层 149 9.1.4 分离 150 9.2 style属性 150 9.2.1 获取样式 151 9.2.2 设置样式 156 9.3 何时该用DOM脚本设置样式 158 9.3.1 根据元素在节点树里的位置来设置样式 158 9.3.2 根据某种条件反复设置某种样式 161 9.3.3 响应事件 165 9.4 class Name属性 167 9.5 小结 171</span><br><span class="line"></span><br><span class="line"> 第10章 用JavaScript实现动画效果 172 10.1 动画基础知识 172 10.1.1 位置 172 10.1.2 时间 175 10.1.3 时间递增量 175 10.1.4 抽象 178 10.2 实用的动画 184 10.2.1 提出问题 184 10.2.2 解决问题 186 10.2.3 CSS 187 10.2.4 JavaScript 189 10.2.5 变量作用域问题 192 10.2.6 改进动画效果 193 10.2.7 添加安全检查 196 10.2.8 生成HTML标记 198 10.3 小结 200</span><br><span class="line"></span><br><span class="line"> 第11章 HTML5 201 11.1 HTML5简介 201 11.2 来自朋友的忠告 203 11.3 几个示例 204 11.3.1 Canvas 205 11.3.2 音频和视频 209 11.3.3 表单 215 11.4 HTML5还有其他特性吗 219 11.5 小结 219</span><br><span class="line"></span><br><span class="line"> 第12章 综合示例 220 12.1 项目简介 220 12.1.1 原始资料 220 12.1.2 站点结构 220 12.1.3 页面结构 221 12.2 设计 222 12.3 CSS 223 12.3.1 颜色 225 12.3.2 布局 226 12.3.3 版式 228 12.4 标记 229 12.5 JavaScript 230 12.5.1 页面突出显示 231 12.5.2 JavaScript幻灯片 235 12.5.3 内部导航 239 12.5.4 JavaScript图片库 242 12.5.5 增强表格 245 12.5.6 增强表单 249 12.5.7 压缩代码 263 12.6 小结 264 附录 JavaScript库 265</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B004VJM5KE/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B004VJM5KE&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec8.images-amazon.com/images/I/51wpFR5o5ML._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript高级程序设计3</title>
    <url>/2020/04/19/javascriptgao-ji-cheng-xu-she-ji-3/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： JavaScript高级程序设计3<br>作者信息： 作者: 泽卡斯 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《JavaScript高级程序设计(第3版)》：JavaScript是基于Java的一种非常松散的面向对象语言，也是Web开发中极受欢迎的一门语言。JavaScript，尽管它的语法和编程风格与Java都很相似，但它却不是Java的“轻量级”版本。JavaScript是一种全新的动态语言，它植根于全球数亿网民都在使用的Web浏览器之中，致力于增强网站和Web应用程序的交互性。<br>在《JavaScript高级程序设计(第3版)》中，将对JavaScript追根溯源，从它在最早的Netscape浏览器中诞生谈起，一直谈到今天的它对DOM和AjaX的强大支持。读者将通过《JavaScript高级程序设计(第3版)》掌握如何运用和扩展这门语言，从而更好地满足自己的需求，以及如何实现客户端与服务器的无缝通信，而又不必求助于Java或隐藏的网页框架（frame元素）。一言以蔽之，《JavaScript高级程序设计(第3版)》将教会你在面对各种常见的Web开发问题时，如何拿出自己的JavaScript解决方案。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章　JavaScript简介　　1</span><br><span class="line">1.1　JavaScript简史　　1</span><br><span class="line">1.2　JavaScript实现　　2</span><br><span class="line">1.2.1　ECMAScript　　3</span><br><span class="line">1.2.2　文档对象模型（DOM）　　5</span><br><span class="line">1.2.3　浏览器对象模型（BOM）　　8</span><br><span class="line">1.3　JavaScript版本　　8</span><br><span class="line">1.4　小结　　9</span><br><span class="line">第2章　在HTML中使用JavaScript　　10</span><br><span class="line">2.1　script元素　　10</span><br><span class="line">2.1.1　标签的位置　　12</span><br><span class="line">2.1.2　延迟脚本　　13</span><br><span class="line">2.1.3　异步脚本　　13</span><br><span class="line">2.1.4　在XHTML中的用法　　14</span><br><span class="line">2.1.5　不推荐使用的语法　　16</span><br><span class="line">2.2　嵌入代码与外部文件　　16</span><br><span class="line">2.3　文档模式　　16</span><br><span class="line">2.4　noscript 元素　　18</span><br><span class="line">2.5　小结　　18</span><br><span class="line">第3章　基本概念　　19</span><br><span class="line">3.1　语法　　19</span><br><span class="line">3.1.1　区分大小写　　19</span><br><span class="line">3.1.2　标识符　　19</span><br><span class="line">3.1.3　注释　　20</span><br><span class="line">3.1.4　严格模式　　20</span><br><span class="line">3.1.5　语句　　20</span><br><span class="line">3.2　关键字和保留字　　21</span><br><span class="line">3.3　变量　　22</span><br><span class="line">3.4　数据类型　　23</span><br><span class="line">3.4.1　typeof操作符　　23</span><br><span class="line">3.4.2　Undefined类型　　24</span><br><span class="line">3.4.3　Null类型　　25</span><br><span class="line">3.4.4　Boolean类型　　26</span><br><span class="line">3.4.5　Number类型　　27</span><br><span class="line">3.4.6　String类型　　32</span><br><span class="line">3.4.7　Object类型　　35</span><br><span class="line">3.5　操作符　　36</span><br><span class="line">3.5.1　一元操作符　　36</span><br><span class="line">3.5.2　位操作符　　39</span><br><span class="line">3.5.3　布尔操作符　　44</span><br><span class="line">3.5.4　乘性操作符　　47</span><br><span class="line">3.5.5　加性操作符　　48</span><br><span class="line">3.5.6　关系操作符　　50</span><br><span class="line">3.5.7　相等操作符　　51</span><br><span class="line">3.5.8　条件操作符　　53</span><br><span class="line">3.5.9　赋值操作符　　53</span><br><span class="line">3.5.10　逗号操作符　　54</span><br><span class="line">3.6　语句　　54</span><br><span class="line">3.6.1　if语句　　54</span><br><span class="line">3.6.2　do-while语句　　55</span><br><span class="line">3.6.3　while语句　　55</span><br><span class="line">3.6.4　for语句　　56</span><br><span class="line">3.6.5　for-in语句　　57</span><br><span class="line">3.6.6　label语句　　58</span><br><span class="line">3.6.7　break和continue语句　　58</span><br><span class="line">3.6.8　with语句　　60</span><br><span class="line">3.6.9　switch语句　　60</span><br><span class="line">3.7　函数　　62</span><br><span class="line">3.7.1　理解参数　　64</span><br><span class="line">3.7.2　没有重载　　66</span><br><span class="line">3.8　小结　　67</span><br><span class="line">第4章　变量、作用域和内存问题　　68</span><br><span class="line">4.1　基本类型和引用类型的值　　68</span><br><span class="line">4.1.1　动态的属性　　68</span><br><span class="line">4.1.2　复制变量值　　69</span><br><span class="line">4.1.3　传递参数　　70</span><br><span class="line">4.1.4　检测类型　　72</span><br><span class="line">4.2　执行环境及作用域　　73</span><br><span class="line">4.2.1　延长作用域链　　75</span><br><span class="line">4.2.2　没有块级作用域　　76</span><br><span class="line">4.3　垃圾收集　　78</span><br><span class="line">4.3.1　标记清除　　78</span><br><span class="line">4.3.2　引用计数　　79</span><br><span class="line">4.3.3　性能问题　　80</span><br><span class="line">4.3.4　管理内存　　81</span><br><span class="line">4.4　小结　　81</span><br><span class="line">第5章　引用类型　　83</span><br><span class="line">5.1　Object类型　　83</span><br><span class="line">5.2　Array类型　　86</span><br><span class="line">5.2.1　检测数组　　88</span><br><span class="line">5.2.2　转换方法　　89</span><br><span class="line">5.2.3　栈方法　　90</span><br><span class="line">5.2.4　队列方法　　91</span><br><span class="line">5.2.5　重排序方法　　92</span><br><span class="line">5.2.6　操作方法　　94</span><br><span class="line">5.2.7　位置方法　　95</span><br><span class="line">5.2.8　迭代方法　　96</span><br><span class="line">5.2.9　缩小方法　　97</span><br><span class="line">5.3　Date类型　　98</span><br><span class="line">5.3.1　继承的方法　　100</span><br><span class="line">5.3.2　日期格式化方法　　101</span><br><span class="line">5.3.3　日期&#x2F;时间组件方法　　102</span><br><span class="line">5.4　RegExp类型　　103</span><br><span class="line">5.4.1　RegExp实例属性　　105</span><br><span class="line">5.4.2　RegExp实例方法　　106</span><br><span class="line">5.4.3　RegExp构造函数属性　　107</span><br><span class="line">5.4.4　模式的局限性　　109</span><br><span class="line">5.5　Function类型　　110</span><br><span class="line">5.5.1　没有重载（深入理解）　　111</span><br><span class="line">5.5.2　函数声明与函数表达式　　111</span><br><span class="line">5.5.3　作为值的函数　　112</span><br><span class="line">5.5.4　函数内部属性　　113</span><br><span class="line">5.5.5　函数属性和方法　　116</span><br><span class="line">5.6　基本包装类型　　118</span><br><span class="line">5.6.1　Boolean类型　　120</span><br><span class="line">5.6.2　Number类型　　120</span><br><span class="line">5.6.3　String类型　　122</span><br><span class="line">5.7　单体内置对象　　130</span><br><span class="line">5.7.1　Global对象　　131</span><br><span class="line">5.7.2　Math对象　　134</span><br><span class="line">5.8　小结　　137</span><br><span class="line">第6章　面向对象的程序设计　　138</span><br><span class="line">6.1　理解对象　　138</span><br><span class="line">6.1.1　属性类型　　139</span><br><span class="line">6.1.2　定义多个属性　　142</span><br><span class="line">6.1.3　读取属性的特性　　143</span><br><span class="line">6.2　创建对象　　144</span><br><span class="line">6.2.1　工厂模式　　144</span><br><span class="line">6.2.2　构造函数模式　　144</span><br><span class="line">6.2.3　原型模式　　147</span><br><span class="line">6.2.4　组合使用构造函数模式和原型模式　　159</span><br><span class="line">6.2.5　动态原型模式　　159</span><br><span class="line">6.2.6　寄生构造函数模式　　160</span><br><span class="line">6.2.7　稳妥构造函数模式　　161</span><br><span class="line">6.3　继承　　162</span><br><span class="line">6.3.1　原型链　　162</span><br><span class="line">6.3.2　借用构造函数　　167</span><br><span class="line">6.3.3　组合继承　　168</span><br><span class="line">6.3.4　原型式继承　　169</span><br><span class="line">6.3.5　寄生式继承　　171</span><br><span class="line">6.3.6　寄生组合式继承　　172</span><br><span class="line">6.4　小结　　174</span><br><span class="line">第7章　函数表达式　　175</span><br><span class="line">7.1　递归　　177</span><br><span class="line">7.2　闭包　　178</span><br><span class="line">7.2.1　闭包与变量　　181</span><br><span class="line">7.2.2　关于this对象　　182</span><br><span class="line">7.2.3　内存泄漏　　183</span><br><span class="line">7.3　模仿块级作用域　　184</span><br><span class="line">7.4　私有变量　　186</span><br><span class="line">7.4.1　静态私有变量　　188</span><br><span class="line">7.4.2　模块模式　　189</span><br><span class="line">7.4.3　增强的模块模式　　191</span><br><span class="line">7.5　小结　　192</span><br><span class="line">第8章　BOM　　193</span><br><span class="line">8.1　window对象　　193</span><br><span class="line">8.1.1　全局作用域　　193</span><br><span class="line">8.1.2　窗口关系及框架　　194</span><br><span class="line">8.1.3　窗口位置　　197</span><br><span class="line">8.1.4　窗口大小　　198</span><br><span class="line">8.1.5　导航和打开窗口　　199</span><br><span class="line">8.1.6　间歇调用和超时调用　　203</span><br><span class="line">8.1.7　系统对话框　　205</span><br><span class="line">8.2　location对象　　207</span><br><span class="line">8.2.1　查询字符串参数　　207</span><br><span class="line">8.2.2　位置操作　　208</span><br><span class="line">8.3　navigator对象　　210</span><br><span class="line">8.3.1　检测插件　　211</span><br><span class="line">8.3.2　注册处理程序　　213</span><br><span class="line">8.4　screen对象　　214</span><br><span class="line">8.5　history对象　　215</span><br><span class="line">8.6　小结　　216</span><br><span class="line">第9章　客户端检测　　217</span><br><span class="line">9.1　能力检测　　217</span><br><span class="line">9.1.1　更可靠的能力检测　　218</span><br><span class="line">9.1.2　能力检测，不是浏览器检测　　220</span><br><span class="line">9.2　怪癖检测　　220</span><br><span class="line">9.3　用户代理检测　　221</span><br><span class="line">9.3.1　用户代理字符串的历史　　222</span><br><span class="line">9.3.2　用户代理字符串检测技术　　228</span><br><span class="line">9.3.3　完整的代码　　242</span><br><span class="line">9.3.4　使用方法　　245</span><br><span class="line">9.4　小结　　246</span><br><span class="line">第10章　DOM　　247</span><br><span class="line">10.1　节点层次　　247</span><br><span class="line">10.1.1　Node类型　　248</span><br><span class="line">10.1.2　Document类型　　253</span><br><span class="line">10.1.3　Element类型　　261</span><br><span class="line">10.1.4　Text类型　　270</span><br><span class="line">10.1.5　Comment类型　　273</span><br><span class="line">10.1.6　CDATASection类型　　274</span><br><span class="line">10.1.7　DocumentType类型　　274</span><br><span class="line">10.1.8　DocumentFragment类型　　275</span><br><span class="line">10.1.9　Attr类型　　276</span><br><span class="line">10.2　DOM操作技术　　277</span><br><span class="line">10.2.1　动态脚本　　277</span><br><span class="line">10.2.2　动态样式　　279</span><br><span class="line">10.2.3　操作表格　　281</span><br><span class="line">10.2.4　使用NodeList　　283</span><br><span class="line">10.3　小结　　284</span><br><span class="line">第11章　DOM扩展　　286</span><br><span class="line">11.1　选择符API　　286</span><br><span class="line">11.1.1　querySelector()方法　　286</span><br><span class="line">11.1.2　querySelectorAll()</span><br><span class="line">方法　　287</span><br><span class="line">11.1.3　matchesSelector()</span><br><span class="line">方法　　288</span><br><span class="line">11.2　元素遍历　　288</span><br><span class="line">11.3　HTML5　　289</span><br><span class="line">11.3.1　与类相关的扩充　　289</span><br><span class="line">11.3.2　焦点管理　　291</span><br><span class="line">11.3.3　HTMLDocument的变化　　292</span><br><span class="line">11.3.4　字符集属性　　293</span><br><span class="line">11.3.5　自定义数据属性　　293</span><br><span class="line">11.3.6　插入标记　　294</span><br><span class="line">11.3.7　scrollIntoView()方法　　298</span><br><span class="line">11.4　专有扩展　　298</span><br><span class="line">11.4.1　文档模式　　298</span><br><span class="line">11.4.2　children属性　　299</span><br><span class="line">11.4.3　contains()方法　　300</span><br><span class="line">11.4.4　插入文本　　301</span><br><span class="line">11.4.5　滚动　　303</span><br><span class="line">11.5　小结　　304</span><br><span class="line">第12章　DOM2和DOM3　　305</span><br><span class="line">12.1　DOM变化　　305</span><br><span class="line">12.1.1　针对XML命名空间的变化　　306</span><br><span class="line">12.1.2　其他方面的变化　　309</span><br><span class="line">12.2　样式　　312</span><br><span class="line">12.2.1　访问元素的样式　　313</span><br><span class="line">12.2.2　操作样式表　　317</span><br><span class="line">12.2.3　元素大小　　320</span><br><span class="line">12.3　遍历　　326</span><br><span class="line">12.3.1　NodeIterator　　328</span><br><span class="line">12.3.2　TreeWalker　　330</span><br><span class="line">12.4　范围　　332</span><br><span class="line">12.4.1　DOM中的范围　　332</span><br><span class="line">12.4.2　IE8及更早版本中的范围　　340</span><br><span class="line">12.5　小结　　343</span><br><span class="line">第13章　事件　　345</span><br><span class="line">13.1　事件流　　345</span><br><span class="line">13.1.1　事件冒泡　　346</span><br><span class="line">13.1.2　事件捕获　　346</span><br><span class="line">13.1.3　DOM事件流　　347</span><br><span class="line">13.2　事件处理程序　　348</span><br><span class="line">13.2.1　HTML事件处理程序　　348</span><br><span class="line">13.2.2　DOM0级事件处理程序　　350</span><br><span class="line">13.2.3　DOM2级事件处理程序　　351</span><br><span class="line">13.2.4　IE事件处理程序　　352</span><br><span class="line">13.2.5　跨浏览器的事件处理程序　　353</span><br><span class="line">13.3　事件对象　　355</span><br><span class="line">13.3.1　DOM中的事件对象　　355</span><br><span class="line">13.3.2　IE中的事件对象　　358</span><br><span class="line">13.3.3　跨浏览器的事件对象　　360</span><br><span class="line">13.4　事件类型　　362</span><br><span class="line">13.4.1　UI事件　　362</span><br><span class="line">13.4.2　焦点事件　　367</span><br><span class="line">13.4.3　鼠标与滚轮事件　　368</span><br><span class="line">13.4.4　键盘与文本事件　　379</span><br><span class="line">13.4.5　复合事件　　384</span><br><span class="line">13.4.6　变动事件　　385</span><br><span class="line">13.4.7　HTML5事件　　388</span><br><span class="line">13.4.8　设备事件　　395</span><br><span class="line">13.4.9　触摸与手势事件　　399</span><br><span class="line">13.5　内存和性能　　402</span><br><span class="line">13.5.1　事件委托　　402</span><br><span class="line">13.5.2　移除事件处理程序　　404</span><br><span class="line">13.6　模拟事件　　405</span><br><span class="line">13.6.1　DOM中的事件模拟　　405</span><br><span class="line">13.6.2　IE中的事件模拟　　410</span><br><span class="line">13.7　小结　　411</span><br><span class="line">第14章　表单脚本　　412</span><br><span class="line">14.1　表单的基础知识　　412</span><br><span class="line">14.1.1　提交表单　　413</span><br><span class="line">14.1.2　重置表单　　414</span><br><span class="line">14.1.3　表单字段　　414</span><br><span class="line">14.2　文本框脚本　　419</span><br><span class="line">14.2.1　选择文本　　420</span><br><span class="line">14.2.2　过滤输入　　423</span><br><span class="line">14.2.3　自动切换焦点　　426</span><br><span class="line">14.2.4　HTML5约束验证API　　427</span><br><span class="line">14.3　选择框脚本　　431</span><br><span class="line">14.3.1　选择选项　　432</span><br><span class="line">14.3.2　添加选项　　434</span><br><span class="line">14.3.3　移除选项　　435</span><br><span class="line">14.3.4　移动和重排选项　　435</span><br><span class="line">14.4　表单序列化　　436</span><br><span class="line">14.5　富文本编辑　　438</span><br><span class="line">14.5.1　使用contenteditable</span><br><span class="line">属性　　438</span><br><span class="line">14.5.2　操作富文本　　439</span><br><span class="line">14.5.3　富文本选区　　441</span><br><span class="line">14.5.4　表单与富文本　　443</span><br><span class="line">14.6　小结　　443</span><br><span class="line">第15章　使用Canvas绘图　　445</span><br><span class="line">15.1　基本用法　　445</span><br><span class="line">15.2　2D上下文　　446</span><br><span class="line">15.2.1　填充和描边　　446</span><br><span class="line">15.2.2　绘制矩形　　447</span><br><span class="line">15.2.3　绘制路径　　449</span><br><span class="line">15.2.4　绘制文本　　451</span><br><span class="line">15.2.5　变换　　453</span><br><span class="line">15.2.6　绘制图像　　456</span><br><span class="line">15.2.7　阴影　　457</span><br><span class="line">15.2.8　渐变　　458</span><br><span class="line">15.2.9　模式　　460</span><br><span class="line">15.2.10　使用图像数据　　460</span><br><span class="line">15.2.11　合成　　462</span><br><span class="line">15.3　WebGL　　463</span><br><span class="line">15.3.1　类型化数组　　463</span><br><span class="line">15.3.2　WebGL上下文　　468</span><br><span class="line">15.3.3　支持　　478</span><br><span class="line">15.4　小结　　478</span><br><span class="line">第16章　HTML5脚本编程　　480</span><br><span class="line">16.1　跨文档消息传递　　480</span><br><span class="line">16.2　原生拖放　　481</span><br><span class="line">16.2.1　拖放事件　　482</span><br><span class="line">16.2.2　自定义放置目标　　482</span><br><span class="line">16.2.3　dataTransfer对象　　483</span><br><span class="line">16.2.4　dropEffect与effectAllowed　　484</span><br><span class="line">16.2.5　可拖动　　485</span><br><span class="line">16.2.6　其他成员　　485</span><br><span class="line">16.3　媒体元素　　486</span><br><span class="line">16.3.1　属性　　487</span><br><span class="line">16.3.2　事件　　488</span><br><span class="line">16.3.3　自定义媒体播放器　　488</span><br><span class="line">16.3.4　检测编解码器的支持情况　　489</span><br><span class="line">16.3.5　Audio类型　　490</span><br><span class="line">16.4　历史状态管理　　491</span><br><span class="line">16.5　小结　　492</span><br><span class="line">第17章　错误处理与调试　　493</span><br><span class="line">17.1　浏览器报告的错误　　493</span><br><span class="line">17.1.1　IE　　493</span><br><span class="line">17.1.2　Firefox　　494</span><br><span class="line">17.1.3　Safari　　496</span><br><span class="line">17.1.4　Opera　　497</span><br><span class="line">17.1.5　Chrome　　498</span><br><span class="line">17.2　错误处理　　499</span><br><span class="line">17.2.1　try-catch语句　　500</span><br><span class="line">17.2.2　抛出错误　　503</span><br><span class="line">17.2.3　错误（error）事件　　505</span><br><span class="line">17.2.4　处理错误的策略　　506</span><br><span class="line">17.2.5　常见的错误类型　　507</span><br><span class="line">17.2.6　区分致命错误和非致命</span><br><span class="line">错误　　510</span><br><span class="line">17.2.7　把错误记录到服务器　　511</span><br><span class="line">17.3　调试技术　　512</span><br><span class="line">17.3.1　将消息记录到控制台　　512</span><br><span class="line">17.3.2　将消息记录到当前页面　　515</span><br><span class="line">17.3.3　抛出错误　　515</span><br><span class="line">17.4　常见的IE错误　　516</span><br><span class="line">17.4.1　操作终止　　516</span><br><span class="line">17.4.2　无效字符　　518</span><br><span class="line">17.4.3　未找到成员　　518</span><br><span class="line">17.4.4　未知运行时错误　　519</span><br><span class="line">17.4.5　语法错误　　519</span><br><span class="line">17.4.6　系统无法找到指定资源　　519</span><br><span class="line">17.5　小结　　520</span><br><span class="line">第18章　JavaScript与XML　　521</span><br><span class="line">18.1　浏览器对XML DOM的支持　　521</span><br><span class="line">18.1.1　DOM2级核心　　521</span><br><span class="line">18.1.2　DOMParser类型　　522</span><br><span class="line">18.1.3　XMLSerializer类型　　523</span><br><span class="line">18.1.4　IE8及之前版本中的XML　　523</span><br><span class="line">18.1.5　跨浏览器处理XML　　527</span><br><span class="line">18.2　浏览器对XPath的支持　　529</span><br><span class="line">18.2.1　DOM3级XPath　　529</span><br><span class="line">18.2.2　IE中的XPath　　534</span><br><span class="line">18.2.3　跨浏览器使用XPath　　535</span><br><span class="line">18.3　浏览器对XSLT的支持　　537</span><br><span class="line">18.3.1　IE中的XSLT　　537</span><br><span class="line">18.3.2　XSLTProcessor类型　　541</span><br><span class="line">18.3.3　跨浏览器使用XSLT　　543</span><br><span class="line">18.4　小结　　544</span><br><span class="line">第19章　E4X　　546</span><br><span class="line">19.1　E4X的类型　　546</span><br><span class="line">19.1.1　XML类型　　546</span><br><span class="line">19.1.2　XMLList类型　　547</span><br><span class="line">19.1.3　Namespace类型　　548</span><br><span class="line">19.1.4　QName类型　　549</span><br><span class="line">19.2　一般用法　　550</span><br><span class="line">19.2.1　访问特性　　551</span><br><span class="line">19.2.2　其他节点类型　　552</span><br><span class="line">19.2.3　查询　　553</span><br><span class="line">19.2.4　构建和操作XML　　555</span><br><span class="line">19.2.5　解析和序列化　　557</span><br><span class="line">19.2.6　命名空间　　558</span><br><span class="line">19.3　其他变化　　559</span><br><span class="line">19.4　全面启用E4X　　560</span><br><span class="line">19.5　小结　　561</span><br><span class="line">第20章　JSON　　562</span><br><span class="line">20.1　语法　　562</span><br><span class="line">20.1.1　简单值　　562</span><br><span class="line">20.1.2　对象　　563</span><br><span class="line">20.1.3　数组　　564</span><br><span class="line">20.2　解析与序列化　　565</span><br><span class="line">20.2.1　JSON对象　　565</span><br><span class="line">20.2.2　序列化选项　　566</span><br><span class="line">20.2.3　解析选项　　569</span><br><span class="line">20.3　小结　　570</span><br><span class="line">第21章　Ajax与Comet　　571</span><br><span class="line">21.1　XMLHttpRequest对象　　571</span><br><span class="line">21.1.1　XHR的用法　　573</span><br><span class="line">21.1.2　HTTP头部信息　　575</span><br><span class="line">21.1.3　GET请求　　576</span><br><span class="line">21.1.4　POST请求　　577</span><br><span class="line">21.2　XMLHttpRequest 2级　　578</span><br><span class="line">21.2.1　FormData　　578</span><br><span class="line">21.2.2　超时设定　　579</span><br><span class="line">21.2.3　overrideMimeType()</span><br><span class="line">方法　　580</span><br><span class="line">21.3　进度事件　　580</span><br><span class="line">21.3.1　load事件　　580</span><br><span class="line">21.3.2　progress事件　　581</span><br><span class="line">21.4　跨源资源共享　　582</span><br><span class="line">21.4.1　IE对CORS的实现　　582</span><br><span class="line">21.4.2　其他浏览器对CORS的</span><br><span class="line">实现　　584</span><br><span class="line">21.4.3　Preflighted Reqeusts　　584</span><br><span class="line">21.4.4　带凭据的请求　　585</span><br><span class="line">21.4.5　跨浏览器的CORS　　585</span><br><span class="line">21.5　其他跨域技术　　586</span><br><span class="line">21.5.1　图像Ping　　586</span><br><span class="line">21.5.2　JSONP　　587</span><br><span class="line">21.5.3　Comet　　588</span><br><span class="line">21.5.4　服务器发送事件　　590</span><br><span class="line">21.5.5　Web Sockets　　591</span><br><span class="line">21.5.6　SSE与Web Sockets　　593</span><br><span class="line">21.6　安全　　593</span><br><span class="line">21.7　小结　　594</span><br><span class="line">第22章　高级技巧　　596</span><br><span class="line">22.1　高级函数　　596</span><br><span class="line">22.1.1　安全的类型检测　　596</span><br><span class="line">22.1.2　作用域安全的构造函数　　597</span><br><span class="line">22.1.3　惰性载入函数　　600</span><br><span class="line">22.1.4　函数绑定　　602</span><br><span class="line">22.1.5　函数柯里化　　604</span><br><span class="line">22.2　防篡改对象　　606</span><br><span class="line">22.2.1　不可扩展对象　　606</span><br><span class="line">22.2.2　密封的对象　　607</span><br><span class="line">22.2.3　冻结的对象　　608</span><br><span class="line">22.3　高级定时器　　609</span><br><span class="line">22.3.1　重复的定时器　　610</span><br><span class="line">22.3.2　Yielding Processes　　612</span><br><span class="line">22.3.3　函数节流　　614</span><br><span class="line">22.4　自定义事件　　616</span><br><span class="line">22.5　拖放　　618</span><br><span class="line">22.5.1　修缮拖动功能　　620</span><br><span class="line">22.5.2　添加自定义事件　　622</span><br><span class="line">22.6　小结　　624</span><br><span class="line">第23章　离线应用与客户端存储　　626</span><br><span class="line">23.1　离线检测　　626</span><br><span class="line">23.2　应用缓存　　627</span><br><span class="line">23.3　数据存储　　628</span><br><span class="line">23.3.1　Cookie　　629</span><br><span class="line">23.3.2　IE用户数据　　637</span><br><span class="line">23.3.3　Web存储机制　　638</span><br><span class="line">23.3.4　IndexedDB　　643</span><br><span class="line">23.4　小结　　654</span><br><span class="line">第24章　最佳实践　　656</span><br><span class="line">24.1　可维护性　　656</span><br><span class="line">24.1.1　什么是可维护的代码　　656</span><br><span class="line">24.1.2　代码约定　　657</span><br><span class="line">24.1.3　松散耦合　　659</span><br><span class="line">24.1.4　编程实践　　662</span><br><span class="line">24.2　性能　　666</span><br><span class="line">24.2.1　注意作用域　　666</span><br><span class="line">24.2.2　选择正确方法　　667</span><br><span class="line">24.2.3　最小化语句数　　672</span><br><span class="line">24.2.4　优化DOM交互　　673</span><br><span class="line">24.3　部署　　676</span><br><span class="line">24.3.1　构建过程　　676</span><br><span class="line">24.3.2　验证　　677</span><br><span class="line">24.3.3　压缩　　679</span><br><span class="line">24.4　小结　　681</span><br><span class="line">第25章　新兴的API　　682</span><br><span class="line">25.1　requestAnimationFrame()　　682</span><br><span class="line">25.1.1　早期动画循环　　682</span><br><span class="line">25.1.2　循环间隔的问题　　683</span><br><span class="line">25.1.3　mozRequestAnimation-Frame　　683</span><br><span class="line">25.1.4　webkitRequestAnima-tionFrame与msRequest-AnimationFrame　　685</span><br><span class="line">25.2　Page Visibility API　　686</span><br><span class="line">25.3　Geolocation API　　687</span><br><span class="line">25.4　File API　　689</span><br><span class="line">25.4.1　FileReader类型　　690</span><br><span class="line">25.4.2　读取部分内容　　692</span><br><span class="line">25.4.3　对象URL　　693</span><br><span class="line">25.4.4　读取拖放的文件　　694</span><br><span class="line">25.4.5　使用XHR上传文件　　695</span><br><span class="line">25.5　Web计时　　696</span><br><span class="line">25.6　Web Workers　　697</span><br><span class="line">25.6.1　使用Worker　　697</span><br><span class="line">25.6.2　Worker全局作用域　　698</span><br><span class="line">25.6.3　包含其他脚本　　699</span><br><span class="line">25.6.4　Web Workers的未来　　700</span><br><span class="line">25.7　小结　　700</span><br><span class="line">附录A　ECMAScript Harmony　　701</span><br><span class="line">附录B　严格模式　　717</span><br><span class="line">附录C　JavaScript库　　723</span><br><span class="line">附录D　JavaScript工具　　727</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B007OQQVMY/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B007OQQVMY&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51NuoStzdEL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript修炼之道</title>
    <url>/2020/04/19/javascriptxiu-lian-zhi-dao/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： JavaScript修炼之道<br>作者信息： 作者: 波顿纽威 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《JavaScript修炼之道》：左页原理右页代码，极速修炼Web开发秘技，专注于浏览器端脚本编程，提供快速的解决方案，任务驱动，以实战掌握JavaScript全貌。<br>JavaScript已无处不在。在当今纷繁复杂的网络世界中，它是不可或缺的组成部分。然而，即便对有经验的开发人员而言，JavaScript的体系都像难以穿越的生态环境系统。为此，《JavaScript修炼之道》以有别于一般教程的任务驱动方式来组织，围绕35个必会的关键JavaScript任务进行论述，并针对常见任务提出了一些新的开发方法，再加上《JavaScript修炼之道》独特的左页原理右页代码的编排方式，使你在阅读过程中快速地获得提升。在《JavaScript修炼之道》中，作者将教会你基本原理、最便利的工具以及业内最佳实践，同时也能帮你简化编程模型，适应更加复杂的交互需求，提升用户在客户端的浏览体验。如果你熟悉其他任何语言编程，那么通过《JavaScript修炼之道》掌握JavaScript将易如反掌。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分 JavaScript必备操作</span><br><span class="line">任务1 动态选择方法及属性2</span><br><span class="line">任务2 通过模块模式实现代码访问控制4</span><br><span class="line">任务3 使用可选&#x2F;可变&#x2F;命名参数6 </span><br><span class="line"></span><br><span class="line"> 第二部分 DOM、事件及定时器 任务4 获得DOM元素的引用10 任务5 动态修饰内容12 任务6 修改元素的内容14 任务7 在DOM加载完成后运行脚本16 任务8 监听及停止监听事件18 任务9 利用事件委托20 任务10 将行为和自定义事件解耦22 任务11 模拟后台处理24</span><br><span class="line"></span><br><span class="line"> 第三部分 UI技巧 任务12 打造漂亮的tooltip28 任务13 制作友好的弹窗30 任务14 预载入图片32 任务15 创造光箱特效34 任务16 实现“无限翻页”36 任务17 在载入内容时保持显示区域38</span><br><span class="line"></span><br><span class="line"> 第四部分 表单技巧 任务18 暂时禁用提交按钮42 任务19 提供输入长度反馈44 任务20 同时选择或反选多个checkbox46 任务21 表单验证：基本技巧48 任务22 表单验证：进阶技巧50 任务23 表单验证：高级技巧52 任务24 在表单中提供动态的帮助tooltip54 任务25 自动完成输入56 任务26 使用动态多文件上传58</span><br><span class="line"></span><br><span class="line"> 第五部分 服务器端技术 任务27 读取及写入cookie 62 任务28 通过Ajax载入内容（同域名）64 任务29 使用JSON 66 任务30 使用JSON-P68 任务31 跨域“Ajax”（方法收集1）70 任务32 跨域“Ajax”（方法收集2）72</span><br><span class="line"></span><br><span class="line"> 第六部分 使用混搭 任务33 Twitter的同步更新76 任务34 Flickr的同步更新78 任务35 获得地理位置及该位置的照片80</span><br><span class="line"></span><br><span class="line"> 第七部分 附录 附录A JavaScript快速参考84 附录B JavaScript调试指南91 附录C JavaScript框架概览104 附录D 求助指南112 参考文献117</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00647RUK6/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00647RUK6&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/516sAeboUyL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript异步编程</title>
    <url>/2020/04/19/javascriptyi-bu-bian-cheng/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： JavaScript异步编程<br>作者信息： 作者: Trevor Burnham [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>如果你是一位JavaScript程序员，如果你想让自己的Web应用拥有更高的响应度，如果你想用更优雅简洁的代码描述那些让你抓狂的“休息，休息一下，等到有结果再继续吧”的业务逻辑，那么本书就是你案头必备的那本JavaScript异步编程宝典。JavaScript异步编程：设计快速响应的网络应用从最最基本也是最最重要的JavaScript事件模型开始，生动地复盘了各种异步应用情景，逐一呈现了目前在用的各种异步设计模式和异步编程类库，从PubSub到Promise，从异步工作流控制类库到worker多线程技术，甚至还谈到了浏览器端脚本的异步加载技术。总而言之，在这里，你能找到JavaScript异步编程的所有，从它的前世，到它的今生，还有它的未来。JavaScript异步编程：设计快速响应的网络应用叙述流畅，从问题引入，到初步解决，再到用例延伸、进阶方案，一路抽丝剥茧，层层推进，精彩纷呈。行文娓娓道来，有如对坐漫谈，令人有如沐春风之感。 本书赞誉<br>献词<br>致谢<br>前言<br>第1章 深入理解JavaScript事件<br>第2章 分布式事件<br>第3章 Promise对象和Deferred对象<br>第4章 Async.js的工作流控制<br>第5章 worker对象的多线程技术<br>第6章 异步的脚本加载<br>附录 JavaScript编辑工具</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00CYM0Z8Y/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00CYM0Z8Y&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51i6%2BXldTeL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>结网 互联网产品经理改变世界</title>
    <url>/2020/04/19/jie-wang-hu-lian-wang-chan-pin-jing-li-gai-bian-shi-jie/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 结网 互联网产品经理改变世界<br>作者信息： 作者: 王坚 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《结网:互联网产品经理改变世界》作者一直从事互联网产品的研究和实战，经验丰富，同时作为导师，指导了大量优秀的产品经理，《结网:互联网产品经理改变世界》的内容也是作者8年来培养产品经理新兵的经验集萃。如果你缺乏培养产品经理的教材，《结网:互联网产品经理改变世界》正好总结了产品经理知识体系，无疑是你很好的选择。<br>《结网:互联网产品经理改变世界》覆盖了相当全面的互联网知识，对于想要了解互联网行业或想要借助互联网进行营销的人来说，都是很好的入门读物。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Prototype职业选择　　1</span><br><span class="line">0.1.0 互联网产品经理　　2</span><br><span class="line">0.1.1 职业测试　　9</span><br><span class="line">0.1.2 职业发展　　14</span><br><span class="line">Alpha创建互联网产品　　21</span><br><span class="line">0.2.0 从概念开始　　22</span><br><span class="line">0.2.1 概念 2.0　　29</span><br><span class="line">0.2.2 过滤　　37</span><br><span class="line">0.2.3 获得投资　　63</span><br><span class="line">0.2.4 把概念变成图纸　　75</span><br><span class="line">0.2.5 关注用户体验　　87</span><br><span class="line">0.2.6 管理项目　　123</span><br><span class="line">0.2.7 检查与处理　　132</span><br><span class="line">0.2.8 网站分析　　138</span><br><span class="line">0.2.9 拉动　　147</span><br><span class="line">0.2.10 持续更新　　160</span><br><span class="line">0.2.11 优雅降级　　170</span><br><span class="line">0.2.12 竞争情报　　173</span><br><span class="line">Beta个人修炼　　183</span><br><span class="line">0.3.0 面对逆境　　184</span><br><span class="line">0.3.1 沟通　　192</span><br><span class="line">0.3.2 创新　　206</span><br><span class="line">0.3.3 自省　　216</span><br><span class="line">0.3.4 练习　　222</span><br><span class="line">资 源　　229</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B003IB3I16/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B003IB3I16&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41xcMl9mlkL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery基础教程(第2版)</title>
    <url>/2020/04/19/jqueryji-chu-jiao-cheng-di-2ban/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： jQuery基础教程(第2版)<br>作者信息： 作者: Jonathan Chaffer [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《jQuery基础教程(第2版)》作为《jQuery基础教程》的升级版，涵盖了jQuery 1.3的全部新特性，特别是新增了介绍jQuery UI（jQuery官方用户界面插件库）的内容。《jQuery基础教程(第2版)》前6章以通俗易懂的方式介绍了jQuery的基本概念，主要包括jQuery的选择符、事件、效果、DOM操作、AJAX支持等。随后3章从理论到实践，通过表格操作、构建功能型表单、实现滑移和翻转效果等实例，深入浅出地讲解了如何创造性地运用jQuery提供的丰富而强大的API。《jQuery基础教程(第2版)》最后两章专门介绍了如何使用和编写jQuery插件。值得一提的是，本版新增的附录D分门别类地列出了所有jQuery API，为高效使用jQuery提供了方便。<br>《jQuery基础教程(第2版)》注重理论与实践相结合，适合初中级Web开发人员阅读和参考。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章　jQuery入门　1</span><br><span class="line">1.1　jQuery能做什么　1</span><br><span class="line">1.2　jQuery为什么如此出色　2</span><br><span class="line">1.3　jQuery项目历史　3</span><br><span class="line">1.4　第一个jQuery驱动的页面　4</span><br><span class="line">1.4.1　下载jQuery　4</span><br><span class="line">1.4.2　建立HTML文档　4</span><br><span class="line">1.4.3　编写jQuery代码　7</span><br><span class="line">1.4.4　最终结果　9</span><br><span class="line">1.5　小结　9 </span><br><span class="line"></span><br><span class="line"> 第2章　选择符　10 2.1　DOM　10 2.2　工厂函数$()　11 2.3　CSS选择符　11 2.4　属性选择符　14 2.5　自定义选择符　15 2.5.1　每隔一行为表格添加样式　16 2.5.2　基于表单的选择符　18 2.6　DOM遍历方法　18 2.6.1　为特定单元格添加样式　19 2.6.2　连缀　20 2.7　访问DOM元素　21 2.8　小结　21</span><br><span class="line"></span><br><span class="line"> 第3章　事件　22 3.1　在页面加载后执行任务　22 3.1.1　代码执行的时机选择　22 3.1.2　基于一个页面执行多个脚本　23 3.1.3　缩短代码的简写方式　24 3.1.4　与其他库共存　24 3.2　简单的事件　25 3.2.1　简单的样式转换器　25 3.2.2　简写的事件　31 3.3　复合事件　32 3.3.1　显示和隐藏高级特性　32 3.3.2　突出显示可单击的项　34 3.4　事件的旅程　35 3.5　通过事件对象改变事件的旅程　37 3.5.1　事件目标　38 3.5.2　停止事件传播　39 3.5.3　默认操作　39 3.5.4　事件委托　40 3.6　移除事件处理程序　42 3.6.1　事件的命名空间　42 3.6.2　重新绑定事件　43 3.7　模仿用户操作　44 3.8　小结　47</span><br><span class="line"></span><br><span class="line"> 第4章　效果　49 4.1　修改内联CSS　49 4.2　基本的隐藏和显示　53 4.3　效果和速度　54 4.3.1　指定显示速度　55 4.3.2　淡入和淡出　55 4.4　复合效果　56 4.5　创建自定义动画　57 4.5.1　切换淡入淡出　58 4.5.2　创建多个属性的动画　58 4.6　并发与排队效果　61 4.6.1　处理一组元素　61 4.6.2　处理多组元素　63 4.6.3　回调函数　65 4.6.4　简单概括　67 4.7　小结　67</span><br><span class="line"></span><br><span class="line"> 第5章　DOM操作　68 5.1　操作属性　68 5.1.1　非class属性　68 5.1.2　深入理解$()工厂函数　70 5.2　插入新元素　72 5.3　移动元素　73 5.3.1　标注、编号和链接到上下文　76 5.3.2　插入脚注　78 5.4　包装元素　79 5.5　复制元素　80 5.5.1　连同事件一起复制　82 5.5.2　通过复制创建突出引用　82 5.5.3　通过CSS使突出引用偏离正文　82 5.5.4　回到代码中　83 5.5.5　修饰突出引用　85 5.6　DOM操作方法的简单归纳　87 5.7　小结　87</span><br><span class="line"></span><br><span class="line"> 第6章　AJAX　88 6.1　基于请求加载数据　88 6.1.1　追加HTML　89 6.1.2　操作JavaScript对象　92 6.1.3　加载XML文档　98 6.2　选择数据格式　101 6.3　向服务器传递数据　102 6.3.1　执行GET请求　102 6.3.2　执行POST请求　105 6.3.3　序列化表单　106 6.4　关注请求　108 6.5　AJAX和事件　111 6.6　安全限制　111 6.7　其他工具　114 6.7.1　低级AJAX方法　114 6.7.2　修改默认选项　114 6.7.3　部分加载HTML页面　115 6.8　小结　117</span><br><span class="line"></span><br><span class="line"> 第7章　表格操作　118 7.1　排序和分页　119 7.1.1　服务器端排序　119 7.1.2　JavaScript排序　120 7.1.3　服务器端分页　134 7.1.4　JavaScript分页　136 7.1.5　完成的代码　140 7.2　修改表格外观　142 7.2.1　突出显示行　142 7.2.2　工具提示条　149 7.2.3　折叠和扩展　153 7.2.4　筛选　155 7.2.5　完成的代码　159 7.3　小结　162</span><br><span class="line"></span><br><span class="line"> 第8章　构建功能型表单　163 8.1　改进基本的表单　163 8.1.1　渐进增强表单样式　163 8.1.2　根据条件显示的字段　169 8.1.3　表单验证　171 8.1.4　复选框操作　178 8.1.5　完成的代码　180 8.2　提升紧凑的表单　183 8.2.1　字段的占位符文本　183 8.2.2　AJAX自动完成　186 8.2.3　完成的代码　193 8.3　操作数字型表单数据　195 8.3.1　购物车表格结构　195 8.3.2　拒绝非数字输入　199 8.3.3　数字计算　199 8.3.4　删除商品　205 8.3.5　修改送货信息　208 8.3.6　完成的代码　211 8.4　小结　213</span><br><span class="line"></span><br><span class="line"> 第9章　滑移和翻转　214 9.1　标题新闻翻转效果　214 9.1.1　设置页面　214 9.1.2　取得新闻源　216 9.1.3　设置翻转效果　219 9.1.4　标题新闻翻转函数　220 9.1.5　悬停时暂停　222 9.1.6　从不同的域中取得新闻源　224 9.1.7　附加的内部渐变效果　226 9.1.8　完成的代码　228 9.2　图像传送带　229 9.2.1　设置页面　230 9.2.2　通过单击滑移图像　233 9.2.3　放大图像　239 9.2.4　完成的代码　250 9.3　小结　253</span><br><span class="line"></span><br><span class="line"> 第10章　使用插件　254 10.1　查找插件和帮助　254 10.2　使用插件　254 10.3　Form插件　255 10.4　jQuery UI插件库　257 10.4.1　效果　257 10.4.2　交互组件　259 10.4.3　部件　261 10.4.4　jQuery UI ThemeRoller　263 10.5　其他插件　264 10.5.1　表单类　264 10.5.2　表格类　266 10.5.3　图像类　268 10.5.4　亮盒及模态对话框　269 10.5.5　图表类　270 10.5.6　事件类　272 10.6　小结　272</span><br><span class="line"></span><br><span class="line"> 第11章　开发插件　273 11.1　添加新的全局函数　273 11.1.1　添加多个函数　273 11.1.2　关键所在　274 11.1.3　创建实用方法　275 11.2　添加jQuery对象方法　276 11.2.1　对象方法的环境　276 11.2.2　方法连缀　278 11.3　DOM遍历方法　280 11.4　添加新的简写方法　283 11.5　方法的参数　286 11.5.1　简单参数　287 11.5.2　参数映射　288 11.5.3　默认参数值　289 11.5.4　回调函数　290 11.5.5　可定制的默认值　291 11.6　添加选择符表达式　292 11.7　共享插件　295 11.7.1　命名约定　295 11.7.2　别名$的使用　295 11.7.3　方法接口　295 11.7.4　文档格式　296 11.8　小结　296</span><br><span class="line"></span><br><span class="line"> 附录A　在线资源　297 附录B　开发工具　303 附录C　JavaScript闭包　307 附录D　快速参考　318</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B002VEDBCC/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B002VEDBCC&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51SQyvXs%2BNL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac功夫</title>
    <url>/2020/04/19/macgong-fu/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Mac功夫<br>作者信息： 作者: 托马斯 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>领略众多扩展苹果系统隐藏功能的技巧<br>学习鲜为人知的操作、挖掘苹果隐藏的宝物<br>介绍300多个有趣的苹果操作系统技巧<br>专业术语都以中文标示，降低阅读难度<br>适用于各版本Mac OS X操作系统<br>10.8美洲狮中增加功能也有相应标注<br>将诸多神秘功能一网打尽、优化Mac日常使用体验</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 介绍 1</span><br><span class="line">1.1 如何读这本书 1</span><br><span class="line">1.2 所有Mac电脑都不需要安装额外插件 2</span><br><span class="line">1.3 致谢 2</span><br><span class="line">1.4 共享 2</span><br><span class="line">第2章 在使用小技巧之前 3</span><br><span class="line">2.1 通过键入命令行来启动隐藏设置 3</span><br><span class="line">2.2 使用苹果菜单或应用程序菜单 4</span><br><span class="line">2.3 创建一个TimeMachine备份 4</span><br><span class="line">2.4 使用鼠标和触控板 4</span><br><span class="line">2.5 管理员账户 5</span><br><span class="line">2.6 注销和登录 5</span><br><span class="line">2.7 使用程序窗口 6</span><br><span class="line">2.8 使用苹果键盘和快捷键 6</span><br><span class="line">第3章 技巧集锦 8</span><br><span class="line">小技巧1 在Dock上显示iTunes音轨信息 8</span><br><span class="line">小技巧2 关闭渐隐和弹出动画效果 9</span><br><span class="line">小技巧3 不用鼠标就能打开应用程序 11</span><br><span class="line">小技巧4 在快速查看的预览窗口里高亮选中文本 11</span><br><span class="line">小技巧5 轻松地调整窗口大小 12</span><br><span class="line">小技巧6 应用程序全屏状态下调出Dock边栏 12</span><br><span class="line">小技巧7 通过推动屏幕边缘来切换桌面 13</span><br><span class="line">小技巧8 用密码保护USB闪存卡 13</span><br><span class="line">小技巧9 找到当前壁纸文件的路径 15</span><br><span class="line">小技巧10 文本摘要工具 15</span><br><span class="line">小技巧11 通过滚动手势显示文件堆栈或应用程序Exposé 16</span><br><span class="line">小技巧12 快速创建文件名列表 17</span><br><span class="line">小技巧13 控制滚动效果 17</span><br><span class="line">小技巧14 访问所有的键盘功能 19</span><br><span class="line">小技巧15 让外接显示器的字体显示效果更平滑 19</span><br><span class="line">小技巧16 快速输入常用符号和字符 19</span><br><span class="line">小技巧17 自动重命名图片 21</span><br><span class="line">小技巧18 安全清倒废纸篓 23</span><br><span class="line">小技巧19 自定义图标 23</span><br><span class="line">小技巧20 查看软件版本信息 24</span><br><span class="line">小技巧21 在桌面上使用Dashboard里的Widget 25</span><br><span class="line">小技巧22 把文件夹里的图片添加到可用壁纸列表 26</span><br><span class="line">小技巧23 将屏幕截图直接复制到剪贴板 26</span><br><span class="line">小技巧24 让笔记本电脑深度睡眠以节省电量 26</span><br><span class="line">小技巧25 精通MissionControl 27</span><br><span class="line">小技巧26 加快系统启动速度 29</span><br><span class="line">小技巧27 了解你在Finder窗口里的详细位置 29</span><br><span class="line">小技巧28 调整Launchpad的可视化特效 30</span><br><span class="line">小技巧29 延长苹果笔记本电脑的电池寿命 31</span><br><span class="line">小技巧30 将各种视觉效果应用到图片上 31</span><br><span class="line">小技巧31 让电子邮件充满个性 32</span><br><span class="line">小技巧32 通过屏幕保护程序选择播放哪首音乐 33</span><br><span class="line">小技巧33 创建一个绝对安全的私人文件保险箱 33</span><br><span class="line">小技巧34 查看Wi—Fi详细信息 35</span><br><span class="line">小技巧35 快速切换耳机和麦克风接口 36</span><br><span class="line">小技巧36 个性化Launchpad 36</span><br><span class="line">小技巧37 为“文本编辑”添加字数统计功能 37</span><br><span class="line">小技巧38 点击并按住键盘快捷键 39</span><br><span class="line">小技巧39 用指定应用程序打开Spotlight的搜索结果文件 39</span><br><span class="line">小技巧40 快速浏览日历 39</span><br><span class="line">小技巧41 了解Spotlight搜索结果的确切位置 40</span><br><span class="line">小技巧42 轻松输入特殊字符 40</span><br><span class="line">小技巧43 在文档里自动创建链接 41</span><br><span class="line">小技巧44 控制应用程序开机自动启动 42</span><br><span class="line">小技巧45 监视CPU的使用率和活动状态 42</span><br><span class="line">小技巧46 创建文档模板和替换短语 43</span><br><span class="line">小技巧47 保持苹果电脑的“清醒”状态 44</span><br><span class="line">小技巧48 检测苹果电脑的内存芯片 45</span><br><span class="line">小技巧49 创建一张OSX操作系统安装&#x2F;启动光盘 46</span><br><span class="line">小技巧50 从崩溃和死机中恢复 48</span><br><span class="line">小技巧51 分享你的地址簿 49</span><br><span class="line">小技巧52 更改Finder窗口的文字字体 49</span><br><span class="line">小技巧53 对电脑进行压力测试 50</span><br><span class="line">小技巧54 注释文件以加速搜索 51</span><br><span class="line">小技巧55 找回资源库文件夹 52</span><br><span class="line">小技巧56 快速在桌面上创建文件替身 53</span><br><span class="line">小技巧57 为Dock文件栈添加视觉特效 53</span><br><span class="line">小技巧58 在桌面上浏览文件的详细信息 55</span><br><span class="line">小技巧59 压缩PDF文件 55</span><br><span class="line">小技巧60 启用键盘重复输入 56</span><br><span class="line">小技巧61 快速整理工具栏上的图标 56</span><br><span class="line">小技巧62 保存可重用的文本片段 56</span><br><span class="line">小技巧63 隐藏文件 57</span><br><span class="line">小技巧64 在Finder窗口标题栏上显示路径 58</span><br><span class="line">小技巧65 设置截图选项 59</span><br><span class="line">小技巧66 创建智能颜色选取器应用程序 60</span><br><span class="line">小技巧67 在没有TimeMachine硬盘的环境下使用TimeMachine备份文件 62</span><br><span class="line">小技巧68 让Dock栏的图标更小 63</span><br><span class="line">小技巧69 一种隐藏的文件栈列表模式 64</span><br><span class="line">小技巧70 直接打开你正在快速查看的文件 65</span><br><span class="line">小技巧71 隐藏所有的窗口 65</span><br><span class="line">小技巧72 改善Finder窗口里的分栏视图 65</span><br><span class="line">小技巧73 显示Spotlight和Dock里文件所在的位置 66</span><br><span class="line">小技巧74 善用效能利器Finder窗口 67</span><br><span class="line">小技巧75 使用打印机池快速打印 68</span><br><span class="line">小技巧76 快速关机、重启或进入睡眠 68</span><br><span class="line">小技巧77 浏览图片和影片的隐藏信息 69</span><br><span class="line">小技巧78 通过拖动打印文件 69</span><br><span class="line">小技巧79 精通Spotlight 70</span><br><span class="line">小技巧80 切换Finder窗口的浏览视图 72</span><br><span class="line">小技巧81 重置苹果电脑的硬件设置 72</span><br><span class="line">小技巧82 了解磁盘剩余空间 73</span><br><span class="line">小技巧83 找回忘记的密码 74</span><br><span class="line">小技巧84 查看打印内容 74</span><br><span class="line">小技巧85 强制使用某个应用程序打开文档 75</span><br><span class="line">小技巧86 保存Spotlight搜索条件 75</span><br><span class="line">小技巧87 在Google地图中查看地址 76</span><br><span class="line">小技巧88 快速执行算术运算 76</span><br><span class="line">小技巧89 获取多个文件的大小总和 77</span><br><span class="line">小技巧90 使用彩色标签来管理项目组文件 77</span><br><span class="line">小技巧91 录制影片、截屏视频及播客 78</span><br><span class="line">小技巧92 在Finder窗口中打印文件 79</span><br><span class="line">小技巧93 添加光驱推出按钮 80</span><br><span class="line">小技巧94 访问隐藏的菜单选项 80</span><br><span class="line">小技巧95 快速启动Google搜索 81</span><br><span class="line">小技巧96 对登录图片应用视觉特效 81</span><br><span class="line">小技巧97 用CoverFlow方式浏览iCal事件 82</span><br><span class="line">小技巧98 放大鼠标指针 82</span><br><span class="line">小技巧99 熟练切换应用程序 83</span><br><span class="line">小技巧100 调整苹果电脑的字典 84</span><br><span class="line">小技巧101 设置超低音量 84</span><br><span class="line">小技巧102 在文件栈中快速查看文件 85</span><br><span class="line">小技巧103 浏览被隐藏的应用程序图标 85</span><br><span class="line">小技巧104 锁定文件 86</span><br><span class="line">小技巧105 换掉Dashboard和MissionControl的壁纸 87</span><br><span class="line">小技巧106 使用屏幕保护程序作为桌面背景 89</span><br><span class="line">小技巧107 在苹果系统登录界面上查看技术支持信息 90</span><br><span class="line">小技巧108 使用AppleRemote遥控器浏览启动菜单 91</span><br><span class="line">小技巧109 禁用程序重启时自动打开文件 91</span><br><span class="line">小技巧110 创建兼容所有操作系统的加密档案 93</span><br><span class="line">小技巧111 快速查看单词含义 95</span><br><span class="line">小技巧112 修复苹果电脑，尤其在硬盘出现问题时 96</span><br><span class="line">小技巧113 取消下载文件的“文件隔离” 96</span><br><span class="line">小技巧114 查看正在编辑文件的存放位置 97</span><br><span class="line">小技巧115 使用键盘快捷键剪切文件 97</span><br><span class="line">小技巧116 直接弹开文件夹 97</span><br><span class="line">小技巧117 在上下翻页时移动光标位置 98</span><br><span class="line">小技巧118 在打开&#x2F;存储对话框中直接进入文件位置 98</span><br><span class="line">小技巧119 解除应用程序崩溃 99</span><br><span class="line">小技巧120 把剪切板里的图片保存为文件 99</span><br><span class="line">小技巧121 仅用键盘操作桌面任务 100</span><br><span class="line">小技巧122 创建邮件快捷方式 100</span><br><span class="line">小技巧123 检查苹果电脑的保修服务和技术支持 101</span><br><span class="line">小技巧124 锁定屏幕 101</span><br><span class="line">小技巧125 用另一个应用程序打开当前工作的文件 102</span><br><span class="line">小技巧126 熟练操作PDF 103</span><br><span class="line">小技巧127 在QuickTimePlayer中编辑影片 105</span><br><span class="line">小技巧128 推出CD&#x2F;DVD光盘 106</span><br><span class="line">小技巧129 检测第二台显示器 107</span><br><span class="line">小技巧130 使用触控板调整影片播放进度 107</span><br><span class="line">小技巧131 捕捉屏幕截图 107</span><br><span class="line">小技巧132 永久忽略软件更新 108</span><br><span class="line">小技巧133 创建字体预览文档 109</span><br><span class="line">小技巧134 在终端程序中快速浏览某个命令的man页面 109</span><br><span class="line">小技巧135 自动完成 110</span><br><span class="line">小技巧136 让Dock栏只显示正在运行的程序 110</span><br><span class="line">小技巧137 在Dock栏上添加最近使用的项目文件栈 111</span><br><span class="line">小技巧138 自定义MissionControl界面的高亮颜色 112</span><br><span class="line">小技巧139 快速访问系统偏好设置工具 113</span><br><span class="line">小技巧140 隐藏桌面图标 114</span><br><span class="line">小技巧141 修复密码 115</span><br><span class="line">小技巧142 将窗口最小化为应用程序图标 116</span><br><span class="line">小技巧143 临时打开&#x2F;关闭Dock栏的放大功能 116</span><br><span class="line">小技巧144 移除系统偏好设置面板中的图标 116</span><br><span class="line">小技巧145 加快PDF文件的浏览速度 118</span><br><span class="line">小技巧146 使用图片编辑器向文档中插入图片 118</span><br><span class="line">小技巧147 文件压缩的高级技巧 118</span><br><span class="line">小技巧148 拍摄照片的高级技巧 119</span><br><span class="line">小技巧149 熟练选中文本内容 120</span><br><span class="line">小技巧150 在文本编辑程序中搜索文字 121</span><br><span class="line">小技巧151 在Mail中快速查看附件和网页 122</span><br><span class="line">小技巧152 把Finder窗口中的链接放到Dock栏上 122</span><br><span class="line">小技巧153 设置小键盘为键盘快捷键 123</span><br><span class="line">小技巧154 清理缓存 124</span><br><span class="line">小技巧155 更改登录界面壁纸 124</span><br><span class="line">小技巧156 使用快捷键显示桌面 126</span><br><span class="line">小技巧157 通过终端快速查看文件 126</span><br><span class="line">小技巧158 新建位于当前文件夹位置的终端窗口 126</span><br><span class="line">小技巧159 鼠标连上电脑后关闭触控板 127</span><br><span class="line">小技巧160 只安装打印机驱动而不安装插件 127</span><br><span class="line">小技巧161 发送前往应用程序的链接 128</span><br><span class="line">小技巧162 做出更大的Safari搜索框 128</span><br><span class="line">小技巧163 复制计算器程序的结果 128</span><br><span class="line">小技巧164 通过书签快速访问图片和PDF 129</span><br><span class="line">小技巧165 在Safari全屏模式下缩小页面的宽度 129</span><br><span class="line">小技巧166 下载软件的更新 129</span><br><span class="line">小技巧167 连接不支持屏幕共享的电脑 130</span><br><span class="line">小技巧168 在Dock中添加空白区域 131</span><br><span class="line">小技巧169 从其他窗口获取信息 132</span><br><span class="line">小技巧170 查看特定时间创建的文件 133</span><br><span class="line">小技巧171 在Safari中下载文件 133</span><br><span class="line">小技巧172 在iCal程序中浏览两周内的安排 136</span><br><span class="line">小技巧173 取消开机提示音 136</span><br><span class="line">小技巧174 放大桌面 137</span><br><span class="line">小技巧175 减少TimeMachine备份的频率 138</span><br><span class="line">小技巧176 切换文档窗口 139</span><br><span class="line">小技巧177 快速重命名文件 139</span><br><span class="line">小技巧178 把文件导入Spotlight索引内 140</span><br><span class="line">小技巧179 禁用询问是否备份的对话框 141</span><br><span class="line">小技巧180 让苹果笔记本电脑的硬盘更快进入睡眠状态 141</span><br><span class="line">小技巧181 自定义系统声音 142</span><br><span class="line">小技巧182 在访问只读文件夹时获得提示 143</span><br><span class="line">小技巧183 快速发送邮件 143</span><br><span class="line">小技巧184 在“预览”程序中缩放、旋转或翻转图片 144</span><br><span class="line">小技巧185 快速新建便笺 144</span><br><span class="line">小技巧186 通过快捷键打开Finder窗口 145</span><br><span class="line">小技巧187 在苹果电脑上熟练操作Podcast 145</span><br><span class="line">小技巧188 一眼看出PDF是否含有多页 147</span><br><span class="line">小技巧189 控制屏幕保护程序 147</span><br><span class="line">小技巧190 从iPhone和iPad中获取图片和影片 147</span><br><span class="line">小技巧191 把网页保存到磁盘中 147</span><br><span class="line">小技巧192 旧物换钱 148</span><br><span class="line">小技巧193 缩短iCal事件的持续时间 149</span><br><span class="line">小技巧194 让苹果电脑“说话” 149</span><br><span class="line">小技巧195 精通字典应用程序 150</span><br><span class="line">小技巧196 优化Finder窗口的滚动效果 151</span><br><span class="line">小技巧197 放大字体，轻松记录 151</span><br><span class="line">小技巧198 存储对话框默认显示为扩展模式 152</span><br><span class="line">小技巧199 全屏快速查看 153</span><br><span class="line">小技巧200 检查输入文字的语法 153</span><br><span class="line">小技巧201 调整Dock栏的观感 154</span><br><span class="line">小技巧202 向PDF文档中添加手绘图 155</span><br><span class="line">小技巧203 删减右键菜单中的选项 155</span><br><span class="line">小技巧204 退出Finder程序 156</span><br><span class="line">小技巧205 撤销操作 156</span><br><span class="line">小技巧206 新建包含所选文件的文件夹 157</span><br><span class="line">小技巧207 快速移除Dashboard界面中的Widget 157</span><br><span class="line">小技巧208 拖动文件后对齐桌面上的图标 157</span><br><span class="line">小技巧209 观看OSX系统的慢速动画效果 157</span><br><span class="line">小技巧210 帮助辨认被隐藏的应用程序 158</span><br><span class="line">小技巧211 中断文件拖动 159</span><br><span class="line">小技巧212 删除TimeMachine备份中的文件 159</span><br><span class="line">小技巧213 连接到共享文件夹或服务器 160</span><br><span class="line">小技巧214 浏览其他国家的AppStore 160</span><br><span class="line">小技巧215 停止生成DS_store文件 161</span><br><span class="line">小技巧216 保存终端窗口中的内容 161</span><br><span class="line">小技巧217 启用隐藏的最小化视觉特效 162</span><br><span class="line">小技巧218 更好地利用双指实现右键单击 163</span><br><span class="line">小技巧219 把一系列图片转换成PDF文件 163</span><br><span class="line">小技巧220 一次只显示一个程序窗口 164</span><br><span class="line">小技巧221 在Finder窗口左边栏添加废纸篓 164</span><br><span class="line">小技巧222 在打开&#x2F;存储对话框中使用快速查看功能 165</span><br><span class="line">小技巧223 从影片文件中提取出声音 165</span><br><span class="line">小技巧224 自动将PDF文档导出到特定文件夹 166</span><br><span class="line">小技巧225 复制并粘贴纯文本 167</span><br><span class="line">小技巧226 使用启动选项 167</span><br><span class="line">小技巧227 创建安全备注 168</span><br><span class="line">小技巧228 一次性关闭所有应用程序 169</span><br><span class="line">小技巧229 升级电脑内存 169</span><br><span class="line">小技巧230 在命令行工具中打开GUI应用程序 170</span><br><span class="line">小技巧231 快速复制多封邮件内容 171</span><br><span class="line">小技巧232 通过终端窗口搜索文件 172</span><br><span class="line">小技巧233 启用Root用户权限 172</span><br><span class="line">小技巧234 自动唤醒苹果笔记本电脑 173</span><br><span class="line">小技巧235 将终端命令行结果输出到GUI程序中 174</span><br><span class="line">小技巧236 禁用某些OSX系统的功能 175</span><br><span class="line">小技巧237 重新定义键盘快捷键 177</span><br><span class="line">小技巧238 复制文本的字体类型 178</span><br><span class="line">小技巧239 使用手势激活应用程序Exposé功能 178</span><br><span class="line">小技巧240 更改替身指向的文件 178</span><br><span class="line">小技巧241 在Spotlight搜索结果列表中选择类别 179</span><br><span class="line">小技巧242 重设Dock栏 179</span><br><span class="line">小技巧243 更改菜单栏图标的位置 179</span><br><span class="line">小技巧244 唤醒苹果笔记本电脑 180</span><br><span class="line">小技巧245 整蛊朋友的苹果电脑 180</span><br><span class="line">小技巧246 以实际尺寸查看图片 181</span><br><span class="line">小技巧247 转换音频和视频格式 182</span><br><span class="line">小技巧248 扩展快速查看功能支持的文件格式 182</span><br><span class="line">小技巧249 通过Google即时搜索选中文本 183</span><br><span class="line">小技巧250 启用另一个Dock栏堆栈动画 183</span><br><span class="line">小技巧251 使用特殊手势切换到前一个桌面空间 183</span><br><span class="line">小技巧252 了解文件的来源 184</span><br><span class="line">小技巧253 在登录界面中添加提示窗口 184</span><br><span class="line">小技巧254 通过命令行启用TimeMachine 185</span><br><span class="line">小技巧255 修复磁盘 186</span><br><span class="line">小技巧256 拆分标签 187</span><br><span class="line">小技巧257 把TimeMachine备份移动到更大的硬盘 187</span><br><span class="line">小技巧258 浏览邮件内的纯文本 188</span><br><span class="line">小技巧259 扩展Spotlight支持的文件类型 189</span><br><span class="line">小技巧260 诊断网络故障 190</span><br><span class="line">小技巧261 加快建立SSH&#x2F;SFTP&#x2F;FTP连接 190</span><br><span class="line">小技巧262 使用预览程序在文档中添加签名 191</span><br><span class="line">小技巧263 加快Mail程序的运行速度 192</span><br><span class="line">小技巧264 使Chrome浏览器网页窗口填满整个桌面 193</span><br><span class="line">小技巧265 搜索系统文件 193</span><br><span class="line">小技巧266 设置开机默认启动的操作系统 194</span><br><span class="line">小技巧267 对电脑运行状态进行转储快照 195</span><br><span class="line">小技巧268 在打开&#x2F;存储对话框中使用相对路径 195</span><br><span class="line">小技巧269 立即取消对话框 195</span><br><span class="line">小技巧270 搜索换行符和制表符 196</span><br><span class="line">小技巧271 在阳光下看清屏幕 196</span><br><span class="line">小技巧272 掌握“存储为”对话框的快捷键 196</span><br><span class="line">小技巧273 快速调用应用程序的偏好设置 196</span><br><span class="line">小技巧274 看到更大的壁纸缩略图 197</span><br><span class="line">小技巧275 快速切换标签 197</span><br><span class="line">小技巧276 浏览旧的TimeMachine硬盘 197</span><br><span class="line">小技巧277 用Safari浏览站内链接 198</span><br><span class="line">小技巧278 远程获取苹果电脑中的文件 198</span><br><span class="line">小技巧279 在应用程序中前进和后退 199</span><br><span class="line">小技巧280 游戏 199</span><br><span class="line">小技巧281 查看磁盘空间的使用情况 200</span><br><span class="line">小技巧282 全屏运行X11应用程序 201</span><br><span class="line">小技巧283 让Dashboard界面的切换方式变回覆盖模式 201</span><br><span class="line">小技巧284 美化iTunes的可视化效果 202</span><br><span class="line">小技巧285 光标跳到“文本编辑”程序的指定行 202</span><br><span class="line">小技巧286 在Launchpad界面中添加Finder程序 202</span><br><span class="line">小技巧287 转发邮件 203</span><br><span class="line">小技巧288 创建苹果电脑间的即时网络连接 203</span><br><span class="line">小技巧289 从屏幕保护程序包中获取精美壁纸 203</span><br><span class="line">小技巧290 使用Emoji表情 204</span><br><span class="line">小技巧291 在文本编辑程序中输入并检查外文 205</span><br><span class="line">小技巧292 在恢复模式中使用Safari 206</span><br><span class="line">小技巧293 从Windows迁移数据到苹果电脑 206</span><br><span class="line">小技巧294 扩展QuickTimePlayer能识别的文件类型 207</span><br><span class="line">小技巧295 阅读产品的官方使用手册 207</span><br><span class="line">小技巧296 在苹果电脑上使用非苹果生产的键盘 208</span><br><span class="line">小技巧297 在登录时自动创建服务器连接 208</span><br><span class="line">小技巧298 反选文件 209</span><br><span class="line">小技巧299 放置多个相同的Widget 209</span><br><span class="line">小技巧300 逐秒浏览影片 210</span><br><span class="line">小技巧301 让网站以应用程序方式打开 210</span><br><span class="line">小技巧302 在线分享影片剪辑 211</span><br><span class="line">小技巧303 在任意位置新建文件夹 211</span><br><span class="line">小技巧304 使用快速查看功能浏览网页 211</span><br><span class="line">小技巧305 通过Finder窗口获取FTP服务器中的文件 212</span><br><span class="line">小技巧306 禁用大写锁定键 212</span><br><span class="line">小技巧307 启用键盘背光 213</span><br><span class="line">小技巧308 查看电池状况 214</span><br><span class="line">小技巧309 轻松放大图片和PDF文件 214</span><br><span class="line">小技巧310 获取真正的仙女座星系图片 214</span><br><span class="line">小技巧311 重启Dock栏 215</span><br><span class="line">小技巧312 使用语音操控苹果电脑 215</span><br><span class="line">小技巧313 设置三指触控手势 217</span><br><span class="line">小技巧314 与不支持AirDrop功能的苹果电脑分享文件 217</span><br><span class="line">小技巧315 继续你的苹果电脑冒险：一些必备的应用程序 218</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00A11060M/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00A11060M&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51qcsDsLQhL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核完全注释</title>
    <url>/2020/04/19/linuxnei-he-wan-quan-zhu-shi/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Linux内核完全注释<br>作者信息： 作者: 赵炯 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Linux内核完全注释》对Linux早期操作系统内核(v0.11)全部代码文件进行了详细全面的注释和说明，旨在使读者能够在尽量短的时间内对Linux的工作机理获得全面而深刻的理解，为进一步学习和研究Linux系统打下坚实的基础.书中首先以Linux源代码版本的变迁历史为主线，详细介绍了Linux系统的发展历史，着重说明了各个内核版本之间的重要区别和改进方面，给出了选择0.11(0.95)版作为研究的对象的原因。然后《Linux内核完全注释》依据内核源代码的组织结构对所有内核程序和文件进行了注释和详细说明。在注释的同时，还介绍了读者应该了解的相关知识，并给出了相关的硬件信息。《Linux内核完全注释》带介绍了内核源代码的组织结构信相互关系。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 概述</span><br><span class="line">1.1 linux的诞生和发展</span><br><span class="line">1.1.1 unix、minix、gnu和posix</span><br><span class="line">1.1.2 linux操作系统的诞生和版本的变迁</span><br><span class="line">1.2 内容综述</span><br><span class="line">1.3 本章小结</span><br><span class="line">1.4 习题</span><br><span class="line">第2章 linux内核体系结构</span><br><span class="line">2.1 linux内核模式和体系结构</span><br><span class="line">2.2 linux中断机制</span><br><span class="line">2.3 linux系统定时</span><br><span class="line">2.4 linux内核进程控制</span><br><span class="line">2.4.1 任务数据结构</span><br><span class="line">2.4.2 进程运行状态</span><br><span class="line">2.4.3 进程初始化</span><br><span class="line">2.4.4 创建新进程</span><br><span class="line">2.4.5 进程调度</span><br><span class="line">2.4.6 终止进程</span><br><span class="line">2.5 linux内核对内存的使用方法</span><br><span class="line">.2.6 linux系统中堆栈的使用方法</span><br><span class="line">2.6.1 初始化阶段</span><br><span class="line">2.6.2 任务的堆栈</span><br><span class="line">2.6.3 内核态与用户态堆栈之间的切换</span><br><span class="line">2.7 linux内核源代码的目录结构</span><br><span class="line">2.7.1 引导启动程序目录boot</span><br><span class="line">2.7.2 文件系统目录fs</span><br><span class="line">2.7.3 头文件主目录include</span><br><span class="line">2.7.4 内核初始化程序目录init</span><br><span class="line">2.7.5 内核程序主目录kernel</span><br><span class="line">2.7.6 内核库函数目录lib</span><br><span class="line">2.7.7 内存管理程序目录mm</span><br><span class="line">2.7.8 编译内核工具程序目录tools</span><br><span class="line">2.8 内核系统与用户程序的关系</span><br><span class="line">2.9 linux内核的编译实验环境</span><br><span class="line">2.10 linux&#x2F;makefile文件</span><br><span class="line">2.11 本章小结</span><br><span class="line">2.12 习题</span><br><span class="line">第3章 内核引导启动程序</span><br><span class="line">3.1 总体功能描述</span><br><span class="line">3.2 程序分析</span><br><span class="line">3.2.1 bootsect.s程序</span><br><span class="line">3.2.2 setup.s程序</span><br><span class="line">3.2.3 head.s程序</span><br><span class="line">3.3 本章小结</span><br><span class="line">3.4 习题</span><br><span class="line">第4章 内核初始化过程</span><br><span class="line">4.1 main.c程序分析</span><br><span class="line">4.2 本章小结</span><br><span class="line">4.3 习题</span><br><span class="line">第5章 进程调度与系统调用</span><br><span class="line">5.1 总体功能描述</span><br><span class="line">5.1.1 中断处理程序</span><br><span class="line">5.1.2 系统调用处理相关程序</span><br><span class="line">5.2 程序分析</span><br><span class="line">5.2.1 asm.s程序</span><br><span class="line">5.2.2 traps.c</span><br><span class="line">5.2.3 system_call.s程序</span><br><span class="line">5.2.4 mktime.c程序</span><br><span class="line">5.2.5 sched.c程序</span><br><span class="line">5.2.6 signal.c程序</span><br><span class="line">5.2.7 exit.c程序</span><br><span class="line">5.2.8 fork.c程序</span><br><span class="line">5.2.9 sys.c程序</span><br><span class="line">5.2.10 vsprintf.c程序</span><br><span class="line">5.2.11 printk.c程序</span><br><span class="line">5.2.12 panic.c程序</span><br><span class="line">5.3 本章小结</span><br><span class="line">5.4 习题</span><br><span class="line">第6章 输入输出系统——块设备驱动程序</span><br><span class="line">6.1 总体功能描述</span><br><span class="line">6.1.1 块设备请求项和请求队列</span><br><span class="line">6.1.2 块设备操作方式</span><br><span class="line">6.2 程序分析</span><br><span class="line">6.2.1 blk.h文件</span><br><span class="line">6.2.2 hd.c程序</span><br><span class="line">6.2.3 ll_rw_blk.c程序</span><br><span class="line">6.2.4 ramdisk.c程序</span><br><span class="line">6.2.5 floppy.c程序</span><br><span class="line">6.3 本章小结</span><br><span class="line">6.4 习题</span><br><span class="line">第7章 输入输出系统——字符设备驱动程序</span><br><span class="line">7.1 总体功能描述</span><br><span class="line">7.1.1 终端驱动程序基本原理</span><br><span class="line">7.1.2 终端基本数据结构</span><br><span class="line">7.1.3 规范模式和非规范模式</span><br><span class="line">7.1.4 控制台驱动程序</span><br><span class="line">7.1.5 串行终端驱动程序</span><br><span class="line">7.1.6 终端驱动程序接口</span><br><span class="line">7.2 程序分析</span><br><span class="line">7.2.1 keyboard.s程序</span><br><span class="line">7.2.2 console.c程序</span><br><span class="line">7.2.3 serial.c程序</span><br><span class="line">7.2.4 rs_io.s程序</span><br><span class="line">7.2.5 tty_io.c程序</span><br><span class="line">7.2.6 tty_ioctl.c程序</span><br><span class="line">7.3 本章小结</span><br><span class="line">7.4 习题</span><br><span class="line">第8章 数学协处理器</span><br><span class="line">8.1 math-emulation.c程序分析</span><br><span class="line">8.2 本章小结</span><br><span class="line">8.3 习题</span><br><span class="line">第9章 文件系统</span><br><span class="line">9.1 总体功能描述</span><br><span class="line">9.1.1 minix文件系统</span><br><span class="line">9.1.2 高速缓冲区</span><br><span class="line">9.1.3 文件系统底层函数</span><br><span class="line">9.1.4 文件中数据的访问操作</span><br><span class="line">9.2 程序分析</span><br><span class="line">9.2.1 buffer.c程序</span><br><span class="line">9.2.2 bitmap.c程序</span><br><span class="line">9.2.3 inode.c程序</span><br><span class="line">9.2.4 super.c程序</span><br><span class="line">9.2.5 namei.c程序</span><br><span class="line">9.2.6 file_table.c程序</span><br><span class="line">9.2.7 block_dev.c程序</span><br><span class="line">9.2.8 file_dev.c程序</span><br><span class="line">9.2.9 pipe.c程序</span><br><span class="line">9.2.10 char_dev.c程序</span><br><span class="line">9.2.11 read_write.c程序</span><br><span class="line">9.2.12 truncate.c程序</span><br><span class="line">9.2.13 open.c程序</span><br><span class="line">9.2.14 exec.c程序</span><br><span class="line">9.2.15 stat.c程序</span><br><span class="line">9.2.16 fcntl.c程序</span><br><span class="line">9.2.17 ioctl.c程序</span><br><span class="line">9.3 本章小结</span><br><span class="line">9.4 习题</span><br><span class="line">第10章 内存管理</span><br><span class="line">10.1 总体功能描述</span><br><span class="line">10.1.1 内存分页管理机制</span><br><span class="line">10.1.2 linux中内存的管理和分配</span><br><span class="line">10.1.3 写时复制机制</span><br><span class="line">10.2 程序分析</span><br><span class="line">10.2.1 memory.c程序</span><br><span class="line">10.2.2 page.s程序</span><br><span class="line">10.3 本章小结</span><br><span class="line">10.4 习题</span><br><span class="line">第11章 包含文件</span><br><span class="line">11.1 程序分析</span><br><span class="line">11.1.1 include&#x2F;目录下的文件</span><br><span class="line">11.1.2 a.out.h文件</span><br><span class="line">11.1.3 const.h文件</span><br><span class="line">11.1.4 ctype.h文件</span><br><span class="line">11.1.5 errno.h文件</span><br><span class="line">11.1.6 fcntl.h文件</span><br><span class="line">11.1.7 signal.h文件</span><br><span class="line">11.1.8 stdarg.h文件</span><br><span class="line">11.1.9 stddef.h文件</span><br><span class="line">11.1.10 string.h文件</span><br><span class="line">11.1.11 termios.h文件</span><br><span class="line">11.1.12 time.h文件</span><br><span class="line">11.1.13 unistd.h文件</span><br><span class="line">11.1.14 utime.h文件</span><br><span class="line">11.1.15 include&#x2F;asm&#x2F;目录下的文件</span><br><span class="line">11.1.16 io.h文件</span><br><span class="line">11.1.17 memory.h文件</span><br><span class="line">11.1.18 segment.h文件</span><br><span class="line">11.1.19 system.h文件</span><br><span class="line">11.1.20 include&#x2F;linux&#x2F;目录下的文件</span><br><span class="line">11.1.21 config.h文件</span><br><span class="line">11.1.22 fdreg.h文件</span><br><span class="line">11.1.23 fs.h文件</span><br><span class="line">11.1.24 hdreg.h文件</span><br><span class="line">11.1.25 head.h文件</span><br><span class="line">11.1.26 kernel.h文件</span><br><span class="line">11.1.27 mm.h文件</span><br><span class="line">11.1.28 sched.h文件</span><br><span class="line">11.1.29 sys.h文件</span><br><span class="line">11.1.30 tty.h文件</span><br><span class="line">11.1.31 include&#x2F;sys&#x2F;目录中的文件</span><br><span class="line">11.1.32 stat.h文件</span><br><span class="line">11.1.33 times.h文件</span><br><span class="line">11.1.34 types.h文件</span><br><span class="line">11.1.35 utsname.h文件</span><br><span class="line">11.1.36 wait.h文件</span><br><span class="line">11.2 本章小结</span><br><span class="line">11.3 习题</span><br><span class="line">第12章 内核库文件</span><br><span class="line">12.1 程序分析</span><br><span class="line">12.1.1 _exit.c程序</span><br><span class="line">12.1.2 close.c程序</span><br><span class="line">12.1.3 ctype.c程序</span><br><span class="line">12.1.4 dup.c程序</span><br><span class="line">12.1.5 errno.c程序</span><br><span class="line">12.1.6 execve.c程序</span><br><span class="line">12.1.7 malloc.c程序</span><br><span class="line">12.1.8 open.c程序</span><br><span class="line">12.1.9 setsid.c程序</span><br><span class="line">12.1.10 string.c程序</span><br><span class="line">12.1.11 wait.c程序</span><br><span class="line">12.1.12 write.c程序</span><br><span class="line">12.2 本章小结</span><br><span class="line">12.3 习题</span><br><span class="line">第13章 内核组建工具</span><br><span class="line">13.1 build.c程序分析</span><br><span class="line">13.2 本章小结</span><br><span class="line">13.3 习题</span><br><span class="line">参考文献</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0011ATTVO/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0011ATTVO&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51X4z4RZCrL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>鸟哥的linux私房菜-服务器架设</title>
    <url>/2020/04/19/niao-ge-de-linuxsi-fang-cai-fu-wu-qi-jia-she/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 鸟哥的linux私房菜-服务器架设<br>作者信息： 作者: 鸟哥 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《鸟哥的Linux私房菜:服务器架设篇(第2版)》适用于各种主流Linux版本，可作为己具有Linux操作系统相关知识的网络系统管理人员的参考手册。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1部分 架站前的进修专区</span><br><span class="line">　第1章 架设之前所需要的技能分析</span><br><span class="line">　第2章 网络基本概念</span><br><span class="line">　第3章 局域网架构简介与linux版本选择</span><br><span class="line">　第4章 连上internet</span><br><span class="line">　第5章 linux常用网络命令</span><br><span class="line">　第6章 linux网络侦错</span><br><span class="line">第2部分 主机的简易防火措施</span><br><span class="line">　第7章 主机基本安全之一：限制linux对外连接端口</span><br><span class="line">　第8章 主机基本安全之二：linux自动在线升级</span><br><span class="line">　第9章 路由器router设置</span><br><span class="line">　第10章 认识网络安全</span><br><span class="line">　第11章 linux防火墙与nat主机</span><br><span class="line">　第12章 申请合法的主机名称</span><br><span class="line">第3部分 局域网与小型企业内各种常见服务器的架设</span><br><span class="line">　第13章 远程联机服务器telnet&#x2F;ssh&#x2F;vnc&#x2F;xdcmp&#x2F;rsh</span><br><span class="line">　第14章 nfs服务器</span><br><span class="line">　第15章 nis服务器</span><br><span class="line">　第16章 dhcp服务器</span><br><span class="line">　第17章 dns服务器</span><br><span class="line">.　第18章 www服务器</span><br><span class="line">　第19章 mail服务器</span><br><span class="line">　第20章 samba服务器</span><br><span class="line">　第21章 vsftpd服务器</span><br><span class="line">　第22章 ntp服务器</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0011FHKO2/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0011FHKO2&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51uy-kzX4ML._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>鸟哥的Linux私房菜-基础学习篇</title>
    <url>/2020/04/19/niao-ge-de-linuxsi-fang-cai-ji-chu-xue-xi-pian/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 鸟哥的Linux私房菜-基础学习篇<br>作者信息： 作者: 鸟哥 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《鸟哥的Linux私房菜:基础学习篇》第二版是最具知名度的Linux入门书《鸟哥的Linux私房菜基础学习篇》的最新版，全面而详细地介绍了Linux操作系统。《鸟哥的Linux私房菜:基础学习篇》分为5个部分：第一部分着重说明Linux的起源及功能，如何规划和安装Linux主机；第二部分介绍Linux的文件系统、文件、目录与磁盘的管理；第三部分介绍文字模式接口shell和管理系统的好帮手shell脚本，另外还介绍了文字编辑器vi和vim的使用方法；第四部分介绍了对于系统安全非常重要的Linux账号的管理，以及主机系统与程序的管理，如查看进程、任务分配和作业管理；第五部分介绍了系统管理员(root)的管理事项，如了解系统运行状况、系统服务，针对登录文件进行解析，对系统进行备份以及核心的管理等。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分　Linux的规则与安装</span><br><span class="line">　第0章　计算机概论　</span><br><span class="line">　第1章　Linux是什么　</span><br><span class="line">　第2章　Linux如何学习　</span><br><span class="line">　第3章　主机规划与磁盘分区　</span><br><span class="line">　第4章　安装CentOS 5.x与多重引导小技巧　</span><br><span class="line">　第5章　首次登录与在线求助man page　</span><br><span class="line">第二部分　Linux文件、目录与磁盘格式</span><br><span class="line">　第6章　Linux的文件权限与目录配置　</span><br><span class="line">　第7章　Linux文件与目录管理　</span><br><span class="line">　第8章　Linux磁盘与文件系统管理　</span><br><span class="line">　第9章　文件与文件系统的压缩与打包　</span><br><span class="line">第三部分　学习shell与shell script</span><br><span class="line">　第10章　vim程序编辑器　</span><br><span class="line">　第11章　认识与学习bash　</span><br><span class="line">　第12章　正则表达式与文件格式化处理　</span><br><span class="line">　第13章　学习shell script　</span><br><span class="line">第四部分　Linux使用者管理</span><br><span class="line">　第14章　Linux账号管理与ACL权限设置　</span><br><span class="line">　第15章　磁盘配额(Quota)与高级文件系统管理　</span><br><span class="line">　第16章　例行性工作(crontab)　</span><br><span class="line">　第17章　程序管理与SELinux初探　</span><br><span class="line">　第18章　认识系统服务(daemons)　</span><br><span class="line">　第19章　认识与分析日志文件　</span><br><span class="line">第五部分　Linux系统管理员</span><br><span class="line">　第20章　启动流程、模块管理与Loader　</span><br><span class="line">　第21章　系统设置工具(网络与打印机)与硬件检测　</span><br><span class="line">　第22章　软件安装：源码与Tarball　</span><br><span class="line">　第23章　软件安装：RPM、SRPM与YUM功能 　</span><br><span class="line">　第24章　X Window设置介绍　</span><br><span class="line">　第25章　Linux备份策略　</span><br><span class="line">　第26章　Linux内核编译与管理　</span><br><span class="line">附录A　快速索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B003TJNO98/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B003TJNO98&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51kbATuMTLL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle核心技术(英文)</title>
    <url>/2020/04/19/oracle-core-essential-internals-for-dbas-and-developers/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Oracle核心技术(英文)<br>作者信息： 作者: Jonathan Lewis [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Oracle资深专家Johnathan Lewis最新力作DBA和开发者必须了解的Oracle核心机制一本令人震撼、让你大开眼界的必读经典本书浓缩了Oracle的核心技术和精华,系统地介绍了数据库性能问题出现的原因以及背后的核心原理,以深入浅出的方式清晰地阐释了如何识别造成瓶颈的原因、如何优化数据库系统、为什么并发会严重降低性能等,是你解决数据库性能问题的必备工具。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章　准备开始　　1</span><br><span class="line">1.1 　Oracle的流程　　1</span><br><span class="line">1.2 　Oracle实战　　4</span><br><span class="line">1.3 　小结　　4</span><br><span class="line">第2章　redo和undo　　5</span><br><span class="line">2.1 　基本数据改变　　5</span><br><span class="line">2.1.1 　数据改变的方法　　6</span><br><span class="line">2.1.2 　示例　　6</span><br><span class="line">2.1.3 　任务报告　　9</span><br><span class="line">2.1.4 　观察总结　　10</span><br><span class="line">2.2 　ACID　　11</span><br><span class="line">2.3 　redo复杂度　　13</span><br><span class="line">2.4 　undo复杂度　　18</span><br><span class="line">2.4.1 　读一致性　　19</span><br><span class="line">2.4.2 　回滚　　19</span><br><span class="line">2.5 　小结　　21</span><br><span class="line">第3章　事务与一致性　　22</span><br><span class="line">3.1 　冲突解决　　22</span><br><span class="line">3.2 　事务与undo　　23</span><br><span class="line">3.2.1 　事务的开始与结束　　24</span><br><span class="line">3.2.2 　事务表　　25</span><br><span class="line">3.2.3 　undo块回顾　　27</span><br><span class="line">3.3 　数据块访问与undo　　30</span><br><span class="line">3.3.1 　设置场景　　30</span><br><span class="line">3.3.2 　事务列表　　31</span><br><span class="line">3.3.3 　并发动作　　33</span><br><span class="line">3.4 　提交SCN　　38</span><br><span class="line">3.4.1 　提交清除　　39</span><br><span class="line">3.4.2 　延迟块清除　　41</span><br><span class="line">3.4.3 　事务表回滚　　44</span><br><span class="line">3.5 　大对象　　48</span><br><span class="line">3.6 　小结　　49</span><br><span class="line">第4章　锁与闩锁　　50</span><br><span class="line">4.1 　事情有先有后　　50</span><br><span class="line">4.1.1 　数组　　50</span><br><span class="line">4.1.2 　指针　　51</span><br><span class="line">4.1.3 　链表　　51</span><br><span class="line">4.1.4 　散列表　　53</span><br><span class="line">4.2 　闩锁　　56</span><br><span class="line">4.2.1 　闩锁背后的逻辑　　56</span><br><span class="line">4.2.2 　闩锁活动统计　　59</span><br><span class="line">4.2.3 　闩锁可扩展性　　63</span><br><span class="line">4.3 　锁　　64</span><br><span class="line">4.3.1 　基础结构　　65</span><br><span class="line">4.3.2 　V$lock的图形展示　　66</span><br><span class="line">4.3.3 　死锁　　69</span><br><span class="line">4.3.4 　锁模式　　72</span><br><span class="line">4.3.5 　保护锁的闩锁　　73</span><br><span class="line">4.3.6 　KGL锁（和pin）　　75</span><br><span class="line">4.3.7 　锁和pin　　75</span><br><span class="line">4.4 　小结　　77</span><br><span class="line">第5章　缓存和复制　　79</span><br><span class="line">5.1 　内存管理　　79</span><br><span class="line">5.1.1 　granule　　80</span><br><span class="line">5.1.2 　granule和缓冲区　　81</span><br><span class="line">5.2 　多个数据块缓存　　83</span><br><span class="line">5.2.1 　granule和缓冲池　　84</span><br><span class="line">5.2.2 　缓冲池　　85</span><br><span class="line">5.3 　工作集　　86</span><br><span class="line">5.4 　LRU&#x2F;TCH算法　　88</span><br><span class="line">5.4.1 　LRU&#x2F;TCH实战　　89</span><br><span class="line">5.4.2 　重新链接缓冲区　　90</span><br><span class="line">5.5 　REPL_AUX　　92</span><br><span class="line">5.6 　查找数据　　94</span><br><span class="line">5.6.1 　pin住缓冲区　　96</span><br><span class="line">5.6.2 　逻辑I&#x2F;O　　98</span><br><span class="line">5.6.3 　更新（update）　　99</span><br><span class="line">5.6.4 　载入散列链　　100</span><br><span class="line">5.6.5 　读一致性拷贝　　100</span><br><span class="line">5.6.6 　物理I&#x2F;O　　101</span><br><span class="line">5.6.7 　表扫描　　102</span><br><span class="line">5.7 　小结　　103</span><br><span class="line">第6章　写入和恢复　　105</span><br><span class="line">6.1 　目标　　105</span><br><span class="line">6.2 　日志写进程　　106</span><br><span class="line">6.2.1 　日志写进程写入　　108</span><br><span class="line">6.2.2 　PL&#x2F;SQL优化　　110</span><br><span class="line">6.2.3 　ACID异常　　113</span><br><span class="line">6.2.4 　提交改进　　113</span><br><span class="line">6.2.5 　过程　　115</span><br><span class="line">6.2.6 　重做日志浪费　　118</span><br><span class="line">6.2.7 　私有重做　　119</span><br><span class="line">6.3 　数据库写进程　　120</span><br><span class="line">6.3.1 　缓冲区头部　　121</span><br><span class="line">6.3.2 　检查点队列　　121</span><br><span class="line">6.3.3 　增量检查点　　123</span><br><span class="line">6.4 　数据库写进程的交互　　124</span><br><span class="line">6.4.1 　数据库写进程与日志写进程　　124</span><br><span class="line">6.4.2 　数据库写进程和LRU　　125</span><br><span class="line">6.4.3 　检查点和队列　　128</span><br><span class="line">6.4.4 　缓冲区头部队列　　132</span><br><span class="line">6.4.5 　检查点和日志文件　　133</span><br><span class="line">6.5 　恢复　　135</span><br><span class="line">6.5.1 　介质恢复　　136</span><br><span class="line">6.5.2 　备用数据库　　137</span><br><span class="line">6.5.3 　闪回数据库　　137</span><br><span class="line">6.5.4 　副作用　　138</span><br><span class="line">6.6 　小结　　139</span><br><span class="line">第7章　解析与优化　　141</span><br><span class="line">7.1 　理解SQL代码　　141</span><br><span class="line">7.1.1 　解析　　141</span><br><span class="line">7.1.2 　优化　　142</span><br><span class="line">7.1.3 　解释tkprof Summaries　　143</span><br><span class="line">7.2 　数据字典缓存　　145</span><br><span class="line">7.2.1 　结构　　149</span><br><span class="line">7.2.2 　数据字典缓存活动　　151</span><br><span class="line">7.3 　什么是解析调用　　154</span><br><span class="line">7.3.1 　Cursor Caching　　155</span><br><span class="line">7.3.2 　持有游标　　157</span><br><span class="line">7.4 　库缓存　　158</span><br><span class="line">7.4.1 　共享池结构　　160</span><br><span class="line">7.4.2 　精妙的共享池结构　　163</span><br><span class="line">7.4.3 　那么，行动吧！　　168</span><br><span class="line">7.5 　解析和优化　　170</span><br><span class="line">7.5.1 　executing、locking和pinning　　173</span><br><span class="line">7.5.2 　互斥锁　　174</span><br><span class="line">7.6 　小结　　175</span><br><span class="line">第8章　RAC及“缺陷”　　176</span><br><span class="line">8.1 　RAC示意图　　177</span><br><span class="line">8.2 　重点是什么　　180</span><br><span class="line">8.2.1 　高可用性　　180</span><br><span class="line">8.2.2 　可扩展性　　181</span><br><span class="line">8.2.3 　网格　　182</span><br><span class="line">8.3 　它如何工作　　183</span><br><span class="line">8.3.1 　全局资源目录　　183</span><br><span class="line">8.3.2 　Master和Shadow　　186</span><br><span class="line">8.3.3 　GCS和GES　　189</span><br><span class="line">8.3.4 　缓存融合　　190</span><br><span class="line">8.3.5 　后果　　193</span><br><span class="line">8.4 　恢复　　195</span><br><span class="line">8.5 　序列　　196</span><br><span class="line">8.5.1 　缓存序列　　197</span><br><span class="line">8.5.2 　深入解析序列　　197</span><br><span class="line">8.5.3 　有序的序列　　199</span><br><span class="line">8.5.4 　序列和索引　　201</span><br><span class="line">8.6 　小结　　203</span><br><span class="line">附录A 　转储与调试　　205</span><br><span class="line">词汇表　　216</span><br><span class="line">索引　　224</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00GNOC9P6/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00GNOC9P6&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51IUcPfylKL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言编程艺术</title>
    <url>/2020/04/19/ryu-yan-bian-cheng-yi-zhu/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： R语言编程艺术<br>作者信息： 作者: 麦特洛夫 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>R是一种用于统计计算与做图的开源软件，同时也是一种编程语言，它广泛应用于企业和学术界的数据分析领域，正在成为最通用的语言之一。由于近几年数据挖掘、大数据等概念的走红，R也越来越多地被人关注。截至本文完成之日，CRAN（http：／／cran。r－project。org／）上共有4383个包，涉及统计、化学、经济、生物、医学、心理、社会学等各个学科。不同类型的公司，比如Google、辉瑞、默克、美国银行、洲际酒店集团和壳牌公司都在使用它，同时以S语言环境为基础的R语言由于其鲜明的特色，一出现就受到了统计专业人士的青睐，成为国外大学里相当标准的统计软件。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">译者序</span><br><span class="line">前言</span><br><span class="line">致谢</span><br><span class="line">第1章 快速入门</span><br><span class="line">1.1 怎样运行R</span><br><span class="line">1.1.1 交互模式</span><br><span class="line">1.1.2 批处理模式</span><br><span class="line">1.2 第一个R会话</span><br><span class="line">1.3 函数入门</span><br><span class="line">1.3.1 变量的作用域</span><br><span class="line">1.3.2 默认参数</span><br><span class="line">1.4 R语言中一些重要的数据结构</span><br><span class="line">1.4.1 向量，R语言中的战斗机</span><br><span class="line">1.4.2 字符串</span><br><span class="line">1.4.3 矩阵</span><br><span class="line">1.4.4 列表</span><br><span class="line">1.4.5 数据框</span><br><span class="line">1.4.6 类</span><br><span class="line">1.5 扩展案例：考试成绩的回归分析</span><br><span class="line">1.6 启动和关闭R</span><br><span class="line">1.7 获取帮助</span><br><span class="line">1.7.1 help（）函数</span><br><span class="line">1.7.2 example（）函数</span><br><span class="line">1.7.3 如果你不太清楚要查找什么</span><br><span class="line">1.7.4 其他主题的帮助</span><br><span class="line">1.7.5 批处理模式的帮助</span><br><span class="line">1.7.6 互联网资源</span><br><span class="line">第2章 向量</span><br><span class="line">2.1 标量、向量、数组与矩阵</span><br><span class="line">2.1.1 添加或删除向量元素</span><br><span class="line">2.1.2 获取向量长度</span><br><span class="line">2.1.3 作为向量的矩阵和数组</span><br><span class="line">2.2 声明</span><br><span class="line">2.3 循环补齐</span><br><span class="line">2.4 常用的向量运算</span><br><span class="line">2.4.1 向量运算和逻辑运算</span><br><span class="line">2.4.2 向量索引</span><br><span class="line">2.4.3 用：运算符创建向量</span><br><span class="line">2.4.4 使用seq（）创建向量</span><br><span class="line">2.4.5 使用rep（）重复向量常数</span><br><span class="line">2.5 使用all（）和any（）</span><br><span class="line">2.5.1 扩展案例：寻找连续出现1的游程</span><br><span class="line">2.5.2 扩展案例：预测离散值时间序列</span><br><span class="line">2.6 向量化运算符</span><br><span class="line">2.6.1 向量输入，向量输出</span><br><span class="line">2.6.2 向量输入，矩阵输出</span><br><span class="line">2.7 NA与NULL值</span><br><span class="line">2.7.1 NA的使用</span><br><span class="line">2.7.2 NULL的使用</span><br><span class="line">2.8 筛选</span><br><span class="line">2.8.1 生成筛选索引</span><br><span class="line">2.8.2 使用subset（）函数筛选</span><br><span class="line">2.8.3 选择函数which（）</span><br><span class="line">2.9 向量化的ifelse（）函数</span><br><span class="line">2.9.1 扩展案例：度量相关性</span><br><span class="line">2.9.2 扩展案例：对鲍鱼数据集重新编码</span><br><span class="line">2.10 测试向量相等</span><br><span class="line">2.11 向量元素的名称</span><br><span class="line">2.12 关于c（）的更多内容</span><br><span class="line">第3章 矩阵和数组</span><br><span class="line">3.1 创建矩阵</span><br><span class="line">3.2 一般矩阵运算</span><br><span class="line">3.2.1 线性代数运算</span><br><span class="line">3.2.2 矩阵索引</span><br><span class="line">3.2.3 扩展案例：图像操作</span><br><span class="line">3.2.4 矩阵元素筛选</span><br><span class="line">3.2.5 扩展案例：生成协方差矩阵</span><br><span class="line">3.3 对矩阵的行和列调用函数</span><br><span class="line">3.3.1 使用apply（）函数</span><br><span class="line">3.3.2 扩展案例：寻找异常值</span><br><span class="line">3.4 增加或删除矩阵的行或列</span><br><span class="line">3.4.1 改变矩阵的大小</span><br><span class="line">3.4.2 扩展案例：找到图中距离最近的一对端点</span><br><span class="line">3.5 向量与矩阵的差异</span><br><span class="line">3.6 避免意外降维</span><br><span class="line">3.7 矩阵的行和列的命名问题</span><br><span class="line">3.8 高维数组</span><br><span class="line">第4章 列表</span><br><span class="line">4.1 创建列表</span><br><span class="line">4.2 列表的常规操作</span><br><span class="line">4.2.1 列表索引</span><br><span class="line">4.2.2 增加或删除列表元素</span><br><span class="line">4.2.3 获取列表长度</span><br><span class="line">4.2.4 扩展案例：文本词汇索引</span><br><span class="line">4.3 访问列表元素和值</span><br><span class="line">4.4 在列表上使用apply系列函数</span><br><span class="line">4.4.1 lapply（）和sapply（）的使用</span><br><span class="line">4.4.2 扩展案例：文本词汇索引（续）</span><br><span class="line">4.4.3 扩展案例：鲍鱼数据</span><br><span class="line">4.5 递归型列表</span><br><span class="line">……</span><br><span class="line">第5章 数据框</span><br><span class="line">第6章 因子和表</span><br><span class="line">第7章 R语言编程结构</span><br><span class="line">第8章 数学运算与模拟</span><br><span class="line">第9章 面向对象的编程</span><br><span class="line">第10章 输入与输出</span><br><span class="line">第11章 字符串操作</span><br><span class="line">第12章 绘图</span><br><span class="line">第13章 调试</span><br><span class="line">第14章 性能提升：速度和内存</span><br><span class="line">第15章 R与其他语言的接口</span><br><span class="line">第16章 R语言并行计算</span><br><span class="line">附录A 安装R</span><br><span class="line">附录B 安装和使用包</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00D5P1JTI/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00D5P1JTI&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51JZno-jjbL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>r语言</tag>
      </tags>
  </entry>
  <entry>
    <title>SEO的艺术 原书第2版</title>
    <url>/2020/04/19/seode-yi-zhu-yuan-shu-di-2ban/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： SEO的艺术 原书第2版<br>作者信息： 作者: 恩吉 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《O’Reilly精品图书系列:SEO的艺术(原书第2版)》由恩吉所著，《O’Reilly精品图书系列:SEO的艺术(原书第2版)》是真正的巨著，作者都是SEO领域的大腕，在SEO顾问、培训以及搜索引擎的理解方面有着胜人一筹的独到观点，而从内容看，《O’Reilly精品图书系列:SEO的艺术(原书第2版)》涵盖了SEO的各个领域，有丰富的实例，不仅详细剖析了不同类型网站在SEO不同阶段的最佳实践，还指出了许多过时以及危险的错误做法，仔细阅读这本书，在了解SEO的正确做法之外，还能够帮助读者远离“黑帽”SEO，实现可持续的网站目标。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">序</span><br><span class="line">前言</span><br><span class="line">第1章 搜索：反映认知、连接商务</span><br><span class="line">1.1 搜索引擎的任务</span><br><span class="line">1.2 搜索引擎的市场份额</span><br><span class="line">1.3 人类搜索的目标</span><br><span class="line">1.4 确定搜索者意图：营销人员和搜索引擎面临的共同挑战</span><br><span class="line">1.5 人们如何搜索</span><br><span class="line">1.6 搜索引擎怎样驱动网络商务</span><br><span class="line">1.7 注意力跟踪：用户如何浏览搜索结果页面</span><br><span class="line">1.8 点击跟踪：用户如何点击自然搜索和付费搜索结果</span><br><span class="line">1.9 结论</span><br><span class="line">第2章 搜索引擎基础</span><br><span class="line">2.1 理解搜索引擎结果</span><br><span class="line">2.2 基于算法的排名系统：爬行、索引和排名</span><br><span class="line">2.3 确定搜索者意图并交付相关、新鲜的内容</span><br><span class="line">2.4 分析排名因素</span><br><span class="line">2.5 使用高级搜索技术</span><br><span class="line">2.6 垂直搜索引擎</span><br><span class="line">2.7 结论</span><br><span class="line">第3章 确定SEO目标，定义网站受众</span><br><span class="line">3.1 SEO从业者所能完成的策略性目标</span><br><span class="line">3.2 每个SEO计划都是量身定制的</span><br><span class="line">3.3 理解搜索引擎流量和用户意图</span><br><span class="line">3.4 在网站开发之前制订SEO计划</span><br><span class="line">3.5 理解受众，寻找合适的定位</span><br><span class="line">3.6 为原始流量开展SEO</span><br><span class="line">3.7 为电子商务开展SEO</span><br><span class="line">3.8 为头脑份额／品牌开展SEO</span><br><span class="line">3.9 为客户挖掘和直接营销开展SEO</span><br><span class="line">3.10 为声誉管理开展SEO</span><br><span class="line">3.11 为意识形态影响力开展SEO</span><br><span class="line">3.12 规划和评估的高级方法</span><br><span class="line">3.13 结论</span><br><span class="line">第4章 SEO的开始阶段</span><br><span class="line">4.1 规划的要素</span><br><span class="line">4.2 确认网站开发过程和参与者</span><br><span class="line">4.3 定义网站信息架构</span><br><span class="line">4.4 审计现有网站，发现SEO问题</span><br><span class="line">4.5 确定当前服务器统计软件并获得权限</span><br><span class="line">4.6 确定主要竞争对手</span><br><span class="line">4.7 评估历史进展</span><br><span class="line">4.8 建立当前索引状态的基准</span><br><span class="line">4.9 建立当前排名基准</span><br><span class="line">4.10 建立当前流量来源和流量的基准</span><br><span class="line">4.11 利用企业资源推动SEO</span><br><span class="line">4.12 整合企业资产和历史数据，进行SEO／网站SWOT分析</span><br><span class="line">4.13 结论</span><br><span class="line">第5章 关键词研究</span><br><span class="line">5.1 策略性的考虑</span><br><span class="line">5.2 理解关键词需求曲线的长尾</span><br><span class="line">5.3 传统方法：行业专门知识，网站内容分析</span><br><span class="line">5.4 关键词研究工具</span><br><span class="line">5.5 确定关键词价值／潜在的ROI</span><br><span class="line">5.6 利用关键词需求的长尾</span><br><span class="line">5.7 结论</span><br><span class="line">第6章 开发SEO友好的网站</span><br><span class="line">6.1 让搜索引擎能够访问你的网站</span><br><span class="line">6.2 创建最优的信息架构</span><br><span class="line">6.3 根域、子域和微型网站</span><br><span class="line">6.4 域名／URL优化</span><br><span class="line">6.5 关键词定位</span><br><span class="line">6.6 内容优化</span><br><span class="line">6.7 重复内容问题</span><br><span class="line">6.8 用Cookie和会话ID控制内容</span><br><span class="line">6.9 内容交互和搜索蜘蛛控制</span><br><span class="line">6.10 重定向</span><br><span class="line">6.11 CMS问题</span><br><span class="line">6.12 多语言／国家定位的最佳实践</span><br><span class="line">6.13 结论</span><br><span class="line">第7章 创建值得链接的内容和链接营销</span><br><span class="line">7.1 链接如何影响搜索引擎排名</span><br><span class="line">7.2 深入探讨搜索引擎评判链接的方法</span><br><span class="line">7.3 链接心理学</span><br><span class="line">7.4 链接建设类型</span><br><span class="line">7.5 选择正确的链接建设策略</span><br><span class="line">7.6 基于内容的链接获取的更多方法</span><br><span class="line">7.7 基于利益的链接营销</span><br><span class="line">7.8 搜索引擎如何与链接垃圾交锋</span><br><span class="line">7.9 通过社会化网络得到链接</span><br><span class="line">7.10 结论</span><br><span class="line">第8章 社会化媒体和用户数据在搜索结果与排名中所起的作用</span><br><span class="line">8.1 为什么依靠社会化信号</span><br><span class="line">8.2 直接影响搜索结果的社会化信号</span><br><span class="line">8.3 社会化媒体营销的间接影响</span><br><span class="line">8.4 监控、度量和改进社会化媒体营销</span><br><span class="line">8.5 作为搜索质量度量指标的用户交互</span><br><span class="line">8.6 文档分析</span><br><span class="line">8.7 优化用户体验以改进SEO</span><br><span class="line">8.8 其他社会化媒体资源</span><br><span class="line">8.9 结论</span><br><span class="line">第9章 优化垂直搜索</span><br><span class="line">9.1 垂直搜索中的机会</span><br><span class="line">9.2 为本地搜索进行优化</span><br><span class="line">9.3 优化产品搜索</span><br><span class="line">9.4 优化新闻、博客和源搜索</span><br><span class="line">9.5 其他：移动、视频／多媒体搜索</span><br><span class="line">9.6 结论</span><br><span class="line">第10章 跟踪结果与度量成功</span><br><span class="line">10.1 为什么度量成功对SEO过程不可或缺</span><br><span class="line">10.2 度量搜索流量</span><br><span class="line">10.3 将SEO与转化和ROI联系起来</span><br><span class="line">10.4 竞争性和诊断搜索指标</span><br><span class="line">10.5 长尾SEO的关键绩效指标</span><br><span class="line">10.6 跟踪重复内容</span><br><span class="line">10.7 其他第三方工具</span><br><span class="line">10.8 结论</span><br><span class="line">第11章 域更改、SEO后再设计以及故障诊断</span><br><span class="line">11.1 内容移动基础</span><br><span class="line">11.2 在网站重新设计期间和之后维持搜索引擎可见性</span><br><span class="line">11.3 在域名更改期间和之后维持搜索引擎可见性</span><br><span class="line">11.4 更换服务器</span><br><span class="line">11.5 隐藏内容</span><br><span class="line">11.6 垃圾过滤和惩罚</span><br><span class="line">11.7 内容剽窃</span><br><span class="line">11.8 更换SEO供应商或者团队成员</span><br><span class="line">11.9 结论</span><br><span class="line">第12章 SEO调查和研究</span><br><span class="line">12.1 SEO调查和分析</span><br><span class="line">12.2 不同搜索引擎和搜索类型的算法差异分析</span><br><span class="line">12.3 竞争分析</span><br><span class="line">12.4 使用搜索引擎提供的SEO工具</span><br><span class="line">12.5 Web上的SEO行业</span><br><span class="line">12.6 参加会议和组织</span><br><span class="line">12.7 结论</span><br><span class="line">第13章 建立内部SEO团队、外包还是两者皆可</span><br><span class="line">13.1 SEO的任务</span><br><span class="line">13.2 使用内部人才和外包带来的活力与挑战</span><br><span class="line">13.3 网站复杂性对SEO工作量的影响</span><br><span class="line">13.4 小型机构的解决方案</span><br><span class="line">13.5 大型机构的解决方案</span><br><span class="line">13.6 雇用SEO人才</span><br><span class="line">13.7 与外部专家合作的情况</span><br><span class="line">13.8 选择SEO公司／顾问</span><br><span class="line">13.9 组合外包SEO和内部SEO团队</span><br><span class="line">13.10 在机构中建立SEO文化</span><br><span class="line">13.11 结论</span><br><span class="line">第14章 进化中的艺术形式：SEO的未来</span><br><span class="line">14.1 搜索的持续演变</span><br><span class="line">14.2 更多搜索内容和内容类型</span><br><span class="line">14.3 个性化、本地化和用户对搜索的影响</span><br><span class="line">14.4 本地、移动和语言识别搜索越来越重要</span><br><span class="line">14.5 市场饱和度和竞争加剧</span><br><span class="line">14.6 SEO是持久的艺术形式</span><br><span class="line">14.7 结论</span><br><span class="line">术语表</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00D2ID5L8/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00D2ID5L8&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41e8M6PjVYL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala编程</title>
    <url>/2020/04/19/scalabian-cheng/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Scala编程<br>作者信息： 作者: Martin Odersky [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Scala编程》经过精心编排以方便读者学习。开始的几章会有足够的基本知识做铺垫，让你能够立即上手用Scala实现简单的任务。全书经过组织，使每个新概念都建立于先前的概念之上-通过一系列的步骤确保帮助你掌握Scala语言及其所体现的重要编程理念。<br>作为Scala的综合教程和参考，《Scala编程》覆盖了语言的全部内容及重要的库。你将学到如何：用Scala编写脚本和系统从Scala调用、Java标准库使用Scala的面向对象特性以函数式风格编程使用Scala的集合库使用特质和混入做设计设计内嵌领域特定语言（DSL）受益于模式匹配利用函数和闭包创建新的控制抽象通过单元测试确保质量用actor编写并行程序<br>由Scala语言的设计者共同执笔，这本权威书籍将逐步引导你学习Scala语言及其背后的思想。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">图示清单</span><br><span class="line">表格清单</span><br><span class="line">代码清单</span><br><span class="line">序</span><br><span class="line">致谢</span><br><span class="line">简介</span><br><span class="line">第1章 可伸展的语言</span><br><span class="line">第2章 Scala入门初探</span><br><span class="line">第3章 Scala入门再探</span><br><span class="line">第4章 类和对象</span><br><span class="line">第5章 基本类型和操作</span><br><span class="line">第6章 函数式对象</span><br><span class="line">第7章 内建控制结构</span><br><span class="line">第8章 函数和闭包</span><br><span class="line">第9章 控制抽象</span><br><span class="line">第10章 组合与继承</span><br><span class="line">第11章 Scala的层级</span><br><span class="line">第12章 特质</span><br><span class="line">第13章 包和引用</span><br><span class="line">第14章 断言和单元测试</span><br><span class="line">第15章 样本类和模式匹配</span><br><span class="line">第16章 使用列表</span><br><span class="line">第17章 集合类型</span><br><span class="line">第18章 有状态的对象</span><br><span class="line">第19章 类型参数化</span><br><span class="line">第20章 抽象成员</span><br><span class="line">第21章 隐式转换和参数</span><br><span class="line">第22章 实现列表</span><br><span class="line">第23章 重访For表达式</span><br><span class="line">第24章 抽取器(Extractors)</span><br><span class="line">第25章 注解</span><br><span class="line">第26章 使用XML</span><br><span class="line">第27章 使用对象的模块化编程</span><br><span class="line">第28章 对象相等性</span><br><span class="line">第29章 结合Scala和Java</span><br><span class="line">第30章 Actor和并发</span><br><span class="line">第31章 连结符解析</span><br><span class="line">第32章 GUI编程</span><br><span class="line">第33章 Scell试算表</span><br><span class="line">附录AUnix和Windows的Scala脚本</span><br><span class="line">术语表</span><br><span class="line">参考文献</span><br><span class="line">关于作者</span><br><span class="line">索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B004EF4TEK/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B004EF4TEK&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51z0sn6jr0L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title>了不起的Node.js:将JavaScript进行到底(英文)</title>
    <url>/2020/04/19/smashing-node-js-javascript-everywhere/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 了不起的Node.js:将JavaScript进行到底(英文)<br>作者信息： 作者: Guillermo Rauch [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Node.js是一个由JavaScript书写而成的强大的web开发框架，它让开发强壮的、伸缩性良好的服务端web应用变得更加简单，容易。本书向你展示了什么是Node以及如何让你在项目中使用它。本书包含大量实际应用中的示例程序，证明了为什么Node.js会快速成为web开发首选工具的原因，通过本书，你能够快速熟悉和掌握达到如下目标所需的Node知识和技能：<br>了解Node基于事件轮询的架构、无阻塞IO以及事件驱动的编程方式<br>精通Node.js的API<br>轻松实现开发实时应用相关的技术，如SOCKET.IO和HTML5 WEBSOCKETS<br>编写能够支持跨多台服务器的高并发应用<br>通过Node来支持多种数据库以及数据存储工具<br>编写在单台服务器情况下能够处理万级并发量的程序<br>能够在一个包含更多Node知识和注解示例（含源代码）的网站上和其他开发者进行实时地沟通交流<br>本书包含大量全彩插图和实用的源代码，绝对是一本革命性web开发工具——Node的实用指南。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PART Ⅰ　从安装与概念开始</span><br><span class="line">CHAPTER 1　安装……………………………………….. 3</span><br><span class="line">在Windows下安装……………………………………….. 3</span><br><span class="line">在OS.X下安装. ………………………………………… 4</span><br><span class="line">在Linux下安装…………………………………………. 5</span><br><span class="line">编译. ……………………………………………………5</span><br><span class="line">确保安装成功. ………………………………………..5</span><br><span class="line">Node.REPL…………………………………………. 5</span><br><span class="line">执行文件…………………………………………………. 6</span><br><span class="line">NPM……………………………………………………….. 6</span><br><span class="line">安装模块…………………………………………………..7</span><br><span class="line">自定义模块. ……………………………………………….8</span><br><span class="line">安装二进制工具包. …………………………………………..9</span><br><span class="line">浏览NPM仓库. ……………………………………………….9</span><br><span class="line">小结……………………………………………………….. 10</span><br><span class="line">CHAPTER 2　JavaScript概览…………………………………..11</span><br><span class="line">介绍…………………………………………………. 11</span><br><span class="line">JavaScript基础…………………………………………….. 12</span><br><span class="line">类型. ………………………………………………… 12</span><br><span class="line">类型的困惑. ……………………………………….. 12</span><br><span class="line">函数. …………………………………………………. 13</span><br><span class="line">THIS、FUNCTION #CALL以及FUNCTION#APPLY……………….. 14</span><br><span class="line">函数的参数数量. ……………………… 14</span><br><span class="line">闭包. ……………………………………………….. 14</span><br><span class="line">类. …………………………………………………….. 15</span><br><span class="line">继承. …………………………………………….. 16</span><br><span class="line">TRY.&#123;&#125;.CATCH.&#123;&#125;……………………………….. 17</span><br><span class="line">v8中的JavaScript…………………………. 17</span><br><span class="line">OBJECT#KEYS………………………………………………. 18</span><br><span class="line">ARRAY#ISARRAY………………………………………… 18</span><br><span class="line">数组方法…………………………………………. 18</span><br><span class="line">字符串方法.. ……………………………………………. 19</span><br><span class="line">JSON……………………………………………………. 19</span><br><span class="line">FUNCTION#BIND………………………………………………. 19</span><br><span class="line">FUNCTION#NAME………………………………………. 19</span><br><span class="line">PROTO（继承）. …………………………………….. 20</span><br><span class="line">存取器………………………………………………. 20</span><br><span class="line">小结…………………………………………………….. 21</span><br><span class="line">CHAPTER ３　阻塞与非阻塞IO…………………………… 23</span><br><span class="line">能力越强，责任就越大…………………………………………. 23</span><br><span class="line">阻塞. ……………………………………………………. 25</span><br><span class="line">单线程的世界. ……………………………………….. 27</span><br><span class="line">错误处理…………………………………………….. 29</span><br><span class="line">堆栈追踪………………………………………… 30</span><br><span class="line">小结……………………………………………………… 32</span><br><span class="line">CHAPTER 4　Node中的JavaScript ………………………………. 33</span><br><span class="line">global对象………………………………………………. 33</span><br><span class="line">实用的全局对象. ………………………………………… 34</span><br><span class="line">模块系统…………………………………………………… 34</span><br><span class="line">绝对和相对模块. ………………………………………….. 35</span><br><span class="line">暴露API. ……………………………………………………… 37</span><br><span class="line">事件………………………………………………… 38</span><br><span class="line">buffer……………………………………………………… 40</span><br><span class="line">小结…………………………………………………………. 41</span><br><span class="line">PART Ⅱ　Node重要的API</span><br><span class="line">CHAPTER 5　命令行工具（CLI）以及FS API：首个Node应用………………. 45</span><br><span class="line">需求…………………………………………. 45</span><br><span class="line">编写首个Node程序……………………………….. 46</span><br><span class="line">创建模块………………………………………. 46</span><br><span class="line">同步还是异步. ………………………. 47</span><br><span class="line">理解什么是流（stream）…………………………….. 49</span><br><span class="line">输入和输出. …………………………………………………. 50</span><br><span class="line">重构. …………………………………. 53</span><br><span class="line">用fs进行文件操作. ………………………… 55</span><br><span class="line">对CLI一探究竟. …………………………………………. 56</span><br><span class="line">argv……………………………………………. 57</span><br><span class="line">工作目录……………………………….. 57</span><br><span class="line">环境变量……………………………………. 58</span><br><span class="line">退出. ……………………………………….. 58</span><br><span class="line">信号. …………………………………………………. 58</span><br><span class="line">ANSI转义码…………………………………….. 59</span><br><span class="line">对fs一探究竟. …………………………………………. 59</span><br><span class="line">Stream………………………………………………… 59</span><br><span class="line">监视. …………………………………… 60</span><br><span class="line">小结……………………………………………… 61</span><br><span class="line">CHAPTER 6　TCP ……………………………………. 63</span><br><span class="line">TCP有哪些特性. …………………………………………….. 64</span><br><span class="line">面向连接的通信和保证顺序的传递. ……………………… 64</span><br><span class="line">面向字节…………………………………. 65</span><br><span class="line">可靠性……………………………………….. 65</span><br><span class="line">流控制………………………………….. 65</span><br><span class="line">拥堵控制………………………………………. 65</span><br><span class="line">Telnet………………………………………………………. 65</span><br><span class="line">基于TCP的聊天程序……………………………………….. 68</span><br><span class="line">创建模块………………………………. 68</span><br><span class="line">理解NET.SERVER.API…………………… 68</span><br><span class="line">接收连接………………………………… 70</span><br><span class="line">data事件. ……………………………………………… 71</span><br><span class="line">状态以及记录连接情况. …………………………………. 73</span><br><span class="line">圆满完成此程序. …………………………………….. 75</span><br><span class="line">一个IRC客户端程序…………………………………… 77</span><br><span class="line">创建模块………………………………………. 77</span><br><span class="line">理解NET#STREAM.API.. ………………………………….. 78</span><br><span class="line">实现部分IRC协议. ………………………………………….. 78</span><br><span class="line">测试实际的IRC服务器. ……………………………. 78</span><br><span class="line">小结……………………………………………………….. 79</span><br><span class="line">CHAPTER 7　HTTP ………………………………………….. 81</span><br><span class="line">HTTP结构………………………………………………… 81</span><br><span class="line">头信息. ……………………………………………… 82</span><br><span class="line">连接…………………………………………………….. 87</span><br><span class="line">一个简单的Web服务器………………………………………….. 88</span><br><span class="line">创建模块………………………………… 88</span><br><span class="line">输出表单……………………………………………. 88</span><br><span class="line">method和URL. ……………………………………. 90</span><br><span class="line">数据. ………………………………………. 92</span><br><span class="line">整合. ………………………………………… 94</span><br><span class="line">让程序更健壮. ………………………………. 95</span><br><span class="line">一个Twitter.Web客户端………………………………….. 96</span><br><span class="line">创建模块………………………………… 96</span><br><span class="line">发送一个简单的HTTP请求. …………………. 97</span><br><span class="line">发送数据………………………………….. 98</span><br><span class="line">获取推文…………………………………………. 99</span><br><span class="line">superagent来拯救………………………………………. 102</span><br><span class="line">使用up重启HTTP服务器………………………………. 103</span><br><span class="line">小结……………………………………… 104</span><br><span class="line">PART Ⅲ　Web开发</span><br><span class="line">CHAPTER 8　Connect ………………………… 107</span><br><span class="line">使用HTTP构建一个简单的网站. ………………………………… 108</span><br><span class="line">通过Connect实现一个简单的网站……………………………….. 111</span><br><span class="line">中间件. …………………………………………. 112</span><br><span class="line">书写可重用的中间件. …………………….114</span><br><span class="line">static中间件. ………………………………………119</span><br><span class="line">query中间件. …………………………………120</span><br><span class="line">logger中间件…………………………………………… 120</span><br><span class="line">body.parser中间件. ……………………………122</span><br><span class="line">cookie…………………………………………………125</span><br><span class="line">会话（session）. ………………………………..126</span><br><span class="line">Redis.session…………………………………………..131</span><br><span class="line">methodOverride中间件. ………………………132</span><br><span class="line">basicAuth中间件. ………………………………..132</span><br><span class="line">小结…………………………………………………….. 134</span><br><span class="line">CHAPTER 9　Express…………………………………………..135</span><br><span class="line">一个小型Express应用. ……………………………….. 135</span><br><span class="line">创建模块……………………………………….136</span><br><span class="line">HTML…………………………………………………..136</span><br><span class="line">SETUP………………………………………………….137</span><br><span class="line">定义路由……………………………………..137</span><br><span class="line">查询. ………………………………………….140</span><br><span class="line">运行. ……………………………………………..141</span><br><span class="line">设置………………………………………………… 142</span><br><span class="line">模板引擎……………………………………………… 143</span><br><span class="line">错误处理……………………………………………….. 144</span><br><span class="line">快捷方法…………………………………………. 144</span><br><span class="line">路由………………………………………… 146</span><br><span class="line">中间件. ……………………………………………. 148</span><br><span class="line">代码组织策略. ………………………………….. 149</span><br><span class="line">小结…………………………………………. 151</span><br><span class="line">CHAPTER 10　WebSocket ……………… 153</span><br><span class="line">Ajax………………………………………. 153</span><br><span class="line">HTML5.WebSocket……………………………………….. 156</span><br><span class="line">一个ECHO示例. ………………………………………………… 157</span><br><span class="line">初始化项目. ………………………………………157</span><br><span class="line">建立服务器. …………………………………………..158</span><br><span class="line">建立客户端. ………………………………..159</span><br><span class="line">运行示例程序. ……………………………..160</span><br><span class="line">鼠标光标…………………………………… 161</span><br><span class="line">初始化示例程序. …………………………………..161</span><br><span class="line">建立服务器. ……………………………………..161</span><br><span class="line">建立客户端. ……………………………….164</span><br><span class="line">运行示例程序. …………………………………..166</span><br><span class="line">面临一个挑战. ……………………………………… 166</span><br><span class="line">关闭并不意味着断开连接. ………………………..166</span><br><span class="line">JSON…………………………………….167</span><br><span class="line">重连. ……………………………………………167</span><br><span class="line">广播. …………………………………………167</span><br><span class="line">WebSocket属于HTML5：早期浏览器不支持. ……………………..167</span><br><span class="line">解决方案………………………………………….167</span><br><span class="line">小结……………………………………………………. 167</span><br><span class="line">CHAPTER 11　Socket.IO………………………………………169</span><br><span class="line">传输…………………………………………. 170</span><br><span class="line">断开.VS.关闭. ……………………………………..170</span><br><span class="line">事件. ……………………………………170</span><br><span class="line">命名空间……………………………………….171</span><br><span class="line">聊天程序…………………………………………. 172</span><br><span class="line">初始化程序. …………………………………172</span><br><span class="line">构建服务器. ……………………………………172</span><br><span class="line">构建客户端. …………………………………173</span><br><span class="line">事件和广播. ………………………………….175</span><br><span class="line">消息接收确认. ……………………………179</span><br><span class="line">一个轮流做DJ的应用………………………….. 180</span><br><span class="line">扩展聊天应用. …………………………………….181</span><br><span class="line">集成Grooveshark.API. ………………………….182</span><br><span class="line">播放歌曲………………………………………..185</span><br><span class="line">小结……………………………………………. 190</span><br><span class="line">PART Ⅳ　数据库</span><br><span class="line">CHAPTER 12　MongoDB…………………..193</span><br><span class="line">安装………………………………………….. 195</span><br><span class="line">使用MongoDB：一个用户认证的例子. ……………………………. 195</span><br><span class="line">构建应用程序. …………………………………195</span><br><span class="line">创建Express.App.. …………………………196</span><br><span class="line">连接MongoDB. ……………………………..200</span><br><span class="line">创建文档………………………………..201</span><br><span class="line">查找文档…………………………….203</span><br><span class="line">身份验证中间件. …………………………….204</span><br><span class="line">校验.. ……………………………………….205</span><br><span class="line">原子性……………………………………….206</span><br><span class="line">安全模式…………………………..206</span><br><span class="line">Mongoose介绍………………………………….. 206</span><br><span class="line">定义模型………………………………….207</span><br><span class="line">定义嵌套的键. ……………………..208</span><br><span class="line">定义嵌套文档. ……………………………….209</span><br><span class="line">构建索引……………………………………209</span><br><span class="line">中间件………………………………………….209</span><br><span class="line">探测模型状态.. ………………………….210</span><br><span class="line">查询. ……………………………………….210</span><br><span class="line">扩展查询………………………………….210</span><br><span class="line">排序.. ………………………………….211</span><br><span class="line">选择. ………………………………………………211</span><br><span class="line">限制.. ……………………………….211</span><br><span class="line">跳过. …………………………………..211</span><br><span class="line">自动产生键. ………………………….211</span><br><span class="line">转换. ……………………………………….212</span><br><span class="line">一个使用Mongoose的例子…………………………………. 212</span><br><span class="line">构建应用……………………………212</span><br><span class="line">重构. …………………………213</span><br><span class="line">建立模型……………………………213</span><br><span class="line">小结…………………………………… 215</span><br><span class="line">CHAPTER 13　MySQL…………………………………….217</span><br><span class="line">node-mysql…………………………………. 217</span><br><span class="line">初始化项目. …………………………………217</span><br><span class="line">Express应用. ……………………………..218</span><br><span class="line">连接MySQL. ……………………………….219</span><br><span class="line">初始化脚本. …………………………………220</span><br><span class="line">创建数据…………………………………………224</span><br><span class="line">获取数据……………………………….228</span><br><span class="line">sequelize…………………………………….. 229</span><br><span class="line">初始化sequelize. …………………………..230</span><br><span class="line">初始化Express应用. ………………………………230</span><br><span class="line">连接sequelize. …………………….233</span><br><span class="line">定义模型和同步. ……………………… 234</span><br><span class="line">创建数据……………………………236</span><br><span class="line">获取数据………………………………..238</span><br><span class="line">删除数据…………………………239</span><br><span class="line">完整地完成应用. ………………………….240</span><br><span class="line">小结…………………………………… 241</span><br><span class="line">CHAPTER 14　Redis………………………………….. 243</span><br><span class="line">安装Redis……………………………………….. 244</span><br><span class="line">Redis查询语言. ……………………………………….. 245</span><br><span class="line">数据类型……………………………………… 245</span><br><span class="line">字符串. ……………………………..246</span><br><span class="line">哈希. ………………………………………….246</span><br><span class="line">列表. ………………………………….. 248</span><br><span class="line">数据集. ……………………………….249</span><br><span class="line">有序数据集. …………………………………..249</span><br><span class="line">Redis和Node. …………………………………… 249</span><br><span class="line">使用node-redis实现一个社交图谱. ………….250</span><br><span class="line">小结………………………………….. 259</span><br><span class="line">PART Ⅴ　测试</span><br><span class="line">CHAPTER 15　代码共享 …………………………… 263</span><br><span class="line">什么样的代码可以共享……………………………………. 263</span><br><span class="line">书写兼容的JavaScript代码………………………….. 264</span><br><span class="line">导出模块………………………………………………264</span><br><span class="line">模拟实现ECMA.API. …………………………..265</span><br><span class="line">模拟实现Node.API. ………………………………..267</span><br><span class="line">模拟实现浏览器端API. ………………………….267</span><br><span class="line">跨浏览器的继承实现. ………………………268</span><br><span class="line">集成到一起：browserbuild. …………………. 268</span><br><span class="line">基础案例………………………………269</span><br><span class="line">小结………………………………….. 271</span><br><span class="line">CHAPTER 16　测试…………………………….. 273</span><br><span class="line">简单测试…………………………………. 273</span><br><span class="line">测试目标……………………………………… 274</span><br><span class="line">测试策略…………………………….. 274</span><br><span class="line">测试程序……………………………………………275</span><br><span class="line">expect.js…………………………………………. 276</span><br><span class="line">API一览. …………………………………..276</span><br><span class="line">Mocha…………………………………………. 278</span><br><span class="line">测试异步代码. …………………………….279</span><br><span class="line">BDD风格. …………………………..281</span><br><span class="line">TDD风格. …………………………………281</span><br><span class="line">export风格. ……………………………282</span><br><span class="line">在浏览器端使用Mocha. ……………………………..282</span><br><span class="line">小结……………………………… 284</span><br><span class="line">索引 ……………………………….. 285</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00GI7EO6U/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00GI7EO6U&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/518Fb1wgAeL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Web之困：现代Web应用安全指南(英文)</title>
    <url>/2020/04/19/the-tangled-web-a-guide-to-securing-modern-web-applications/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Web之困：现代Web应用安全指南(英文)<br>作者信息： 作者: Michal Zalewski [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>“Thorough and comprehensive coverage from one of the foremost experts in browser security.” -Tavis Ormandy, Google Inc. Modern web applications are built on a tangle of technologies that have been developed over time and then haphazardly pieced together. Every piece of the web application stack, from HTTP requests to browser-side scripts, comes with important yet subtle security consequences. To keep users safe, it is essential for developers to confidently navigate this landscape. In The Tangled Web, Michal Zalewski, one of the world’s top browser security experts, offers a compelling narrative that explains exactly how browsers work and why they’re fundamentally insecure. Rather than dispense simplistic advice on vulnerabilities, Zalewski examines the entire browser security model, revealing weak points and providing crucial information for shoring up web application security. You’ll learn how to: * Perform common but surprisingly complex tasks such as URL parsing and HTML sanitization * Use modern security features like Strict Transport Security, Content Security Policy, and Cross-Origin Resource Sharing * Leverage many variants of the same-origin policy to safely compartmentalize complex web applications and protect user credentials in case of XSS bugs * Build mashups and embed gadgets without getting stung by the tricky frame navigation policy * Embed or host user-supplied content without running into the trap of content sniffing For quick reference, “Security Engineering Cheat Sheets” at the end of each chapter offer ready solutions to problems you’re most likely to encounter. With coverage extending as far as planned HTML5 features, The Tangled Web will help you create secure web applications that stand the test of time.</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Preface ………………………………………………………………………………………………………..xvii</span><br><span class="line">Chapter 1: Security in the World of Web Applications ………………………………………………..1</span><br><span class="line">PART I: ANATOMY OF THE WEB …………………………………………………………………. 21</span><br><span class="line">Chapter 2: It Starts with a URL …………………………………………………………………………….23</span><br><span class="line">Chapter 3: Hypertext Transfer Protocol ………………………………………………………………….41</span><br><span class="line">Chapter 4: Hypertext Markup Language ………………………………………………………………. 69</span><br><span class="line">Chapter 5: Cascading Style Sheets ………………………………………………………………………87</span><br><span class="line">Chapter 6: Browser-Side Scripts …………………………………………………………………………..95</span><br><span class="line">Chapter 7: Non-HTML Document Types ……………………………………………………………….117</span><br><span class="line">Chapter 8: Content Rendering with Browser Plug-ins………………………………………………..127</span><br><span class="line">PART II: BROWSER SECURITY FEATURES ……………………………………………………… 139</span><br><span class="line">Chapter 9: Content Isolation Logic ……………………………………………………………………..141</span><br><span class="line">Chapter 10: Origin Inheritance………………………………………………………………………….165</span><br><span class="line">Chapter 11: Life Outside Same-Origin Rules ………………………………………………………….173</span><br><span class="line">Chapter 12: Other Security Boundaries ……………………………………………………………….187</span><br><span class="line">Chapter 13: Content Recognition Mechanisms……………………………………………………….197</span><br><span class="line">Chapter 14: Dealing with Rogue Scripts ………………………………………………………………213</span><br><span class="line">Chapter 15: Extrinsic Site Privileges ……………………………………………………………………225</span><br><span class="line">PART III: A GLIMPSE OF THINGS TO COME ………………………………………………….. 233</span><br><span class="line">Chapter 16: New and Upcoming Security Features …………………………………………………235</span><br><span class="line">Chapter 17: Other Browser Mechanisms of Note ……………………………………………………255</span><br><span class="line">Chapter 18: Common Web Vulnerabilities……………………………………………………………261</span><br><span class="line">Epilogue ……………………………………………………………………………………………………..267</span><br><span class="line">Notes …………………………………………………………………………………………………………269</span><br><span class="line">Index ………………………………………………………………………………………………………….283</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/1593273886/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=1593273886&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/516vnTrKJJL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>unix网络编程第一卷</title>
    <url>/2020/04/19/unixwang-luo-bian-cheng/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： unix网络编程第一卷<br>作者信息： 作者: 史蒂文斯 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《UNIX网络编程(卷1):套接字联网API(第3版)》全面深入地介绍了如何使用套接字API进行网络编程。全书不但介绍了基本编程内容，还涵盖了与套接字编程相关的高级主题，对于客户/服务器程序的各种设计方法也作了完整的探讨，最后还深入分析了流这种设备驱动机制。<br>《UNIX网络编程(卷1):套接字联网API(第3版)》内容详尽且具权威性，几乎每章都提供精选的习题，并提供了部分习题的答案，是网络研究和开发人员理想的参考书。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分 简介和TCP&#x2F;IP</span><br><span class="line">第1章 简介 2</span><br><span class="line">1.1 概述 2</span><br><span class="line">1.2 一个简单的时间获取客户程序 5</span><br><span class="line">1.3 协议无关性 9</span><br><span class="line">1.4 错误处理：包裹函数 10</span><br><span class="line">1.5 一个简单的时间获取服务器程序 12</span><br><span class="line">1.6 本书中客户&#x2F;服务器程序示例索引表 14</span><br><span class="line">1.7 OSI模型 16</span><br><span class="line">1.8 BSD网络支持历史 17</span><br><span class="line">1.9 测试用网络及主机 19</span><br><span class="line">1.10 Unix标准 22</span><br><span class="line">1.11 64位体系结构 24</span><br><span class="line">1.12 小结 25</span><br><span class="line">习题 25 </span><br><span class="line"></span><br><span class="line"> 第2章 传输层：TCP、UDP和SCTP 27 2.1 概述 27 2.2 总图 27 2.3 用户数据报协议（UDP） 29 2.4 传输控制协议（TCP） 30 .2.5 流控制传输协议（SCTP） 31 2.6 TCP连接的建立和终止 31 2.7 TIME_WAIT状态 37 2.8 SCTP关联的建立和终止 38 2.9 端口号 42 2.10 TCP端口号与并发服务器 43 2.11 缓冲区大小及限制 45 2.12 标准因特网服务 50 2.13 常见因特网应用的协议使用 51 2.14 小结 52 习题 53</span><br><span class="line"></span><br><span class="line"> 第二部分 基本套接字编程 第3章 套接字编程简介 56 3.1 概述 56 3.2 套接字地址结构 56 3.3 值-结果参数 61 3.4 字节排序函数 63 3.5 字节操纵函数 66 3.6 inet_aton、inet_addr和inet_ntoa函数 67 3.7 inet_pton和inet_ntop函数 68 3.8 sock_ntop和相关函数 70 3.9 readn、writen和readline函数 72 3.10 小结 76 习题 76</span><br><span class="line"></span><br><span class="line"> 第4章 基本TCP套接字编程 77 4.1 概述 77 4.2 socket函数 77 4.3 connect函数 80 4.4 bind函数 81 4.5 listen函数 84 4.6 accept函数 88 4.7 fork和exec函数 90 4.8 并发服务器 91 4.9 close函数 93 4.10 getsockname和getpeername函数 94 4.11 小结 96 习题 96</span><br><span class="line"></span><br><span class="line"> 第5章 TCP客户&#x2F;服务器程序示例 97 5.1 概述 97 5.2 TCP回射服务器程序：main函数 97 5.3 TCP回射服务器程序：str_echo函数 98 5.4 TCP回射客户程序：main函数 99 5.5 TCP回射客户程序：str_cli函数 100 5.6 正常启动 101 5.7 正常终止 102 5.8 POSIX信号处理 103 5.9 处理SIGCHLD信号 106 5.10 wait和waitpid函数 108 5.11 accept返回前连接中止 111 5.12 服务器进程终止 112 5.13 SIGPIPE信号 113 5.14 服务器主机崩溃 114 5.15 服务器主机崩溃后重启 115 5.16 服务器主机关机 116 5.17 TCP程序例子小结 116 5.18 数据格式 117 5.19 小结 120 习题 120</span><br><span class="line"></span><br><span class="line"> 第6章 I&#x2F;O复用：select和poll函数 122 6.1 概述 122 6.2 I&#x2F;O模型 122 6.3 select函数 127 6.4 str_cli函数（修订版） 132 6.5 批量输入 133 6.6 shutdown函数 136 6.7 str_cli函数（再修订版） 137 6.8 TCP回射服务器程序（修订版） 138 6.9 pselect函数 142 6.10 poll函数 144 6.11 TCP回射服务器程序（再修订版） 146 6.12 小结 148 习题 149</span><br><span class="line"></span><br><span class="line"> 第7章 套接字选项 150 7.1 概述 150 7.2 getsockopt和setsockopt函数 150 7.3 检查选项是否受支持并获取默认值 152 7.4 套接字状态 156 7.5 通用套接字选项 156 7.6 IPv4套接字选项 168 7.7 ICMPv6套接字选项 169 7.8 IPv6套接字选项 169 7.9 TCP套接字选项 171 7.10 SCTP套接字选项 173 7.11 fcntl函数 182 7.12 小结 184 习题 184</span><br><span class="line"></span><br><span class="line"> 第8章 基本UDP套接字编程 186 8.1 概述 186 8.2 recvfrom和sendto函数 187 8.3 UDP回射服务器程序：main函数 187 8.4 UDP回射服务器程序：dg_echo函数 188 8.5 UDP回射客户程序：main函数 190 8.6 UDP回射客户程序：dg_cli函数 190 8.7 数据报的丢失 191 8.8 验证接收到的响应 191 8.9 服务器进程未运行 193 8.10 UDP程序例子小结 194 8.11 UDP的connect函数 196 8.12 dg_cli函数（修订版） 199 8.13 UDP缺乏流量控制 200 8.14 UDP中的外出接口的确定 203 8.15 使用select函数的TCP和UDP回射服务器程序 204 8.16 小结 206 习题 207</span><br><span class="line"></span><br><span class="line"> 第9章 基本SCTP套接字编程 208 9.1 概述 208 9.2 接口模型 208 9.3 sctp_bindx函数 212 9.4 sctp_connectx函数 213 9.5 sctp_getpaddrs函数 213 9.6 sctp_freepaddrs函数 213 9.7 sctp_getladdrs函数 214 9.8 sctp_freeladdrs函数 214 9.9 sctp_sendmsg函数 214 9.10 sctp_recvmsg函数 215 9.11 sctp_opt_info函数 215 9.12 sctp_peeloff函数 216 9.13 shutdown函数 216 9.14 通知 217 9.15 小结 221 习题 222</span><br><span class="line"></span><br><span class="line"> 第10章 SCTP客户&#x2F;服务器程序例子 223 10.1 概述 223 10.2 SCTP一到多式流分回射服务器程序：main函数 223 10.3 SCTP一到多式流分回射客户程序：main函数 225 10.4 SCTP流分回射客户程序：sctpstr_cli函数 226 10.5 探究头端阻塞 228 10.6 控制流的数目 233 10.7 控制终结 233 10.8 小结 234 习题 235</span><br><span class="line"></span><br><span class="line"> 第11章 名字与地址转换 236 11.1 概述 236 11.2 域名系统 236 11.3 gethostbyname函数 239 11.4 gethostbyaddr函数 242 11.5 getservbyname和getservbyport函数 242 11.6 getaddrinfo函数 245 11.7 gai_strerror函数 250 11.8 freeaddrinfo函数 251 11.9 getaddrinfo函数：IPv6 251 11.10 getaddrinfo函数：例子 253 11.11 host_serv函数 254 11.12 tcp_connect函数 254 11.13 tcp_listen函数 257 11.14 udp_client函数 261 11.15 udp_connect函数 263 11.16 udp_server函数 264 11.17 getnameinfo函数 266 11.18 可重入函数 267 11.19 gethostbyname_r和gethostbyaddr_r函数 270 11.20 作废的IPv6地址解析函数 271 11.21 其他网络相关信息 272 11.22 小结 273 习题 274</span><br><span class="line"></span><br><span class="line"> 第三部分 高级套接字编程 第12章 IPv4与IPv6的互操作性 278 12.1 概述 278 12.2 IPv4客户与IPv6服务器 278 12.3 IPv6客户与IPv4服务器 281 12.4 IPv6地址测试宏 283 12.5 源代码可移植性 284 12.6 小结 284 习题 285</span><br><span class="line"></span><br><span class="line"> 第13章 守护进程和inetd超级服务器 286 13.1 概述 286 13.2 syslogd守护进程 286 13.3 syslog函数 287 13.4 daemon_init函数 289 13.5 inetd守护进程 293 13.6 daemon_inetd函数 297 13.7 小结 299 习题 299</span><br><span class="line"></span><br><span class="line"> 第14章 高级I&#x2F;O函数 300 14.1 概述 300 14.2 套接字超时 300 14.3 recv和send函数 305 14.4 readv和writev函数 306 14.5 recvmsg和sendmsg函数 307 14.6 辅助数据 310 14.7 排队的数据量 313 14.8 套接字和标准I&#x2F;O 313 14.9 高级轮询技术 316 14.10 T&#x2F;TCP：事务目的TCP 320 14.11 小结 322 习题 323</span><br><span class="line"></span><br><span class="line"> 第15章 Unix域协议 324 15.1 概述 324 15.2 Unix域套接字地址结构 324 15.3 socketpair函数 326 15.4 套接字函数 327 15.5 Unix域字节流客户&#x2F;服务器程序 327 15.6 Unix域数据报客户&#x2F;服务器程序 329 15.7 描述符传递 330 15.8 接收发送者的凭证 337 15.9 小结 340 习题 340</span><br><span class="line"></span><br><span class="line"> 第16章 非阻塞式I&#x2F;O 341 16.1 概述 341 16.2 非阻塞读和写：str_cli函数（修订版） 342 16.3 非阻塞connect 351 16.4 非阻塞connect：时间获取客户程序 352 16.5 非阻塞connect：Web客户程序 354 16.6 非阻塞accept 362 16.7 小结 363 习题 363</span><br><span class="line"></span><br><span class="line"> 第17章 ioctl操作 365 17.1 概述 365 17.2 ioctl函数 365 17.3 套接字操作 366 17.4 文件操作 367 17.5 接口配置 367 17.6 get_ifi_info函数 369 17.7 接口操作 378 17.8 ARP高速缓存操作 378 17.9 路由表操作 380 17.10 小结 381 习题 381</span><br><span class="line"></span><br><span class="line"> 第18章 路由套接字 382 18.1 概述 382 18.2 数据链路套接字地址结构 382 18.3 读和写 383 18.4 sysctl操作 390 18.5 get_ifi_info函数 394 18.6 接口名字和索引函数 397 18.7 小结 401 习题 401</span><br><span class="line"></span><br><span class="line"> 第19章 密钥管理套接字 402 19.1 概述 402 19.2 读和写 403 19.3 倾泻安全关联数据库 404 19.4 创建静态安全关联 407 19.5 动态维护安全关联 412 19.6 小结 415 习题 416</span><br><span class="line"></span><br><span class="line"> 第20章 广播 417 20.1 概述 417 20.2 广播地址 418 20.3 单播和广播的比较 419 20.4 使用广播的dg_cli函数 422 20.5 竞争状态 424 20.6 小结 431 习题 432</span><br><span class="line"></span><br><span class="line"> 第21章 多播 433 21.1 概述 433 21.2 多播地址 433 21.3 局域网上多播和广播的比较 436 21.4 广域网上的多播 438 21.5 源特定多播 440 21.6 多播套接字选项 441 21.7 mcast_join和相关函数 445 21.8 使用多播的dg_cli函数 450 21.9 接收IP多播基础设施会话声明 451 21.10 发送和接收 454 21.11 SNTP：简单网络时间协议 457 21.12 小结 461 习题 461</span><br><span class="line"></span><br><span class="line"> 第22章 高级UDP套接字编程 462 22.1 概述 462 22.2 接收标志、目的IP地址和接口索引 462 22.3 数据报截断 467 22.4 何时用UDP代替TCP 467 22.5 给UDP应用增加可靠性 469 22.6 捆绑接口地址 478 22.7 并发UDP服务器 482 22.8 IPv6分组信息 483 22.9 IPv6路径MTU控制 486 22.10 小结 487 习题 488</span><br><span class="line"></span><br><span class="line"> 第23章 高级SCTP套接字编程 489 23.1 概述 489 23.2 自动关闭的一到多式服务器程序 489 23.3 部分递送 490 23.4 通知 492 23.5 无序的数据 495 23.6 捆绑地址子集 496 23.7 确定对端和本端地址信息 497 23.8 给定IP地址找出关联ID 500 23.9 心搏和地址不可达 501 23.10 关联剥离 502 23.11 定时控制 503 23.12 何时改用SCTP代替TCP 505 23.13 小结 506 习题 506</span><br><span class="line"></span><br><span class="line"> 第24章 带外数据 507 24.1 概述 507 24.2 TCP带外数据 507 24.3 sockatmark函数 513 24.4 TCP带外数据小结 519 24.5 客户&#x2F;服务器心搏函数 520 24.6 小结 524 习题 524</span><br><span class="line"></span><br><span class="line"> 第25章 信号驱动式I&#x2F;O 525 25.1 概述 525 25.2 套接字的信号驱动式I&#x2F;O 525 25.3 使用SIGIO的UDP回射服务器程序 527 25.4 小结 532 习题 533</span><br><span class="line"></span><br><span class="line"> 第26章 线程 534 26.1 概述 534 26.2 基本线程函数：创建和终止 535 26.3 使用线程的str_cli函数 537 26.4 使用线程的TCP回射服务器程序 538 26.5 线程特定数据 542 26.6 Web客户与同时连接 549 26.7 互斥锁 552 26.8 条件变量 555 26.9 Web客户与同时连接（续） 558 26.10 小结 560 习题 560</span><br><span class="line"></span><br><span class="line"> 第27章 IP选项 561 27.1 概述 561 27.2 IPv4选项 561 27.3 IPv4源路径选项 562 27.4 IPv6扩展首部 569 27.5 IPv6步跳选项和目的地选项 569 27.6 IPv6路由首部 573 27.7 IPv6粘附选项 577 27.8 历史性IPv6高级API 578 27.9 小结 579 习题 579</span><br><span class="line"></span><br><span class="line"> 第28章 原始套接字 580 28.1 概述 580 28.2 原始套接字创建 580 28.3 原始套接字输出 581 28.4 原始套接字输入 582 28.5 ping程序 584 28.6 traceroute程序 596 28.7 一个ICMP消息守护程序 608 28.8 小结 622 习题 622</span><br><span class="line"></span><br><span class="line"> 第29章 数据链路访问 623 29.1 概述 623 29.2 BPF：BSD分组过滤器 623 29.3 DLPI：数据链路提供者接口 625 29.4 Linux：SOCK_PACKET和 PFPACKET 626 29.5 libpcap：分组捕获函数库 627 29.6 libnet：分组构造与输出函数库 627 29.7 检查UDP的校验和字段 628 29.8 小结 645 习题 645</span><br><span class="line"></span><br><span class="line"> 第30章 客户&#x2F;服务器程序设计范式 646 30.1 概述 646 30.2 TCP客户程序设计范式 648 30.3 TCP测试用客户程序 649 30.4 TCP迭代服务器程序 650 30.5 TCP并发服务器程序，每个客户一个子进程 650 30.6 TCP预先派生子进程服务器程序，accept无上锁保护 653 30.7 TCP预先派生子进程服务器程序，accept使用文件上锁保护 659 30.8 TCP预先派生子进程服务器程序，accept使用线程上锁保护 662 30.9 TCP预先派生子进程服务器程序，传递描述符 663 30.10 TCP并发服务器程序，每个客户一个线程 667 30.11 TCP预先创建线程服务器程序，每个线程各自accept 669 30.12 TCP预先创建线程服务器程序，主线程统一accept 671 30.13 小结 673 习题 674</span><br><span class="line"></span><br><span class="line"> 第31章 流 675 31.1 概述 675 31.2 概貌 675 31.3 getmsg和putmsg函数 678 31.4 getpmsg和putpmsg函数 679 31.5 ioctl函数 680 31.6 TPI：传输提供者接口 680 31.7 小结 689 习题 689</span><br><span class="line"></span><br><span class="line"> 附录A IPv4、IPv6、ICMPv4和ICMPv6 690 附录B 虚拟网络 704 附录C 调试技术 708 附录D 杂凑的源代码 714 附录E 精选习题答案 726 参考文献 756 索引 763</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B003SWP8XG/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B003SWP8XG&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51zuPI39naL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>unix</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows Via C/C++</title>
    <url>/2020/04/19/windows-via-cpp/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Windows Via C/C++<br>作者信息： 作者: Jeffrey M. Richter [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>Master the intricacies of application development with unmanaged C++ code - straight from the experts. Jeffrey Richter’s classic book is now fully revised for Windows XP, Windows Vista, and Windows Server 2008. You get in-depth, comprehensive guidance, advanced techniques, and extensive code samples to help you program Windows - based applications. Discover how to: * Architect and implement your applications for both 32-bit and 64-bit Windows * Create and manipulate processes and jobs * Schedule, manage, synchronize and destroy threads * Perform asynchronous and synchronous device I/O operations with the I/O completion port * Allocate memory using various techniques including virtual memory, memory-mapped files, and heaps * Manipulate the default committed physical storage of thread stacks * Build DLLs for delay-loading, API hooking, and process injection * Using structured exception handling, Windows Error Recovery, and Application Restart services</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Part I Required Reading</span><br><span class="line">　1　Error Handling</span><br><span class="line">　2 Working with Characters and Strings</span><br><span class="line">　3　Kernel Objects</span><br><span class="line">Part II　Getting Work Done</span><br><span class="line">　4　Processes</span><br><span class="line">　5 Jobs</span><br><span class="line">　6 Thread Basics</span><br><span class="line">　7 Thread Scheduling, Priorities, and Affinities</span><br><span class="line">　8 Thread Synchronization in User Mode</span><br><span class="line">　9 Thread Synchronization with Kernel Objects</span><br><span class="line">10　Synchronous and Asynchronous Device I&#x2F;O</span><br><span class="line">11 The Windows Thread Pool</span><br><span class="line">12　Fibers</span><br><span class="line">part III　Memory Management</span><br><span class="line">13　Windows Memory Architecture</span><br><span class="line">14　Exploring Virtual Memory</span><br><span class="line">15　Using Virtual Memory in Your Own Applications</span><br><span class="line">16 A Thread’s Stack</span><br><span class="line">17　Memory-Mapped Files</span><br><span class="line">18 Heaps</span><br><span class="line">Part IV　Dynamic-Link Libraries</span><br><span class="line">　19　DLL Basics</span><br><span class="line">　12　DLL Advanced Techniques</span><br><span class="line">　21 Thread-Local Storage</span><br><span class="line">　22　DLL Injection and API Hooking</span><br><span class="line">Part V　Structured Exception Handling</span><br><span class="line">　23 Termination Handlers</span><br><span class="line">　24　Exception Handlers and Software Exceptions</span><br><span class="line">25　Unhandled Exceptions, Vectored Exception Handling, and C++Exceptions</span><br><span class="line">26　Error Reporting and Application Recovery</span><br><span class="line">Part VI　Appendixes</span><br><span class="line">　A The Build Environment</span><br><span class="line">　B　Message Crackers, Child Control Macros,and API Macros</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/0735663777/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=0735663777&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41KlL1-2DjL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows环境下32位汇编语言程序设计</title>
    <url>/2020/04/19/windowshuan-jing-xia-32wei-hui-bian-yu-yan-cheng-xu-she-ji/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Windows环境下32位汇编语言程序设计<br>作者信息： 作者: 罗云彬 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Windows环境下32位汇编语言程序设计》从编写应用程序的角度，从“HelloWorld”这个简单的例子开始到编写多线程、注册表和网络通信等复杂的程序，通过60多个实例逐渐深入Win32汇编语言的方方面面。Windows环境下32位汇编语言是一种全新的编程语言。它使用与C++语言相同的API接口，不仅可以用来开发出大型的软件，而且是了解操作系统运行细节的最佳方式。 </p>
<p>《Windows环境下32位汇编语言程序设计》从编写应用程序的角度，从“Hello World！”这个简单的例子开始到编写多线程、注册表和网络通信等复杂的程序，通过60多个实例逐渐深入Win32汇编语言的方方面面。 </p>
<p>《Windows环境下32位汇编语言程序设计》作者罗云彬拥有十余年汇编语言编程经验，是汇编编程网站<a href="http://asm.yeah.net和汇编编程论坛http://win32asm.yeah.net的站长。《Windows环境下32位汇编语言程序设计》是作者多年来编程工作的总结，适合于欲通过Win32汇编语言编写Windows程序的读者。" target="_blank" rel="noopener">http://asm.yeah.net和汇编编程论坛http://win32asm.yeah.net的站长。《Windows环境下32位汇编语言程序设计》是作者多年来编程工作的总结，适合于欲通过Win32汇编语言编写Windows程序的读者。</a></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 背景知识</span><br><span class="line">1.1 Win32的软硬件平台</span><br><span class="line">1.2 Windows的特色</span><br><span class="line">1.3 必须了解的东西</span><br><span class="line">第2章 准备编程环境</span><br><span class="line">2.1 Win32可执行文件的开发过程</span><br><span class="line">2.2 编译器和链接器</span><br><span class="line">2.3 创建资源</span><br><span class="line">2.4 make工具的用法</span><br><span class="line">2.5 获取资料</span><br><span class="line">2.6 构建编程环境</span><br><span class="line">第3章 使用MASM</span><br><span class="line">3.1 Win32汇编源程序的结构</span><br><span class="line">3.2 调用API</span><br><span class="line">3.3 标号、变量和数据结构</span><br><span class="line">3.4 使用子程序</span><br><span class="line">3.5 高级语法</span><br><span class="line">3.6 代码风格</span><br><span class="line">第4章 第一个窗口程序</span><br><span class="line">4.1 开始了解窗口</span><br><span class="line">4.2 分析窗口程序</span><br><span class="line">4.3 窗口间的消息互发</span><br><span class="line">4.4 实验</span><br><span class="line">第5章 使用资源</span><br><span class="line">5.1 菜单和加速键</span><br><span class="line">5.2 图标和光标</span><br><span class="line">5.3 位图</span><br><span class="line">5.4 对话框</span><br><span class="line">5.5 字符串资源</span><br><span class="line">5.6 版本信息资源</span><br><span class="line">5.7 二进制资源和自定义资源</span><br><span class="line">第6章 定时器</span><br><span class="line">6.1 定时器简介</span><br><span class="line">6.2 定时器的使用</span><br><span class="line">6.3 取Windows时间</span><br><span class="line">第7章 图形操作</span><br><span class="line">7.1 GDI原理</span><br><span class="line">7.2 绘制图形</span><br><span class="line">7.3 创建和使用位图</span><br><span class="line">7.4 块传送操作</span><br><span class="line">7.5 区域和路径</span><br><span class="line">第8章 通用对话框</span><br><span class="line">8.1 通用对话框简介</span><br><span class="line">8.2 使用通用对话框</span><br><span class="line">8.3 浏览目录对话框</span><br><span class="line">第9章 通用控件</span><br><span class="line">9.1 通用控件简介</span><br><span class="line">9.2 使用状态栏</span><br><span class="line">9.3 使用工具栏</span><br><span class="line">9.4 使用Richedit控件</span><br><span class="line">9.5 窗口的子类化</span><br><span class="line">9.6 控件的超类化</span><br><span class="line">第10章 内存管理和文件操作</span><br><span class="line">10.1 内存管理</span><br><span class="line">10.2 文件操作</span><br><span class="line">10.3 驱动器和目录</span><br><span class="line">10.4 内存映射文件</span><br><span class="line">第11章 动态链接库和钩子</span><br><span class="line">第12章 多线程</span><br><span class="line">第13章 进程控制</span><br><span class="line">第14章 异常处理</span><br><span class="line">第15章 注册表和INI文件</span><br><span class="line">第16章 TCP&#x2F;IP和网络通信</span><br><span class="line">第17章 PE文件</span><br><span class="line">参考文献</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00DZ2406K/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00DZ2406K&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51G1lvideiL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX环境高级编程(第2版)</title>
    <url>/2020/04/19/B00114GRG0/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： UNIX环境高级编程(第2版)<br>作者信息： 作者: 史蒂文斯 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《UNIX环境高级编程(第2版)》编辑推荐：内容权威，概念清晰，阐述精辟，对于所有层次UNIX程序员都是一本不可或缺的参考书。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 UNIX基础知识1</span><br><span class="line">1.1引言1</span><br><span class="line">1.2UNIX体系结构1</span><br><span class="line">1.3登录1</span><br><span class="line">1.4文件和目录3</span><br><span class="line">1.5输入和输出6</span><br><span class="line">1.6程序和进程8</span><br><span class="line">1.7出错处理10</span><br><span class="line">1.8用户标识12</span><br><span class="line">1.9信号14</span><br><span class="line">1.10时间值15</span><br><span class="line">1.11系统调用和库函数16</span><br><span class="line">1.12小结17</span><br><span class="line">习题18</span><br><span class="line">第2章 UNIX标准化及实现19</span><br><span class="line">2.1引言19</span><br><span class="line">2.2UNIX标准化19</span><br><span class="line">2.2.1ISO C19</span><br><span class="line">2.2.2IEEE POSIX20</span><br><span class="line">2.2.3Single UNIX Specification25</span><br><span class="line">2.2.4FIPS26</span><br><span class="line">2.3UNIX系统实现26</span><br><span class="line">2.3.1SVR426</span><br><span class="line">2.3.24.4BSD27</span><br><span class="line">2.3.3FreeBSD27</span><br><span class="line">2.3.4Linux27</span><br><span class="line">2.3.5Mac OS X28</span><br><span class="line">2.3.6Solaris28</span><br><span class="line">2.3.7其他UNIX系统28</span><br><span class="line">2.4标准和实现的关系28</span><br><span class="line">2.5限制29</span><br><span class="line">2.5.1ISO C限制29</span><br><span class="line">2.5.2POSIX限制30</span><br><span class="line">2.5.3XSI限制32</span><br><span class="line">2.5.4sysconf、pathconf和fpathconf函数32</span><br><span class="line">2.5.5不确定的运行时限制38</span><br><span class="line">2.6选项42</span><br><span class="line">2.7功能测试宏44</span><br><span class="line">2.8基本系统数据类型45</span><br><span class="line">2.9标准之间的冲突45</span><br><span class="line">2.10小结46</span><br><span class="line">习题46</span><br><span class="line">第3章 文件I&#x2F;O47</span><br><span class="line">3.1引言47</span><br><span class="line">3.2文件描述符47</span><br><span class="line">3.3open函数48</span><br><span class="line">3.4creat函数49</span><br><span class="line">3.5close函数50</span><br><span class="line">3.6lseek函数50</span><br><span class="line">3.7read函数53</span><br><span class="line">3.8write函数54</span><br><span class="line">3.9I&#x2F;O的效率54</span><br><span class="line">3.10文件共享56</span><br><span class="line">3.11原子操作59</span><br><span class="line">3.12dup和dup2函数60</span><br><span class="line">3.13sync、fsync和fdatasync函数61</span><br><span class="line">3.14fcntl函数62</span><br><span class="line">3.15ioctl函数66</span><br><span class="line">3.16&#x2F;dev&#x2F;fd67</span><br><span class="line">3.17小结68</span><br><span class="line">习题68</span><br><span class="line">第4章 文件和目录71</span><br><span class="line">4.1引言71</span><br><span class="line">4.2stat、fstat和lstat函数71</span><br><span class="line">4.3文件类型72</span><br><span class="line">4.4设置用户ID和设置组ID74</span><br><span class="line">4.5文件访问权限75</span><br><span class="line">4.6新文件和目录的所有权77</span><br><span class="line">4.7access函数77</span><br><span class="line">4.8umask函数79</span><br><span class="line">4.9chmod和fchmod函数81</span><br><span class="line">4.10粘住位83</span><br><span class="line">4.11chown、fchown和lchown函数84</span><br><span class="line">4.12文件长度85</span><br><span class="line">4.13文件截短86</span><br><span class="line">4.14文件系统86</span><br><span class="line">4.15link、unlink、remove和rename函数89</span><br><span class="line">4.16符号链接91</span><br><span class="line">4.17symlink和readlink函数94</span><br><span class="line">4.18文件的时间94</span><br><span class="line">4.19utime函数95</span><br><span class="line">4.20mkdir和rmdir函数97</span><br><span class="line">4.21读目录98</span><br><span class="line">4.22chdir、fchdir和getcwd函数102</span><br><span class="line">4.23设备特殊文件104</span><br><span class="line">4.24文件访问权限位小结106</span><br><span class="line">4.25小结106</span><br><span class="line">习题107</span><br><span class="line">第5章 标准I&#x2F;O库109</span><br><span class="line">5.1引言109</span><br><span class="line">5.2流和FILE对象109</span><br><span class="line">5.3标准输入、标准输出和标准出错110</span><br><span class="line">5.4缓冲110</span><br><span class="line">5.5打开流112</span><br><span class="line">5.6读和写流114</span><br><span class="line">5.7每次一行I&#x2F;O116</span><br><span class="line">5.8标准I&#x2F;O的效率117</span><br><span class="line">5.9二进制I&#x2F;O119</span><br><span class="line">5.10定位流120</span><br><span class="line">5.11格式化I&#x2F;O121</span><br><span class="line">5.12实现细节125</span><br><span class="line">5.13临时文件127</span><br><span class="line">5.14标准I&#x2F;O的替代软件130</span><br><span class="line">5.15小结130</span><br><span class="line">习题130</span><br><span class="line">第6章 系统数据文件和信息133</span><br><span class="line">6.1引言133</span><br><span class="line">6.2口令文件133</span><br><span class="line">6.3阴影口令136</span><br><span class="line">6.4组文件137</span><br><span class="line">6.5附加组ID138</span><br><span class="line">6.6实现的区别139</span><br><span class="line">6.7其他数据文件139</span><br><span class="line">6.8登录账户记录140</span><br><span class="line">6.9系统标识141</span><br><span class="line">6.10时间和日期例程142</span><br><span class="line">6.11小结146</span><br><span class="line">习题146</span><br><span class="line">第7章 进程环境147</span><br><span class="line">7.1引言147</span><br><span class="line">7.2main函数147</span><br><span class="line">7.3进程终止147</span><br><span class="line">7.4命令行参数151</span><br><span class="line">7.5环境表152</span><br><span class="line">7.6C程序的存储空间布局152</span><br><span class="line">7.7共享库154</span><br><span class="line">7.8存储器分配154</span><br><span class="line">7.9环境变量157</span><br><span class="line">7.10setjmp和longjmp函数159</span><br><span class="line">7.11getrlimit和setrlimit函数164</span><br><span class="line">7.12小结168</span><br><span class="line">习题168</span><br><span class="line">第8章 进程控制171</span><br><span class="line">8.1引言171</span><br><span class="line">8.2进程标识符171</span><br><span class="line">8.3fork函数172</span><br><span class="line">8.4vfork函数176</span><br><span class="line">8.5exit函数178</span><br><span class="line">8.6wait和waitpid函数179</span><br><span class="line">8.7waitid函数183</span><br><span class="line">8.8wait3和wait4函数184</span><br><span class="line">8.9竞争条件185</span><br><span class="line">8.10exec函数188</span><br><span class="line">8.11更改用户ID和组ID192</span><br><span class="line">8.12解释器文件196</span><br><span class="line">8.13system函数200</span><br><span class="line">8.14进程会计203</span><br><span class="line">8.15用户标识208</span><br><span class="line">8.16进程时间208</span><br><span class="line">8.17小结210</span><br><span class="line">习题211</span><br><span class="line">第9章 进程关系213</span><br><span class="line">9.1引言213</span><br><span class="line">9.2终端登录213</span><br><span class="line">9.3网络登录216</span><br><span class="line">9.4进程组218</span><br><span class="line">9.5会话219</span><br><span class="line">9.6控制终端220</span><br><span class="line">9.7tcgetpgrp、tcsetpgrp和tcgetsid函数221</span><br><span class="line">9.8作业控制222</span><br><span class="line">9.9shell执行程序225</span><br><span class="line">9.10孤儿进程组228</span><br><span class="line">9.11FreeBSD实现230</span><br><span class="line">9.12小结231</span><br><span class="line">习题232</span><br><span class="line">第10章 信号233</span><br><span class="line">10.1引言233</span><br><span class="line">10.2信号概念233</span><br><span class="line">10.3signal函数240</span><br><span class="line">10.4不可靠的信号242</span><br><span class="line">10.5中断的系统调用244</span><br><span class="line">10.6可重入函数246</span><br><span class="line">10.7SIGCLD语义248</span><br><span class="line">10.8可靠信号术语和语义250</span><br><span class="line">10.9kill和raise函数251</span><br><span class="line">10.10alarm和pause函数252</span><br><span class="line">10.11信号集256</span><br><span class="line">10.12sigprocmask函数258</span><br><span class="line">10.13sigpending函数259</span><br><span class="line">10.14sigaction函数261</span><br><span class="line">10.15sigsetjmp和siglongjmp函数266</span><br><span class="line">10.16sigsuspend函数268</span><br><span class="line">10.17abort函数274</span><br><span class="line">10.18system函数276</span><br><span class="line">10.19sleep函数280</span><br><span class="line">10.20作业控制信号282</span><br><span class="line">10.21其他特征284</span><br><span class="line">10.22小结285</span><br><span class="line">习题285</span><br><span class="line">第11章 线程287</span><br><span class="line">11.1引言287</span><br><span class="line">11.2线程概念287</span><br><span class="line">11.3线程标识288</span><br><span class="line">11.4线程的创建288</span><br><span class="line">11.5线程终止291</span><br><span class="line">11.6线程同步297</span><br><span class="line">11.7小结311</span><br><span class="line">习题311</span><br><span class="line">第12章 线程控制313</span><br><span class="line">12.1引言313</span><br><span class="line">12.2线程限制313</span><br><span class="line">12.3线程属性314</span><br><span class="line">12.4同步属性318</span><br><span class="line">12.5重入324</span><br><span class="line">12.6线程私有数据328</span><br><span class="line">12.7取消选项331</span><br><span class="line">12.8线程和信号333</span><br><span class="line">12.9线程和fork336</span><br><span class="line">12.10线程和I&#x2F;O339</span><br><span class="line">12.11小结340</span><br><span class="line">习题340</span><br><span class="line">第13章 守护进程341</span><br><span class="line">13.1引言341</span><br><span class="line">13.2守护进程的特征341</span><br><span class="line">13.3编程规则342</span><br><span class="line">13.4出错记录345</span><br><span class="line">13.5单实例守护进程348</span><br><span class="line">13.6守护进程的惯例350</span><br><span class="line">13.7客户进程-服务器进程模型354</span><br><span class="line">13.8小结354</span><br><span class="line">习题354</span><br><span class="line">第14章 高级I&#x2F;O355</span><br><span class="line">14.1引言355</span><br><span class="line">14.2非阻塞I&#x2F;O355</span><br><span class="line">14.3记录锁357</span><br><span class="line">14.4STREAMS370</span><br><span class="line">14.5I&#x2F;O多路转接379</span><br><span class="line">14.5.1select和pselect函数381</span><br><span class="line">14.5.2poll函数384</span><br><span class="line">14.6异步I&#x2F;O386</span><br><span class="line">14.6.1系统V异步I&#x2F;O386</span><br><span class="line">14.6.2BSD异步I&#x2F;O387</span><br><span class="line">14.7readv和writev函数387</span><br><span class="line">14.8readn和writen函数389</span><br><span class="line">14.9存储映射I&#x2F;O390</span><br><span class="line">14.10小结395</span><br><span class="line">习题396</span><br><span class="line">第15章 进程间通信397</span><br><span class="line">15.1引言397</span><br><span class="line">15.2管道398</span><br><span class="line">15.3popen和pclose函数403</span><br><span class="line">15.4协同进程408</span><br><span class="line">15.5FIFO412</span><br><span class="line">15.6XSI IPC415</span><br><span class="line">15.6.1标识符和键415</span><br><span class="line">15.6.2权限结构416</span><br><span class="line">15.6.3结构限制417</span><br><span class="line">15.6.4优点和缺点417</span><br><span class="line">15.7消息队列418</span><br><span class="line">15.8信号量422</span><br><span class="line">15.9共享存储427</span><br><span class="line">15.10客户进程-服务器进程属性432</span><br><span class="line">15.11小结434</span><br><span class="line">习题434</span><br><span class="line">第16章 网络IPC：套接字437</span><br><span class="line">16.1引言437</span><br><span class="line">16.2套接字描述符437</span><br><span class="line">16.3寻址439</span><br><span class="line">16.3.1字节序440</span><br><span class="line">16.3.2地址格式441</span><br><span class="line">16.3.3地址查询442</span><br><span class="line">16.3.4将套接字与地址绑定449</span><br><span class="line">16.4建立连接450</span><br><span class="line">16.5数据传输452</span><br><span class="line">16.6套接字选项464</span><br><span class="line">16.7带外数据466</span><br><span class="line">16.8非阻塞和异步I&#x2F;O467</span><br><span class="line">16.9小结468</span><br><span class="line">习题468</span><br><span class="line">第17章 高级进程间通信469</span><br><span class="line">17.1引言469</span><br><span class="line">17.2基于STREAMS的管道469</span><br><span class="line">17.2.1命名的STREAMS管道472</span><br><span class="line">17.2.2唯一连接473</span><br><span class="line">17.3UNIX域套接字476</span><br><span class="line">17.3.1命名UNIX域套接字477</span><br><span class="line">17.3.2唯一连接478</span><br><span class="line">17.4传送文件描述符482</span><br><span class="line">17.4.1经由基于STREAMS的管道传送文件描述符484</span><br><span class="line">17.4.2经由UNIX域套接字传送文件描述符486</span><br><span class="line">17.5open服务器版本1493</span><br><span class="line">17.6open服务器版本2498</span><br><span class="line">17.7小结505</span><br><span class="line">习题505</span><br><span class="line">第18章 终端I&#x2F;O507</span><br><span class="line">18.1引言507</span><br><span class="line">18.2综述507</span><br><span class="line">18.3特殊输入字符512</span><br><span class="line">18.4获得和设置终端属性516</span><br><span class="line">18.5终端选项标志516</span><br><span class="line">18.6stty命令522</span><br><span class="line">18.7波特率函数523</span><br><span class="line">18.8行控制函数524</span><br><span class="line">18.9终端标识524</span><br><span class="line">18.10规范模式529</span><br><span class="line">18.11非规范模式532</span><br><span class="line">18.12终端的窗口大小537</span><br><span class="line">18.13termcap，terminfo和curses539</span><br><span class="line">18.14小结540</span><br><span class="line">习题540</span><br><span class="line">第19章 伪终端541</span><br><span class="line">19.1引言541</span><br><span class="line">19.2概述541</span><br><span class="line">19.3打开伪终端设备544</span><br><span class="line">19.3.1基于STREAMS的伪终端547</span><br><span class="line">19.3.2基于BSD的伪终端549</span><br><span class="line">19.3.3基于Linux的伪终端551</span><br><span class="line">19.4pty_fork函数553</span><br><span class="line">19.5pty程序555</span><br><span class="line">19.6使用pty程序559</span><br><span class="line">19.7高级特性564</span><br><span class="line">19.8小结565</span><br><span class="line">习题565</span><br><span class="line">第20章 数据库函数库567</span><br><span class="line">20.1引言567</span><br><span class="line">20.2历史567</span><br><span class="line">20.3函数库568</span><br><span class="line">20.4实现概述569</span><br><span class="line">20.5集中式或非集中式572</span><br><span class="line">20.6并发574</span><br><span class="line">20.7构造函数库574</span><br><span class="line">20.8源代码575</span><br><span class="line">20.9性能598</span><br><span class="line">20.10小结600</span><br><span class="line">习题601</span><br><span class="line">第21章 与网络打印机通信603</span><br><span class="line">21.1引言603</span><br><span class="line">21.2网络打印协议603</span><br><span class="line">21.3超文本传输协议605</span><br><span class="line">21.4打印假脱机技术605</span><br><span class="line">21.5源代码607</span><br><span class="line">21.6小结644</span><br><span class="line">习题645</span><br><span class="line">附录A函数原型647</span><br><span class="line">附录B其他源代码677</span><br><span class="line">附录C部分习题答案685</span><br><span class="line">参考书目709</span><br><span class="line">索引715</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00114GRG0/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00114GRG0&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51K-kirfoWL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>unix</tag>
      </tags>
  </entry>
  <entry>
    <title>社会工程 安全体系中的人性漏洞(英文)</title>
    <url>/2020/04/19/an-quan-ti-xi-zhong-de-ren-xing-lou-dong/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 社会工程 安全体系中的人性漏洞(英文)<br>作者信息： 作者: Christopher Hadnagy [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>著名安全专家解密社会工程手法的权威著作<br>社会工程专家的精彩故事令你瞠目结舌<br>众多专业人士强力推荐，亚马逊读者一致好评</p>
<p>帮助你：<br>学习社会工程人员采用的心理学原则及其运用方法<br>了解社会工程人员所精通的说服技巧<br>看清狡猾的骗子如何利用摄像头、GPS定位设备和来电显示行骗<br>知晓在网络上能够找到海量的信息<br>剖析真实世界的社会工程实例</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目　录 </span><br><span class="line"></span><br><span class="line"> 第1章　社会工程学初探　1 1.1　为何本书很重要　2 1.1.1　本书框架　3 1.1.2　本书内容　4 1.2　社会工程概述　7 1.2.1　社会工程及其定位　10 1.2.2　社会工程人员的类型　12 1.2.3　社会工程的框架及其使用方法　14 1.3　小结　15</span><br><span class="line"></span><br><span class="line"> 第2章　信息收集　16 2.1　收集信息　18 2.1.1　使用BasKet　18 2.1.2　使用Dradis　20 2.1.3　像社会工程人员一样思考　21 2.2　信息源　25 2.2.1　从网站上收集信息　25 2.2.2　运用观察的力量　29 2.2.3　垃圾堆里找信息　30 2.2.4　运用分析软件　31 2.3　交流模型　32 2.3.1　交流模型及其根源　34 2.3.2　制定交流模型　36 2.4　交流模型的力量　39</span><br><span class="line"></span><br><span class="line"> 第3章　诱导　41 3.1　诱导的含义　42 3.2　诱导的目的　44 3.2.1　铺垫　46 3.2.2　成为成功的诱导者　49 3.2.3　提问的学问　52 3.3　精通诱导　55 3.4　小结　57</span><br><span class="line"></span><br><span class="line"> 第4章　伪装：如何成为任何人　58 4.1　什么是伪装　59 4.2　伪装的原则和计划阶段　60 4.2.1　调查越充分，成功的几率越大　60 4.2.2　植入个人爱好会提高成功率　61 4.2.3　练习方言或者表达方式　63 4.2.4　使用电话不会减少社会工程人员投入的精力　64 4.2.5　伪装越简单，成功率越高　65 4.2.6　伪装必须显得自然　66 4.2.7　为目标提供逻辑结论或下一步安排　67 4.3　成功的伪装　68 4.3.1　案例1：斯坦利·马克·瑞夫金　68 4.3.2　案例2：惠普　70 4.3.3　遵纪守法　72 4.3.4　其他伪装工具　73 4.4　小结　74</span><br><span class="line"></span><br><span class="line"> 第5章　心理战术：社会工程心理学　75 5.1　思维模式　76 5.1.1　感官　77 5.1.2　3种主要的思维模式　77 5.2　微表情　81 5.2.1　愤怒　83 5.2.2　厌恶　85 5.2.3　轻蔑　87 5.2.4　恐惧　89 5.2.5　惊讶　91 5.2.6　悲伤　92 5.2.7　快乐　95 5.2.8　训练自己识别微表情　97 5.2.9　社会工程人员如何运用微表情　99 5.3　神经语言程序学　103 5.3.1　神经语言程序学的历史　104 5.3.2　神经语言程序学的准则　105 5.3.3　社会工程人员如何应用NLP　106 5.4　采访和审讯　109 5.4.1　专业的审讯技巧　110 5.4.2　手势　116 5.4.3　双臂和手的摆放　118 5.4.4　聆听：通往成功之门　119 5.5　即刻达成共识　123 5.5.1　真正地想要了解他人　123 5.5.2　注意自身形象　123 5.5.3　善于聆听　124 5.5.4　留心自己对他人的影响　124 5.5.5　尽量少谈论自己　125 5.5.6　谨记：同情心是达成共识的关键　125 5.5.7　扩大知识领域　126 5.5.8　挖掘你的好奇心　126 5.5.9　设法满足他人的需求　127 5.5.10　使用其他建立共识的技巧　129 5.5.11　测试“共识”　130 5.6　人类思维缓冲区溢出　131 5.6.1　设定最基本的原则　132 5.6.2　人性操作系统的模糊测试　133 5.6.3　嵌入式指令的规则　134 5.7　小结　135</span><br><span class="line"></span><br><span class="line"> 第6章　影响：说服的力量　137 6.1　影响和说服的5项基本原则　138 6.1.1　心中有明确的目标　138 6.1.2　共识、共识、共识　139 6.1.3　保持自身和环境一致　141 6.1.4　不要疯狂，要灵活应变　141 6.1.5　内省　141 6.2　影响战术　142 6.2.1　回报　142 6.2.2　义务　145 6.2.3　让步　147 6.2.4　稀缺　148 6.2.5　权威　151 6.2.6　承诺和一致性　153 6.2.7　喜欢　157 6.2.8　共识或社会认同　159 6.3　改动现实：框架　163 6.3.1　政治活动　163 6.3.2　在日常生活中使用框架　164 6.3.3　框架联盟的4种类型　168 6.3.4　社会工程人员如何利用框架战术　172 6.4　操纵：控制你的目标　177 6.4.1　召回还是不召回　179 6.4.2　焦虑的最终治愈　180 6.4.3　你不能让我买那个　181 6.4.4　令目标积极地响应　184 6.4.5　操纵激励　185 6.5　社会工程中的操纵　189 6.5.1　提高目标的暗示感受性　189 6.5.2　控制目标的环境　190 6.5.3　迫使目标重新评估　190 6.5.4　让目标感到无能为力　191 6.5.5　给予非肉体惩罚　192 6.5.6　威胁目标　192 6.5.7　使用积极的操纵　193 6.6　小结　195</span><br><span class="line"></span><br><span class="line"> 第7章　社会工程工具　197 7.1　物理工具　198 7.1.1　开锁器　198 7.1.2　摄像机和录音设备　204 7.1.3　使用GPS跟踪器　207 7.2　在线信息收集工具　214 7.2.1　Maltego　214 7.2.2　社会工程人员工具包　216 7.2.3　基于电话的工具　221 7.2.4　密码分析工具　224 7.3　小结　228</span><br><span class="line"></span><br><span class="line"> 第8章　案例研究：剖析社会工程人员　229 8.1　米特尼克案例1：攻击DMV　230 8.1.1　目标　230 8.1.2　故事　230 8.1.3　社会工程框架的运用　233 8.2　米特尼克案例2：攻击美国社会保障局　235 8.2.1　目标　235 8.2.2　故事　235 8.2.3　社会工程框架的运用　237 8.3　海德纳吉案例1：自负的CEO　238 8.3.1　目标　238 8.3.2　故事　239 8.3.3　社会工程框架的运用　243 8.4　海德纳吉案例2：主题乐园丑闻　244 8.4.1　目标　244 8.4.2　故事　245 8.4.3　社会工程框架的运用　247 8.5　最高机密案例1：不可能的使命　248 8.5.1　目标　248 8.5.2　故事　249 8.5.3　社会工程框架的运用　253 8.6　最高机密案例2：对黑客的社会工程　254 8.6.1　目标　254 8.6.2　故事　255 8.6.3　社会工程框架的运用　260 8.7　案例学习的重要性　261 8.8　小结　261</span><br><span class="line"></span><br><span class="line"> 第9章　预防和补救　262 9.1　学会识别社会工程攻击　263 9.2　创建具有个人安全意识的文化　264 9.3　充分认识信息的价值　266 9.4　及时更新软件　268 9.5　编制参考指南　269 9.6　学习社会工程审计案例　269 9.6.1　理解什么是社会安全审计　269 9.6.2　设立审计目标　270 9.6.3　审计中的可为与不可为　271 9.6.4　挑选最好的审计人员　272 9.7　总结　273 9.7.1　社会工程并非总是消极的　273 9.7.2　收集与组织信息的重要性　274 9.7.3　谨慎用词　274 9.7.4　巧妙伪装　275 9.7.5　练习解读表情　276 9.7.6　操纵与影响　276 9.7.7　警惕恶意策略　276 9.7.8　利用你的恐惧　277 9.8　小结　278</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00GWP2GG8/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00GWP2GG8&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41cKXRDWifL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏之旅 我的编程感悟</title>
    <url>/2020/04/19/B00112ZOE8/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 游戏之旅 我的编程感悟<br>作者信息： 作者: 浏览全部评论  [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《游戏之旅：我的编程感悟》忠实地记录了作者十余年来对游戏编程的所思、所感、所悟。全书按照作者本人学习和实践的过程，带着读者从基础的计算机知识到高级的编程技术，从非常专业的汇编优化到非常实际的项目管理进行了一次游戏开发的全景探索。　　《游戏之旅：我的编程感悟》不仅适合游戏开发者阅读，也会给所有的开发者和程序爱好者带来启示。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一章  计算机，游戏，我</span><br><span class="line">第二章  算法，程序的灵魂</span><br><span class="line">第三章  编程语言</span><br><span class="line">第四章  前Windows时代</span><br><span class="line">第五章  Windows编程</span><br><span class="line">第六章  汇编优化</span><br><span class="line">第七章  SIMD指令</span><br><span class="line">第八章  引擎中的优化</span><br><span class="line">第九章  C和C++</span><br><span class="line">第十章  调试</span><br><span class="line">第十一章  脚本</span><br><span class="line">第十二章  版本控制</span><br><span class="line">第十三章  开发方法</span><br><span class="line">第十四章  编程和游戏</span><br><span class="line">后记</span><br><span class="line">致谢</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00112ZOE8/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00112ZOE8&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41CiBCeYWdL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>敏捷软件开发(原则模式与实践)</title>
    <url>/2020/04/19/B00116MMA8/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 敏捷软件开发(原则模式与实践)<br>作者信息： 作者: 马丁 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《敏捷软件开发：原则模式与实践》是综合性、实用性的敏捷开发和极限编程方面的指南，讲述了在预算和时间要求下软件开发人员和项目经理如何使用敏捷开发完成项目：使用真实案例讲解如何用极限编程来设计、测试、重构和结对编程；包含了极具价值的可重用的C++和Java源代码；还重点讲述了如何使用UML和设计模式解决面向客户系统的问题。《敏捷软件开发：原则模式与实践》于2003年荣获第13届软件开发图书震撼大奖，适于用作高校计算机专业本科生、研究生和软件学院的软件工程和软件开发相关课程的教材或参考书，也适于软件开发和管理人员提高自身水平学习之用。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第Ⅰ部分 敏捷开发 第一章 敏捷实践 1.1 敏捷联盟 1.2 原则 1.3 结论 参考文献 第二章 极限编程概述 2.1 极限编程实践 2.2 结论 参考文献 第三章 计划 3.1 初始探索 3.2 发布计划 3.3 迭代计划 3.4 任务计划 3.5 迭代 3.6 结论 参考文献 第四章 测试 4.1 测试驱动的开发方法 4.2 验收测试 4.3 结论 参考文献 第五章 重构 5.1 素数产生程序一个简单的重构示例 5.2 结论 参考文献 第六章 一次编程实践 6.1 保龄球比赛 6.2 结论 第Ⅱ部分 敏捷设计 第七章 什么是敏捷设计 7.1 软件出了什么错 7.2 设计的臭味——腐化软件的气味 7.3 “Copy”程序 7.4 保持尽可能好的设计 7.5 结论 参考文献 第八章 单一责任原则（SRP） 8.1 单一职责原则（SRP） 8.2 结论 参考文献 第九章 开放—封闭原则（OCP） 9.1 开放—封闭原则（OCP） 9.2 描述 9.3 关键是抽象 9.4 结论 参考文献 第十章 Liskov替换原则（LSP） 10.1 Liskov替换原则（LSP） 10.2 一个违反LSP的简单例子 10.3 正方形和矩形，更微妙的违规 10.4 一个实际的例子 10.5 用提取公共部分的方法代替继承 10.6 启发式规则和习惯用法 10.7 结论 参考文献 第十一章 依赖倒置原则（DIP） 11.1 依赖倒置原则（DIP） 11.2 层次化 11.3 一个简单的例子 11.4 熔炉示例 11.5 结论 参考文献 第十二章 接口隔离原则（ISP） 12.1 接口污染 12.2 分离客户就是分离接口 12.3 接口隔离原则（ISP） 12.4 类接口与对象接口 12.5 ATM用户界面的例子 12.6 结论 参考文献 第Ⅲ部分 薪水支付案例研究 第十三章 COMMAND模式和ACTIVE OBJECT模式 第十四章 TEMPLATE METHOD模式和STRATEGY模式：继承与委托 第十五章 FACADE模式和MEDIATOR模式 第十六章 SINGLETON模式和MONOSTATE模式 第十七章 NULL OBJECT模式 第十八章 薪水支付案例研究：第一次迭代开始 第十九章 薪水支付案例研究：实现 第Ⅳ部分 打包薪水支付系统 第二十章 包的设计原则 第二十一章 FACTORY模式 第二十二章 薪水支付案例研究（第2部分） 第Ⅴ部分 气象站案例研究 第二十三章 COMPOSITE模式 第二十四章 OBSERVER模式——回归为模式 第二十五章 ABSTRACT SERVER模式、ADAPTER模式和BRIDGE模式 第二十六章 PROXY模式和STAIRWAY TO HEAVEN模式：管理第三方API 第二十七章 案例研究：气象站 第Ⅵ部分 ETS案例研究 第二十八章 VISITOR模式 第二十九章 STATE模式 第三十章 ETS框架 附录 附录A UML表示法Ⅰ：CGI示例 附录B UML表示法Ⅱ：统计多路复用器 附录C 两个公司的讽刺小品 附录D 源代码就是设计 索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00116MMA8/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00116MMA8&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec8.images-amazon.com/images/I/51DLHZAZCkL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++游戏编程</title>
    <url>/2020/04/19/B00116FG1K/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C++游戏编程<br>作者信息： 作者: 略皮斯 （Llopis Noel） [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1部分 初识C＋＋威力第1章 继承1.1 类</span><br><span class="line">1.2 继承</span><br><span class="line">1.3 多态和虚函数</span><br><span class="line">1.4 是否使用继承</span><br><span class="line">1.5 使用或者避免使用继承的时机</span><br><span class="line">1.6 继承的实现（高级话题）</span><br><span class="line">1.7 性能分析（高级话题）</span><br><span class="line">1.8 替代方案（高级话题）</span><br><span class="line">1.9 程序架构和继承（高级话题）</span><br><span class="line">1.10 结论</span><br><span class="line">1.11 阅读建议第2章 多重继承2.1 使用多重继承</span><br><span class="line">2.2 多重继承的问题</span><br><span class="line">2.3 多态</span><br><span class="line">2.4 什么时候使用，什么时候避免多重继承</span><br><span class="line">2.5 多重继承的实现（高级话题）</span><br><span class="line">2.6 性能分析（高级话题）</span><br><span class="line">2.7 结论</span><br><span class="line">2.8 阅读建议第3章 常量及引用3.1 常量</span><br><span class="line">3.2 引用</span><br><span class="line">3.3 强制转换</span><br><span class="line">3.4 结论</span><br><span class="line">3.5 阅读建议第4章 模板4.1 寻找通用代码</span><br><span class="line">4.2 模板</span><br><span class="line">4.3 使用模板的不足之处</span><br><span class="line">4.4 使用模板的时机</span><br><span class="line">4.5 模板专门化（高级话题）</span><br><span class="line">4.6 结论</span><br><span class="line">4.7 阅读建议第5章 异常处理5.1 错误的处理</span><br><span class="line">5.2 异常的使用</span><br><span class="line">5.3 异常的保护代码</span><br><span class="line">5.4 异常的开销分析</span><br><span class="line">5.5 异常的使用时机</span><br><span class="line">5.6 结论</span><br><span class="line">5.7 阅读建议第2部分 性能和内存第6章 性能6.1 性能和优化</span><br><span class="line">6.2 函数类型</span><br><span class="line">6.3 函数内联</span><br><span class="line">6.4 函数开销更多的方面</span><br><span class="line">6.5 避免复制</span><br><span class="line">6.6 构造函数和析构函数</span><br><span class="line">6.7 数据缓存与内存对齐（高级话题）</span><br><span class="line">6.8 结论</span><br><span class="line">6.9 阅读建议第7章 内存分配7.1 栈</span><br><span class="line">7.2 堆</span><br><span class="line">7.3 静态分配</span><br><span class="line">7.4 动态分配</span><br><span class="line">7.5 定制内存管理</span><br><span class="line">7.6 内存池</span><br><span class="line">7.7 万一出现紧急情况（内存耗尽）</span><br><span class="line">7.8 结论</span><br><span class="line">7.9 阅读建议第8章 标准模板库——容器8.1 STL概述</span><br><span class="line">8.2 用还是不用STL</span><br><span class="line">8.3 序列式容器</span><br><span class="line">8.4 关联式容器</span><br><span class="line">8.5 容器适配器</span><br><span class="line">8.6 结论</span><br><span class="line">8.7 阅读建议第9章 STL算法及高级主题9.1 算符（函数对象）</span><br><span class="line">9.2 算法</span><br><span class="line">9.3 字符串</span><br><span class="line">9.4 分配算符（高级话题）</span><br><span class="line">9.5 当STL不满足要求时（高级话题）</span><br><span class="line">9.6 结论</span><br><span class="line">9.7 阅读建议第3部分 专门技术第10章 抽象接口10.1 抽象接口</span><br><span class="line">10.2 通用C＋＋实现</span><br><span class="line">10.3 作为绝缘层的抽象接口</span><br><span class="line">10.4 作为类特征的抽象接口</span><br><span class="line">10.5 其他方面</span><br><span class="line">10.6 结论</span><br><span class="line">10.7 阅读建议第11章 插件11.1 对插件的需要</span><br><span class="line">11.2 插件结构</span><br><span class="line">11.3 插件的组装</span><br><span class="line">11.4 插件的应用</span><br><span class="line">11.5 结论</span><br><span class="line">11.6 阅读建议第12章 运行期类型信息12.1 不使用RTTI进行工作</span><br><span class="line">12.2 使用RTTI</span><br><span class="line">12.3 标准C＋＋RTTI</span><br><span class="line">12.4 自定义RTTI系统</span><br><span class="line">12.5 结论</span><br><span class="line">12.6 阅读建议第13章 对象的创建与管理13.1 对象的创建</span><br><span class="line">13.2 对象工厂</span><br><span class="line">13.3 共享对象</span><br><span class="line">13.4 结论</span><br><span class="line">13.5 阅读建议第14章 对象的序列化14.1 游戏实体序列化概述</span><br><span class="line">14.2 游戏实体序列化的实现</span><br><span class="line">14.3 组装起来</span><br><span class="line">14.4 结论</span><br><span class="line">14.5 阅读建议第15章 处理大型项目15.1 逻辑结构与物理结构</span><br><span class="line">15.2 类和文件</span><br><span class="line">15.3 头文件</span><br><span class="line">15.4 库</span><br><span class="line">15.5 配置</span><br><span class="line">15.6 结论</span><br><span class="line">15.7 阅读建议第16章 防止游戏崩溃16.1 使用断言</span><br><span class="line">16.2 刷新机器状态</span><br><span class="line">16.3 处理“坏”数据</span><br><span class="line">16.4 结论</span><br><span class="line">16.5 阅读建议关于附带光盘</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00116FG1K/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00116FG1K&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51l5eGeDv2L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>人月神话</title>
    <url>/2020/04/19/B0011C2P7W/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 人月神话<br>作者信息： 作者: 弗雷德里克•布鲁克斯 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《人月神话》编辑推荐：又见人月神话，重温软工经典”。1.软件领域绝无仅有，32年之后依旧畅销不衰的传奇经典！2.软件开发人员、软件项目经理、系统分析师必读的一本书！《人月神话》读者包括：软件开发人员、软件项目经理、系统分析师等IT从业者。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 焦油坑</span><br><span class="line">编程系统产品</span><br><span class="line">职业的乐趣</span><br><span class="line">职业的苦恼</span><br><span class="line">第2章 人月神话</span><br><span class="line">乐观主义</span><br><span class="line">人月</span><br><span class="line">系统测试</span><br><span class="line">空泛的估算</span><br><span class="line">重复产生的进度灾难</span><br><span class="line">第3章 外科手术队伍</span><br><span class="line">问题</span><br><span class="line">Mills的建议</span><br><span class="line">如何运作</span><br><span class="line">团队的扩建</span><br><span class="line">第4章 贵族专制、民主政治和系统设计</span><br><span class="line">概念的完整性</span><br><span class="line">获得概念的完整性</span><br><span class="line">贵族专制统治和民主政治</span><br><span class="line">在等待时，实现人员应该做什么</span><br><span class="line">第5章 画蛇添足</span><br><span class="line">结构师的交互准则和机制</span><br><span class="line">自律——开发第二个系统所带来的后果</span><br><span class="line">第6章 贯彻执行</span><br><span class="line">文档化的规格说明——手册</span><br><span class="line">形式化定义</span><br><span class="line">直接整合</span><br><span class="line">会议和大会</span><br><span class="line">多重实现</span><br><span class="line">电话日志</span><br><span class="line">产品测试</span><br><span class="line">第7章 为什么巴比伦塔会失败</span><br><span class="line">巴比伦塔的管理教训</span><br><span class="line">大型编程项目中的交流</span><br><span class="line">项目工作手册</span><br><span class="line">大型编程项目的组织架构</span><br><span class="line">第8章 胸有成竹</span><br><span class="line">第9章 削足适履</span><br><span class="line">第10章 提纲挈领</span><br><span class="line">第11章 未雨绸缪</span><br><span class="line">第12章 干将莫邪</span><br><span class="line">第13章 整体部分</span><br><span class="line">第14章 祸起萧墙</span><br><span class="line">第15章 另外一面</span><br><span class="line">第16章 没有银弹</span><br><span class="line">第17章 再论“没有银弹”</span><br><span class="line">第18章 《人月神话》的观点：是与非？</span><br><span class="line">第19章 20年后的《人月神话》</span><br><span class="line">结束语：令人向往、激动人心和充满乐趣的50年</span><br><span class="line">注解与参考文献</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0011C2P7W/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0011C2P7W&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41uKeLDawFL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机程序的构造和解释(原书第2版)</title>
    <url>/2020/04/19/B0011AP7RY/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 计算机程序的构造和解释(原书第2版)<br>作者信息： 作者: 艾伯森 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《计算机程序的构造和解释(原书第2版)》自出版以来，世界各地已有100多所院校采用《计算机程序的构造和解释(原书第2版)》做教材，其中包括美国斯坦福大学、美国普林斯顿大学、英国牛津大学、日本东京大学等。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">出版者的话 专家指导委员会 序 第2版前言 第1版前言 致谢 第1章 构造过程抽象 1.1 程序设计的基本元素 1.2 过程与它们所产生的计算 1.3 用高阶函数做抽象 第2章 构造数据现象 2.1 数据抽象导引 2.2 层次性数据和闭包性质 2.3 符号数据 2.4 抽象数据的多重表示 2.5 带有通用型操作的系统 第3章 模块化、对象和状态 3.1 赋值和局部状态 3.2 求值的环境模型 3.3 用变动数据做模拟 3.4 并发：时间是一个本质问题 3.5 流 第4章 元语言抽象 4.1 元循环求值器 4.2 Scheme的变形——惰性求值 4.3 Scheme的变形——非确定性计算 4.4 逻辑程序设计 第5章 寄存器机器里的计算 5.1 寄存器机器的设计 5.2 一个寄存器机器模拟器 5.3 存储分配和废料收集 5.4 显式控制的求值器 5.5 编译 参考文献 练习表 索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0011AP7RY/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0011AP7RY&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/5101vl17BkL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法分析 C++语言描述(第2版)</title>
    <url>/2020/04/19/B0011CFNOE/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 数据结构与算法分析 C++语言描述(第2版)<br>作者信息： 作者: 奈霍夫 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>数据结构是计算机科学专业的核心课程之一。对数据结构的传统学习，拓展到了抽象数据类型的学习。    《数据结构与算法分析:C++语言描述》(第2版)可作为大专院校计算机或软件专业的教材，也可以作为从事计算机工程与应用的科技人员的参考用书。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章  软件开发</span><br><span class="line">第2章  抽象数据类型入门</span><br><span class="line">第3章  数据结构和抽象数据类型</span><br><span class="line">第4章  OOP和ADT进阶——类</span><br><span class="line">第5章  标准C++输入&#x2F;输出和字符串类</span><br><span class="line">第6章  列表</span><br><span class="line">第7章  栈</span><br><span class="line">第8章  队列</span><br><span class="line">第9章  ADT实现：模板和标准容器</span><br><span class="line">第10章  ADT实现——递归、算法分析以及标准算法</span><br><span class="line">第11章  其他链表结构</span><br><span class="line">第12章  二叉树和散列表</span><br><span class="line">第13章  排序</span><br><span class="line">第14章  OOP和ADT</span><br><span class="line">第15章  树</span><br><span class="line">第16章  图和有向图 </span><br><span class="line"></span><br><span class="line"> 附录A ASCII字符集 附录B 小测验答案</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0011CFNOE/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0011CFNOE&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51ElF87FYUL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Reversing 逆向工程揭密</title>
    <url>/2020/04/19/B0011F60C0/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Reversing 逆向工程揭密<br>作者信息： 作者: 杨艳 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Reversing:逆向工程揭密》适合软件逆向工程的从业人员以及软件开发者们阅读。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1部分 逆向</span><br><span class="line">　第1章 基础</span><br><span class="line">　　1.1 什么是逆向工程</span><br><span class="line">　　1.2 软件逆向工程：逆向</span><br><span class="line">　　1.3 逆向应用</span><br><span class="line">　　　1.3.1 与安全相关的逆向</span><br><span class="line">　　　1.3.2 软件开发中的逆向</span><br><span class="line">　　1.4 底层软件</span><br><span class="line">　　　1.4.1 汇编语言</span><br><span class="line">　　　1.4.2 编译器</span><br><span class="line">　　　1.4.3 虚拟机和字节码</span><br><span class="line">　　　1.4.4 操作系统</span><br><span class="line">　　1.5 逆向过程</span><br><span class="line">　　　1.5.1 系统级逆向</span><br><span class="line">　　　1.5.2 代码级逆向</span><br><span class="line">　　1.6 工具</span><br><span class="line">　　　1.6.1 系统监控工具</span><br><span class="line">　　　1.6.2 反汇编器</span><br><span class="line">　　　1.6.3 调试器</span><br><span class="line">　　　1.6.4 反编译器</span><br><span class="line">　　1.7 逆向合法吗？</span><br><span class="line">　　　1.7.1 互操作性</span><br><span class="line">　　　1.7.2 竞争</span><br><span class="line">　　　1.7.3 版权法</span><br><span class="line">　　　1.7.4 商业机密和专利权</span><br><span class="line">　　　1.7.5 美国数字千禧版权法</span><br><span class="line">　　　1.7.6 DMCA案例</span><br><span class="line">　　　1.7.7 许可证协议</span><br><span class="line">　　1.8 代码范例与工具</span><br><span class="line">　　1.9 结论</span><br><span class="line">　第2章 底层软件</span><br><span class="line">　　2.1 高阶视角</span><br><span class="line">　　　2.1.1 程序结构</span><br><span class="line">　　　2.1.2 数据管理</span><br><span class="line">　　　2.1.3 控制流</span><br><span class="line">　　　2.1.4 高级语言</span><br><span class="line">　　2.2 低阶视角</span><br><span class="line">　　　2.2.1 底层数据管理</span><br><span class="line">　　　2.2.2 控制流</span><br><span class="line">　　2.3 汇编语言</span><br><span class="line">　　　2.3.1 寄存器</span><br><span class="line">　　　2.3.2 标志位</span><br><span class="line">　　　2.3.3 指令格式</span><br><span class="line">　　　2.3.4 基本指令</span><br><span class="line">　　　2.3.5 范例</span><br><span class="line">　　2.4 编译器和编译入门</span><br><span class="line">　　　2.4.1 定义编译器</span><br><span class="line">　　　2.4.2 编译器架构</span><br><span class="line">　　　2.4.3 列表文件</span><br><span class="line">　　　2.4.4 专用编译器</span><br><span class="line">　　2.5 执行环境</span><br><span class="line">　　　2.5.1 软件执行环境（虚拟机）</span><br><span class="line">　　　2.5.2 现代处理器的硬件执行环境</span><br><span class="line">　　2.6 结论</span><br><span class="line">　第3章 Windows基础知识</span><br><span class="line">　第4章 逆向工具</span><br><span class="line">第2部分 应用逆向</span><br><span class="line">　第5章 未公开的技术</span><br><span class="line">　第6章 破译文件格式</span><br><span class="line">　第7章 审查程序的二进制码</span><br><span class="line">　第8章 逆向恶意软件</span><br><span class="line">第3部分 破解</span><br><span class="line">　第9章 盗版与拷贝保护</span><br><span class="line">　第10章 反逆向技术</span><br><span class="line">　第11章 突破保护</span><br><span class="line">第4部分 反汇编之外</span><br><span class="line">　第12章 逆向.NET</span><br><span class="line">　第13章 反编译</span><br><span class="line">附录A 揭密代码结构</span><br><span class="line">附录B 理解编译后的算术运算</span><br><span class="line">附录C 破译程序数据</span><br><span class="line">索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0011F60C0/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0011F60C0&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51LfAgSi01L._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title>修改代码的艺术</title>
    <url>/2020/04/19/B0011F5B98/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 修改代码的艺术<br>作者信息： 作者: 平均4.0 星  [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>修改代码的集大成之作.Amazon全五星图书..适用于各种语言或平台… 《修改代码的艺术》是继《重构》和《重构与模式》之后探讨修改代码技术的又一里程碑式的著作，而且从广度和深度上都超过了前两部经典。书中不仅讲述了面向对象语言(Java、C#和C++)代码，也有专章讨论C这样的过程式语言。作者将理解、测试和修改代码的原理、技术和最新工具(自动化重构工具、单元测试框架、仿对象、集成测试框架等)与解依赖技术及大量开发和设计优秀代码的原则、最佳实践相结合，许多内容非常深入，而且常常发前人所未发。书中处处体现出作者独到的洞察力，以及多年开发和指导软件项目所积累的丰富经验和深厚功力。通过这部集大成之作，你不仅能掌握最顶尖的修改代码技术，还可以大大提高对代码和软件开发的领悟力。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分　修改机理</span><br><span class="line">第1章　修改软件</span><br><span class="line">第2章　带着反馈工作</span><br><span class="line">第3章　感知和分离</span><br><span class="line">第4章　接缝模型</span><br><span class="line">第5章　工具 </span><br><span class="line"></span><br><span class="line"> 第二部分　修改代码的技术 第6章　时间紧迫、但必须修改 第7章　漫长的修改 第8章　添加特性 第9章　无法将类放入测试用具中 第10章　无法在测试用具中运行方法 第11章　修改时应当测试哪些方法　 第12章　在同一地进行多处测试、是否应该将相关的所有类都解依赖 第13章　修改时应该怎样写测试　 第14章　棘手的库依赖问题 第15章　到处都是API调用　 第16章　对代码的理解不足 第17章　应用毫无结构可言 第18章　测试代码碍手碍脚　 第19章　对非面向对象的项目、如何安全地对它进行修改 第20章　处理大类 第21章　需要修改大量相同的代码　 第22章　要修改一个巨型方法，却没法为它编写测试　 第23章　降低修改的风险 第24章　当你感到绝望明</span><br><span class="line"></span><br><span class="line"> 第三部分　解依赖技术 第24章　解依赖技术 附录　重构 术语表 索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0011F5B98/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0011F5B98&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51KtYvxuEyL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出JavaScript</title>
    <url>/2020/04/19/B001HN6FGC/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 深入浅出JavaScript<br>作者信息： 作者: 莫里森 (Michael Morrison) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《深入浅出JavaScript》由东南大学出版社出版。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Intro xxiii </span><br><span class="line">1 the interactive web: Reacting to the Virtual World 1</span><br><span class="line">2 storing data: Everything Has Its Place 33</span><br><span class="line">3 exploring the client: Browser Spelunking 85</span><br><span class="line">4 decision making: If There’s a Fork in the Road, Take It .. 135</span><br><span class="line">5 looping: At the Risk of Repeating Myself 189</span><br><span class="line">6 functions: Reduce, Reuse, Recycle 243</span><br><span class="line">7 forms and validation: Getting the User to Tell All 289</span><br><span class="line">8 wrangling the page: Slicing and Dicing HTML with the DOM 343</span><br><span class="line">9 bringing data to life: Objects as Frankendata 393</span><br><span class="line">10 creating custom objects: Having It Your Way with Custom Objects 449</span><br><span class="line">11 kill bugs dead: Good Scripts Gone Wrong 485</span><br><span class="line">12 dynamic data: Touchy-Feely Web Applications 537</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001HN6FGC/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001HN6FGC&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51bKKbJwSXL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>走出软件作坊(IT人升职必备)</title>
    <url>/2020/04/19/B001N2M502/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 走出软件作坊(IT人升职必备)<br>作者信息： 作者: 浏览全部评论  [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《走出软件作坊》使本土创业团队自力更求解放，国内中小企业艰难突围好榜样。《走出软件作坊》主要读者对象是IT企业的研发主管、项目经理和软件开发人员，以及即将到IT企业工作的高校毕业生。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">引子——这本书适合谁</span><br><span class="line">组织结构篇</span><br><span class="line">双龙会——CTO与技术总监</span><br><span class="line">人，是人，真的是人——团队文化</span><br><span class="line">四套马车——团队配合</span><br><span class="line">大长今——项目经理</span><br><span class="line">走钢索的人——架构师 </span><br><span class="line"></span><br><span class="line"> 过程管理篇 一个人在战斗——老系统维护 兄弟连——项目开发 我要飞得更高——新产品战略 波、波、波——产品生命周期 定风波——产品定位 焦油坑——项目需求调研 文档知多少——设计文档编写方法 沙场秋点兵——开发团队练兵 百变金刚——企业业务开发平台架构 代码那些事儿——代码编写规范 风语者——软件测试 蛋白质女孩——产品文案 恶魔吹着笛子来——售前经理 修女也疯狂——售前、项目管理、实施适用的演示方法 水至清则无鱼——软件费用报价方法 量贩式实施一实施费用报价方法 将服务费用进行到底——服务费用报价方法 黑衣人——打造实施顾问 实施经理的工具箱——实施过程管理 灯塔客户——试点实施 客服顾问的工具箱——客服支持</span><br><span class="line"></span><br><span class="line"> 激励考核篇 那根胡萝卜——团队激励 一天到晚游泳的鱼——员工绩效考核</span><br><span class="line"></span><br><span class="line"> 职业发展篇 七里香——新人入职手册 敢问路在何方——员工职业发展出路 财主家也没有余粮了——创业小作坊职业发展出路 终结者——CTO职业发展出路</span><br><span class="line"></span><br><span class="line"> 未来趋势篇 兵临城下——未来企业管理软件领域的新挑战 像咨询师一样思考——发展IT咨询业务 无间道——未来不会再有研发和销售 轻骑兵——未来软件开发模式 沙尘暴——令人焦虑的技术时代 色即是空——虚公司</span><br><span class="line"></span><br><span class="line"> 心路成长篇 我就是一个香港导演——关联性思维 方法为什么——皆在一个“心”字 懈寄生——帮助过我的那些书那些人 一分钟先生——自我时间管理 达芬奇密码——从游击队到正规军 亢龙有悔——方法反思 ……</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001N2M502/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001N2M502&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/412sKNOCcqL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>职场</tag>
      </tags>
  </entry>
  <entry>
    <title>HeadFirst设计模式(中文版)</title>
    <url>/2020/04/19/B0011FBU34/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： HeadFirst设计模式(中文版)<br>作者信息： 作者: 弗里曼 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Head First设计模式(中文版)》编辑推荐：强大的写作阵容。《Head First设计模式(中文版)》作者Eric Freeman；ElElisabeth Freeman是作家、讲师和技术顾问。Eric拥有耶鲁大学的计算机科学博士学位，E1isabath拥有耶鲁大学的计算机科学硕士学位。Kathy Sierra FHBert Bates是畅销的HeadFirst系列书籍的创立者，也是Sun公司Java开发员认证考试的开发者。《Head First设计模式(中文版)》的产品设计应用神经生物学、认知科学，以及学习理论，这使得此书能够将这些知识深深地印在你的脑海里，不容易被遗忘。《Head First设计模式(中文版)》的编写方式采用引导式教学，不直接告诉你该怎么做，而是利用故事当作引子，带领读者思考并想办法解决问题。解决问题的过程中又会产生一些新的问题，再继续思考、继续解决问题，这样可以加深体会。作者以大量的生活化故事当背景，例如第1章是鸭子，第2章是气象站，第3章是咖啡店，书中搭配大量的插图(几乎每一页都有图)，所以阅读起来生动有趣，不会感觉到昏昏欲睡。作者还利用歪歪斜斜的手写字体，增加“现场感”。精心设计许多爆笑的对白，让学习过程不会太枯燥。还有模式告白节目，将设计模式拟人化成节目来宾，畅谈其内在的一切。《Head First设计模式(中文版)》大量采用uML的class Diagram(Static Structure Diagram)。书中的例子程序虽然都是用JaVa编写，但是《Head First设计模式(中文版)》所介绍的内容对于任何00语言的用户都适用，包括c++和c孝。每一章都有数目不等的测验题。每章最后有一页要点整理，这也是精华所在，我都是利用这一页做复习。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">概览</span><br><span class="line">引子</span><br><span class="line">1 设计模式入门 欢迎来到设计模式世界</span><br><span class="line">2 观察者模式 让你的对象知悉现况</span><br><span class="line">3 装饰者模式 装饰对象</span><br><span class="line">4 工厂模式 烘烤OO的精华</span><br><span class="line">5 单件模式 独一无二的对象</span><br><span class="line">6 命令模式 封装调用</span><br><span class="line">7 适配器模式与外观模式 随遇模式</span><br><span class="line">8 模板方法模式 封装算法</span><br><span class="line">9 选代器与组合模式 管理良好的集合</span><br><span class="line">10 状态模式 事物的状态</span><br><span class="line">11 代理模式 控制对象访问</span><br><span class="line">12 复合模式 模式中的模型</span><br><span class="line">13 与设计模式相处 真实世界中的模式</span><br><span class="line">附录A：剩下的模式</span><br><span class="line">索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0011FBU34/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0011FBU34&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51oPLkauKuL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>编程珠玑(第2版)</title>
    <url>/2020/04/19/B001GNBZFE/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 编程珠玑(第2版)<br>作者信息： 作者: Jon Bentley [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《编程珠玑(第2版)》的特色是通过一些精心设计的有趣而又颇具指导意义的程序，对实用程序设计技巧及基本设计原则进行了透彻而睿智的描述，为复杂的编程问题提供了清晰而完备的解决思路。《编程珠玑(第2版)》对各个层次的程序员都具有很高的阅读价值。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分 基础</span><br><span class="line">第1章 开篇 3</span><br><span class="line">1.1 一次友好的对话 3</span><br><span class="line">1.2 准确的问题描述 4</span><br><span class="line">1.3 程序设计 4</span><br><span class="line">1.4 实现概要 5</span><br><span class="line">1.5 原理 6</span><br><span class="line">1.6 习题 7</span><br><span class="line">1.7 深入阅读 9 </span><br><span class="line"></span><br><span class="line"> 第2章 啊哈! 算法 11 2.1 三个问题 11 2.2 无处不在的二分搜索 12 2.3 基本操作的威力 13 2.4 排序 15 2.5 原理 16 2.6 习题 17 2.7 深入阅读 18 2.8 变位词程序的实现(边栏) 18</span><br><span class="line"></span><br><span class="line"> 第3章 数据决定程序结构 21 3.1 一个调查程序 21 3.2 格式信函编程 23 3.3 一组示例 25 3.4 结构化数据 26 3.5 用于特殊数据的强大工具 27 3.6 原理 28 3.7 习题 29 3.8 深入阅读 30</span><br><span class="line"></span><br><span class="line"> 第4章 编写正确的程序 33 4.1 二分搜索的挑战 33 4.2 编写程序 34 4.3 理解程序 36 4.4 原理 38 4.5 程序验证的角色 39 4.6 习题 40 4.7 深入阅读 42</span><br><span class="line"></span><br><span class="line"> 第5章 编程小事 43 5.1 从伪代码到C程序 43 5.2 测试工具 44 5.3 断言的艺术 46 5.4 自动测试 48 5.5 计时 49 5.6 完整的程序 50 5.7 原理 51 5.8 习题 51 5.9 深入阅读 52 5.10 调试(边栏) 53</span><br><span class="line"></span><br><span class="line"> 第二部分 性能 第6章 程序性能分析 57 6.1 实例研究 57 6.2 设计层面 59 6.3 原理 60 6.4 习题 61 6.5 深入阅读 61</span><br><span class="line"></span><br><span class="line"> 第7章 粗略估算 63 7.1 基本技巧 64 7.2 性能估计 66 7.3 安全系数 68 7.4 Little定律 69 7.5 原理 70 7.6 习题 70 7.7 深入阅读 71 7.8 日常生活中的速算(边栏) 72</span><br><span class="line"></span><br><span class="line"> 第8章 算法设计技术 73 8.1 问题及简单算法 73 8.2 两个平方算法 74 8.3 分治算法 75 8.4 扫描算法 77 8.5 实际运行时间 77 8.6 原理 79 8.7 习题 80 8.8 深入阅读 81</span><br><span class="line"></span><br><span class="line"> 第9章 代码调优 83 9.1 典型的故事 83 9.2 急救方案集锦 84 9.3 大手术——二分搜索 88 9.4 原理 91 9.5 习题 92 9.6 深入阅读 94</span><br><span class="line"></span><br><span class="line"> 第10章 节省空间 95 10.1 关键在于简单 95 10.2 示例问题 96 10.3 数据空间技术 99 10.4 代码空间技术 101 10.5 原理 103 10.6 习题 104 10.7 深入阅读 105 10.8 巨大的节省(边栏) 105</span><br><span class="line"></span><br><span class="line"> 第三部分 应用 第11章 排序 109 11.1 插入排序 109 11.2 一种简单的快速排序 110 11.3 更好的几种快速排序 113 11.4 原理 115 11.5 习题 116 11.6 深入阅读 117</span><br><span class="line"></span><br><span class="line"> 第12章 取样问题 119 12.1 问题 119 12.2 一种解决方案 120 12.3 设计空间 121 12.4 原理 123 12.5 习题 124 12.6 深入阅读 125</span><br><span class="line"></span><br><span class="line"> 第13章 搜索 127 13.1 接口 127 13.2 线性结构 129 13.3 二分搜索树 132 13.4 用于整数的结构 134 13.5 原理 135 13.6 习题 136 13.7 深入阅读 137 13.8 一个实际搜索问题(边栏) 137</span><br><span class="line"></span><br><span class="line"> 第14章 堆 141 14.1 数据结构 141 14.2 两个关键函数 143 14.3 优先级队列 145 14.4 一种排序算法 148 14.5 原理 150 14.6 习题 150 14.7 深入阅读 152</span><br><span class="line"></span><br><span class="line"> 第15章 字符串 153 15.1 单词 153 15.2 短语 156 15.3 生成文本 158 15.4 原理 163 15.5 习题 163 15.6 深入阅读 164 第1版跋 165 第2版跋 167 附录A 算法分类 169 附录B 估算测试 173 附录C 时空开销模型 175 附录D 代码调优法则 181 附录E 用于搜索的C++类 187 部分习题提示 191 部分习题答案 195 索引 221</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001GNBZFE/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001GNBZFE&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41XWr5AKHDL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理(第2版)</title>
    <url>/2020/04/19/B001NGO85I/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 编译原理(第2版)<br>作者信息： 作者: Alfred V. Aho [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《编译原理(第2版)》是编译领域无可替代的经典著作，被广大计算机专业人士誉为“龙书”。《编译原理(第2版)》上一版自1986年出版以来，被世界各地的著名高等院校和研究机构（包括美国哥伦比亚大学、斯坦福大学、哈佛大学、普林斯顿大学、贝尔实验室）作为本科生和研究生的编译原理课程的教材。该书对我国高等计算机教育领域也产生了重大影响。编译领域里程碑式的经典著作——龙书，20年后终于出版新版！这是一个延绵30年的故事，这是一部关于龙书的传奇！最新版本，增添两章节内容，使龙书地位更权威！第2版对每一章都进行了全面的修订，以反映自上一版出版20多年来软件工程。程序设计语言和计算机体系结构方面的发展对编译技术的影响。《编译原理(第2版)》全面介绍了编译器的设计，并强调编译技术在软件设计和开发中的广泛应用。每章中都包含大量的习题和丰富的参考文献。1977年，Alfred V.Aho和Jeffrey D.Ullman合作出版了《Principies of Compilet Design》，封面是一位骑士和一只恐龙，那恐龙是绿色的，因此被称为龙书或绿龙书。1986年，原来的两位作者加上Ravi Sethi，升级了前一《编译原理(第2版)》，书名改为《compi Iers：Principles，Techniques and Tools》，封面依然沿用骑士和恐龙，那恐龙是红色的，因此被称为龙书二或者红龙书。又过了一个9年又一个9年，编译领域的巨无霸——龙书始终都没有升级。终于在2006年底，龙书升级了。作者又增加了Monica S.Lam，名字与龙书二相同，封面依然沿用恐龙和武士的设计，这次的龙是紫色的，因此被称为龙书三或者紫龙书。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">出版者的话</span><br><span class="line">译者序</span><br><span class="line">前言</span><br><span class="line">第1章 引论</span><br><span class="line">1.1 语言处理器</span><br><span class="line">1.2 一个编译器的结构</span><br><span class="line">1.2.1 词法分析</span><br><span class="line">1.2.2 语法分析</span><br><span class="line">1.2.3 语义分析</span><br><span class="line">1.2.4 中间代码生成</span><br><span class="line">1.2.5 代码优化</span><br><span class="line">1.2.6 代码生成</span><br><span class="line">1.2.7 符号表管理</span><br><span class="line">1.2.8 将多个步骤组合成趟</span><br><span class="line">1.2.9 编译器构造工具 </span><br><span class="line"></span><br><span class="line"> 1.3 程序设计语言的发展历程 1.3.1 走向高级程序设计语言 1.3.2 对编译器的影响 1.3.3 1.3 节的练习</span><br><span class="line"></span><br><span class="line"> 1.4 构建一个编译器的相关科学 1.4.1 编译器设计和实现中的建模 1.4.2 代码优化的科学</span><br><span class="line"></span><br><span class="line"> 1.5 编译技术的应用 1.5.1 高级程序设计语言的实现 1.5.2 针对计算机体系结构的优化 1.5.3 新计算机体系结构的设计 1.5.4 程序翻译 1.5.5 软件生产率工具</span><br><span class="line"></span><br><span class="line"> 1.6 程序设计语言基础 1.6.1 静态和动态的区别 1.6.2 环境与状态 1.6.3 静态作用域和块结构 1.6.4 显式访问控制 1.6.5 动态作用域 1.6.6 参数传递机制 1.6.7 别名 1.6.8 1.6 节的练习 1.7 第1章的总结 1.8 第1章的参考书目</span><br><span class="line"></span><br><span class="line"> 第2章 一个简单的语法制导翻译器 2.1 引言 2.2 语法定义 2.2.1 文法定义 2.2.2 推导 2.2.3 语法分析树 2.2.4 二义性 2.2.5 运算符的结合性 2.2.6 运算符的优先级 2.2.7 2.2 节的练习</span><br><span class="line"></span><br><span class="line"> 2.3 语法制导翻译 2.3.1 后缀表示 2.3.2 综合属性 2.3.3 简单语法制导定义 2.3.4 树的遍历 2.3.5 翻译方案 2.3.6 2.3 节的练习</span><br><span class="line"></span><br><span class="line"> 2.4 语法分析 2.4.1 自顶向下分析方法 2.4.2 预测分析法 2.4.3 何时使用产生式 2.4.4 设计一个预测语法分析器 2.4.5 左递归 2.4.6 2.4 节的练习</span><br><span class="line"></span><br><span class="line"> 2.5 简单表达式的翻译器 2.5.1 抽象语法和具体语法 2.5.2 调整翻译方案 2.5.3 非终结符号的过程 2.5.4 翻译器的简化 2.5.5 完整的程序</span><br><span class="line"></span><br><span class="line"> 2.6 词法分析 2.6.1 剔除空白和注释 2.6.2 预读 2.6.3 常量 2.6.4 识别关键字和标识符 2.6.5 词法分析器 2.6.6 2.6 节的练习</span><br><span class="line"></span><br><span class="line"> 2.7 符号表 2.7.1 为每个作用域设置一个符号表 2.7.2 符号表的使用 2.8 中间代码生成 2.8.1 两种中间表示形式 2.8.2 语法树的构造 2.8.4 三地址码 2.8.5 2.8 节的练习 2.9 第2章的总结</span><br><span class="line"></span><br><span class="line"> 第3章 词法分析 3.1 词法分析器的作用 3.1.1 词法分析及解析 3.1.2 词法单元、模式、词素 3.1.3 词法单元的属性 3.1.4 词法错误 3.1.5 3.1 节的练习</span><br><span class="line"></span><br><span class="line"> 3.2 输入缓冲 3.2.1 缓冲区对 3.2.2 哨兵标记</span><br><span class="line"></span><br><span class="line"> 3.3 词法单元的规约 3.3.1 串和语言 3.3.2 语言上的运算 3.3.3 正则表达式 3.3.4 正则定义 3.3.5 正则表达式的扩展 3.3.6 3.3 节的练习</span><br><span class="line"></span><br><span class="line"> 3.4 词法单元的识别 3.4.1 状态转换图 3.4.2 保留字和标识符的识别 3.4.3 完成我们的连续性例子 3.4.4 基于状态转换图的词法分析器的体系结构 3.4.5 3.4 节的练习</span><br><span class="line"></span><br><span class="line"> 3.5 词法分析器生成工具Lex 3.5.1 Lex的使用 3.5.2 Lex程序的结构 3.5.3 Lex中的冲突解决 3.5.4 向前看运算符 3.5.5 3.5 节练习</span><br><span class="line"></span><br><span class="line"> 3.6 有穷自动机 3.6.1 不确定的有穷自动机 3.6.2 转换表 3.6.3 NFA接受输入字符串 3.6.4 确定的有穷自动机 3.6.5 3.6 节的练习</span><br><span class="line"></span><br><span class="line"> 3.7 从正则表达式到自动机 3.7.1 从NFA到DFA的转换 3.7.2 NFA的模拟 3.7.3 NFA模拟效率 3.7.4 从正则表达式构造NFA 3.7.5 字符串处理算法的效率 3.7.6 3.7 节的练习</span><br><span class="line"></span><br><span class="line"> 3.8 词法分析器生成工具的设计 3.8.1 被生成的词法分析器的结构 3.8.2 基于NFA的模式匹配 3.8.3 词法分析器使用的DFA 3.8.4 实现向前看运算符 3.8.5 3.8 的练习</span><br><span class="line"></span><br><span class="line"> 3.9 基于DFA的模式匹配器的优化 3.9.1 NFA的重要状态 3.9.2 根据抽象语法树计算得到的函数 3.9.3 计算nullable、firstpos及lastpos 3.9.4 计算followpos 3.9.5 根据正则表达式构建DFA 3.9.6 最小化一个DFA的状态数 3.9.7 词法分析器的状态最小化 3.9.8 在DFA模拟中用时间换取空间 3.9.9 3.9 节的练习 3.9.10 第3章的总结 3.11 第3章参考文献</span><br><span class="line"></span><br><span class="line"> 第4章 语法分析 4.1 引论 4.1.1 语法分析器的角色 4.1.2 代表性的文法 4.1.3 语法错误的处理 4.1.4 错误恢复策略</span><br><span class="line"></span><br><span class="line"> 4.2 上下文无关文法 4.2.1 上下文无关文法的正式定义 4.2.2 符号表示的惯例 4.2.3 推导 4.2.4 语法分析树和推导 4.2.5 二义性 4.2.6 验证文法生成的语言 4.2.7 上下文无关文法和正则表达式 4.2.8 4.2 节的练习</span><br><span class="line"></span><br><span class="line"> 4.3 设计文法 4.3.1 词法分析和语法分析 4.3.2 消除二义性 4.3.3 左递归的消除 4.3.4 提取左公因子 4.3.5 非上下文无关的语言构造 4.3.6 4.3 节的练习</span><br><span class="line"></span><br><span class="line"> 4.4 自顶向下的语法分析 4.4.1 递归下降的语法分析 4.4.2 FIRST和FOLLOW 4.4.3 LL(1)文法 4.4.4 非递归的预测分析 4.4.5 预测分析中的错误恢复 4.4.6 4.4 节的练习</span><br><span class="line"></span><br><span class="line"> 4.5 自底向上的语法分析 4.5.1 归约 4.5.2 句柄剪枝 4.5.3 移入-归约语法分析技术 4.5.4 移入-归约语法分析中的冲突 4.5.5 4.5 节的练习</span><br><span class="line"></span><br><span class="line"> 4.6 LR语法分析技术介绍：简单LR技术 4.6.1 为什么使用LR语法分析器？ 4.6.2 项和LR(0)自动机 4.6.3 LR-语法分析算法 4.6.4 构造SLR-分析表 4.6.5 可行前缀 4.6.6 4.6 节的练习</span><br><span class="line"></span><br><span class="line"> 4.7 更强大的LR语法分析器 4.7.1 规范LR(1)项 4.7.2 构造LR(1)项集 4.7.3 规范LR(1)分析表 4.7.4 构造LALR语法分析表 4.7.5 LALR语法分析表的高效构造方法 4.7.6 LR语法分析表的压缩 4.7.7 4.7 节的练习</span><br><span class="line"></span><br><span class="line"> 4.8 使用二义性文法 4.8.1 用优先级和结合性解决冲突 4.8.2 “悬空-else”二义性 4.8.3 LR语法分析中的错误恢复 4.8.4 4.8 节的练习</span><br><span class="line"></span><br><span class="line"> 4.9 语法分析器的生成工具 4.9.1 语法分析器的生成工具Yacc 4.9.2 使用Yacc处理二义性文法 4.9.3 用Lex创建Yacc的词法分析器 4.9.4 Yacc中的错误恢复 4.9.5 4.9节的练习 4.10：第4章的小结 4.11 第4章的参考文献</span><br><span class="line"></span><br><span class="line"> 第5章 语法制导的翻译 5.1 语法制导定义 5.1.1 继承属性和综合属性 5.1.2 在一棵语法分析树的结点上对一个SDD求值 5.1.3 5.1 节的练习</span><br><span class="line"></span><br><span class="line"> 5.2 SDD的求值顺序 5.2.1 依赖图 5.2.2 属性求值的顺序 5.2.3 S-属性定义 5.2.4 L-属性定义 5.2.5 具有受控副作用的语义规则 5.2.6 5.2 节的练习</span><br><span class="line"></span><br><span class="line"> 5.3 语法制导翻译的应用 5.3.1 抽象语法树的构造 5.3.2 类型的结构 5.3.3 5.3 节的练习</span><br><span class="line"></span><br><span class="line"> 5.4 语法制导的翻译方案 5.4.1 后缀翻译方案 5.4.2 后缀SDT的语法分析栈实现 5.4.3 产生式内部带有语义动作的SDT 5.4.4 从SDT中消除左递归 5.4.5 L-属性定义的SDT 5.4.6 5.4 节的练习</span><br><span class="line"></span><br><span class="line"> 5.5 实现L-属性的SDD 5.5.1 在递归下降语法分析过程中进行翻译 5.5.2 边扫描边生成代码 5.5.3 L-属性的SDD和LL语法分析 5.5.4 L-属性的SDD的自底向上语法分析 5.5.5 5.5 节的练习 5.6 第5章的总结 5.7 第5章的参考文献 第6章 中间代码生成 第7章 运行时刻环境 第7章 总结 第8章 代码生成 第9章 机器无关优化 第10章 指令级并行 第11章 并行性和局部性的优化 第12章 过程间分析</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001NGO85I/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001NGO85I&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51Bv6BJig-L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机科学概论</title>
    <url>/2020/04/19/B001TDM10Y/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 计算机科学概论<br>作者信息： 作者: 戴尔 (Nell Dale) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《计算机科学概论》采用大量最新素材，全面介绍计算机科学领域的基础知识。《计算机科学概论》由当今该领域备受赞誉且经验丰富的教育家Nell Dale和John Lewis共同编写。就整体而言，全书内容翔实、覆盖面广，旨在向读者展示计算机科学的全貌；从细节上看，《计算机科学概论》层次清晰、描述生动；从信息讲起，分别介绍了关于硬件、编程、操作系统、应用以及通信方面的内容，涉及计算机科学的各个层面。 《计算机科学概论》内容严谨、深入浅出，是计算机科学专业学生理想的入门教材。《计算机科学概论》特点：采用一般语言对编程概念进行了描述，关于Java、C++语言对该问题的描述在《计算机科学概论》的配套网站 <a href="http://csilluminated.jbpub.com" target="_blank" rel="noopener">http://csilluminated.jbpub.com</a>) 中提供。增加了名人传记、历史事件以及技术发展的前沿知识；并在每章中就科技发展对人类社会伦理道德的影响进行了探讨。包含大量练习和思考题，方便教学。 《计算机科学概论》的配套网站集学术性及趣味性于一体，提供了大量教学资源：Flash幻灯片、在线术语表、互动学习、填字游戏、HTML帮助信息等，以更灵活的方式多方位地加深读者对《计算机科学概论》知识的理解。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">出版者的话</span><br><span class="line">专家指导委员会</span><br><span class="line">译者序</span><br><span class="line">前言</span><br><span class="line">第一部分 基础篇</span><br><span class="line">第1章 全景图</span><br><span class="line">1.1 计算系统</span><br><span class="line">1.1.1 计算系统的分层</span><br><span class="line">1.1.2 抽象</span><br><span class="line">1.2 计算的历史</span><br><span class="line">1.2.1 计算硬件的简史</span><br><span class="line">1.2.2 计算软件的简史</span><br><span class="line">1.2.3 预言</span><br><span class="line">1.3 计算工具和计算学科</span><br><span class="line">小结</span><br><span class="line">练习</span><br><span class="line">思考题 </span><br><span class="line"></span><br><span class="line"> 第二部分 信息层 第2章 二进制数值和记数系统 2.1 数字分类 2.2 自然数 2.2.1 位置记数法 2.2.2 二进制、八进制和十六进制 2.2.3 其他记数系统中的运算 2.2.4 以2的幂为基数的记数系统 2.2.5 把十进制数转换成其他数制的数 2.2.6 二进制数值和计算机 小结 练习 思考题</span><br><span class="line"></span><br><span class="line"> 第3章 数据表示法 3.1 数据和计算机 3.1.1 模拟信息和数字信息 3.1.2 二进制表示法 3.2 数字数据的表示法 3.2.1 负数表示法 3.2.2 实数表示法 3.3 文本表示法 3.3.1 ASCII字符集 3.3.2 Unicode字符集 3.3.3 文本压缩 3.4 音频信息表示法 3.4.1 音频格式 3.4.2 MP3音频格式 3.5 图像和图形的表示法 3.5.1 颜色表示法 3.5.2 数字化图像和图形 3.5.3 图形的矢量表示法 3.6 视频表示法 小结 练习 思考题</span><br><span class="line"></span><br><span class="line"> 第三部分 硬件层 第4章门和电路 4.1 计算机和电学 4.2 门 4.2.1 非门 4.2.2 与门 4.2.3 或门 4.2.4 异或门 4.2.5 与非门和或非门 4.2.6 门处理回顾 4.2.7 具有更多输入的门</span><br><span class="line"></span><br><span class="line"> 4.3 门的构造 4.4 电路 4.4.1 组合电路 4.4.2 加法器 4.4.3 多路复用器 4.5 存储器电路 4.6 集成电路 4.7 CPU芯片 小结 道德问题：电子邮件隐私权 练习 思考题</span><br><span class="line"></span><br><span class="line"> 第5章 计算部件 5.1 独立的计算机部件 5.2 存储程序的概念 5.2.1 冯？诺伊曼体系结构 5.2.2 读取一执行周期 5.2.3 RAM和ROM 5.2.4 二级存储设备 5.2.5 触摸屏 5.3 非冯？诺伊曼体系结构 小结 道德问题：生物信息学研究和deCODE Genetics公司的案例 练习 思考题</span><br><span class="line"></span><br><span class="line"> 第四部分 程序设计层 第6章问题求解和算法设计 6.1 问题求解 6.1.1 如何解决问题 6.1.2 应用Polya的问题求解策略 6.2 算法 6.2.1 计算机问题求解 6.2.2 执行算法 6.2.3 开发算法 6.3 伪代码 6.3.1 执行一个伪代码算法 6.3.2 伪代码的功能 6.3.3 伪代码示例 6.4 自顶向下设计方法 6.4.1 一个通用的实例 6.4.2 一个计算机实例 6.4.3 方法总结 6.4.4 测试算法 6.5 面向对象方法 6.5.1 面向对象 6.5.2 设计方法 6.5.3 一个通用的实例 6.5.4 一个计算机实例 6.6 几个重要思想 6.6.1 信息隐蔽 6.6.2 抽象 6.6.3 事物命名 6.6.4 程序设计语言 6.6.5 测试 小结 道德问题：计算机专业人员许可 练习 思考题</span><br><span class="line"></span><br><span class="line"> 第7章 低级程序设计语言 7.1 计算机操作 7.2 抽象的分层 7.3 机器语言 7.4 一个程序实例 7.4.1 问题和算法 7.4.2 程序 7.5 汇编语言 7.5.1 Pep／7汇编语言 7.5.2 伪代码操作 7.5.3 “Hello”程序的汇编语言版本 7.5.4 一个新程序 7.5.5 具有分支的程序 7.5.6 具有循环的程序 7.6 其他重要思想 7.6.1 抽象 7.6.2 测试 7.6.3 测试计划实现 小结 道德问题：软件盗版和版权 练习 思考题</span><br><span class="line"></span><br><span class="line"> 第8章 高级程序设计语言 8.1 翻译过程 8.1.1 编译器 8.1.2 解释器 8.2 程序设计语言的范型 8.3 命令式语言的功能性 8.3.1 布尔表达式 8.3.2 强类型化 8.3.3 输入／输出结构 8.3.4 控制结构 8.3.5 复合数据类型 8.4 面向对象语言的功能性 8.4.1 封装 8.4.2 继承 8.4.3 多态性 小结 道德问题：开源软件的发展 练习 思考题</span><br><span class="line"></span><br><span class="line"> 第9章 抽象数据类型和算法 9.1 抽象数据类型 9.2 实现 9.2.1 基于数组的实现 9.2.2 链式实现 9.3 列表 9.3.1 列表的基本操作 9.3.2 其他列表操作 9.4 排序 9.4.1 选择排序 9.4.2 冒泡排序 9.4.3 快速排序 9.5 二分检索法 9.6 栈和队列 9.6.1 栈 9.6.2 队列 9.6.3 实现 9.7 树 9.7.1 二叉树 9.7.2 二叉检索树 9.7.3 其他操作 9.7.4 图 9.8 程序设计库 小结 道德问题：使用计算机的恶作剧和欺诈行为 练习 思考题</span><br><span class="line"></span><br><span class="line"> 第五部分 操作系统层 第10章 操作系统 10.1 操作系统的角色 10.1.1 内存、进程和CPU管理 10.1.2 批处理 10.1.3 分时操作 10.1.4 其他OS要素 10.2 内存管理 10.2.1 单块内存管理 10.2.2 分区内存管理 10.2.3 页式内存管理 10.3 进程管理 10.3.1 进程状态 10.3.2 进程控制块 10.4 CPU调度 10.4.1 先到先服务 10.4.2 最短作业优先 10.4.3 循环调度法 小结 道德问题：数字版权管理和关于sony公司的根目录案件的争论 练习 思考题</span><br><span class="line"></span><br><span class="line"> 第11章 文件系统和目录 11.1 文件系统 11.1.1 文本文件和二进制文件 11.1.2 文件类型 11.1.3 文件操作 11.1.4 文件访问 11.1.5 文件保护 11.2 目录 11.2.1 目录树 11.2.2 路径名 11.3 磁盘调度 11.3.1 先到先服务磁盘调度法 11.3.2 最短寻道时间优先磁盘调度法 11.3.3 SCAN磁盘调度法 小结 道德问题：垃圾邮件 练习 思考题</span><br><span class="line"></span><br><span class="line"> 第六部分 应用程序层 第12章 信息系统 12.1 信息管理 12.2 电子制表软件 12.2.1 电子数据表公式 12.2.2 循环引用 12.2.3 电子数据表分析 12.3 数据库管理系统 12.3.1 关系模型 12.3.2 关系 12.3.3 结构化查询语言 12.3.4 数据库设计 12.4 信息安全 12.4.1 机密性、完整性和可用性 12.4.2 密码学 小结 道德问题：加密 练习 思考题</span><br><span class="line"></span><br><span class="line"> 第13章 人工智能 13.1 思维机 13.1.1 图灵测试 13.1.2 AI问题的各个方面 13.2 知识表示 13.2.1 语义网 13.2.2 检索树 13.3 专家系统 13.4 神经网络 13.4.1 生物神经网络 13.4.2 人工神经网络 13.5 自然语言处理 13.5.1 语音合成 13.5.2 语音识别 13.5.3 自然语言理解 13.6 机器人学 13.6.1 感知一规划一执行范型 13.6.2 包孕体系结构 13.6.3 物理部件 小结 道德问题：HIPAA（健康保险携带和责任法案） 练习 思考题</span><br><span class="line"></span><br><span class="line"> 第14章 模拟、图形学和其他应用程序 14.1 什么是模拟 14.1.1 复杂系统 14.1.2 模型 14.1.3 构造模型 14.1.4 排队系统 14.1.5 气象模型 14.1.6 其他模型 14.1.7 必要的计算能力 14.2 计算机图形学 14.2.1 光的工作原理 14.2.2 物体形状 14.2.3 光模拟 14.2.4 复杂对象的建模 14.2.5 让物体动起来 14.3 嵌入式系统 14.4 电子商务 14.5 计算机安全 14.5.1 恶意代码 14.5.2 安全攻击 小结 道德问题：入侵大学的计算机系统，查询 录取程序中某人的录取状态 练习 思考题</span><br><span class="line"></span><br><span class="line"> 第七部分 通信层 第15章 网络 15.1 连网 15.1.1 网络的类型 15.1.2 Internet连接 15.1.3 包交换 15.2 开放式系统和协议 15.2.1 开放式系统 15.2.2 网络协议 15.2.3 TCP／IP 15.2.4 高层协议 15.2.5 MIME类型 15.2.6 防火墙 15.3 网络地址 小结 道德问题：无所不在的计算 练习 思考题</span><br><span class="line"></span><br><span class="line"> 第16章 万维网 16.1 Web简介 16.1.1 搜索引擎 16.1.2 即时消息 16.1.3 博客 16.1.4 cookje 16.2 HTML 16.2.1 基本的HTML格式 16.2.2 图像和链接 16.3 交互式Web页 16.3.1.1 ava小程序 16.3.2 Java服务器页 16.4 XML 小结 道德问题：写博客 练习 思考题</span><br><span class="line"></span><br><span class="line"> 第八部分 总结 第17章 计算的限制 17.1 硬件 17.1.1 算术运算的限制 17.1.2 部件的限制 17.1.3 通信的限制 17.2 软件 17.2.1 软件的复杂度 17.2.2 当前提高软件质量的方法 17.2.3 臭名昭著的软件错误 17.3 问题 17.3.1 算法比较 17.3.2 图灵机 17.3.3 停机问题 17.3.4 算法分类 小结 道德问题：深度链接 练习 思考题 参考文献</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001TDM10Y/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001TDM10Y&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51VostuezwL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员的自我修养 链接、装载与库</title>
    <url>/2020/04/19/B0027VSA7U/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 程序员的自我修养 链接、装载与库<br>作者信息： 作者: 潘爱民 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《程序员的自我修养：链接、装载与库》深入浅出地对系统软件的底层形成机制进行条分缕析真正提升程序员的自我修养</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1部分 简介</span><br><span class="line">　第1章 温故而知新</span><br><span class="line">　　1.1 从HELLO WORLD 说起</span><br><span class="line">　 1.2 万变不离其宗</span><br><span class="line">　　1.3 站得高，望得远</span><br><span class="line">　　1.4 操作系统做什么</span><br><span class="line">　　1.5 内存不够怎么办</span><br><span class="line">　　1.6 众人拾柴火焰高</span><br><span class="line">　　1.7 本章小结</span><br><span class="line">第2部分 静态链接</span><br><span class="line">　第2章 编译和链接</span><br><span class="line">　　2.1 被隐藏了的过程</span><br><span class="line">　　2.2 编译器做了什么</span><br><span class="line">　　2.3 链接器年龄比编译器长</span><br><span class="line">　　2.4 模块拼装——静态链接</span><br><span class="line">　　2.5 本章小结</span><br><span class="line">　第3章 目标文件里有什么</span><br><span class="line">　　3.1 目标文件的格式</span><br><span class="line">　　3.2 目标文件是什么样的</span><br><span class="line">　　3.3 挖掘SIMPLESECTION.O</span><br><span class="line">　　3.4 ELF 文件结构描述</span><br><span class="line">　　3.5 链接的接口——符号</span><br><span class="line">　　3.6 调试信息</span><br><span class="line">　　3.7 本章小结</span><br><span class="line">　第4章 静态链接</span><br><span class="line">　　4.1 空间与地址分配</span><br><span class="line">　　4.2 符号解析与重定位</span><br><span class="line">　　4.3 COMMON 块</span><br><span class="line">　　4.4 C++相关问题</span><br><span class="line">　　4.5 静态库链接</span><br><span class="line">　　4.6 链接过程控制</span><br><span class="line">　　4.7 BFD 库</span><br><span class="line">　　4.8 本章小结</span><br><span class="line">　第5章 WINDOWS PE&#x2F;COFF</span><br><span class="line">　　5.1 WINDOWS 的二进制文件格式PE&#x2F;COFF 134</span><br><span class="line">　　5.2 PE 的前身——COFF</span><br><span class="line">　　5.3 链接指示信息</span><br><span class="line">　　5.4 调试信息</span><br><span class="line">　　5.5 大家都有符号表</span><br><span class="line">　　5.6 WINDOWS 下的ELF——PE</span><br><span class="line">　　5.7 本章小结</span><br><span class="line">第3部分 装载与动态链接</span><br><span class="line">　第6章 可执行文件的装载与进程</span><br><span class="line">　　6.1 进程虚拟地址空间</span><br><span class="line">　　6.2 装载的方式</span><br><span class="line">　　6.3 从操作系统角度看可执行文件的装载</span><br><span class="line">　　6.4 进程虚存空间分布</span><br><span class="line">　　6.5 LINUX 内核装载ELF 过程简介</span><br><span class="line">　　6.6 WINDOWS PE 的装载</span><br><span class="line">　　6.7 本章小结</span><br><span class="line">　第7章 动态链接</span><br><span class="line">　　7.1 为什么要动态链接</span><br><span class="line">　　7.2 简单的动态链接例子</span><br><span class="line">　　7.3 地址无关代码</span><br><span class="line">　　7.4 延迟绑定（PLT）</span><br><span class="line">　　7.5 动态链接相关结构</span><br><span class="line">　　7.6 动态链接的步骤和实现</span><br><span class="line">　　7.7 显式运行时链接</span><br><span class="line">　　7.8 本章小结</span><br><span class="line">　第8章 LINUX 共享库的组织</span><br><span class="line">　　8.1 共享库版本</span><br><span class="line">　　8.2 符号版本</span><br><span class="line">　　8.3 共享库系统路径</span><br><span class="line">　　8.4 共享库查找过程</span><br><span class="line">　　8.5 环境变量</span><br><span class="line">　　8.6 共享库的创建和安装</span><br><span class="line">　　8.7 本章小结</span><br><span class="line">　第9章 WINDOWS 下的动态链接</span><br><span class="line">　　9.1 DLL 简介</span><br><span class="line">　　9.2 符号导出导入表</span><br><span class="line">　　9.3 DLL 优化</span><br><span class="line">　　9.4 C++与动态链接</span><br><span class="line">　　9.5 DLL HELL</span><br><span class="line">　　9.6 本章小结</span><br><span class="line">第4部分 库与运行库</span><br><span class="line">　第10章 内存</span><br><span class="line">　　10.1 程序的内存布局</span><br><span class="line">　　10.2 栈与调用惯例</span><br><span class="line">　　10.3 堆与内存管理</span><br><span class="line">　　10.4 本章小结</span><br><span class="line">　第11章 运行库</span><br><span class="line">　　11.1 入口函数和程序初始化</span><br><span class="line">　　11.2 C&#x2F;C++运行库</span><br><span class="line">　　11.3 运行库与多线程</span><br><span class="line">　　11.4 C++全局构造与析构</span><br><span class="line">　　11.5 FREAD 实现</span><br><span class="line">　　11.6 本章小结</span><br><span class="line">　第12章 系统调用与API</span><br><span class="line">　　12.1 系统调用介绍</span><br><span class="line">　　12.2 系统调用原理</span><br><span class="line">　　12.3 WINDOWS API</span><br><span class="line">　　12.4 本章小结</span><br><span class="line">　第13章 运行库实现</span><br><span class="line">　　13.1 C 语言运行库</span><br><span class="line">　　13.2 如何使用MINI CRT</span><br><span class="line">　　13.3 C++运行库实现</span><br><span class="line">　　13.4 如何使用MINI CRT++</span><br><span class="line">　　13.5 本章小结</span><br><span class="line">附录A</span><br><span class="line">　A.1 字节序（BYTE ORDER）</span><br><span class="line">　A.2 ELF 常见段</span><br><span class="line">　A.3 常用开发工具命令行参考</span><br><span class="line">索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0027VSA7U/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0027VSA7U&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51DWO8hbBfL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>架构之美</title>
    <url>/2020/04/19/B002YK59LE/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 架构之美<br>作者信息： 作者: 斯宾耐立思(Diomidis Spinellis) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《架构之美》荣获2009年度引进版优秀图书奖！健壮、优雅、灵活和易维护的软件架构是怎样炼成的?《架构之美》通过一系列优秀的文章回答了这个问题，这些文章来自于十几位当今一流的软件设计师和架构师。在每篇文章中，作者都向们展示了一个著名的软件架构，并分析了什么让其具有创新性，让其极其符合设计目标。《架构之美》Facebook的架构如何建立在以数据为中心的应用生态系统之上。Xen的创新架构对操作系统未来的影响。KDE项目的社区过程如何让软件的架构从粗略的草图演进为漂亮的系统。不断滋长的特征如何让GNUEmacs获得从未预料到的功能。JikesRVM自优化、自足执行的运行时环境背后的魔法。 获奖证书：</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">序</span><br><span class="line">前言</span><br><span class="line">第一部分 论架构</span><br><span class="line">第1章 什么是架构</span><br><span class="line">1.1 简介</span><br><span class="line">1.2 创建软件架构</span><br><span class="line">1.3 架构结构</span><br><span class="line">1.4 好的架构</span><br><span class="line">1.5 美丽的架构</span><br><span class="line">1.6 致谢</span><br><span class="line">1.7 参考文献 </span><br><span class="line"></span><br><span class="line"> 第2章 两个系统的故事：现代软件神话 2.1 混乱大都市 2.2 设计之城 2.3 说明什么问题 2.4 轮到您了 2.5 参考文献</span><br><span class="line"></span><br><span class="line"> 第二部分 企业级应用架构 第3章 伸缩性架构设计 3.1 简介 3.2 背景 3.3 架构 3.4 关于架构的思考</span><br><span class="line"></span><br><span class="line"> 第4章 记忆留存 4.1 功能和约束 4.2 工作流 4.3 架构关注点 4.4 用户反应 4.5 结论</span><br><span class="line"></span><br><span class="line"> 第5章 面向资源的架构：在Web中 5.1 简介 5.2 传统的Web服务 5.3 Web 5.4 面向资源的架构 5.5 数据驱动的应用 5.6 应用面向资源的架构 5.7 结论</span><br><span class="line"></span><br><span class="line"> 第6章 数据增长：Facebook平台的架构 6.1 简介 6.2 创建一个社会关系Web服务 6.3 创建社会关系数据查询服务 6.4 创建一个社会关系Web门户：FBML 6.5 系统的支持功能 6.6 总结</span><br><span class="line"></span><br><span class="line"> 第三部分 系统架构 第7章 Xen和虚拟化之美 7.1 简介 7.2 Xenoservers 7.3 虚拟化的挑战 7.4 半虚拟化 7.5 Xen的变换形式 7.6 改变的硬件，改变的Xen 7.7 经验教训 7.8 延伸阅读</span><br><span class="line"></span><br><span class="line"> 第8章 Guardian：一个容错操作系统环境 8.1 Tandem&#x2F;16，将来所有的计算机都会像这样构建 8.2 硬件 8.3 机械布局 8.4 处理器架构 8.5 处理器间总线 8.6 输入&#x2F;输出 8.7 进程结构 8.8 消息系统 8.9 文件系统 8.10 民间传说 8.11 弊端 8.12 后继者 8.13 延伸阅读</span><br><span class="line"></span><br><span class="line"> 第9章 JPC：一个纯Java的x86PC模拟程序 9.1 简介 9.2 概念验证 9.3 PC架构 9.4 Java性能技巧 9.5 把4GB放入4GB：这不起作用 9.6 保护模式的危险 9.7 从事一项毫无成功希望的斗争 9.8 劫持JVM 9.9 最终灵活性 9.10 最佳安全性 9.11 第二次做会更好</span><br><span class="line"></span><br><span class="line"> 第10章 元循环虚拟机的力量：JikesRVM 10.1 背景 10.2 与运行时环境相关的传言 10.3 JikesRVM简史 10.4 一个自足执行的运行时自举 10.5 运行时组件 10.6 经验教训 参考文献</span><br><span class="line"></span><br><span class="line"> 第四部分 最终用户应用架构 第11章 GNUEmacs：滋长的特性是其优势 11.1 使用中的Emacs 11.2 Emacs的架构 11.3 滋长的特性 11.4 另外两个架构</span><br><span class="line"></span><br><span class="line"> 第12章 当集市开始构建教堂 12.1 简介 12.2 KDE项目的历史和组织结构 12.3 Akonadi 12.4 ThreadWeaver</span><br><span class="line"></span><br><span class="line"> 第五部分 语言与架构 第13章 软件架构：面向对象与面向功能 13.1 概述 13.2 示例 13.3 面向功能解决方案的模块性评价 13.4 面向对象视图 13.5 面向对象模块性的评价和改进 13.6 代理：将操作封装到对象中 致谢 参考文献</span><br><span class="line"></span><br><span class="line"> 第14章 重读经典 14.1 所有东西都是对象 14.2 类型是隐式定义的 14.3 问题 14.4 砖块和灰浆建筑架构 参考文献 跋</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B002YK59LE/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B002YK59LE&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51mKSKWB9yL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>代码整洁之道</title>
    <url>/2020/04/19/B0031M9GHC/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 代码整洁之道<br>作者信息： 作者: 马丁 (Robert C. Martin) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《代码整洁之道》：细节之中自有天地，整洁成就卓越代码尽管糟糕的代码也能运行，但如果代码不整洁，会使整个开发团队泥足深陷，写得不好的代码每年都要耗费难以计数的时间和资源。然而这种情况并非无法避免。著名软件专家RoberfC.Marlin在《代码整洁之道》中为你呈现出了革命性的视野。Martin携同ObjectMetltor公司的同事，从他们有关整洁代码的最佳敏捷实践中提炼出软件技艺的价值观，以飨读者，让你成为更优秀的程序员——只要你着手研读《代码整洁之道》。阅读《代码整洁之道》需要你做些什么呢？你将阅读代码——大量代码。《代码整洁之道》促使你思考代码中何谓正确，何谓错误。更重要的是，《代码整洁之道》将促使你重新评估自己的专业价值观，以及对自己技艺的承诺。从《代码整洁之道》中可以学到：好代码和糟糕的代码之间的区别：如何编写好代码，如何将糟糕的代码转化为好代码：如何创建好名称、好函数、好对象和好类；如何格式化代码以实现其可读性的最大化：如何在不妨碍代码逻辑的前提下充分实现错误处理；如何进行单元测试和测试驱动开发。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章　整洁代码　1</span><br><span class="line">1.1　要有代码　2</span><br><span class="line">1.2　糟糕的代码　2</span><br><span class="line">1.3　混乱的代价　3</span><br><span class="line">1.3.1　华丽新设计　4</span><br><span class="line">1.3.2　态度　4</span><br><span class="line">1.3.3　迷题　5</span><br><span class="line">1.3.4　整洁代码的艺术　5</span><br><span class="line">1.3.5　什么是整洁代码　6</span><br><span class="line">1.4　思想流派　10</span><br><span class="line">1.5　我们是作者　11</span><br><span class="line">1.6　童子军军规　12</span><br><span class="line">1.7　前传与原则　12</span><br><span class="line">1.8　小结　12</span><br><span class="line">1.9　文献　13 </span><br><span class="line"></span><br><span class="line"> 第2章　有意义的命名　15 2.1　介绍　15 2.2　名副其实　16 2.3　避免误导　17 2.4　做有意义的区分　18 2.5　使用读得出来的名称　19 2.6　使用可搜索的名称　20 2.7　避免使用编码　21 2.7.1　匈牙利语标记法　21 2.7.2　成员前缀　21 2.7.3　接口和实现　22 2.8　避免思维映射　22 2.9　 类名　23 2.10　方法名　23 2.11　别扮可爱　23 2.12　每个概念对应一个词　24 2.13　别用双关语　24 2.14　使用解决方案领域名称　25 2.15　使用源自所涉问题领域的名称　25 2.16　添加有意义的语境　25 2.17　不要添加没用的语境　27 2.18　最后的话　27</span><br><span class="line"></span><br><span class="line"> 第3章　函数　29 3.1　短小　32 3.2　只做一件事　33 3.3　每个函数一个抽象层级　34 3.4　switch语句　35 3.5　使用描述性的名称　36 3.6　函数参数　37 3.6.1　一元函数的普遍形式　38 3.6.2　标识参数　38 3.6.3　二元函数　38 3.6.4　三元函数　39 3.6.5　参数对象　39 3.6.6　参数列表　40 3.6.7　动词与关键字　40 3.7　无副作用　40 3.8　分隔指令与询问　42 3.9　使用异常替代返回错误码　42 3.9.1　抽离Try&#x2F;Catch代码块　43 3.9.2　错误处理就是一件事　44 3.9.3　Error.java依赖磁铁　44 3.10　别重复自己　44 3.11　结构化编程　45 3.12　如何写出这样的函数　45 3.13　小结　45 3.14　SetupTeardownIncluder程序　46 3.15　文献　48</span><br><span class="line"></span><br><span class="line"> 第4章　注释　49 4.1　注释不能美化糟糕的代码　50 4.2　用代码来阐述　51 4.3　好注释　51 4.3.1　法律信息　51 4.3.2　提供信息的注释　51 4.3.3　对意图的解释　52 4.3.4　阐释　53 4.3.5　警示　53 4.3.6　TODO注释　54 4.3.7　放大　54 4.3.8　公共API中的Javadoc　55 4.4　坏注释　55 4.4.1　喃喃自语　55 4.4.2　多余的注释　56 4.4.3　误导性注释　58 4.4.4　循规式注释　58 4.4.5　日志式注释　59 4.4.6　废话注释　59 4.4.7　可怕的废话　61 4.4.8　能用函数或变量时就别用注释　62 4.4.9　位置标记　62 4.4.10　括号后面的注释　62 4.4.11　归属与署名　63 4.4.12　注释掉的代码　63 4.4.13　HTML注释　64 4.4.14　非本地信息　64 4.4.15　信息过多　65 4.4.16　不明显的联系　65 4.4.17　函数头　66 4.4.18　非公共代码中的Javadoc　66 4.4.19　范例　66 4.5　文献　69</span><br><span class="line"></span><br><span class="line"> 第5章　格式　71 5.1　格式的目的　72 5.2　垂直格式　72 5.2.1　向报纸学习　73 5.2.2　概念间垂直方向上的区隔　73 5.2.3　垂直方向上的靠近　74 5.2.4　垂直距离　75 5.2.5　垂直顺序　79 5.3　横向格式　79 5.3.1　水平方向上的区隔与靠近　80 5.3.2　水平对齐　81 5.3.3　缩进　82 5.3.4　空范围　84 5.4　团队规则　84 5.5　鲍勃大叔的格式规则　85</span><br><span class="line"></span><br><span class="line"> 第6章　对象和数据结构　87 6.1　数据抽象　87 6.2　数据、对象的反对称性　89 6.3　得墨忒耳律　91 6.3.1　火车失事　91 6.3.2　混杂　92 6.3.3　隐藏结构　92 6.4　数据传送对象　93 6.5　小结　94 6.6　文献　94</span><br><span class="line"></span><br><span class="line"> 第7章　错误处理　95 7.1　使用异常而非返回码　96 7.2　先写Try-Catch-Finally语句　97 7.3　使用不可控异常　98 7.4　给出异常发生的环境说明　99 7.5　依调用者需要定义异常类　99 7.6　定义常规流程　100 7.7　别返回null值　101 7.8　别传递null值　102 7.9　小结　103 7.10 文献　104</span><br><span class="line"></span><br><span class="line"> 第8章　边界　105 8.1　使用第三方代码　106 8.2　浏览和学习边界　107 8.3　学习log4j　108 8.4　学习性测试的好处不只是免费　110 8.5　使用尚不存在的代码　110 8.6　整洁的边界　111 8.7　文献　112</span><br><span class="line"></span><br><span class="line"> 第9章　单元测试　113 9.1　TDD三定律　114 9.2　保持测试整洁　115 9.3　整洁的测试　116 9.3.1　面向特定领域的测试语言　118 9.3.2　双重标准　119 9.4　每个测试一个断言　121 9.5　F.I.R.S.T.　122 9.6　小结　123 9.7　文献　124</span><br><span class="line"></span><br><span class="line"> 第10章　类　125 10.1　类的组织　126 10.2　类应该短小　126 10.2.1　单一权责原则　128 10.2.2　内聚　129 10.2.3　保持内聚性就会得到许多短小的类　130 10.3　为了修改而组织　136 10.4　文献　139</span><br><span class="line"></span><br><span class="line"> 第11章　系统　141 11.1　如何建造一个城市　142 11.2　将系统的构造与使用分开　142 11.2.1　分解main　143 11.2.2　工厂　143 11.2.3　依赖注入　144 11.3　扩容　145 11.4　Java代理　148 11.5　纯Java AOP框架　150 11.6　AspectJ的方面　152 11.7　测试驱动系统架构　153 11.8　优化决策　154 11.9　明智使用添加了可论证价值的标准　154 11.10 系统需要领域特定语言　154 11.11 小结　155 11.12 文献　155</span><br><span class="line"></span><br><span class="line"> 第12章　迭进　157 12.1　通过迭进设计达到整洁目的　157 12.2　简单设计规则1：运行所有测试　158 12.3　简单设计规则2～4：重构　158 12.4　不可重复　159 12.5　表达力　161 12.6　尽可能少的类和方法　162 12.7　小结　162 12.8　文献　162</span><br><span class="line"></span><br><span class="line"> 第13章　并发编程　163 13.1　为什么要并发　164 13.2　挑战　165 13.3　并发防御原则　166 13.3.1　单一权责原则　166 13.3.2　推论：限制数据作用域　166 13.3.3　推论：使用数据复本　167 13.3.4　推论：线程应尽可能地独立　167 13.4　了解Java库　167 13.5　了解执行模型　168 13.5.1　生产者-消费者模型　169 13.5.2　读者-作者模型　169 13.5.3　宴席哲学家　169 13.6　警惕同步方法之间的依赖　169 13.7　保持同步区域微小　170 13.8　很难编写正确的关闭代码　170 13.9　测试线程代码　171 13.9.1　将伪失败看作可能的线程问题　171 13.9.2　先使非线程代码可工作　171 13.9.3　编写可插拔的线程代码　172 13.9.4　编写可调整的线程代码　172 13.9.5　运行多于处理器数量的线程　172 13.9.6　在不同平台上运行　172 13.9.7　装置试错代码　173 13.9.8　硬编码　173 13.9.9　自动化　174 13.10　小结　175 13.11　文献　175</span><br><span class="line"></span><br><span class="line"> 第14章　逐步改进　176 14.1　Args的实现　177 14.2　Args：草稿　183 14.2.1　所以我暂停了　195 14.2.2　渐进　195 14.3　字符串参数　197 14.4　小结　234</span><br><span class="line"></span><br><span class="line"> 第15章　JUnit内幕　235 15.1　JUnit框架　236 15.2　小结　249</span><br><span class="line"></span><br><span class="line"> 第16章　重构SerialDate　251 16.1　首先，让它能工作　252 16.2　让它做对　254 16.3　小结　266 16.4　文献　267</span><br><span class="line"></span><br><span class="line"> 第17章　味道与启发　269 17.1　注释　270 17.2　环境　271 17.3　函数　271 17.4　一般性问题　272 17.5　Java　288 17.6　名称　291 17.7　测试　294 17.8　小结　295 17.9　文献　296</span><br><span class="line"></span><br><span class="line"> 附录A　并发编程II　297 A.1　客户端&#x2F;服务器的例子　297 A.1.1　服务器　297 A.1.2　添加线程代码　298 A.1.3　观察服务器端　299 A.1.4　小结　301 A.2　执行的可能路径　301 A.2.1　路径数量　302 A.2.2　深入挖掘　303 A.2.3　小结　305 A.3　了解类库　305 A.3.1　Executor框架　305 A.3.2　非锁定的解决方案　306 A.3.3　非线程安全类　307 A.4　方法之间的依赖可能破坏并发代码　308 A.4.1　容忍错误　309 A.4.2　基于客户代码的锁定　309 A.4.3　基于服务端的锁定　311 A.5　提升吞吐量　312 A.5.1　单线程条件下的吞吐量　313 A.5.2　多线程条件下的吞吐量　313 A.6　死锁　314 A.6.1　互斥　315 A.6.2　上锁及等待　315 A.6.3　无抢先机制　315 A.6.4　循环等待　315 A.6.5　不互斥　316 A.6.6　不上锁及等待　316 A.6.7　满足抢先机制　317 A.6.8　不做循环等待　317 A.7　测试多线程代码　317 A.8　测试线程代码的工具支持　320 A.9　小结　320 A.10 教程：完整代码范例　321 A.10.1　客户端&#x2F;服务器非线程代码　321 A.10.2　使用线程的客户端&#x2F;服务器代码　324 附录B　org.jfree.date.SerialDate　327 结束语　389</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0031M9GHC/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0031M9GHC&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41jiPKJEFDL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>高效程序员的45个习惯 敏捷开发修炼之道</title>
    <url>/2020/04/19/B0033WSFAO/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 高效程序员的45个习惯 敏捷开发修炼之道<br>作者信息： 作者: 苏帕拉马尼亚姆(Venkat Subramaniam) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《高效程序员的45个习惯:敏捷开发修炼之道》：融知识、哲理、实践于一体的奇书高效程序员必读之作秉承Pragmatic经典系列的卓越风格十年来，软件行业发生了翻天覆地的变化。敏捷方法大行其道。测试和测试驱动开发在很多开发人员的工作中扮演着重要的角色。作为一名程序员，你应该培养怎样的素质，方能对多变的环境应对自如，始终立于不败之地？《高效程序员的45个习惯:敏捷开发修炼之道》简明实用、见解深刻，总结了高效程序员在开发过程中的45个个人习惯、思想观念和方法。有助于开发人员在开发进程、编码工作、开发者态度、项目和团队管理，以及持续学习等5个方面积极修炼。通过学习这些内容，养成这些好的习惯，你可以极大地提升自己的编程实力，更快速、更可靠地支付高质量的软件。从而成为真正的高效程序员。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 敏捷——高效软件开发之道 </span><br><span class="line"></span><br><span class="line"> 第2章 态度决定一切 1. 做事 2. 欲速则不达 3. 对事不对人 4. 排除万难，奋勇前进</span><br><span class="line"></span><br><span class="line"> 第3章 学无止境 5. 跟踪变化 6. 对团队投资 7. 懂得丢弃 8. 打破砂锅问到底 9. 把握开发节奏</span><br><span class="line"></span><br><span class="line"> 第4章 交付用户想要的软件 10. 让客户做决定 11. 让设计指导而不是操纵开发 12. 合理地使用技术 13. 保持可以发布 14. 提早集成，频繁集成 15. 提早实现自动化部署 16. 使用演示获得频繁反馈 17. 使用短迭代，增量发布 18. 固定的价格就意味着背叛承诺</span><br><span class="line"></span><br><span class="line"> 第5章 敏捷反馈 19. 守护天使 20. 先用它再实现它 21. 不同环境，就有不同问题 22. 自动验收测试 23. 度量真实的进度 24. 倾听用户的声音</span><br><span class="line"></span><br><span class="line"> 第6章 敏捷编码 25. 代码要清晰地表达意图 26. 用代码沟通 27. 动态评估取舍 28. 增量式编程 29. 保持简单 30. 编写内聚的代码 31. 告知，不要询问 32. 根据契约进行替换</span><br><span class="line"></span><br><span class="line"> 第7章 敏捷调试 33. 记录问题解决日志 34. 警告就是错误 35. 对问题各个击破 36. 报告所有的异常 37. 提供有用的错误信息</span><br><span class="line"></span><br><span class="line"> 第8章 敏捷协作 38. 定期安排会面时间 39. 架构师必须写代码 40. 实行代码集体所有制 41. 成为指导者 42. 允许大家自己想办法 43. 准备好后再共享代码 44. 做代码复查 45. 及时通报进展与问题</span><br><span class="line"></span><br><span class="line"> 第9章 尾声：走向敏捷 9.1 只要一个新的习惯 9.2 拯救濒临失败的项目 9.3 引入敏捷：管理者指南 9.4 引入敏捷：程序员指南 9.5 结束了吗 附录A 资源 索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0033WSFAO/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0033WSFAO&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51U0fZa87AL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>别告诉我你懂PPT</title>
    <url>/2020/04/19/B003553OJQ/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 别告诉我你懂PPT<br>作者信息： 作者: 李治 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《别告诉我你懂PPT》，5分钟搞定客户和老板的职场必杀技。以下人群请勿翻阅此书：讲PPT时，听众睡成一片但不觉得囧；不相信PPT能为项目争取到更多的资金；不认为奇妙的PPT能够让老板高看你一眼；压根就不认为PPT能改变命运。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">第一章 让你的PPT讲故事</span><br><span class="line">第一节 抓住眼球的雷人主标题</span><br><span class="line">一、标题&#x3D;震撼力</span><br><span class="line">二、三步起一个精妙的主标题</span><br><span class="line">三、找到一个精妙标题的路径</span><br><span class="line">第二节 用副标题点破窗户纸</span><br><span class="line">一、清晰副标题的必要性</span><br><span class="line">二、清晰副标题的要点</span><br><span class="line">第三节 不简单的简单完整句</span><br><span class="line">一、简单完整句其实不简单</span><br><span class="line">二、完整你的简单句</span><br><span class="line">第四节 骨灰级的PPT结构——总分总</span><br><span class="line">一、第一个总：概述</span><br><span class="line">二、把你的分论点制作成页标题</span><br><span class="line">三、第二个总：总结</span><br><span class="line">第五节 随手拈来的创意线索</span><br><span class="line">一、魅力线索——被遗忘的法宝</span><br><span class="line">二、线索就要这样挖 </span><br><span class="line"></span><br><span class="line"> 第二章 让你的模板与众不同 第一节 模板里的小细节与大学问 一、页面布局，功能来分类 二、结构变活，要靠概述页和章节过渡页 三、让内容页清晰完整 四、结束页要表达一颗感恩的心 第二节 省心型模板简单不“撞衫” 一、给现成模板做个整容小手术 二、让模板有些新变化</span><br><span class="line"></span><br><span class="line"> 第三章 让PPT3分钟能看懂 第一节 清晰表达你的信息 一、PPT清晰表达信息的三个层次 二、PPT清晰表达信息的三大原则 第二节 中规中矩使用字体字号 一、不同字体对号入座 二、字体的混搭要混而不杂 三、字号的中庸原则 四、线条粗细有讲究 第三节 和谐不张扬的颜色搭配 一、色彩里的哆来咪 二、留心颜色的意义</span><br><span class="line"></span><br><span class="line"> 第四章 玩转PPT的5种武器 第一节 与众不同的PPT文字风格 一、PPT行文就像课堂笔记 二、两个小窍门让文字更好用 三、小心文字里的5宗罪 第二节 横竖有理的表格表达 一、表格是PPT的天敌 二、别把Excel原样贴过来 三、循规蹈矩地做表格 四、表格不能过度图形化 五、讲述表格的4步套路 六、表格里的变形金刚 第三节 一目了然的趋势图 一、分清图中的“虚”与“实” 二、选对图的类型 三、跟着国画学画图 四、关注细节 五、讲述趋势图的6步 第四节 画龙必点睛的图片 一、一图值千言 二、图片分类有讲究 三、图片是信息的好助手 四、让图片各就各位 …… 第五节 存在必精彩的动画</span><br><span class="line"></span><br><span class="line"> 第五章 大胆Show出PPT 第一节 良好的开场白是成功演讲的一半 第二节 虎头更虎尾的完美结束 第三节 让紧张情绪见鬼去吧 后记 致谢</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B003553OJQ/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B003553OJQ&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51VKF7X0TaL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>职场</tag>
      </tags>
  </entry>
  <entry>
    <title>重构 改善既有代码的设计</title>
    <url>/2020/04/19/B003BY6PLK/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 重构 改善既有代码的设计<br>作者信息： 作者: 福勒(Martin Fowler) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>重构，一言以蔽之，就是在不改变外部行为的前提下，有条不紊地改善代码。多年前，正是《重构:改善既有代码的设计》原版的出版，使重构终于从编程高手们的小圈子走出，成为众多普通程序员日常开发工作中不可或缺的一部分。《重构:改善既有代码的设计》也因此成为与《设计模式》齐名的经典著作，被译为中、德、俄、日等众多语言，在世界范围内畅销不衰。《重构:改善既有代码的设计》凝聚了软件开发社区专家多年摸索而获得的宝贵经验，拥有不因时光流逝而磨灭的价值。今天，无论是重构本身，业界对重构的理解，还是开发工具对重构的支持力度，都与《重构:改善既有代码的设计》最初出版时不可同日而语，但书中所蕴涵的意味和精华，依然值得反复咀嚼，而且往往能够常读常新。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 重构，第一个案例1</span><br><span class="line">1.1 起点1</span><br><span class="line">1.2 重构的第一步7</span><br><span class="line">1.3 分解并重组statement()8</span><br><span class="line">1.4 运用多态取代与价格相关的条件逻辑34</span><br><span class="line">1.5 结语52 </span><br><span class="line"></span><br><span class="line"> 第2章 重构原则53 2.1 何谓重构53 2.2 为何重构55 2.3 何时重构57 2.4 怎么对经理说60 2.5 重构的难题62 2.6 重构与设计66 2.7 重构与性能69 2.8 重构起源何处71</span><br><span class="line"></span><br><span class="line"> 第3章 代码的坏味道75 3.1 DuplicatedCode（重复代码）76 3.2 LongMethod（过长函数）76 3.3 LargeClass（过大的类）78 3.4 LongParameterList（过长参数列）78 3.5 DivergentChange（发散式变化）79 3.6 ShotgunSurgery（霰弹式修改）80 3.7 FeatureEnvy（依恋情结）80 3.8 DataClumps（数据泥团）81 3.9 PrimitiveObsession（基本类型偏执）81 3.10 SwitchStatements（switch惊悚现身）82 3.11 ParallelInheritanceHierarchies（平行继承体系）83 3.12 LazyClass（冗赘类）83 3.13 SpeculativeGenerality（夸夸其谈未来性）83 3.14 TemporaryField（令人迷惑的暂时字段）84 3.15 MessageChains（过度耦合的消息链）84 3.16 MiddleMan（中间人）85 3.17 InappropriateIntimacy（狎昵关系）85 3.18 AlternativeClasseswithDifferentInterfaces（异曲同工的类）85 3.19 IncompleteLibraryClass（不完美的库类）86 3.20 DataClass（纯稚的数据类）86 3.21 RefusedBequest（被拒绝的遗赠）87 3.22 Comments（过多的注释）87</span><br><span class="line"></span><br><span class="line"> 第4章 构筑测试体系89 4.1 自测试代码的价值89 4.2 JUnit测试框架91 4.3 添加更多测试97</span><br><span class="line"></span><br><span class="line"> 第5章 重构列表103 5.1 重构的记录格式103 5.2 寻找引用点105 5.3 这些重构手法有多成熟106</span><br><span class="line"></span><br><span class="line"> 第6章 重新组织函数109 6.1 ExtractMethod（提炼函数）110 6.2 InlineMethod（内联函数）117 6.3 InlineTemp（内联临时变量）119 6.4 ReplaceTempwithQuery（以查询取代临时变量）120 6.5 IntroduceExplainingVariable（引入解释性变量）124 6.6 SplitTemporaryVariable（分解临时变量）128 6.7 RemoveAssignmentstoParameters（移除对参数的赋值）131 6.8 ReplaceMethodwithMethodObject（以函数对象取代函数）135 6.9 SubstituteAlgorithm（替换算法）139</span><br><span class="line"></span><br><span class="line"> 第7章 在对象之间搬移特性141 7.1 MoveMethod（搬移函数）142 7.2 MoveField（搬移字段）146 7.3 ExtractClass（提炼类）149 7.4 InlineClass（将类内联化）154 7.5 HideDelegate（隐藏“委托关系”）157 7.6 RemoveMiddleMan（移除中间人）160 7.7 IntroduceForeignMethod（引入外加函数）162 7.8 IntroduceLocalExtension（引入本地扩展）164</span><br><span class="line"></span><br><span class="line"> 第8章 重新组织数据169 8.1 SelfEncapsulateField（自封装字段）171 8.2 ReplaceDataValuewithObject（以对象取代数据值）175 8.3 ChangeValuetoReference（将值对象改为引用对象）179 8.4 ChangeReferencetoValue（将引用对象改为值对象）183 8.5 ReplaceArraywithObject（以对象取代数组）186 8.6 DuplicateObservedData（复制“被监视数据”）189 8.7 ChangeUnidirectionalAssociationtoBidirectional（将单向关联改为双向关联）197 8.8 ChangeBidirectionalAssociationtoUnidirectional（将双向关联改为单向关联）200 8.9 ReplaceMagicNumberwithSymbolicConstant（以字面常量取代魔法数）204 8.10 EncapsulateField（封装字段）206 8.11 EncapsulateCollection（封装集合）208 8.12 ReplaceRecordwithDataClass（以数据类取代记录）217 8.13 ReplaceTypeCodewithClass（以类取代类型码）218 8.14 ReplaceTypeCodewithSubclasses（以子类取代类型码）223 8.15 ReplaceTypeCodewithState&#x2F;Strategy（以State&#x2F;Strategy取代类型码）227 8.16 ReplaceSubclasswithFields（以字段取代子类）232</span><br><span class="line"></span><br><span class="line"> 第9章 简化条件表达式237 9.1 DecomposeConditional（分解条件表达式）238 9.2 ConsolidateConditionalExpression（合并条件表达式）240 9.3 ConsolidateDuplicateConditionalFragments（合并重复的条件片段）243 9.4 RemoveControlFlag（移除控制标记）245 9.5 ReplaceNestedConditionalwithGuardClauses（以卫语句取代嵌套条件表达式）250 9.6 ReplaceConditionalwithPolymorphism（以多态取代条件表达式）255 9.7 IntroduceNullObject（引入Null对象）260 9.8 IntroduceAssertion（引入断言）267</span><br><span class="line"></span><br><span class="line"> 第10章 简化函数调用271 10.1 RenameMethod（函数改名）273 10.2 AddParameter（添加参数）275 10.3 RemoveParameter（移除参数）277 10.4 SeparateQueryfromModifier（将查询函数和修改函数分离）279 10.5 ParameterizeMethod（令函数携带参数）283 10.6 ReplaceParameterwithExplicitMethods（以明确函数取代参数）285 10.7 PreserveWholeObject（保持对象完整）288 10.8 ReplaceParameterwithMethods（以函数取代参数）292 10.9 IntroduceParameterObject（引入参数对象）295 10.10 RemoveSettingMethod（移除设值函数）300 10.11 HideMethod（隐藏函数）303 10.12 ReplaceConstructorwithFactoryMethod（以工厂函数取代构造函数）304 10.13 EncapsulateDowncast（封装向下转型）308 10.14 ReplaceErrorCodewithException（以异常取代错误码）310 10.15 ReplaceExceptionwithTest（以测试取代异常）315</span><br><span class="line"></span><br><span class="line"> 第11章 处理概括关系319 11.1 PullUpField（字段上移）320 11.2 PullUpMethod（函数上移）322 11.3 PullUpConstructorBody（构造函数本体上移）325 11.4 PushDownMethod（函数下移）328 11.5 PushDownField（字段下移）329 11.6 ExtractSubclass（提炼子类）330 …… 第12章 大型重构359 第13章 重构，复用与现实379 第14章 重构工具401 第15章 总结409 参考书目413 要点列表417 索引419</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B003BY6PLK/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B003BY6PLK&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51y2cdpFPKL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>设计心理学</title>
    <url>/2020/04/19/B003CIOS1O/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 设计心理学<br>作者信息： 作者: 唐纳德•A•诺曼 (Donald Arthur Norman) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《设计心理学》编辑推荐：设计学权威力作，设计师必读经典。别再用设计的错误惩罚我们自己。中国工业设计之父柳冠中教授推荐。中国设计美学家杭间教授推荐！诺曼博士告诉你，不是你太笨，而是物品的设计有问题！当你在生活中磕磕绊绊，颇具现代感的水龙头却弄得你手忙脚乱，面对繁复的使用说明书却不知所措，不会使用最潮的手机而感觉跟不上时代……人前的尴尬，人后的无奈这都是你的错吗？</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">推荐序一：设计是无言的服务 柳冠中</span><br><span class="line">推荐序二：“小”是一种更伟大的关怀</span><br><span class="line">新版序</span><br><span class="line">初版序</span><br><span class="line">第一章 日用品中的设计问题</span><br><span class="line">要想弄明白操作方法．你需要获得工程学学位</span><br><span class="line">日常生活中的烦恼</span><br><span class="line">日用品心理学</span><br><span class="line">易理解性和易使用性的设计原则</span><br><span class="line">可怜的设计人员</span><br><span class="line">技术进步带来的矛盾</span><br><span class="line">注释 </span><br><span class="line"></span><br><span class="line"> 第二章 日常操作心理学 替设计人员代过 日常生活中的错误观念 找错怪罪对象 人类思考和解释的本质 采取行动的七个阶段 执行和评估之间的差距 行动的七阶段分析法 .注释</span><br><span class="line"></span><br><span class="line"> 第三章 头脑中的知识与外界知识 行为的精确性与知识的不精确性 记忆是储存在头脑中的知识 记忆也是储存于外界的知识 外界知识和头脑中知识之间的权衡 注释</span><br><span class="line"></span><br><span class="line"> 第四章 知道要做什么 常用限制因素的类别 预设用途和限制因素的应用 可视性和反馈 注释</span><br><span class="line"></span><br><span class="line"> 第五章 人非圣贤，孰能无过 失误 错误 日常活动的结构 有意识行为和下意识行为 与差错相关的设计原则 设计哲学 注释</span><br><span class="line"></span><br><span class="line"> 第六章 设计中的挑战 设计的自然演进 设计人员为何误入歧途 设计过程的复杂性 水龙头：设计中所遇到的种种难题 设计人员的两大致命诱惑 注释</span><br><span class="line"></span><br><span class="line"> 第七章 以用户为中心的设计 化繁为简的七个原则 故意增加操作难度 设计的社会功能 日用品的设计 注释</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B003CIOS1O/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B003CIOS1O&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41pb%2BliaxfL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>企业应用架构模式</title>
    <url>/2020/04/19/B003LBSRDM/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 企业应用架构模式<br>作者信息： 作者: 福勒(Martin Fowler) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《企业应用架构模式》编辑推荐：企业应用开发的实践得益于多种新技术的出现，多层的面向对象平台（如Java、.NET）已经日渐平常。这些新工具和新技术有能力构建更强大的企业应用程序，但是在实现上还不太容易。由于开发人员未能充分理解有经验的对象程序开发人员在架构方面的经验和教训.因此企业应用中经常存在一些共同的错误。《企业应用架构模式》就是面向企业应用开发者的，可帮助他们迎接这种艰难挑战。《企业应用架构模式》的作者Ma riin Fowler注意到，尽管技术本身存在变化——从Smalltalk到CORBA，再到。Java和NET，但基本的设计思想并没有太多变化，可以加以适当调整，用来解决那些共同的问题。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">译者序</span><br><span class="line">前言</span><br><span class="line">模式列表</span><br><span class="line">引言 1</span><br><span class="line">0.1 架构 1</span><br><span class="line">0.2 企业应用 2</span><br><span class="line">0.3 企业应用的种类 3</span><br><span class="line">0.4 关于性能的考虑 4</span><br><span class="line">0.5 模式 6</span><br><span class="line">0.5.1 模式的结构 7</span><br><span class="line">0.5.2 模式的局限性 9 </span><br><span class="line"></span><br><span class="line"> 第一部分 表述 第1章 分层 12 1.1 企业应用中层次的演化 13 1.2 三个基本层次 14 1.3 为各层选择运行环境 15</span><br><span class="line"></span><br><span class="line"> 第2章 组织领域逻辑 19 2.1 抉择 22 2.2 服务层 23</span><br><span class="line"></span><br><span class="line"> 第3章 映射到关系数据库 25 .3.1 架构模式 25 3.2 行为问题 28 3.3 读取数据 29 3.4 结构映射模式 30 3.4.1 关系的映射 30 3.4.2 继承 33 3.5 建立映射 34 3.6 使用元数据 35 3.7 数据库连接 36 3.8 其他问题 38 3.9 进一步阅读 38</span><br><span class="line"></span><br><span class="line"> 第4章 Web表现层 39 4.1 视图模式 41 4.2 输入控制器模式 43 4.3 进一步阅读 43</span><br><span class="line"></span><br><span class="line"> 第5章 并发 45 5.1 并发问题 45 5.2 执行语境 46 5.3 隔离与不变性 47 5.4 乐观并发控制和悲观并发控制 48 5.4.1 避免不一致读 49 5.4.2 死锁 49 5.5 事务 50 5.5.1 ACID 51 5.5.2 事务资源 51 5.5.3 减少事务隔离以提高灵活性 52 5.5.4 业务事务和系统事务 53 5.6 离线并发控制的模式 54 5.7 应用服务器并发 55 5.8 进一步阅读 56</span><br><span class="line"></span><br><span class="line"> 第6章 会话状态 57 6.1 无状态的价值 57 6.2 会话状态 58 6.3 存储会话状态的方法 59</span><br><span class="line"></span><br><span class="line"> 第7章 分布策略 61 7.1 分布对象的诱惑 61 7.2 远程接口和本地接口 62 7.3 必须使用分布的情况 63 7.4 关于分布边界 64 7.5 分布接口 64</span><br><span class="line"></span><br><span class="line"> 第8章 通盘考虑 67 8.1 从领域层开始 67 8.2 深入到数据源层 68 8.2.1 事务脚本的数据源 68 8.2.2 表模块的数据源 69 8.2.3 领域模型的数据源 69 8.3 表现层 69 8.4 一些关于具体技术的建议 70 8.4.1 Java和J2EE 70 8.4.2 .NET 71 8.4.3 存储过程 71 8.4.4 Web Services 72 8.5 其他分层方式 72</span><br><span class="line"></span><br><span class="line"> 第二部分 模 式 第9章 领域逻辑模式 76 9.1 事务脚本（Transaction Script） 76 9.1.1 运行机制 76 9.1.2 使用时机 77 9.1.3 收入确认问题 78 9.1.4 例：收入确认（Java） 78 9.2 领域模型（Domain Model） 81 9.2.1 运行机制 81 9.2.2 使用时机 83 9.2.3 进一步阅读 83 9.2.4 例：收入确认（Java） 84 9.3 表模块（Table Module） 87 9.3.1 运行机制 88 9.3.2 使用时机 90 9.3.3 例：基于表模块的收入确认（C#） 90 9.4 服务层（Service Layer） 93 9.4.1 运行机制 94 9.4.2 使用时机 96 9.4.3 进一步阅读 96 9.4.4 例：收入确认（Java） 96</span><br><span class="line"></span><br><span class="line"> 第10章 数据源架构模式 101 10.1 表数据入口（Table Data Gateway） 101 10.1.1 运行机制 101 10.1.2 使用时机 102 10.1.3 进一步阅读 102 10.1.4 例：人员入口（C#） 103 10.1.5 例：使用ADO.NET数据集（C#） 104 10.2 行数据入口（Row Data Gateway） 106 10.2.1 运行机制 107 10.2.2 使用时机 108 10.2.3 例：人员记录（Java） 108 10.2.4 例：领域对象的数据保持器（Java） 111 10.3 活动记录（Active Record） 112 10.3.1 运行机制 112 10.3.2 使用时机 113 10.3.3 例：一个简单的Person类（Java） 113 10.4 数据映射器（Data Mapper） 115 10.4.1 运行机制 116 10.4.2 使用时机 119 10.4.3 例：一个简单的数据映射器（Java） 119 10.4.4 例：分离查找方法（Java） 123 10.4.5 例：创建一个空对象（Java） 126</span><br><span class="line"></span><br><span class="line"> 第11章 对象－关系行为模式 129 11.1 工作单元（Unit of Work） 129 11.1.1 运行机制 129 11.1.2 使用时机 133 11.1.3 例：使用对象注册的工作单元（Java） 134 11.2 标识映射（Identity Map） 137 11.2.1 运行机制 137 11.2.2 使用时机 139 11.2.3 例：标识映射中的方法（Java） 139 11.3 延迟加载（Lazy Load） 140 11.3.1 运作机制 140 11.3.2 使用时机 142 11.3.3 例：延迟初始化（Java） 142 11.3.4 例：虚代理（Java） 142 11.3.5 例：使用值保持器（Java） 144 11.3.6 例：使用重影（C#） 144</span><br><span class="line"></span><br><span class="line"> 第12章 对象－关系结构模式 151 12.1 标识域（Identity Field） 151 12.1.1 工作机制 151 12.1.2 使用时机 154 12.1.3 进一步阅读 154 12.1.4 例：整型键（C#） 154 12.1.5 例：使用键表（Java） 155 12.1.6 例：使用组合键（Java） 157 12.2 外键映射（Foreign Key Mapping） 166 12.2.1 运行机制 167 12.2.2 使用时机 169 12.2.3 例：单值引用（Java） 169 12.2.4 例：多表查询（Java） 172 12.2.5 例：引用集合（C#） 173 12.3 关联表映射（Association Table Mapping） 175 12.3.1 运行机制 176 12.3.2 使用时机 176 12.3.3 例：雇员和技能（C#） 177 12.3.4 例：使用直接的SQL（Java） 179 12.3.5 例：用一次查询查多个雇员（Java） 182 12.4 依赖映射（Dependent Mapping） 186 12.4.1 运行机制 186 12.4.2 使用时机 187 12.4.3 例：唱片和曲目（Java） 188 12.5 嵌入值（Embedded Value） 190 12.5.1 运行机制 190 12.5.2 使用时机 190 12.5.3 进一步阅读 191 12.5.4 例：简单值对象（Java） 191 12.6 序列化LOB（Serialized LOB） 192 12.6.1 运行机制 193 12.6.2 使用时机 194 12.6.3 例：在XML中序列化一个部门层级（Java） 194 12.7 单表继承（Single Table Inheritance） 196 12.7.1 运行机制 197 12.7.2 使用时机 197 12.7.3 例：运动员的单表（C#） 198 12.7.4 从数据库中加载对象 199 12.8 类表继承（Class Table Inheritance） 202 12.8.1 运行机制 202 12.8.2 使用时机 203 12.8.3 进一步阅读 203 12.8.4 例：运动员和他们的家属（C#） 203 12.9 具体表继承（Concrete Table Inheritance） 208 12.9.1 运行机制 209 12.9.2 使用时机 210 12.9.3 例：具体运动员（C#） 210 12.10 继承映射器（Inheritance Mappers） 214 12.10.1 运行机制 215 12.10.2 使用时机 216</span><br><span class="line"></span><br><span class="line"> 第13章 对象－关系元数据映射模式 217 13.1 元数据映射（Metadata Mapping） 217 13.1.1 运行机制 217 13.1.2 使用时机 218 13.1.3 例：使用元数据和反射（Java） 219 13.2 查询对象（Query Object） 224 13.2.1 运行机制 225 13.2.2 使用时机 225 13.2.3 进一步阅读 226 13.2.4 例：简单的查询对象（Java） 226 13.3 资源库（Repository） 228 13.3.1 运行机制 229 13.3.2 使用时机 230 13.3.3 进一步阅读 231 13.3.4 例：查找一个人所在的部门（Java） 231 13.3.5 例：资源库交换策略（Java） 231</span><br><span class="line"></span><br><span class="line"> 第14章 Web表现模式 233 14.1 模型－视图－控制器（Model View Controller） 233 14.1.1 运行机制 233 14.1.2 使用时机 234 14.2 页面控制器（Page Controller） 235 14.2.1 运行机制 235 14.2.2 使用时机 236 14.2.3 例：Servlet控制器和JSP视图的简单演示（Java） 236 14.2.4 例：使用JSP充当处理程序（Java） 238 14.2.5 例：代码隐藏的页面控制器（C#） 241 14.3 前端控制器（Front Controller） 243 14.3.1 运行机制 244 14.3.2 使用时机 245 14.3.3 进一步阅读 246 14.3.4 例：简单的显示（Java） 246 14.4 模板视图（Template View） 248 14.4.1 运行机制 249 14.4.2 使用时机 251 14.4.3 例：分离的控制器，使用JSP充当视图（Java） 252 14.4.4 例：ASP.NET服务器页面（C#） 253 14.5 转换视图（Transform View） 256 14.5.1 运行机制 256 14.5.2 使用时机 257 14.5.3 例：简单的转换（Java） 257 14.6 两步视图（Two Step View） 259 14.6.1 运行机制 259 14.6.2 使用时机 260 14.6.3 例：两阶XSLT（XSLT） 264 14.6.4 例：JSP和定制标记（Java） 266 14.7 应用控制器（Application Controller） 269 14.7.1 运行机制 270 14.7.2 使用时机 271 14.7.3 进一步阅读 271 14.7.4 例：状态模型应用控制器（Java） 271</span><br><span class="line"></span><br><span class="line"> 第15章 分布模式 275 15.1 远程外观（Remote Facade） 275 15.1.1 运行机制 276 15.1.2 使用时机 278 15.1.3 例：使用Java语言的会话bean来作为远程外观（Java） 278 15.1.4 例：Web Service（C#） 281 15.2 数据传输对象（Data Transfer Object） 285 15.2.1 运行机制 285 15.2.2 使用时机 288 15.2.3 进一步阅读 289 15.2.4 例：传输唱片信息（Java） 289 15.2.5 例：使用XML实现序列化（Java） 293</span><br><span class="line"></span><br><span class="line"> 第16章 离线并发模式 295 16.1 乐观离线锁（Optimistic Offline Lock） 295 16.1.1 运行机制 296 16.1.2 使用时机 298 16.1.3 例：领域层与数据映射器（Java） 298 16.2 悲观离线锁（Pessimistic Offline Lock） 302 16.2.1 运行机制 303 16.2.2 使用时机 305 16.2.3 例：简单锁管理对象（Java） 305 16.3 粗粒度锁（Coarse-Grained Lock） 310 16.3.1 运行机制 310 16.3.2 使用时机 312 16.3.3 例：共享的乐观离线锁（Java） 312 16.3.4 例：共享的悲观离线锁（Java） 316 16.3.5 例：根对象乐观离线锁（Java） 317 16.4 隐含锁（Implicit Lock） 318 16.4.1 运行机制 318 16.4.2 使用时机 319 16.4.3 例：隐含的悲观离线锁（Java） 319</span><br><span class="line"></span><br><span class="line"> 第17章 会话状态模式 321 17.1 客户会话状态（Client Session State） 321 17.1.1 运行机制 321 17.1.2 使用时机 322 17.2 服务器会话状态（Server Session State） 322 17.2.1 运行机制 322 17.2.2 使用时机 324 17.3 数据库会话状态（Database Session State） 324 17.3.1 运行机制 324 17.3.2 使用时机 325</span><br><span class="line"></span><br><span class="line"> 第18章 基本模式 327 18.1 入口（Gateway） 327 18.1.1 运行机制 327 18.1.2 使用时机 328 18.1.3 例：私有消息服务的入口（Java） 329 18.2 映射器（Mapper） 331 18.2.1 运行机制 332 18.2.2 使用时机 332 18.3 层超类型（Layer Supertype） 332 18.3.1 运行机制 332 18.3.2 使用时机 333 18.3.3 例：领域对象（Java） 333 18.4 分离接口（Separated Interface） 333 18.4.1 运行机制 334 18.4.2 使用时机 335 18.5 注册表（Registry） 335 18.5.1 运行机制 336 18.5.2 使用时机 337 18.5.3 例：单子注册表（Java） 337 18.5.4 例：线程安全的注册表（Java） 338 18.6 值对象（Value Object） 339 18.6.1 运行机制 339 18.6.2 使用时机 340 18.7 货币（Money） 340 18.7.1 运行机制 341 18.7.2 使用时机 342 18.7.3 例：货币类（Java） 343 18.8 特殊情况（Special Case） 346 18.8.1 运行机制 347 18.8.2 使用时机 347 18.8.3 进一步阅读 347 18.8.4 例：一个简单的空对象（C#） 347 18.9 插件（Plugin） 348 18.9.1 运行机制 349 18.9.2 使用时机 350 18.9.3 例：ID生成器（Java） 350 18.10 服务桩（Service Stub） 352 18.10.1 运行机制 352 18.10.2 使用时机 353 18.10.3 例：销售税服务（Java） 353 18.11 记录集（Record Set） 355 18.11.1 运行机制 355 18.11.2 使用时机 356 参考文献 359</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B003LBSRDM/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B003LBSRDM&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/511odOlDcVL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>我编程,我快乐 程序员职业规划之道</title>
    <url>/2020/04/19/B003YU5GNE/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 我编程,我快乐 程序员职业规划之道<br>作者信息： 作者: 福勒(Fowler.C.) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《我编程,我快乐:程序员职业规划之道》：程序员生存、成功、制胜的法则、源自IT精英的职业发展秘诀、热爱工作，享受生活。要在当今的IT职场取得成功，必须像经营企业那样对待你的事业。在本书中.你将学到如何规划自己的职业生涯。让它向着你选择的目标前进。使人生更快乐、更美好。作者运用其独特的思维方式，启发程序员不能只注重技能上的提高.还要关注自己的职业发展。书中涉及新旧技术的取舍、技术与业务的关系、技术是要专精还是要广博等，相信这也是长久以来困扰你的问题。带着这些问题去阅读此书.定会受益良多。此外。本书中的每一章都包含一篇或几篇各领域成功人士的文章，让你直接了解他们如何规划自己的职业生涯。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 选择市场</span><br><span class="line">1 稳定成熟的技术还是未成熟的新技术?</span><br><span class="line">2 供应和需求</span><br><span class="line">3 只会编程是不够的</span><br><span class="line">4 做团队中最差的</span><br><span class="line">5 在思维上投资</span><br><span class="line">6 不要听从父母</span><br><span class="line">7 做一名通才</span><br><span class="line">8 成为一名专家</span><br><span class="line">9 切忌孤注一掷</span><br><span class="line">10 热爱它，不然就离开它 </span><br><span class="line"></span><br><span class="line"> 第2章 在产品上投资 11 学习钓鱼 12 学习行业是如何运转的 13 寻找良师 14 做一名良师 15 练习，练习．再练习 16 做事的方法 17 站在巨人的肩膀上 18 在工作中，将自己自动化</span><br><span class="line"></span><br><span class="line"> 第3章 执行 19 就是现在 20 读心术 21 每日成绩 22 别忘了你在为谁工作 23 安分守己 24 今天我能把工作做到多好? 25 你的价值是多少 26 一桶水中的鹅卵石 27 爱上维护 28 8小时激情燃烧 29 学习如何失败 30 说。不 31 不要恐慌 32 说出来、行动、展示</span><br><span class="line"></span><br><span class="line"> 第4章 推销不仅仅是迎合 33 不要忽视感觉 34 探险向导 35 学会沟通，善于写作 36 到场 37 适当的言语 38 改变世界 39 让人们听到你的声音 40 创建自己的商标 41 发布你编写的程序 42 变为卓越的能力 43 建立关系</span><br><span class="line"></span><br><span class="line"> 第5章 保持技术领先 44 已经过时的技术 45 你已经失去工作了 46 没有终点的道路 47 给自己傲一份蓝图 48 要注意观察市场变化 49 镜子里的胖子 50 南印度捉猴陷阱 51 避免瀑布型职业计划 52 每天都有进步 53 独立 祝你开心 参考文献</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B003YU5GNE/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B003YU5GNE&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51W--YRsIXL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>职场</tag>
      </tags>
  </entry>
  <entry>
    <title>HeadFirst软件开发(中文版)</title>
    <url>/2020/04/19/B003STDPXO/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： HeadFirst软件开发(中文版)<br>作者信息： 作者: 皮隆尼(Dan Pilone) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>您将从《Head First软件开发(中文版)》学会什么？你可曾想过测试驱动开发的真正含义吗？你又曾想过高级顾问是如何运用最佳实践赚取高额钟点费的吗？或许，你正准备进行自动化的构建，使代码在版本控制之中，为软件进行重构，并将一些设计模式集成到你的软件系统之中。在你完成《Head First软件开发(中文版)》阅读之时，你将能跟踪工作量完成状况，解释开发团队中开发人员的编码能力与时间效率值，并且为项目反复进行需求、设计、开发与部署等工作。这《Head First软件开发(中文版)》为何与众不同？我们认为你的时间宝贵，不应该浪费在努力理解新概念之中。利用最新的认知科学与学习理论的研究成果，  《Head First软件开发》采取专为大脑工作而设计的丰富视觉化风格，而不是令人昏昏欲睡的冗赘叙述。重视大脑的学习指南。学习Mary如何满足她的客户的真实用户故事，通过测试驱动开发去避免不可见的软件灾难，通过跟踪burn-down率保持你的项目进度，通过开发速度弄清你的团队的生产率并以此进行评估。掌握经验丰富的软件开发人员的技术和工具。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目录（简要版）</span><br><span class="line">引言</span><br><span class="line">1 伟大的软件开发：让客户满意</span><br><span class="line">2 收集需求：知道客户需要什么</span><br><span class="line">3 项目规划：为成功而筹划</span><br><span class="line">4 使用情节和任务：开始你实际的工作</span><br><span class="line">5 足够好的设计：以良好的设计完成工作</span><br><span class="line">6 版本控制：防御性开发</span><br><span class="line">6．5 构建你的软件代码：自动化构建……</span><br><span class="line">7 测试和连续集成：智者千虑必有一失</span><br><span class="line">8 测试驱动开发：让代码负起责来</span><br><span class="line">9 结束开发循环：涓涓细流归大海……</span><br><span class="line">10 下一轮开发循环：无事就要生非</span><br><span class="line">11 软件错误：专业排错</span><br><span class="line">12 真实的世界：落实流程 </span><br><span class="line"></span><br><span class="line"> 目录（详实版） 引言 把你的心思放在软件开发上。此时，你们围坐在一起，准备开始学习，但你的大脑不停地告诉你，要学习的内容并不重要。你的大脑告诉你说，“最好在大脑中留一点空间，因为还有更重要的事情，就像油价要不要上涨，徒手攀登是不是一个错误的想法。”所以，你如何哄骗你的大脑去思考你的生活真地依赖于你学习怎样开发伟大的软件? 本书适合谁? 我们知道你们在想什么 元认知 让你的大脑顺从你 读我 技术审阅团队 致谢</span><br><span class="line"></span><br><span class="line"> 1 伟大的软件开发 让客户满意 如果你的客户不爽，每个人都不会爽! 软件系统中每段伟大的代码都源自客户的宏大想法。身为职业的软件开发人员，你的工作就是把这些想法付诸实现。但是，要把客户模糊不清的想法转换为可工作的软件代码——客户满意的代码，并不是一件很容易的事情。在本章中，你将学到如何通过交付满足需求、且在预计的时间和预算内的软件，避免成为软件开发战役的阵亡将士。打开你的笔记本电脑，让我们踏上交付伟大软件的征途吧! Tom’s Trail即将上线 大多数项目都有两个焦点 大霹雳式开发法 时间飞驰：两周以后 大霹雳开发法通常以一团糟结束 伟大的软件开发是…… 通过开发循环达到目标 每个开发循环是一个微型项目 每个开发循环都会产生有品质的软件 客户会请求变更 由你来进行调整 然而，有一些大的问题 开发循环自动处理变更(好啦，一点点啦) 直到软件交付，你的开发工作才算完成 软件开发工具箱</span><br><span class="line"></span><br><span class="line"> 2 收集需求 知道客户想要什么 你不能总能得到你想要的……但你的客户应该可以! 伟大的软件开发交付客户所需要的软件系统。本章的内容都将讲述与客户沟通以弄清他们对软件系统的需求。你将学会使用情节(UserStories)、头脑风暴(Brainstorming)、估计游戏(Estimationgame)如何有助于你获得客户的真实想法的。这样的话，在你完成项目之时，你就能深信你开发的软件系统就是客户所想要的，而不是一个低劣的、其他系统的仿制品。 orion’s Orbits正在进行现代化 与客户沟通，获得更多的信息 与客户共筑愿景 有时你的共筑愿景的会议可以这样…… 找出人们真正在做的事情 需求一定是面向客户的 通过客户反馈，澄清需求 使用情节定义了项目要构建什么…… 时间估计值定义了什么时候完成开发 小组交流 玩计划扑克牌的游戏 验证假设 大而不当的使用情节估计值 目标是收敛 需求与估计的反复循环 最后，你准备估计整个项目……</span><br><span class="line"></span><br><span class="line"> 3 项目规划 为成功而筹划 每段伟大的代码始于伟大的计划。 在本章，你就要学会如何创建计划。你要学会与客户一道按优先顺序排序他们的需求。你还要确定开发循环，使你和你的团队向一个方向努力。最后，你还要创建一个有可行性的开发计划，你和你的团队有信心地执行和监控该计划。到你工作完成之时，你就确切地知道如何从需求到软件的第一次交付。 客户现在就要他们的软件! 与客户一起确定优先级顺序 我们知道什么是Milestone 1.0版(好吧，可能知道) 如果功能太多，重新进行优先顺序排序 更多人力有时意味着减损绩效 找到合理的Milestone 1.0 开发循环应该简短和易行 将你的计划与真实情况作比较 时间效率值是在作估计时需要考虑的时间开销 理想国里的程序员…… 现实世界里的开发人员…… 你的开发循环何时算太长? 在你着手开发循环之前，先处理时间效率值 该进行评估了 管理爱炭脾气的客户 墙上的大白板 如何毁了团队的生活</span><br><span class="line"></span><br><span class="line"> 4 使用情节和任务 开始你实际的工作 开始去工作。使用情节抓住了你需要为客户开发什么，但现在是认真开始工作并分派所需要完成的工作的时候了，这样你才能使使用情节成为现实。在这一章里，你将学会如何将使用情节分解成任务，任务估计(Task Estimates)如何帮助你从头到尾跟踪项目。你将学会如何更新你的白板，使进行中的任务成为完成，最终完成整个使用情节。沿着这条道路，你将处理和优先顺序排序你的客户不可避免地增加给你的工作。 iSwoon简介 你的任务汇总了吗? 标注剩余的任务 把任务写在白板上 开始为任务工作 “正在进行中”表示任务正在进行 万一我同时做两件事呢? 你的第一次碰头会…… 任务1：创建：Data类 碰头会：第五天，第一周的最后一天…… 碰头会：第二周的第二天…… 在此先打断一下…… 你必须跟踪计划外的任务 意料之外的任务会让你的工作量完成情况呈上升趋势 时间效率值有帮助，但…… 我们有很多事情要做…… ……但是，我们确切地知道我们身在何处 Velocity的心声 …… 5 足够好的设计 6.1 版本控制 6.2 构建代码 7 测试和连续集成 8 测试驱动开发 9 结束开发循环 10 下一劳务出口开发循环 11 软件错误 12 真实的世界 附录</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B003STDPXO/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B003STDPXO&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/5135nZulFbL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机程序设计艺术 卷3 排序与查找(英文版•第2版)</title>
    <url>/2020/04/19/B00471YUNQ/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 计算机程序设计艺术 卷3 排序与查找(英文版•第2版)<br>作者信息： 作者: Donald E.Knuth [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《计算机程序设计艺术 卷3:排序与查找(英文版·第2版)》：《计算机程序设计艺术》系列著作对计算机领域产生了深远的影响。这一系列堪称一项浩大的工程，自1962年开始编写，计划出版7卷，目前已经出版了4卷。《美国科学家》杂志曾将这套书与爱因斯坦的《相对论》等书并列称为20世纪最重要的12本物理学著作。目前Knuth正将毕生精力投入到这部史诗性著作的撰写中。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Chapter 5 Sorting 1</span><br><span class="line">5.1 Combinatorial Properties of Permutations 11</span><br><span class="line">5.1.1 Inversions 11</span><br><span class="line">5.1.2 Permutations of a Multiset 22</span><br><span class="line">5.1.3 Runs 35</span><br><span class="line">5.1.4 Tableaux and Involutions 47</span><br><span class="line">5.2 Internal sorting 73</span><br><span class="line">5.2.1 Sorting by Insertion 80</span><br><span class="line">5.2.2 Sorting by Exchanging 105</span><br><span class="line">5.2.3 Sorting by Selection 138</span><br><span class="line">5.2.4 Sorting by Merging 158</span><br><span class="line">5.2.5 Sorting by Distribution 168</span><br><span class="line">5.3 Optimum Sorting 180</span><br><span class="line">5.3.1 Minimum-Comparison Sorting 180</span><br><span class="line">5.3.2 Minimum-Comparison Merging 197</span><br><span class="line">5.3.3 Minimum-Comparison Selection 207</span><br><span class="line">5.3.4 Networks for Sorting 219</span><br><span class="line">5.4 External Sorting 248</span><br><span class="line">5.4.1 Multiway Merging and Replacement Selection 252</span><br><span class="line">5.4.2 The Polyphase Merge 267</span><br><span class="line">5.4.3 The Cascade Merge 288</span><br><span class="line">5.4.4 Reading Tape Backwards 299</span><br><span class="line">5.4.5 The Oscillating Sort 311</span><br><span class="line">5.4.6 Practical Considerations for Tape Merging 317</span><br><span class="line">5.4.7 External Radix Sorting 343</span><br><span class="line">5.4.8 Two-Tape Sorting 348</span><br><span class="line">5.4.9 Disks and Drums 356</span><br><span class="line">5.5 Summary, History, and Bibliography 380</span><br><span class="line">Chapter 6 Searching 392</span><br><span class="line">6.1 Sequential Searching 396</span><br><span class="line">6.2 Searching by Comparison of Keys 409</span><br><span class="line">6.2.1 Searching an Ordered Table 409</span><br><span class="line">6.2.2 Binary Tree Searching 426</span><br><span class="line">6.2.3 Balanced Trees 458</span><br><span class="line">6.2.4 Multiway Trees 481</span><br><span class="line">6.3 Digital Searching 492</span><br><span class="line">6.4 Hashing 513</span><br><span class="line">6.5 Retrieval on Secondary Keys 559</span><br><span class="line">Answers to Exercises 584</span><br><span class="line">Appendix A Tables of Numerical Quantities 748</span><br><span class="line">1. Fundamental Constants (decimal) 748</span><br><span class="line">2. Fundamental Constants (octal) 749</span><br><span class="line">3. Harmonic Numbers, Bernoulli Numbers, Fibonacci Numbers 750</span><br><span class="line">Appendix B Index to Notations 752</span><br><span class="line">Index and Glossary 757</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00471YUNQ/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00471YUNQ&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51hTQgSZIFL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员修炼之道 从小工到专家</title>
    <url>/2020/04/19/B004GV08CY/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 程序员修炼之道 从小工到专家<br>作者信息： 作者: 亨特(Andrew Hunt) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《程序员修炼之道:从小工到专家》：传承大师智慧 领悟技术本真经典名著 翻译良品 典藏不二之选</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">序</span><br><span class="line">第1章 注重实效的哲学 1</span><br><span class="line">1 我的源码让猫给吃了 2</span><br><span class="line">2 软件的熵 3</span><br><span class="line">3 石头汤与煮青蛙 5</span><br><span class="line">4 足够好的软件 8</span><br><span class="line">5 你的知识资产 10</span><br><span class="line">6 交流 14 </span><br><span class="line"></span><br><span class="line"> 第2章 注重实效的途径 19 7 重复的危害 20 8 正交性 25 9 可撤消性 33 10 曳光弹 36 11 原型与便笺 40 12 领域语言 43 13 估算 48</span><br><span class="line"></span><br><span class="line"> 第3章 基本工具 55 14 纯文本的威力 56 15 shell游戏 60 16 强力编辑 63 17 源码控制 67 18 调试 69 19 文本操纵 77 20 代码生成器 80</span><br><span class="line"></span><br><span class="line"> 第4章 注重实效的偏执 85 21 按合约设计 86 22 死程序不说谎 95 23 断言式编程 97 24 何时使用异常 100 25 怎样配平资源 103</span><br><span class="line"></span><br><span class="line"> 第5章 弯曲，或折断 111 26 解耦与得墨忒耳法则 112 27 元程序设计 117 28 时间耦合 121 29 它只是视图 127 30 黑板 134</span><br><span class="line"></span><br><span class="line"> 第6章 当你编码时 139 31 靠巧合编程 140 32 算法速率 144 33 重构 149 34 易于测试的代码 153 35 邪恶的向导 160</span><br><span class="line"></span><br><span class="line"> 第7章 在项目开始之前 163 36 需求之坑 163 37 解开不可能解开的谜题 172 38 等你准备好 174 39 规范陷阱 176 40 圆圈与箭头 178</span><br><span class="line"></span><br><span class="line"> 第8章 注重实效的项目 181 41 注重实效的团队 181 42 无处不在的自动化 186 43 无情的测试 191 44 全都是写 200 45 极大的期望 205 46 傲慢与偏见 208</span><br><span class="line"></span><br><span class="line"> 附录A 资源 209 专业协会 209 建设藏书库 210 Internet资源 212 参考文献 221 附录B 练习解答 225 索引 249 注重实效的程序员之快速参考指南 263</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B004GV08CY/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B004GV08CY&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51Z8gCBHedL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>中文编程 从入门到精通(附光盘1张)</title>
    <url>/2020/04/19/B004IYJ2QC/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 中文编程 从入门到精通(附光盘1张)<br>作者信息： 作者: 大连易翔软件开发有限公司 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《中文编程:从入门到精通》：中文编程语言 易学易用实用全中文呈可视 蹭平台编程模块化开发 面向对象编程内置输八法 即时信息帮助可广充支持厍 麦持所有数据库即看即学 轻松学会编程国文并茂 代码明晰行业程序源码解读 游戏开发设计分析</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分 易语言的基础知识</span><br><span class="line">第一章 概述</span><br><span class="line">1.1 易语言概述</span><br><span class="line">1.1.1 易语言简介</span><br><span class="line">1.1.2 易语言的发展史</span><br><span class="line">1.1.3 易语言的特点</span><br><span class="line">1.2 易语言的安装</span><br><span class="line">1.3 易语言的工作界面</span><br><span class="line">1.3.1 易语言的界面</span><br><span class="line">1.3.2 易语言的菜单栏</span><br><span class="line">1.4 代码编辑环境</span><br><span class="line">1.4.1 代码输入提示</span><br><span class="line">1.4.2 前层提示信息</span><br><span class="line">1.4.3 代码输入方式</span><br><span class="line">1.4.4 参数分步输入</span><br><span class="line">1.4.5 输入注释与代码屏蔽</span><br><span class="line">1.4.6 易语言语句分类</span><br><span class="line">1.4.7 易语言中的关键字</span><br><span class="line">1.4.8 书签</span><br><span class="line">1.4.9 即时帮助和帮助文档</span><br><span class="line">1.5 第一个易语言程序</span><br><span class="line">1.6 我的播放器(一)</span><br><span class="line">1.7 小结 </span><br><span class="line"></span><br><span class="line"> 第二章 易语言编程基础 2.1 变量与常量 2.1.1 数据类型 2.1.2 变量 2.1.3 常量 2.1.4 资源表 2.2 运算符和表达式 2.2.1 运算符 2.2.2 表达式 2.2.3 赋值运算符和赋值表达式 2.3 子程序的编写与调用 2.3.1 了解子程序 2.3.2 事件子程序 2.3.3 用户自定义子程序 2.3.4 子程序的返回值 2.3.5 子程序的调用 2.3.6 子程序的参数 2.3.7 子程序的递归调用 2.4 我的播放器(二) 2.5 小结 2.6 习题</span><br><span class="line"></span><br><span class="line"> 第二部分 易语言的命令与组件 第三章 易语言的命令 3.1 了解易语言命令i 3.1.1 易语言命令概述 3.1.2 易语言命令的格式 3.1.3 易语言命令的参数 3.1.4易语言命令的返回值 3.1.5 易语言命令嵌套调用 3.1.6 数组参数与数组返回值 3.2 流程控制命令 3.2.1 了解流程控制类命令 3.2.2 分支类流程控制命令 3.2.3 循环类流程控制命令 3.2.4 跳转类流程控制命令 3.3 算术运算命令 3.3.1 基本算术运算命令及其运算符 3.3.2 扩展算术运算命令 3.4 逻辑比较 3.4.1 逻辑比较命令 3.4.2 多条件逻辑比较时的运算顺序 3.5 位运算命令 3.5.1 了解位运算 3.5.2 常用进制 3.5.3 位运算命令 3.6 数组操作命令 3.6.1 了解数组 3.6.2 数组操作命令 3.7 环境存取命令 3.8 拼音处理命令 3.9 文本操作命令 3.9.1 文字编码和存储方式 3.9.2 ASCII 3.9.3 区别键代码和文字编码 3.9.4 文本操作命令 3.10 时间操作命令 3.11 数值转换命令 3.12 字节集操作命令 3.13 磁盘操作命令 3.13.1 相关知识 3.13.2 易语言中的磁盘操作命令 3.14 文件读写命令 3.15 系统处理命令 3.15.1 了解剪辑板 3.15.2 了解注册表 3.15.3 系统处理命令 3.16 媒体播放命令 3.16.1 常见的音频格式 3.16.2 媒体播放命令 3.17网络通信命令 3.17.1 了解IP地址 3.17.2 一I解域名与主机名 3.17.3 易语言中的网络通信命令 3.18 其他命令 3.19 我的播放器(三) 3.2 0小结 3.2 1习题</span><br><span class="line"></span><br><span class="line"> 第四章 易语言组件 4.1 窗口 4.1.1 窗口的定义 4.1.2 共有属性 4.1.3 独有属性 4.1.4.共有事件 4.1.5 独有事件 4.1.6 共有命令 4.2 菜单 4.2.1 创建菜单 4.2.2 菜单的热键及属性 4.3 按钮类组件 4.3.1 按钮 4.3.2 图形按钮 4.4 列表类组件 4.4.1 组合框 4.4.2 列表框 4.4.3 选择列表框 4.5 系统类组件 4.5.1 通用对话框 4.5.2 文件框 4.5.3 目录框 4.5.4 驱动器框 4.5.5 端口 4.6 图形类组件 4.6.1 图片框 4.6.2 画板 4.6.3 颜色选择器 4.7 分组类组件 4.7.1 分组框 4.7.2 外形框 4.7.3 选择框 4.7.4 单选框 4.7.5 选择夹 4.8 位置控制类组件 4.8.1 进度条 4.8.2 滑块条 4.8.3 横向滚动条 4.8.4 纵向滚动条 4.8.5 调节器 4.9 网络与通信组件 4.9.1 客户 4.9.2 服务器 4.9.3 数据报 4.9.4 超级链接框 4.10时间类组件 4.10.1 时钟 4.10.2 月历 4.10.3 日期框 4.11显示类组件 4.11.1 编辑框 4.11.2 标签 4.11.3表格 4.11.4 打印机 4.11.5 影像框 4.12数据库类组件 4.12.1 数据库提供者 4.12.2 数据源 4.12.3 通用提供者 4.13核心库内置数据类型 4.13.1 库内置数据类型的使用 4.13.2 字体 4.13.3 打印设置信息 4.14.我的播放器(四) 4.15小结 4.16习题</span><br><span class="line"></span><br><span class="line"> 第三部分 易语言的数据库应用 第五章 易语言数据库的应用 5.1 了解易语言数据库 5.2 创建易数据库 5.2.1 使用菜单创建易数据库 5.2.2 使用代码创建易数据库 5.3 为易数据库添加记录 5.4 易数据库密码的设置 5.5 易数据库相关组件 5.5.1 易数据库相关组件分类 5.5.2 易数据库相关组件介绍 5.5.3 易数据库组件关联方法 5.6 程序界面设计与组件关联 5.6.1 易数据库程序的界面设计 5.6.2 易数据库程序的组件关联 5.7 易数据库的操作命令 5.7.1 数据库的打开与关闭 5.7.2 数据库指针的跳转命令 5.7.3 记录读取命令 5.7.4.数据源的常用命令 5.7.5 记录的添加与修改命令 5.7.6 记录的删除命令 5.7.7 复制记录与复制结构命令 5.7.8 数值统计类命令 5.7.9 记录的查找 5.7.1 0索引的创建与使用 5.8 我的播放器(五) 5.9 小结 5.1 0习题</span><br><span class="line"></span><br><span class="line"> 第六章 外部数据库的应用 6.1 外部数据库简介 6.1.1 外部数据库组件 6.1.2 ODBC与ADO 6.1.3 Access数据库 6.2 SQL语言应用 6.2.1 常用的SQL语句 6.2.2 定义数据库用户的权限 6.2.3 定义表的结构 6.2.4 数据检索 6.3 外部数据库组件 6.3.1 “外部数据提供者”组件 6.3.2 J_立用实例 6.3.3 “外部数据库”组件 6.4.数据库连接和记录集 6.4.1 应用实例 6.4.2 “数据库连接”组件 6.4.3 “记录集”组件 6.5 小结 6.6 习题</span><br><span class="line"></span><br><span class="line"> 第四部分 易语言高级应用 第七章 DLL的应用 7.1 了解DLI 7.2 编写DLI 7.3 编译DLI 7.4 调用DLI 7.5 小结 7.6 习题</span><br><span class="line"></span><br><span class="line"> 第八章 API的应用 8.1 了解API 8.2 定义API 8.3 调用API 8.3.1 调用系统API 8.3.2 调用非系统API 8.4 应用实例 8.5 小结 8.6 习题</span><br><span class="line"></span><br><span class="line"> 第九章 OCX组件与类型库 9.1 OCX组件 9.1.1 OCX组件的安装 9.1.2 OCX组件的使用 9.2 类型库 9.2.1 类型库的安装 9.2.2 类型库的使用 9.3 小结 9.4 习题</span><br><span class="line"></span><br><span class="line"> 第十章 面向对象 10.1 了解面向对象 10.1.1 类的概念 10.1.2 类的创建 10.2 类的特性 10.2.1 类的封装性 10.2.2 类的继承性 10.2.3 类的多态性 10.3 小结 10.4 习题</span><br><span class="line"></span><br><span class="line"> 第十一章 对象和COM对象 11.1 对象的应用 11.1.1 对象型变量的定义 11.1.2 “对象”数据类型 11.1.3 “变体型”数据类型 11.2 COM对象的应用 11.3 小结 11_4习题</span><br><span class="line"></span><br><span class="line"> 第十二章 易模块的应用 12.1 了解易模块 12.2 易模块的开发与编译 12.2.1 易模块的开发 12.2.2 易模块的编译 12.3 易模块的引用方法 12.4 易模块的应用实例 12.5 小结 12.6 习题</span><br><span class="line"></span><br><span class="line"> 第十三章 易语言向导 13.1 了解易语言向导 13.2 易语言向导支持库 ：13.3 易语言向导的编写 13.4.易语言向导的使用方法 13.5 小结 13.6 习题</span><br><span class="line"></span><br><span class="line"> 第十四章 程序调试 14.1 了解程序调试 14.2 运行调试 14.2.1 预编译调试 14.2.2 运行中的调试 14.3 调试命令 14.4 小结 14.5 习题</span><br><span class="line"></span><br><span class="line"> 第十五章 程序的编译与发布 15.1 编译前的配置 15.2 易语言程序的编译 ：15.2.1 易语言5.x版本的编译 15.2.2 易语言4.x版本的编译 15.3 编译生成安装软件 15.4 编译安装应用实例 15.5 小结 15.6 习题</span><br><span class="line"></span><br><span class="line"> 第五部分 易语言程序的解读和程序设计思路 第十六章 解读学校图书管理系统 16.1 软件需求分析 16.1.1 软件使用环境 16.1.2 功能需求分析 16.1.3 软件运行环境需求 16.2 解读学校图书管理系统 16.2.1 试运行程序 16.2.2 解读程序 16.3 后记</span><br><span class="line"></span><br><span class="line"> 第十七章 解读游戏——对对碰 17.1 游戏策划分析 17.1 JJ游戏策划文档实例 17.1.2 小结 17.2 解读游戏——对对碰 17.2.1 解读游戏构架 17.2.2 解读游戏逻辑 17.2.3 解读特殊块功能的实现 17.2.4 解读重绘画面 17.3 后记</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B004IYJ2QC/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B004IYJ2QC&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/519YDhWoUzL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>易语言</tag>
      </tags>
  </entry>
  <entry>
    <title>大话数据结构</title>
    <url>/2020/04/19/B0053F0HNW/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 大话数据结构<br>作者信息： 作者: 程杰 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《大话数据结构》为超级畅销书《大话设计模式》作者程杰潜心三年推出的扛鼎之作！以一个计算机教师教学为场景，讲解数据结构和相关算法的知识。通篇以一种趣味方式来叙述，大量引用了各种各样的生活知识来类比，并充分运用图形语言来体现抽象内容，对数据结构所涉及到的一些经典算法做到逐行分析、多算法比较。与市场上的同类数据结构图书相比，本书内容趣味易读，算法讲解细致深刻，是一本非常适合自学的读物。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章  数据结构绪论 1</span><br><span class="line">1.1  开场白  2</span><br><span class="line">如果你交给某人一个程序，你将折磨他一整天；如果你教某人如何编写程序，你将折磨他一辈子。</span><br><span class="line">1.2  你数据结构怎么学的？ 3</span><br><span class="line">他完成开发并测试通过后，得意地提交了代码。项目经理看完代码后拍着桌子对他说：“你数据结构是怎么学的？”</span><br><span class="line">1.3  数据结构起源 4</span><br><span class="line">1.4  基本概念和术语 5</span><br><span class="line">正所谓“巧妇难为无米之炊”，再强大的计算机，也要有“米”下锅才可以干活，否则就是一堆破铜烂铁。这个“米”就是数据。</span><br><span class="line">1.4.1  数据 5</span><br><span class="line">1.4.2  数据元素 5</span><br><span class="line">1.4.3  数据项 6</span><br><span class="line">1.4.4  数据对象 6</span><br><span class="line">1.4.5  数据结构 6</span><br><span class="line">1.5  逻辑结构与物理结构 7</span><br><span class="line">1.5.1  逻辑结构 7</span><br><span class="line">1.5.2  物理结构 9</span><br><span class="line">1.6  抽象数据类型 11</span><br><span class="line">大家都需要房子住，但显然没钱考虑大房子是没有意义的。于是商品房就出现了各种各样的户型，有几百平米的别墅，也有仅两平米的胶囊公寓……</span><br><span class="line">1.6.1  数据类型 11</span><br><span class="line">1.6.2  抽象数据类型 12</span><br><span class="line">1.7  总结回顾 14</span><br><span class="line">1.8  结尾语 15</span><br><span class="line">最终的结果一定是，你对着别人很牛的说“数据结构——就那么回事。” </span><br><span class="line"></span><br><span class="line"> 第2章 算法 17 2.1 开场白 18 2.2 数据结构与算法关系 18 计算机界的前辈们，是一帮很牛很牛的人，他们使得很多看似没法解决或者很难解决的问题，变得如此美妙和神奇。 2.3 两种算法的比较 19 高斯在上小学的一天，老师要求每个学生都计算1+2+…+100的结果，谁先算出来谁先回家…… 2.4 算法定义 20 现实世界中的算法千变万化，没有通用算法可以解决所有问题。甚至一个小问题，某个解决此类问题很优秀的算法却未必就适合它。 2.5 算法的特性 21 2.5.1 输入输出 21 2.5.2 有穷性 21 2.5.3 确定性 21 2.5.4 可行性 21 2.6 算法设计的要求 22 求100个人的高考成绩平均分与求全省所有考生的成绩平均分在占用时间和内存存储上有非常大的差异，我们自然追求高效率和低存储的算法来解决问题。 2.6.1 正确性 22 2.6.2 可读性 23 2.6.3 健壮性 23 2.6.4 时间效率高和存储量低 23 2.7 算法效率的度量方法 24 随着n值越来越大，它们在时间效率上的差异也就越来越大。好比有些人每天都在学习，而另一些人，打打游戏、睡睡大觉，毕业后前者名企争着要，后者求职处处无门。 2.7.1 事后统计方法 24 2.7.2 事前分析估算方法 25 2.8 函数的渐近增长 27 2.9 算法时间复杂度 29 理解大O推导不算难，难的其实是对数列的一些相关运算，这考察的更多的是数学知识和能力。 2.9.1 算法时间复杂度定义 29 2.9.2 推导大O阶方法 30 2.9.3 常数阶 30 2.9.4 线性阶 31 2.9.5 对数阶 32 2.9.6 平方阶 32 2.10 常见的时间复杂度 35 有些时候，告诉你某些东西不可以去尝试，也是一种知识的传递。总不能非要去被毒蛇咬一口才知道蛇不可以去招惹吧。 2.11 最坏情况与平均情况 35 2.12 算法空间复杂度 36 事先建立一个有2050大的数组，然后把所有年份按下标数字对应，如果是闰年，此数组项的值就是1，如果不是就是0。这样，所谓的判断某一年是否是闰年就变成了查找这个数组的某一项的值是多少的问题。 2.13 总结回顾 37 2.14 结尾语 38 愚公移山固然可敬，但发明炸药和推土机，可能更加实在和聪明。</span><br><span class="line"></span><br><span class="line"> 第3章 线性表 41 3.1 开场白 42 门外家长都挤在大门口与门里的小孩子的井然有序，形成了鲜明对比。哎，有时大人的所作所为，其实还不如孩子。 3.2 线性表的定义 42 3.3 线性表的抽象数据类型 45 有时我们想知道某个小朋友（比如麦兜）是否是班级的同学，老师会告诉我说，没有，麦兜是在春田花花幼儿园里。这种查找某个元素是否存在的操作很常用。 3.4 线性表的顺序存储结构 47 他每次一吃完早饭就冲着去了图书馆，挑一个好地儿，把他书包里的书，一本一本的按座位放好，长长一排，九个座硬是被他占了。 3.4.1 顺序存储定义 47 3.4.2 顺序存储方式 47 3.4.3 数据长度与线性表长度区别 48 3.4.4 地址计算方法 49 3.5 顺序存储结构的插入与删除 50 春运时去买火车票，大家都排队排着好好的，这时来了一个美女：“可否让我排在你前面？”这可不得了，后面的人像蠕虫一样，全部都得退后一步。 3.5.1 获得元素操作 50 3.5.2 插入操作 51 3.5.3 删除操作 52 3.5.4 线性表顺序存储结构的优缺点 54 3.6 线性表的链式存储结构 55 反正也是要让相邻元素间留有足够余地，那干脆所有元素都不要考虑相邻位置了，哪有空位就到哪里。而只是让每个元素知道它下一个元素的位置在哪里。 3.6.1 顺序存储结构不足的解决 办法 55 3.6.2 线性表链式存储结构定义 56 3.6.3 头指针与头结点的异同 58 3.6.4 线性表链式存储结构代码描述 58 3.7 单链表的读取 60 3.8 单链表的插入与删除 61 本来是爸爸左牵着妈妈的手、右牵着宝宝的手在马路边散步。突然迎面走来一美女，爸爸失神般地望着，此情景被妈妈逮个正着，于是扯开父子俩，拉起宝宝的左手就快步朝前走去。 3.8.1 单链表的插入 61 3.8.2 单链表的删除 64 3.9 单链表的整表创建 66 3.10 单链表的整表删除 69 3.11 单链表结构与顺序存储结构优缺点 70 3.12 静态链表 71 对于一些语言，如Basic、Fortran等早期的编程高级语言，由于没有指针，这链表结构，按照前面我们的讲法，它就没法实现了。怎么办呢？ 3.12.1 静态链表的插入操作 73 3.12.2 静态链表的删除操作 75 3.12.3 静态链表优缺点 77 3.13 循环链表 78 这个轮回的思想很有意思。它强调了不管你今生是穷是富，如果持续行善积德，下辈子就会好过，反之就会遭到报应。 3.14 双向链表 81 就像每个人的人生一样，欲收获就得付代价。双向链表既然是比单链表多了如可以反向遍历查找等的数据结构，那么也就需要付出一些小的代价。 3.15 总结回顾 84 3.16 结尾语 85 如果你觉得上学读书是受罪，假设你可以活到80岁，其实你最多也就吃了20年苦。用人生四分之一的时间来换取其余时间的幸福生活，这点苦不算啥。</span><br><span class="line"></span><br><span class="line"> 第4章 栈与队列 87 4.1 开场白 88 想想看，在你准备用枪的时候，突然这手枪明明有子弹却打不出来，这不是要命吗。 4.2 栈的定义 89 类似的很多软件，比如Word、Photoshop等，都有撤消（undo）的操作，也是用栈这种思想方式来实现的。 4.2.1 栈的定义 89 4.2.2 进栈出栈变化形式 90 4.3 栈的抽象数据类型 91 4.4 栈的顺序存储结构及实现 92 4.4.1 栈的顺序存储结构 92 4.4.2 栈的顺序存储结构进栈操作 93 4.4.3 栈的顺序存储结构出栈操作 94 4.5 两栈共享空间 94 两个大学室友毕业同时到北京工作，他们都希望租房时能找到独自住的一室户或一室一厅，可找来找去发现，实在是承受不起。 4.6 栈的链式存储结构及实现 97 4.6.1 栈的链式存储结构 97 4.6.2 栈的链式存储结构进栈操作 98 4.6.3 栈的链式存储结构出栈操作 99 4.7 栈的作用 100 4.8 栈的应用——递归 100 当你往镜子前面一站，镜子里面就有一个你的像。但你试过两面镜子一起照吗？如果A、B两面镜子相互面对面放着，你往中间一站，嘿，两面镜子里都有你的千百个“化身”。 4.8.1 斐波那契数列实现 101 4.8.2 递归定义 103 4.9 栈的应用——四则运算表达式求值 104 4.9.1 后缀（逆波兰）表示法定义 104 4.9.2 后缀表达式计算结果 106 4.9.3 中缀表达式转后缀表达式 108 4.10 队列的定义 111 电脑有时会处于疑似死机的状态。就当你失去耐心，打算了Reset时。突然它像酒醒了一样，把你刚才点击的所有操作全部都按顺序执行了一遍。 4.11 队列的抽象数据类型 112 4.12 循环队列 113 你上了公交车发现前排有两个空座位，而后排所有座位都已经坐满，你会怎么做？立马下车，并对自己说，后面没座了，我等下一辆？没这么笨的人，前面有座位，当然也是可以坐的。 4.12.1 队列顺序存储的不足 112 4.12.2 循环队列定义 114 4.13 队列的链式存储结构及实现 117 4.13.1 队列链式存储结构入队操作118 4.13.2 队列链式存储结构出队操作 119 4.14 总结回顾 120 4.15 结尾语 121 人生，需要有队列精神的体现。南极到北极，不过是南纬90度到北纬90度的队列，如果你中途犹豫，临时转向，也许你就只能和企鹅相伴永远。可事实上，无论哪个方向，只要你坚持到底，你都可以到达终点。</span><br><span class="line"></span><br><span class="line"> 第5章 串 123 5.1 开场白 124 “枯眼望遥山隔水，往来曾见几心知？壶空怕酌一杯酒，笔下难成和韵诗。途路阻人离别久，讯音无雁寄回迟。孤灯夜守长寥寂，夫忆妻兮父忆儿。”……可再仔细一读发现，这首诗竟然可以倒过来读。 5.2 串的定义 124 我所提到的“over”、“end”、“lie”其实就是“lover”、“friend”、“believe”这些单词字符串的子串。 5.3 串的比较 126 5.4 串的抽象数据类型 127 5.5 串的存储结构 128 感情上发生了问题，为了向女友解释一下，我准备发一条短信，一共打了75个字。最后八个字是“我恨你是不可能的”，点发送。后来得知对方收到的，只有70个字，短信结尾是“……我恨你”。 5.5.1 串的顺序存储结构 129 5.5.2 串的链式存储结构 131 5.6 朴素的模式匹配算法 131 主串为S&#x3D;”00000000000000000000000000000000000000000000000001”，而要匹配的子串为T&#x3D;”0000000001”，……在匹配时，每次都得将T中字符循环到最后一位才发现，哦，原来它们是不匹配的。 5.7 KMP模式匹配算法 135 很多年前我们的科学家觉得像这种有多个0和1重复字符的字符串，却需要挨个遍历的算法，是非常糟糕的事情。 5.7.1 KMP模式匹配算法原理 135 5.7.2 next数组值推导 139 5.7.3 KMP模式匹配算法实现 141 5.7.4 KMP模式匹配算法改进 142 5.7.5 nextval数组值推导 144 5.8 总结回顾 146 5.9 结尾语 146 《璇玑图》共八百四十字，纵横各二十九字，纵、横、斜、交互、正、反读或退一字、迭一字读均可成诗，诗有三、四、五、六、七言不等，目前有人统计可组成七千九百五十八首诗。听清楚哦，是7958首。</span><br><span class="line"></span><br><span class="line"> 第6章 树 149 6.1 开场白 150 无论多高多大的树，那也是从小到大的，由根到叶，一点点成长起来的。俗话说十年树木，百年树人，可一棵大树又何止是十年这样容易。 6.2 树的定义 150 树的定义其实就是我们在讲解栈时提到的递归的方法。也就是在树的定义之中还用到了树的概念，这是比较新的一种定义方法。 6.2.1 结点分类 152 6.2.2 结点间关系 152 6.2.3 树的其他相关概念 153 6.3 树的抽象数据类型 154 6.4 树的存储结构 155 6.4.1 双亲表示法 155 6.4.2 孩子表示法 158 6.4.3 孩子兄弟表示法 162 6.5 二叉树的定义 163 苏东坡曾说：“人有悲欢离合，月有阴晴圆缺，此事古难全”。意思就是完美是理想，不完美才是人生。我们通常举的例子也都是左高右低、参差不齐的二叉树。那是否存在完美的二叉树呢？ 6.5.1 二叉树特点 164 6.5.2 特殊二叉树 166 6.6 二叉树的性质 169 6.6.1 二叉树性质1 169 6.6.2 二叉树性质2 169 6.6.3 二叉树性质3 169 6.6.4 二叉树性质4 170 6.6.5 二叉树性质5 171 6.7 二叉树的存储结构 172</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0053F0HNW/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0053F0HNW&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51dpzHw4KpL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>人件(第2版)</title>
    <url>/2020/04/19/B004OQJX2M/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 人件(第2版)<br>作者信息： 作者: UML China [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《人件(第2版)》是软件管理与软件工程译丛之一。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第Ⅰ篇管理人力资源</span><br><span class="line">第1章 在今天的某个地方，一个项目正在失败</span><br><span class="line">问题的实质</span><br><span class="line">高科技幻觉 </span><br><span class="line"></span><br><span class="line"> 第2章 做吉士汉堡，卖吉士汉堡 错误限额 管理：莽汉的定义 人员储备 一个稳定状态的项目就是死胡同 我们还没有时间来考虑这项工作 只有时间来做这项工作</span><br><span class="line"></span><br><span class="line"> 第3章 维也纳在等着你 使用西班牙人理论的管理 来自后方的一句话 世上没有加班这回事 工作狂 生产力：赢得战役和输掉战争 反复</span><br><span class="line"></span><br><span class="line"> 第4章 质量——如果时间许可 逃避优秀 质量是免费的，但 否决权</span><br><span class="line"></span><br><span class="line"> 第5章 重新研究帕金森定律 帕金森定律和牛顿定律 要是见过我说的那位， 你就不会这么说了 来自新南威尔士大学的一些数据 帕金森定律主题的变化</span><br><span class="line"></span><br><span class="line"> 第6章 苦杏仁苷 在睡觉时减肥 七个女妖 这就是管理 …… 第Ⅱ篇 办公环境 第7章 家具警察 第8章 朝九晚五无所为 第9章 在空间上省钱 第10章 脑力时间与体力时间 第11章 电话 第12章 把门带上 第13章 采取保护步骤</span><br><span class="line"></span><br><span class="line"> 第Ⅲ篇 适当人选 第14章 霍恩布洛尔因子 第15章 雇用一个变戏法的人 第16章 很高兴在这里 第17章 自愈系统</span><br><span class="line"></span><br><span class="line"> 第Ⅳ篇 培育高生产力团队 第18章 整体大于部分的总和 第19章 黑衣团队 第20章　团队自杀 第21章 一顿意大利通心粉晚宴 第22章 思想开放 第23章 促使团队形成的亲和力</span><br><span class="line"></span><br><span class="line"> 第Ⅴ篇 在这里工作应该很开心 第24章 混乱和秩序 第25章 “自由电子” 第26章 霍尔加·丹斯克</span><br><span class="line"></span><br><span class="line"> 第Ⅵ篇 《人件》续集 第27章 再访团队自杀 第28章 竞争 第29章 过程改进步骤 第30章 使变更成为可能 第31章 人力资本 第32章 公司的学习 第33章 管理上的最大罪行是…… 第34章 社区的形成 注释 参考文献</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B004OQJX2M/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B004OQJX2M&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41u8ubypTvL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 3D游戏开发技术详解与典型案例</title>
    <url>/2020/04/19/B0051PH5FW/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Android 3D游戏开发技术详解与典型案例<br>作者信息： 作者: 吴亚峰 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>目前市面上的Android技术书籍还比较少，Android 3D游戏开发的书籍更是没有。因此，在现在市面上，Android游戏开发的书籍特别是Android 3D游戏开发的书籍还是有相当大的市场需求。<br>《Android3D游戏开发技术详解与典型案例》既介绍了Android 3D游戏开发中必知必会的基础知识，同时通过7个真实案例向读者介绍Android 3D游戏的完整开发步骤，希望通过本书能够使读者尽快掌握Android 3D游戏开发的相关知识。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一篇 必知必会的基础知识</span><br><span class="line">第1章 英雄还看今朝——Android简介 20</span><br><span class="line">1.1 群雄割据的手机市场   20</span><br><span class="line">1.1.1 手机市场的两颗新星       20</span><br><span class="line">1.1.2 手机操作系统的5大元老       21</span><br><span class="line">1.2 Android的未来及特点 22</span><br><span class="line">1.2.1 得中国市场者得天下       22</span><br><span class="line">1.2.2 全新的概念带来全新的体验   22</span><br><span class="line">1.3 Android开发环境的搭建    22</span><br><span class="line">1.3.1 SDK的安装及环境配置   22</span><br><span class="line">1.3.2 Eclipse集成开发环境的搭建   23</span><br><span class="line">1.3.3 模拟器的创建和运行       24</span><br><span class="line">1.4 第一个Android应用程序的开发       25</span><br><span class="line">1.4.1 第一个Android程序 26</span><br><span class="line">1.4.2 Android应用程序的调试 27</span><br><span class="line">1.5 Android应用程序运行的内部机制    29</span><br><span class="line">1.5.1 Android应用程序的项目结构 30</span><br><span class="line">1.5.2 Android 应用程序的系统架构       31</span><br><span class="line">1.5.3 Android 应用程序框架    32</span><br><span class="line">1.5.4 Android 运行时       32</span><br><span class="line">1.5.5 系统库       33</span><br><span class="line">1.5.6 Linux内核 34</span><br><span class="line">1.6 本章小结      34</span><br><span class="line">第2章 数风流人物——当前流行游戏类型简介    35</span><br><span class="line">2.1 AVG冒险游戏     35</span><br><span class="line">2.1.1 游戏玩法   35</span><br><span class="line">2.1.2 视觉效果   35</span><br><span class="line">2.1.3 游戏设计   36</span><br><span class="line">2.2 PZL益智类游戏   36</span><br><span class="line">2.2.1 游戏玩法   36</span><br><span class="line">2.2.2 视觉效果   37</span><br><span class="line">2.2.3 游戏设计   37</span><br><span class="line">2.3 ACT动作游戏      38</span><br><span class="line">2.3.1 历代游戏介绍   38</span><br><span class="line">2.3.2 未来动作游戏的发展       39</span><br><span class="line">2.4 RPG角色扮演类游戏 40</span><br><span class="line">2.4.1 历代游戏介绍   40</span><br><span class="line">2.4.2 Android平台游戏移植     42</span><br><span class="line">2.5 STG射击类游戏 43</span><br><span class="line">2.5.1 游戏的分类       43</span><br><span class="line">2.5.2 游戏的玩法       44</span><br><span class="line">2.5.3 游戏设计   44</span><br><span class="line">2.6 FPS第一人称视角射击游戏      44</span><br><span class="line">2.6.1 游戏玩法   44</span><br><span class="line">2.6.2 视觉效果   45</span><br><span class="line">2.6.3 游戏设计   45</span><br><span class="line">2.7 SLG策略游戏      46</span><br><span class="line">2.7.1 游戏的玩法       46</span><br><span class="line">2.7.2 视觉效果   46</span><br><span class="line">2.7.3 游戏设计   47</span><br><span class="line">2.8 SPT体育类游戏   47</span><br><span class="line">2.8.1 游戏的玩法       47</span><br><span class="line">2.8.2 视觉效果   47</span><br><span class="line">2.8.3 游戏设计   47</span><br><span class="line">2.9 本章小结      48</span><br><span class="line">第3章 不积跬步，无以至千里—游戏开发基础知识    49</span><br><span class="line">3.1 游戏中的声音      49</span><br><span class="line">3.1.1 迅雷不及掩耳的即时音效       49</span><br><span class="line">3.1.2 一个即时音效的例子       50</span><br><span class="line">3.1.3 背景音乐播放技术   53</span><br><span class="line">3.1.4 简单音乐播放器实现       55</span><br><span class="line">3.2 手机中的数据库——SQLite       59</span><br><span class="line">3.2.1 SQLite数据库简介   59</span><br><span class="line">3.2.2 SQLite数据库的基本操作       60</span><br><span class="line">3.2.3 SQLite操作数据库的简单应用       60</span><br><span class="line">3.3 文件I&#x2F;O 64</span><br><span class="line">3.3.1 轻松访问SD卡 64</span><br><span class="line">3.3.2 访问手机中的存储文件夹       67</span><br><span class="line">3.3.3 读取assets中的文件 68</span><br><span class="line">3.4 存储简单数据的利器——Preferences       70</span><br><span class="line">3.4.1 Preferences简介       70</span><br><span class="line">3.4.2 Preferences实现显示上次登录时间       70</span><br><span class="line">3.5 SURFACEView在游戏中的使用       72</span><br><span class="line">3.5.1 SurfaceView简单操作      72</span><br><span class="line">3.5.2 简单动画场景的绘制       73</span><br><span class="line">3.6 本章小结      78</span><br><span class="line">第4章 千里之行，始于足下—3D开发基础知识 79</span><br><span class="line">4.1 OpenGL ES 简介 79</span><br><span class="line">4.1.1 师出名门的OpenGL ES   79</span><br><span class="line">4.1.2 三角形组成的世界   80</span><br><span class="line">4.1.3 第一个OpenGL ES三角形      82</span><br><span class="line">4.2 不同的绘制方式   87</span><br><span class="line">4.2.1 点和线的绘制   87</span><br><span class="line">4.2.2 索引法绘制三角形   93</span><br><span class="line">4.2.3 顶点法绘制三角形   101</span><br><span class="line">4.3 不一样的投影，不一样的世界   103</span><br><span class="line">4.3.1 正交投影   103</span><br><span class="line">4.3.2 透视投影   104</span><br><span class="line">4.3.3 两种投影的比较       105</span><br><span class="line">4.3.4 近大远小的原理       112</span><br><span class="line">4.4 本章小结      114</span><br><span class="line">第5章 愿君多采撷，此物最相思——光照效果的开发       115</span><br><span class="line">5.1 五彩缤纷的源泉——光源   115</span><br><span class="line">5.1.1 光源的开启及关闭   115</span><br><span class="line">5.1.2 设定光源的数量       116</span><br><span class="line">5.1.3 定向光       117</span><br><span class="line">5.1.4 定位光       118</span><br><span class="line">5.2 光源的颜色   119</span><br><span class="line">5.2.1 环境光       119</span><br><span class="line">5.2.2 散射光       120</span><br><span class="line">5.2.3 镜面反射光       121</span><br><span class="line">5.3 材料反光属性的法官——法向量及材质   121</span><br><span class="line">5.3.1 法向量的作用   121</span><br><span class="line">5.3.2 光照的开启及关闭例子   122</span><br><span class="line">5.3.3 物体的材质       128</span><br><span class="line">5.3.4 设定光源数量的例子       128</span><br><span class="line">5.4 两个物体发光的例子   132</span><br><span class="line">5.4.1 定位光例子的实现   132</span><br><span class="line">5.4.2 自发光物体加运动光源的实现       135</span><br><span class="line">5.4.3 MySurfaceView.java详解 137</span><br><span class="line">5.5 面法向量与点平均法向量   143</span><br><span class="line">5.5.1 面法向量的应用       143</span><br><span class="line">5.5.2 点平均法向量的应用       145</span><br><span class="line">5.6 本章小结      146</span><br><span class="line">第6章 为伊消得人憔悴—纹理映射       147</span><br><span class="line">6.1 3D世界的花衣——纹理贴图     147</span><br><span class="line">6.1.1 指定纹理   147</span><br><span class="line">6.1.2 分配纹理坐标   148</span><br><span class="line">6.1.3 纹理贴图三角形的实现   149</span><br><span class="line">6.1.4 纹理贴图球体的构建       153</span><br><span class="line">6.2 使用纹理映射构建地月模型      161</span><br><span class="line">6.2.1 浩瀚星空中的地月系       161</span><br><span class="line">6.2.2 地月系的案例讲解   162</span><br><span class="line">6.3 纹理拉伸      170</span><br><span class="line">6.3.1 纹理拉伸的原理与用途   170</span><br><span class="line">6.3.2 纹理拉伸案例讲解   172</span><br><span class="line">6.4 纹理过滤      175</span><br><span class="line">6.4.1 最近点采样       175</span><br><span class="line">6.4.2 线性纹理过滤   176</span><br><span class="line">6.4.3 mipmap：多重细节层      176</span><br><span class="line">6.5 视角的合理设置   177</span><br><span class="line">6.5.1 不同视角的3D世界 177</span><br><span class="line">6.5.2 合理视角案例讲解   178</span><br><span class="line">6.6 本章小结      180</span><br><span class="line">第7章 海阔凭鱼跃，天高任鸟飞—3D基本形状的构建      181</span><br><span class="line">7.1   圆柱体 181</span><br><span class="line">7.1.1 圆柱体的几何方程   181</span><br><span class="line">7.1.2 圆柱体的OpenGL ES实现      182</span><br><span class="line">7.2 圆锥体   190</span><br><span class="line">7.2.1 圆锥体的几何方程   190</span><br><span class="line">7.2.2 圆锥体的OpenGL ES实现      190</span><br><span class="line">7.3 圆环      193</span><br><span class="line">7.3.1 圆环的几何方程       193</span><br><span class="line">7.3.2 圆环的OpenGL ES实现 193</span><br><span class="line">7.4 抛物面   196</span><br><span class="line">7.4.1 抛物面的几何方程   196</span><br><span class="line">7.4.2 抛物面的OpenGL ES实现      197</span><br><span class="line">7.5 双曲面   199</span><br><span class="line">7.5.1 双曲面的几何方程   199</span><br><span class="line">7.5.2 双曲面的OpenGL ES实现      200</span><br><span class="line">7.6 螺旋面   202</span><br><span class="line">7.6.1 螺旋面的几何方程   202</span><br><span class="line">7.6.2 螺旋面的OpenGL ES实现      203</span><br><span class="line">7.7 本章小结      205</span><br><span class="line">第8章 执子之手，与子偕老——坐标变换    206</span><br><span class="line">8.1 理解坐标变换      206</span><br><span class="line">8.1.1 坐标变换的实质       206</span><br><span class="line">8.1.2 重要的堆栈操作       207</span><br><span class="line">8.2 缩放变换      208</span><br><span class="line">8.2.1 缩放变换原理分析   208</span><br><span class="line">8.2.2 OpenGL ES中的缩放变换实现       208</span><br><span class="line">8.3 平移变换      211</span><br><span class="line">8.3.1 平移变换理论概览   211</span><br><span class="line">8.3.2 OpenGL ES中的平移变换实现       212</span><br><span class="line">8.4 旋转变换      213</span><br><span class="line">8.4.1 旋转变换原理概述   213</span><br><span class="line">8.4.2 OpenGL ES中的旋转变换实现       214</span><br><span class="line">8.5 复合变换的简单案例——地月系模型      215</span><br><span class="line">8.6 用复合变换模拟现实世界   216</span><br><span class="line">8.7 本章小结      218</span><br><span class="line">第9章 孤帆远影碧空尽—摄像机与雾特效    219</span><br><span class="line">9.1 摄像机   219</span><br><span class="line">9.1.1 摄像机的简介   219</span><br><span class="line">9.1.2 摄像机的设置   220</span><br><span class="line">9.2 雾特效   221</span><br><span class="line">9.2.1 雾特效的相关知识   221</span><br><span class="line">9.2.2 雾特效核心代码       222</span><br><span class="line">9.3 摄像机与雾特效实现沙漠中的金字塔      222</span><br><span class="line">9.3.1 场景部件——四面体和太阳东升西落   223</span><br><span class="line">9.3.2 场景部件——星空类       226</span><br><span class="line">9.3.3 场景的创建       229</span><br><span class="line">9.3.4 摄像机Up方向变换效果 232</span><br><span class="line">9.4 本章小结      233</span><br><span class="line">第10章 假作真时真亦假——混合 234</span><br><span class="line">10.1 什么是混合 234</span><br><span class="line">10.2 源因子和目标因子    235</span><br><span class="line">10.2.1 源因子和目标因子的默认实现方式     235</span><br><span class="line">10.2.2 预定义常量分析     235</span><br><span class="line">10.2.3 常用的组合方式     236</span><br><span class="line">10.2.4 启用混合 237</span><br><span class="line">10.3 混合案例    237</span><br><span class="line">10.3.1 一个混合的简单案例     237</span><br><span class="line">10.3.2 带光晕和云层效果的地月系模型 241</span><br><span class="line">10.3.3 滤光器中的世界     245</span><br><span class="line">10.4 本章小结    250</span><br><span class="line">第11章 蓦然回首，那人却在灯火阑珊处—3D高级技术    251</span><br><span class="line">11.1 标志板 251</span><br><span class="line">11.1.1 标志板技术概述     251</span><br><span class="line">11.1.2 标志板的案例 252</span><br><span class="line">11.2 飘扬的旗帜 254</span><br><span class="line">11.2.1 旗帜飘动效果原理 254</span><br><span class="line">11.2.2 飘扬旗帜案例讲解 255</span><br><span class="line">11.3 山地的生成技术 257</span><br><span class="line">11.3.1 灰度图地形技术概述     257</span><br><span class="line">11.3.2 灰度图生成3D地形       258</span><br><span class="line">11.3.3 地形场景效果的提升     261</span><br><span class="line">11.4 镜像技术     263</span><br><span class="line">11.4.1 镜像技术的简介     264</span><br><span class="line">11.4.2 镜像技术的实现     265</span><br><span class="line">11.4.3 镜像技术的提升     267</span><br><span class="line">11.5 本章小结     268</span><br><span class="line">第12章 心有灵犀一点通——传感器      269</span><br><span class="line">12.1 传感器简介 269</span><br><span class="line">12.1.1 磁场传感器简介     269</span><br><span class="line">12.1.2 光传感器简介 269</span><br><span class="line">12.1.3 距离传感器简介     270</span><br><span class="line">12.1.4 加速度传感器简介 270</span><br><span class="line">12.1.5 姿态传感器简介     271</span><br><span class="line">12.1.6 SensorSimulator模拟器的配置     273</span><br><span class="line">12.2 传感器的数据传输    276</span><br><span class="line">12.2.1 加速传感器的数据传输 276</span><br><span class="line">12.2.2 姿态传感器的数据传输 278</span><br><span class="line">12.3 传感器实例——平衡球    279</span><br><span class="line">12.4 本章小结    287</span><br><span class="line">第13章 千锤万凿出深山——游戏中的数学与物理      288</span><br><span class="line">13.1 必知必会的几何知识 288</span><br><span class="line">13.1.1 三维笛卡儿坐标系 288</span><br><span class="line">13.1.2 向量 288</span><br><span class="line">13.1.3 加减法     290</span><br><span class="line">13.1.4 向量的点积     291</span><br><span class="line">13.1.5 向量的叉积     291</span><br><span class="line">13.1.6 空间平面的确定     292</span><br><span class="line">13.2 不可或缺的物理世界 293</span><br><span class="line">13.2.1 重力系统 293</span><br><span class="line">13.2.2 碰撞 298</span><br><span class="line">13.2.3 完全弹性碰撞 299</span><br><span class="line">13.2.4 带有能量损失的弹性碰撞     302</span><br><span class="line">13.2.5 粒子系统 303</span><br><span class="line">13.3 本章小结    311</span><br><span class="line">第14章 山舞银蛇，原驰蜡象—AI基本理念 312</span><br><span class="line">14.1 AI简介       312</span><br><span class="line">14.1.1 什么是智能     312</span><br><span class="line">14.1.2 什么是游戏AI 312</span><br><span class="line">14.2 AI引擎的基本组成与设计       313</span><br><span class="line">14.2.1 智能体     313</span><br><span class="line">14.2.2 处理机与感知 314</span><br><span class="line">14.2.3 导航 314</span><br><span class="line">14.3 游戏AI中图的搜索   315</span><br><span class="line">14.3.1 深度优先搜索 315</span><br><span class="line">14.3.2 广度优先搜索 321</span><br><span class="line">14.3.3 Dijkstra搜索    325</span><br><span class="line">14.3.4 广度优先A算法的实现 329 14.3.5 Dijkstra A算法的实现   332</span><br><span class="line">14.3.6 A与非A算法之间的比较   334</span><br><span class="line">14.4 模糊逻辑    336</span><br><span class="line">14.4.1 普通集合 336</span><br><span class="line">14.4.2 模糊集合 337</span><br><span class="line">14.4.3 模糊语言变量 339</span><br><span class="line">14.4.4 模糊规则 339</span><br><span class="line">14.5 本章小结    340</span><br><span class="line">第15章 独上高楼，望尽天涯路——开发小秘籍 341</span><br><span class="line">15.1 地图设计器 341</span><br><span class="line">15.1.1 不可或缺的地图设计器 341</span><br><span class="line">15.1.2 简单的地图设计器 341</span><br><span class="line">15.2 多键技术    347</span><br><span class="line">15.2.1 增加游戏可玩度的多键技术 347</span><br><span class="line">15.2.2 多键技术的实例演示     348</span><br><span class="line">15.3 虚拟键盘    350</span><br><span class="line">15.4 查找表技术 351</span><br><span class="line">15.5 状态机 352</span><br><span class="line">15.6 AABB边界框     354</span><br><span class="line">15.6.1 AABB的表达方法 355</span><br><span class="line">15.6.2 计算AABB     355</span><br><span class="line">15.6.3 AABB与边界球的比较 356</span><br><span class="line">15.6.4 球与球的碰撞 357</span><br><span class="line">15.6.5 两个AABB的碰撞 358</span><br><span class="line">15.6.6 球与AABB的碰撞 361</span><br><span class="line">15.7 穿透效应    363</span><br><span class="line">15.8 拾取技术    367</span><br><span class="line">15.8.1 拾取技术的原理     367</span><br><span class="line">15.8.2 拾取技术的实现     369</span><br><span class="line">15.9 天空盒与天空穹 377</span><br><span class="line">15.9.1 天空盒的介绍 377</span><br><span class="line">15.9.2 天空穹的介绍 380</span><br><span class="line">15.10 本章小结   382</span><br><span class="line">第二篇 案 例 实 战</span><br><span class="line">第16章 体育类游戏—《疯狂投篮》      384</span><br><span class="line">16.1 游戏的背景及功能概述    384</span><br><span class="line">16.1.1 背景概述 384</span><br><span class="line">16.1.2 功能简介 384</span><br><span class="line">16.2 游戏的策划及准备工作    388</span><br><span class="line">16.2.1 游戏的策划     388</span><br><span class="line">16.2.2 Android平台下游戏的准备工作   388</span><br><span class="line">16.3 游戏的架构 389</span><br><span class="line">16.3.1 游戏中用到的主要技术 389</span><br><span class="line">16.3.2 各类的简要介绍     389</span><br><span class="line">16.3.3 游戏的框架简介     391</span><br><span class="line">16.4 游戏公共类的设计与实现 393</span><br><span class="line">16.4.1 主类BasketballActivity的实现      393</span><br><span class="line">16.4.2 游戏常量类的介绍 396</span><br><span class="line">16.5 游戏菜单界面类的设计与实现 398</span><br><span class="line">16.5.1 游戏开始菜单的框架设计     398</span><br><span class="line">16.5.2 游戏开始菜单的实现     399</span><br><span class="line">16.5.3 游戏帮助、关于、加载及结束界面的设计与实现     402</span><br><span class="line">16.6 游戏界面的设计与实现    402</span><br><span class="line">16.6.1 游戏界面的框架设计     402</span><br><span class="line">16.6.2 游戏界面的实现     404</span><br><span class="line">16.7 游戏界面中主要场景的绘制及篮球运动 407</span><br><span class="line">16.7.1 游戏中墙壁、地板、球和篮板等的绘制     407</span><br><span class="line">16.7.2 篮板的整体绘制     409</span><br><span class="line">16.7.3 篮球的运动实现     410</span><br><span class="line">16.8 游戏界面的碰撞检测及物体拾取    413</span><br><span class="line">16.8.1 篮球与篮框的碰撞检测 413</span><br><span class="line">16.8.2 篮球与墙壁、地板和屋顶的碰撞检测 416</span><br><span class="line">16.8.3 手机屏幕拾取技术 418</span><br><span class="line">16.9 游戏的优化与改进    419</span><br><span class="line">第17章 益智类游戏—《旋转积木》      421</span><br><span class="line">17.1 游戏的背景及功能概述    421</span><br><span class="line">17.1.1 背景概述 421</span><br><span class="line">17.1.2 功能简介 421</span><br><span class="line">17.2 游戏的策划及准备工作    424</span><br><span class="line">17.2.1 游戏的策划     424</span><br><span class="line">17.2.2 Android平台下游戏的准备工作   424</span><br><span class="line">17.3 游戏的架构 425</span><br><span class="line">17.3.1 游戏中用到的主要技术 425</span><br><span class="line">17.3.2 各类的简要介绍     425</span><br><span class="line">17.3.3 游戏的框架简介     427</span><br><span class="line">17.4 地图设计器的开发    428</span><br><span class="line">17.5 游戏公共类的设计与实现 431</span><br><span class="line">17.5.1 主类MainActivity的实现      431</span><br><span class="line">17.5.2 游戏常量类的介绍 434</span><br><span class="line">17.6 游戏菜单界面类的设计与实现 437</span><br><span class="line">17.6.1 游戏开始菜单的框架设计     438</span><br><span class="line">17.6.2 游戏开始菜单的实现     439</span><br><span class="line">17.6.3 游戏帮助、关于、设置及胜利界面的设计与实现     441</span><br><span class="line">17.7 游戏界面的设计与实现    442</span><br><span class="line">17.7.1 游戏界面的框架设计     442</span><br><span class="line">17.7.2 游戏触控方法的实现     443</span><br><span class="line">17.7.3 游戏界面的实现     445</span><br><span class="line">17.7.4 生成纹理ID的方法       448</span><br><span class="line">17.8 游戏界面中主要场景的绘制    449</span><br><span class="line">17.8.1 游戏中背景、移表板、图标的绘制     449</span><br><span class="line">17.8.2 地图的绘制     450</span><br><span class="line">17.8.3 积木的绘制     451</span><br><span class="line">17.9 游戏界面的动画效果 453</span><br><span class="line">17.9.1 积木转动的动画效果     453</span><br><span class="line">17.9.2 游戏失败、获胜的动画效果 457</span><br><span class="line">17.10 游戏界面的碰撞检测      458</span><br><span class="line">17.11 游戏的优化与改进   460</span><br><span class="line">第18章 休闲类游戏—《摩天大楼》      461</span><br><span class="line">18.1 游戏的背景及功能概述    461</span><br><span class="line">18.1.1 背景概述 461</span><br><span class="line">18.1.2 功能简介 461</span><br><span class="line">18.2 游戏的策划及准备工作    465</span><br><span class="line">18.2.1 游戏的策划     465</span><br><span class="line">18.2.2 Android平台下游戏的准备工作   465</span><br><span class="line">18.3 游戏的架构 466</span><br><span class="line">18.3.1 游戏中用到的主要技术 466</span><br><span class="line">18.3.2 各类的简要介绍     467</span><br><span class="line">18.3.3 游戏的框架简介     468</span><br><span class="line">18.4 游戏公共类的设计与实现 469</span><br><span class="line">18.4.1 主类GL_Demo的实现   469</span><br><span class="line">18.4.2 游戏常量类的介绍 474</span><br><span class="line">18.5 游戏菜单界面类的设计与实现 475</span><br><span class="line">18.5.1 游戏开始菜单的框架设计     475</span><br><span class="line">18.5.2 游戏开始菜单的实现     476</span><br><span class="line">18.5.3 游戏帮助、关于、设置、加载及胜利界面的设计与实现 481</span><br><span class="line">18.6 游戏界面的设计与实现    481</span><br><span class="line">18.6.1 游戏界面的框架设计     481</span><br><span class="line">18.6.2 游戏界面的实现     483</span><br><span class="line">18.7 游戏界面中主要场景的绘制    487</span><br><span class="line">18.7.1 游戏中背景、地板、建筑块的绘制     487</span><br><span class="line">18.7.2 树的绘制 487</span><br><span class="line">18.8 游戏界面的碰撞检测 488</span><br><span class="line">18.9 游戏的优化与改进    492</span><br><span class="line">第19章 动作类游戏—《3D空战》 493</span><br><span class="line">19.1 游戏的背景及功能概述    493</span><br><span class="line">19.1.1 背景概述 493</span><br><span class="line">19.1.2 功能简介 494</span><br><span class="line">19.2 游戏的策划及准备工作    496</span><br><span class="line">19.2.1 游戏的策划     496</span><br><span class="line">19.2.2 Android平台下游戏的准备工作   497</span><br><span class="line">19.3 游戏的架构 498</span><br><span class="line">19.3.1 游戏中用到的主要技术 498</span><br><span class="line">19.3.2 各类的简要介绍     498</span><br><span class="line">19.3.3 游戏的框架简介     500</span><br><span class="line">19.4 游戏公共类的设计与实现 502</span><br><span class="line">19.4.1 主类GL_Demo的实现   502</span><br><span class="line">19.4.2 游戏常量类的介绍 503</span><br><span class="line">19.5 游戏菜单界面类的设计与实现 504</span><br><span class="line">19.5.1 游戏菜单的框架设计     504</span><br><span class="line">19.5.2 游戏菜单的实现     506</span><br><span class="line">19.5.3 游戏帮助、关于、设置、加载及胜利界面的设计与实现 509</span><br><span class="line">19.6 游戏界面的设计与实现    509</span><br><span class="line">19.6.1 游戏界面的框架设计     509</span><br><span class="line">19.6.2 游戏界面的实现     511</span><br><span class="line">19.7 游戏界面中飞机的绘制    513</span><br><span class="line">19.8 游戏中的运动线程和碰撞检测 515</span><br><span class="line">19.9 游戏的优化与改进    525</span><br><span class="line">第20章  桌面类游戏—《激情台球》      527</span><br><span class="line">20.1 游戏的背景及功能概述    527</span><br><span class="line">20.1.1 背景概述 527</span><br><span class="line">20.1.2 功能简介 527</span><br><span class="line">20.2 游戏的策划及准备工作    531</span><br><span class="line">20.2.1 游戏的策划     531</span><br><span class="line">20.2.2 Android平台下游戏的准备工作   532</span><br><span class="line">20.3 游戏的架构 533</span><br><span class="line">20.3.1 游戏中用到的主要技术 533</span><br><span class="line">20.3.2 各类的简要介绍     533</span><br><span class="line">20.3.3 游戏的框架简介     535</span><br><span class="line">20.4 网络端的开发    536</span><br><span class="line">20.4.1 服务器的简要介绍 536</span><br><span class="line">20.4.2 服务器的代码介绍 537</span><br><span class="line">20.4.3 客户端线程的代码介绍 542</span><br><span class="line">20.5 游戏公共类的设计与实现 545</span><br><span class="line">20.5.1 主类MyActivity的实现 545</span><br><span class="line">20.5.2 游戏常量类的介绍 549</span><br><span class="line">20.6 游戏菜单界面类的设计与实现 551</span><br><span class="line">20.6.1 游戏开始菜单的框架设计     552</span><br><span class="line">20.6.2 游戏菜单的动画实现     555</span><br><span class="line">20.6.3 游戏帮助、关于、设置及胜利等界面的设计与实现 556</span><br><span class="line">20.7 游戏界面的设计与实现    557</span><br><span class="line">20.7.1 游戏界面的框架设计     557</span><br><span class="line">20.7.2 游戏中onKeyDown方法的实现   558</span><br><span class="line">20.7.3 游戏界面的实现     560</span><br><span class="line">20.8 游戏界面中主要场景的绘制    563</span><br><span class="line">20.8.1 仪表板、地板的绘制     563</span><br><span class="line">20.8.2 台球桌的绘制 564</span><br><span class="line">20.8.3 球的绘制 566</span><br><span class="line">20.9 游戏中的碰撞检测    567</span><br><span class="line">20.9.1 球与球台边角碰撞检测的原理     567</span><br><span class="line">20.9.2 球与球碰撞检测的原理 569</span><br><span class="line">20.9.3 球与球台边角碰撞检测的实现     570</span><br><span class="line">20.9.4 球与球碰撞检测的实现 574</span><br><span class="line">20.9.5 球运动线程的实现 576</span><br><span class="line">20.10 游戏的优化与改进   578</span><br><span class="line">第21章 射击类游戏—《抢滩登陆》      579</span><br><span class="line">21.1 游戏的背景及功能概述    579</span><br><span class="line">21.1.1 背景概述 579</span><br><span class="line">21.1.2 功能简介 579</span><br><span class="line">21.2 游戏的策划及准备工作    583</span><br><span class="line">21.2.1 游戏的策划     583</span><br><span class="line">21.2.2 Android平台下游戏的准备工作   583</span><br><span class="line">21.3 游戏的架构 584</span><br><span class="line">21.3.1 游戏中用到的主要技术 584</span><br><span class="line">21.3.2 各类的简要介绍     585</span><br><span class="line">21.3.3  游戏的框架简介     588</span><br><span class="line">21.4 游戏公共类的设计与实现 589</span><br><span class="line">21.4.1 主类Activity的实现      590</span><br><span class="line">21.4.2 游戏常量类的介绍 594</span><br><span class="line">21.5 游戏菜单界面类的设计与实现 598</span><br><span class="line">21.5.1 游戏菜单界面的框架设计     598</span><br><span class="line">21.5.2 游戏菜单界面的实现     600</span><br><span class="line">21.5.3 游戏帮助、关于及结束界面的设计与实现 604</span><br><span class="line">21.6 游戏界面的设计与实现    605</span><br><span class="line">21.6.1 游戏界面的框架设计     605</span><br><span class="line">21.6.2 游戏界面的实现     607</span><br><span class="line">21.7 游戏界面中主要场景的绘制及实物运动 613</span><br><span class="line">21.7.1 游戏中的绘制 613</span><br><span class="line">21.7.2 灯塔的整体绘制     614</span><br><span class="line">21.7.3 物体的运动实现     616</span><br><span class="line">21.8 游戏中的碰撞检测    621</span><br><span class="line">21.9 游戏的优化与改进    625</span><br><span class="line">第22章 竞技类游戏—《乡村飙车》      627</span><br><span class="line">22.1 游戏的背景及功能概述    627</span><br><span class="line">22.1.1 背景概述 627</span><br><span class="line">22.1.2 功能简介 627</span><br><span class="line">22.2 游戏的策划及准备工作    631</span><br><span class="line">22.2.1 游戏的策划     631</span><br><span class="line">22.2.2 Android平台下游戏的准备工作   632</span><br><span class="line">22.3 游戏的框架介绍 634</span><br><span class="line">22.3.1 游戏中用到的主要技术 634</span><br><span class="line">22.3.2 各类的简单介绍     635</span><br><span class="line">22.3.3 游戏的框架介绍     638</span><br><span class="line">22.4 游戏公共类的设计与实现 640</span><br><span class="line">22.4.1 主类Activity_GL_Racing的实现 640</span><br><span class="line">22.4.2 游戏常量类的介绍 645</span><br><span class="line">22.5 游戏菜单类的设计与实现 649</span><br><span class="line">22.5.1 游戏主菜单的设计与实现     650</span><br><span class="line">22.5.2 游戏加载界面的设计与实现 651</span><br><span class="line">22.5.3 游戏历史界面的设计与实现 656</span><br><span class="line">22.5.4 游戏帮助、设置、关于、选择等界面的设计与实现 658</span><br><span class="line">22.6 游戏界面的设计与实现    659</span><br><span class="line">22.6.1 游戏界面的框架设计     659</span><br><span class="line">22.6.2 游戏界面的实现     661</span><br><span class="line">22.6.3 传感器应用与多点触控技术 665</span><br><span class="line">22.7 游戏界面中主要场景的绘制    666</span><br><span class="line">22.7.1 游戏界面中场景的分层绘制及渲染优化     667</span><br><span class="line">22.7.2 游戏界面中地图赛道的生成与绘制     669</span><br><span class="line">22.7.3 场景部件的绘制     671</span><br><span class="line">22.7.4 游戏中汽车的加载 673</span><br><span class="line">22.7.5 游戏中树的绘制技术     677</span><br><span class="line">22.7.6 场景中游戏辅助部件的绘制 679</span><br><span class="line">22.8 游戏中的碰撞检测及行驶圈数判定 681</span><br><span class="line">22.8.1 汽车与公路部件的碰撞检测 683</span><br><span class="line">22.8.2 汽车行驶圈数判定 685</span><br><span class="line">22.8.3 汽车与可碰撞部件的碰撞检测及其动画实现     686</span><br><span class="line">22.9 游戏的优化与改进    688</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0051PH5FW/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0051PH5FW&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51qPgTcuaaL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop权威指南(第2版)(修订•升级版)</title>
    <url>/2020/04/19/B0055QFIA6/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Hadoop权威指南(第2版)(修订•升级版)<br>作者信息： 作者: 怀特 (Tom White) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Hadoop权威指南(第2版)(修订•升级版)》编辑推荐：Google帝国的基石是什么？MapReduce算法！开源项目Hadoop作为它的一个具体实现，可以轻松用于构建和维护一个可靠性高、伸缩性强的分布式系统。作者Tom White作为Hadoop的项目负责人，通过自己对Hadoop和Hadoop社区的理解，化繁为简，用浅显易懂的语言介绍了Hadoop能做什么，怎么做才能充分发挥Hadoop的优势，Hadoop能够和哪些开源工具结合使用。《Hadoop权威指南（第2版）》是一本主题丰富、讲解透彻的权威参考书，可帮助程序员了解分析海量数据集的细枝末节，帮助管理员掌握搭建和运行Hadoop集群的具体过程。经过修订和更新的第2版概述了Hadoop的最新动态，例如Hive、sqoop和Avro等。书中还提供了案例分析来帮助读者了解如何用Hadoop来解决具体的问题。如果想充分利用数据，从中挖掘出有价值的见解或者观点，毫无疑问，《Hadoop权威指南(第2版)(修订•升级版)》将是您不可或缺的重要参考。“谁说大象不能跳舞？Hadoop-轻松应对海量数据存储与分析所带来的挑战！”使用Hadoop分布式文件系统（HDFS）来存储大型数据集，然后用MapReduce对这些数据II执行分布式计算。Hadoop的数据和I/O构建块（用于压缩、数据完整性、序列化和持久处理）。探究MapReduce应用开发中常见的陷阱和高级特性。设计，构建和管理Hadoop专用集群或在云上运行Hadoop。使用Pig这种高级的查询语言来进行大规模数据处理。使用Hive（Hadoop的数据仓库系统）来分析数据集。使用HBase（Hadoop的数据库）来处理结构化数据和半结构化数据。深入介绍Zookeeper，一个用于构建分布式系统的协作类型工具箱。Cloudera是一家行业领先的Hadoop软件和服务供应商。Cloudera’s Distribution forHadoop （CDH）是一个基于Apache Hadoop的综合性数据管理平台，Cloudera Enterprise则包括一些工具、平台和支持，供生产环境中使用Hadoop时使用。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 初识Hadoop</span><br><span class="line">数据！数据！</span><br><span class="line">数据存储与分析</span><br><span class="line">与其他系统相比</span><br><span class="line">关系型数据库管理系统</span><br><span class="line">网格计算</span><br><span class="line">志愿计算</span><br><span class="line">Hadoop 发展简史</span><br><span class="line">Apache Hadoop和Hadoop生态圈 </span><br><span class="line"></span><br><span class="line"> 第2章 关于MapReduce 一个气象数据集 数据的格式 使用Unix工具进行数据分析 使用Hadoop分析数据 map阶段和reduce阶段 横向扩展 合并函数 运行一个分布式的MapReduce作业 Hadoop的Streaming Ruby版本 Python版本 Hadoop Pipes 编译运行</span><br><span class="line"></span><br><span class="line"> 第3章 Hadoop分布式文件系统 HDFS的设计 HDFS的概念 数据块 namenode和datanode 命令行接口 基本文件系统操作 Hadoop文件系统 接口 Java接口 从Hadoop URL中读取数据 通过FileSystem API读取数据 写入数据 目录 查询文件系统 删除数据 数据流 文件读取剖析 文件写入剖析 一致模型 通过 distcp并行拷贝 保持 HDFS 集群的均衡 Hadoop的归档文件 使用Hadoop归档文件 不足</span><br><span class="line"></span><br><span class="line"> 第4章 Hadoop I&#x2F;O 数据完整性 HDFS的数据完整性 LocalFileSystem ChecksumFileSystem 压缩 codec 压缩和输入切分 在MapReduce中使用压缩 序列化 Writable接口 Writable类 实现定制的Writable类型 序列化框架 Avro 依据文件的数据结构 写入SequenceFile MapFile</span><br><span class="line"></span><br><span class="line"> 第5章 MapReduce应用开发 配置API 合并多个源文件 可变的扩展 配置开发环境 配置管理 辅助类GenericOptionsParser，Tool和ToolRunner 编写单元测试 mapper reducer 本地运行测试数据 在本地作业运行器上运行作业 测试驱动程序 在集群上运行 打包 启动作业 MapReduce的Web界面 获取结果 作业调试 使用远程调试器 作业调优 分析任务 MapReduce的工作流 将问题分解成MapReduce作业 运行独立的作业</span><br><span class="line"></span><br><span class="line"> 第6章 MapReduce的工作机制 剖析MapReduce作业运行机制 作业的提交 作业的初始化 任务的分配 任务的执行 进度和状态的更新 作业的完成 失败 任务失败 tasktracker失败 jobtracker失败 作业的调度 Fair Scheduler Capacity Scheduler shuffle和排序 map端 reduce端 配置的调优 任务的执行 推测式执行 重用JVM 跳过坏记录 任务执行环境</span><br><span class="line"></span><br><span class="line"> 第7章 MapReduce的类型与格式 MapReduce的类型 默认的MapReduce作业 输入格式 输入分片与记录 文本输入 二进制输入 多种输入 数据库输入(和输出) 输出格式 文本输出 二进制输出 多个输出 延迟输出 数据库输出</span><br><span class="line"></span><br><span class="line"> 第8章 MapReduce的特性 计数器 内置计数器 用户定义的Java计数器 用户定义的Streaming计数器 排序 准备 部分排序 总排序 二次排序 联接 map端联接 reduce端联接 边数据分布 利用JobConf来配置作业 分布式缓存 MapReduce库类</span><br><span class="line"></span><br><span class="line"> 第9章 构建Hadoop集群 集群规范 网络拓扑 集群的构建和安装 安装Java 创建Hadoop用户 安装Hadoop 测试安装 SSH配置 Hadoop配置 配置管理 环境设置 Hadoop守护进程的关键属性 Hadoop守护进程的地址和端口 Hadoop的其他属性 创建用户帐号 安全性 Kerberos和Hadoop 委托令牌 其他安全性改进 利用基准测试程序测试Hadoop集群 Hadoop基准测试程序 用户的作业 云上的Hadoop Amazon EC2上的Hadoop</span><br><span class="line"></span><br><span class="line"> 第10章 管理Hadoop HDFS 永久性数据结构 安全模式 日志审计 工具 监控 日志 度量 Java管理扩展(JMX) 维护 日常管理过程 委任节点和解除节点 升级</span><br><span class="line"></span><br><span class="line"> 第11章 Pig简介 安装与运行Pig 执行类型 运行Pig程序 Grunt Pig Latin编辑器 示例 生成示例 与数据库比较 PigLatin 结构 语句 表达式 类型 模式 函数 用户自定义函数 过滤UDF 计算UDF 加载UDF 数据处理操作 加载和存储数据 过滤数据 分组与连接数据 对数据进行排序 组合和分割数据 Pig实战 并行处理 参数代换</span><br><span class="line"></span><br><span class="line"> 第12章 Hive 第13章 HBase 第14章 ZooKeeper 第15章 开源工具 第16章 实例分析</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0055QFIA6/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0055QFIA6&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51N3QfgLUUL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>你早该这么玩Excel</title>
    <url>/2020/04/19/B005DJHV8C/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 你早该这么玩Excel<br>作者信息： 作者: 伍昊 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《你早该这么玩Excel》编辑推荐：以一敌百Excel 心法，教你职场“偷懒”的秘诀。◆觉得工具书没啥用．看了几页就扔到一边。◆看见E表后两眼放光，数据越多，症状越重。◆越来越享受同事的夸奖，甚至有上瘾的危险。◆效率高而闲得慌，被Boss逼着去做更重要的工作。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 换个角度玩儿Excel</span><br><span class="line">第1节 两招让你脱胎换骨</span><br><span class="line">搞定源数据，不背菜单也能玩</span><br><span class="line">聚焦汇总表，不用做来只用“变”</span><br><span class="line">第2节 天下只有一张表</span><br><span class="line">一个模板打天下</span><br><span class="line">我的文件比你少</span><br><span class="line">格式标准都会填</span><br><span class="line">第3节 人人都能成高手 </span><br><span class="line"></span><br><span class="line"> 第2章 十宗罪进行时 第1节 表格中的“父子关系” 第2节 错误的“正确”做法毁了你的表格 换个地方写标题 顺着流程排字段 拆了隔断，连成一片 合计请等下回分解 化繁为简，去掉多余表头 千万别合并，单元格有一说一 缺啥别缺源数据 分手容易牵手难 别把Excel当Word 分类汇总不是手工活儿</span><br><span class="line"></span><br><span class="line"> 第3章 Excel超越你的想象 第1节 三表概念——难道Excel也是系统？ Excel和系统哪里不一样？ 如此解读默认三张表 第2节 左手企业系统，右手Excel 第3节 Excel决定企业存亡</span><br><span class="line"></span><br><span class="line"> 第4章 玩转透视表，工作的滋味甜过初恋 第1节 数据透视表初体验 数据透视表在哪里 数据透视表能做什么 数据透视表怎么做 第2节 早知如此，何必当初 “拖”出合计行 “变”出汇总表 拆分源数据的“偏方” 第3节 汇总报表，拖拽有“理” “躺着”不如“站着” 按“天”汇总要不得 不超过两个列字段 汇总跟着文字走 字段主次要分明 第4节 巧妙组合日期 日期字段怎么放 日期很特殊 正确的日期才特殊 第5节 追根溯“源” 第6节 关联数据齐步走 “！” 预约源数据 新建明细数据≠源数据 找得到的工具栏 关键时刻要备份 第7节 你还应该知道这几招 去掉数据的“分身” 汇总数排排站 可以复制的汇总表 第8节 找到初恋的感觉了吗？</span><br><span class="line"></span><br><span class="line"> 第5章 揭秘天下第一表的神奇“配方” 第1节 学Excel不是走单行线 第2节 五味良药“配”出天下第一表 第一味“顾全局”：背景确认 第二味“知目的”：明确需求 第三味“勾轮廓”：字段设定 第四味“定结构”：流程解析 第五味“细打磨”：表格装修</span><br><span class="line"></span><br><span class="line"> 第6章 图表，怎么简单怎么做 第1节 别把Excel中的图表当PPT做 第2节 心动不如行动 第3节 无外乎三种图表 俯视大饼 端正柱子 装“点”折线 第4节 一招美化你的图表 第5节 概念图——向左走向右走 第6节 让图表动一下</span><br><span class="line"></span><br><span class="line"> 第7章 埋头做表别忘了抬头看路 第1节 赢得同事的认可 建立“高品质”形象 好的经验书面总结 保管好报表 善于分享 第2节 赢得老板的认可 比吩咐的多做一点 汇报进度并按时完成 邮件就是你的脸 给老板做多选题 我真的不懂VBA 致谢</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B005DJHV8C/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B005DJHV8C&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/517jG7eHj4L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>职场</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL反模式</title>
    <url>/2020/04/19/B005N4L03E/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： SQL反模式<br>作者信息： 作者: 卡尔文 (Bill Karwin) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《SQL反模式》：深入剖析数据库编程常见错误，提升SQL功力的实用宝典，大师指点令人茅塞顿开。多数软件开发人员并不是SQL专家，很多人对SQL的错误使用更使其效率低且难以维护。《SQL反模式》针对SQL使用中经常犯的错误展开分析.从数据库的逻辑设计、物理设计、查询设计、应用开发几个方面总结归纳各种典型错误，提出避免陷阱的方法。作为一本经验总结性的著作，《SQL反模式》是数据库编程人员不可或缺的手边书。你也会学到最新的全文搜索技术，设计出可以防范SQL注入的代码，掌握其他非常实用的使用技巧。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 引言 1</span><br><span class="line">1.1 谁需要这本书 2</span><br><span class="line">1.2 本书内容 2</span><br><span class="line">1.2.1 本书结构 3</span><br><span class="line">1.2.2 反模式分解 4</span><br><span class="line">1.3 本书未涉及的内容 4</span><br><span class="line">1.4 规约 5</span><br><span class="line">1.5 范例数据库 6</span><br><span class="line">1.6 致谢 8 </span><br><span class="line"></span><br><span class="line"> 第一部分 逻辑型数据库设计反模式</span><br><span class="line"></span><br><span class="line"> 第2章 乱穿马路 10 2.1 目标:存储多值属性 11 2.2 反模式:格式化的逗号分隔列表 11 2.2.1 查询指定账号的产品 11 2.2.2 查询指定产品的账号 12 2.2.3 执行聚合查询 12 2.2.4 更新指定产品的账号 12 2.2.5 验证产品ID 13 2.2.6 选择合适的分隔符 13 2.2.7 列表长度限制 13 2.3 如何识别反模式 14 2.4 合理使用反模式 14 2.5 解决方案:创建一张交叉表 14 2.5.1 通过账号查询产品和反过来查询 15 2.5.2 执行聚合查询 16 2.5.3 更新指定产品的相关联系人 16 2.5.4 验证产品ID 16 2.5.5 选择分隔符 17 2.5.6 列表长度限制 17 2.5.7 其他使用交叉表的好处 17</span><br><span class="line"></span><br><span class="line"> 第3章 单纯的树 18 3.1 目标:分层存储与查询 18 3.2 反模式:总是依赖父节点 19 3.2.1 使用邻接表查询树 20 3.2.2 使用邻接表维护树 21 3.3 如何识别反模式 22 3.4 合理使用反模式 23 3.5 解决方案:使用其他树模型 24 3.5.1 路径枚举 24 3.5.2 嵌套集 26 3.5.3 闭包表 29 3.5.4 你该使用哪种设计 33</span><br><span class="line"></span><br><span class="line"> 第4章 需要ID 34 4.1 目标:建立主键规范 35 4.2 反模式:以不变应万变 36 4.2.1 冗余键值 36 4.2.2 允许重复项 37 4.2.3 意义不明的关键字 38 4.2.4 使用USING关键字 38 4.2.5 使用组合键之难 39 4.3 如何识别反模式 39 4.4 合理使用反模式 40 4.5 解决方案:裁剪设计 40 4.5.1 直截了当地描述设计 40 4.5.2 打破传统 41 4.5.3 拥抱自然键和组合键 41</span><br><span class="line"></span><br><span class="line"> 第5章 不用钥匙的入口 43 5.1 目标:简化数据库架构 43 5.2 反模式:无视约束 44 5.2.1 假设无瑕代码 44 5.2.2 检查错误 45 5.2.3 “那不是我的错!” 45 5.2.4 进退维谷 46 5.3 如何识别反模式 46 5.4 合理使用反模式 47 5.5 解决方案:声明约束 47 5.5.1 支持同步修改 48 5.5.2 系统开销过度？不见得 48</span><br><span class="line"></span><br><span class="line"> 第6章 实体-属性-值 50 6.1 目标:支持可变的属性 50 6.2 反模式:使用泛型属性表 51 6.2.1 查询属性 53 6.2.2 支持数据完整性 53 6.2.3 无法声明强制属性 53 6.2.4 无法使用SQL的数据类型 53 6.2.5 无法确保引用完整性 54 6.2.6 无法配置属性名 55 6.2.7 重组列 55 6.3 如何识别反模式 56 6.4 合理使用反模式 56 6.5 解决方案:模型化子类型 57 6.5.1 单表继承 57 6.5.2 实体表继承 58 6.5.3 类表继承 60 6.5.4 半结构化数据模型 61 6.5.5 后处理 61</span><br><span class="line"></span><br><span class="line"> 第7章 多态关联 64 7.1 目标:引用多个父表 65 7.2 反模式:使用双用途外键 65 7.2.1 定义多态关联 65 7.2.2 使用多态关联进行查询 66 7.2.3 非面向对象范例 67 7.3 如何识别反模式 68 7.4 合理使用反模式 69 7.5 解决方案:让关系变得简单 69 7.5.1 反向引用 69 7.5.2 创建交叉表 69 7.5.3 设立交通灯 70 7.5.4 双向查找 71 7.5.5 合并跑道 71 7.5.6 创建共用的超级表 72</span><br><span class="line"></span><br><span class="line"> 第8章 多列属性 75 8.1 目标:存储多值属性 75 8.2 反模式:创建多个列 76 8.2.1 查询数据 76 8.2.2 添加及删除值 77 8.2.3 确保唯一性 78 8.2.4 处理不断增长的值集 78 8.3 如何识别反模式 79 8.4 合理使用反模式 79 8.5 解决方案:创建从属表 80</span><br><span class="line"></span><br><span class="line"> 第9章 元数据分裂 82 9.1 目标:支持可扩展性 83 9.2 反模式:克隆表与克隆列 83 9.2.1 不断产生的新表 84 9.2.2 管理数据完整性 84 9.2.3 同步数据 85 9.2.4 确保唯一性 85 9.2.5 跨表查询 86 9.2.6 同步元数据 86 9.2.7 管理引用完整性 86 9.2.8 标识元数据分裂列 87 9.3 如何识别反模式 87 9.4 合理使用反模式 88 9.5 解决方案:分区及标准化 89 9.5.1 使用水平分区 89 9.5.2 使用垂直分区 89 9.5.3 解决元数据分裂列 91</span><br><span class="line"></span><br><span class="line"> 第二部分 物理数据库设计反模式</span><br><span class="line"></span><br><span class="line"> 第10章 取整错误 94 10.1 目标:使用小数取代整数 94 10.2 反模式:使用FLOAT类型 95 10.2.1 舍入的必要性 95 10.2.2 在SQL中使用FLOAT 96 10.3 如何识别反模式 98 10.4 合理使用反模式 98 10.5 解决方案:使用NUMERIC类型 98</span><br><span class="line"></span><br><span class="line"> 第11章 每日新花样 100 11.1 目标:限定列的有效值 100 11.2 反模式:在列定义上指定可选值 101 11.2.1 中间的是哪个 102 11.2.2 添加新口味 103 11.2.3 老的口味永不消失 103 11.2.4 可移植性低下 103 11.3 如何识别反模式 104 11.4 合理使用反模式 104 11.5 解决方案:在数据中指定值 104 11.5.1 查询候选值集合 105 11.5.2 更新检查表中的值 105 11.5.3 支持废弃数据 105 11.5.4 良好的可移植性 106</span><br><span class="line"></span><br><span class="line"> 第12章 幽灵文件 107 12.1 目标:存储图片或其他多媒体大文件 107 12.2 反模式:假设你必须使用文件系统 108 12.2.1 文件不支持DELETE 109 12.2.2 文件不支持事务隔离 109 12.2.3 文件不支持回滚操作 109 12.2.4 文件不支持数据库备份工具 110 12.2.5 文件不支持SQL的访问权限设置 110 12.2.6 文件不是SQL数据类型 110 12.3 如何识别反模式 111 12.4 合理使用反模式 111 12.5 解决方案:在需要时使用BLOB 类型 112</span><br><span class="line"></span><br><span class="line"> 第13章 乱用索引 114 13.1 目标:优化性能 115 13.2 反模式:无规划地使用索引 115 13.2.1 无索引 115 13.2.2 索引过多 116 13.2.3 索引也无能为力 117 13.3 如何识别反模式 118 13.4 合理使用反模式 119 13.5 解决方案:MENTOR你的索引 119 13.5.1 测量 120 13.5.2 解释 121 13.5.3 挑选 122 13.5.4 测试 123 13.5.5 优化 123 13.5.6 重建 123</span><br><span class="line"></span><br><span class="line"> 第三部分 查询反模式</span><br><span class="line"></span><br><span class="line"> 第14章 对未知的恐惧 126 14.1 目标:辨别悬空值 127 14.2 反模式:将NULL作为普通的值,反之亦然 127 14.2.1 在表达式中使用NULL 127 14.2.2 搜索允许为空的列 128 14.2.3 在查询参数中使用NULL 128 14.2.4 避免上述问题 128 14.3 如何识别反模式 130 14.4 合理使用反模式 130 14.5 解决方案:将NULL视为特殊值 131 14.5.1 在标量表达式中使用NULL 131 14.5.2 在布尔表达式中使用NULL 132 14.5.3 检索NULL值 132 14.5.4 声明NOT NULL的列 133 14.5.5 动态默认值 134</span><br><span class="line"></span><br><span class="line"> 第15章 模棱两可的分组 135 15.1 目标:获取每组的最大值 135 15.2 反模式:引用非分组列 136 15.2.1 单值规则 136 15.2.2 我想要的查询 137 15.3 如何识别反模式 138 15.4 合理使用反模式 139 15.5 解决方案:无歧义地使用列 140 15.5.1 只查询功能依赖的列 140 15.5.2 使用关联子查询 140 15.5.3 使用衍生表 140 15.5.4 使用JOIN 141 15.5.5 对额外的列使用聚合函数 142 15.5.6 连接同组所有值 142</span><br><span class="line"></span><br><span class="line"> 第16章 随机选择 144 16.1 目标:获取样本记录 144 16.2 反模式:随机排序 145 16.3 如何识别反模式 146 16.4 合理使用反模式 146 16.5 解决方案:没有具体的顺序 146 16.5.1 从1到最大值之间随机选择 146 16.5.2 选择下一个最大值 147 16.5.3 获取所有的键值,随机选择一个 147 16.5.4 使用偏移量选择随机行 148 16.5.5 专有解决方案 149</span><br><span class="line"></span><br><span class="line"> 第17章 可怜人的搜索引擎 150 17.1 目标:全文搜索 150 17.2 反模式:模式匹配断言 151 17.3 如何识别反模式 152 17.4 合理使用反模式 152 17.5 解决方案:使用正确的工具 152 17.5.1 数据库扩展 153 17.5.2 第三方搜索引擎 157</span><br><span class="line"></span><br><span class="line"> 第18章 意大利面条式查询 162 18.1 目标:减少SQL查询数量 162 18.2 反模式:使用一步操作解决复杂问题 163 18.2.1 副作用 163 18.2.2 那好像还不够…… 164 18.3 如何识别反模式 165 18.4 合理使用反模式 165 18.5 解决方案:分而治之 166 18.5.1 一步一个脚印 166 18.5.2 寻找UNION标记 167 18.5.3 解决老板的问题 167 18.5.4 使用SQL自动生成SQL 168</span><br><span class="line"></span><br><span class="line"> 第19章 隐式的列 170 19.1 目标:减少输入 171 19.2 反模式:捷径会让你迷失方向 171 19.2.1 破坏代码重构 171 19.2.2 隐藏的开销 172 19.2.3 你请求,你获得 172 19.3 如何识别反模式 173 19.4 合理使用反模式 173 19.5 解决方案:明确列出列名 174 19.5.1 预防错误 174 19.5.2 你不需要它 175 19.5.3 无论如何你都需要放弃使用通配符 175</span><br><span class="line"></span><br><span class="line"> 第四部分 应用程序开发反模式</span><br><span class="line"></span><br><span class="line"> 第20章 明文密码 178 20.1 目标:恢复或重置密码 178 20.2 反模式:使用明文存储密码 179 20.2.1 存储密码 179 20.2.2 验证密码 180 20.2.3 在E-mail中发送密码 180 20.3 如何识别反模式 181 20.4 合理使用反模式 181 20.5 解决方案:先哈希,后存储 182 20.5.1 理解哈希函数 182 20.5.2 在SQL中使用哈希 183 20.5.3 给哈希加料 183 20.5.4 在SQL中隐藏密码 185 20.5.5 重置密码,而非恢复密码 186</span><br><span class="line"></span><br><span class="line"> 第21章 SQL注入 188 21.1 目标:编写SQL动态查询 189 21.2 反模式:将未经验证的输入作为代码执行 189 21.2.1 意外无处不在 190 21.2.2 对Web安全的严重威胁 190 21.2.3 寻找治愈良方 191 21.3 如何识别反模式 195 21.4 合理使用反模式 196 21.5 解决方案:不信任任何人 196 21.5.1 过滤输入内容 196 21.5.2 参数化动态内容 197 21.5.3 给动态输入的值加引号 197 21.5.4 将用户与代码隔离 198 21.5.5 找个可靠的人来帮你审查代码 200</span><br><span class="line"></span><br><span class="line"> 第22章 伪键洁癖 202 22.1 目标:整理数据 202 22.2 反模式:填充角落 203 22.2.1 不按照顺序分配编号 203 22.2.2 为现有行重新编号 204 22.2.3 制造数据差异 204 22.3 如何识别反模式 205 22.4 合理使用反模式 205 22.5 解决方案:克服心里障碍 205 22.5.1 定义行号 205 22.5.2 使用GUID 206 22.5.3 最主要的问题 207</span><br><span class="line"></span><br><span class="line"> 第23章 非礼勿视 209 23.1 目标:写更少的代码 210 23.2 反模式:无米之炊 210 23.2.1 没有诊断的诊断 210 23.2.2 字里行间 211 23.3 如何识别反模式 212 23.4 合理使用反模式 213 23.5 解决方案:优雅地从错误中恢复 213 23.5.1 保持节奏 213 23.5.2 回溯你的脚步 214</span><br><span class="line"></span><br><span class="line"> 第24章 外交豁免权 215 24.1 目标:采用最佳实践 215 24.2 反模式:将SQL视为二等公民 216 24.3 如何识别反模式 216 24.4 合理使用反模式 217 24.5 解决方案:建立一个质量至上的文化 217 24.5.1 陈列A:编写文档 218 24.5.2 寻找证据:源代码版本控制 220 24.5.3 举证:测试 222 24.5.4 例证:同时处理多个分支 223</span><br><span class="line"></span><br><span class="line"> 第25章 魔豆 225 25.1 目标:简化MVC的模型 226 25.2 反模式:模型仅仅是活动记录 227 25.2.1 活动记录模式连接程序模型和数据库结构 228 25.2.2 活动记录模式暴露了CRUD系列函数 228 25.2.3 活动记录模式支持弱域模型 229 25.2.4 魔豆难以进行单元测试 231 25.3 如何识别反模式 232 25.4 合理使用反模式 232 25.5 解决方案:模型包含活动记录 232 25.5.1 领会模型的意义 233 25.5.2 将领域模型应用到实际工作中 234 25.5.3 测试简单对象 236 25.5.4 回到地球 237</span><br><span class="line"></span><br><span class="line"> 第五部分 附录</span><br><span class="line"></span><br><span class="line"> 附录A 规范化规则 240 附录B 参考书目 252</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B005N4L03E/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B005N4L03E&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51qf2ptTuzL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>C++反汇编与逆向分析技术揭秘</title>
    <url>/2020/04/19/B005OGEL7I/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： C++反汇编与逆向分析技术揭秘<br>作者信息： 作者: 钱林松 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《C++反汇编与逆向分析技术揭秘》：深度揭秘软件逆向分析技术的流程与方法，理论与实践完美结合，由安全领域资深专家亲自执笔，看雪软件安全网站创始人段钢等多位安全领域专家联袂推荐。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">第一部分 准备工作</span><br><span class="line">第1章 熟悉工作环境和相关工具 &#x2F; 2</span><br><span class="line">1.1 调试工具Microsoft Visual C++ 6.0和OllyDBG &#x2F; 2</span><br><span class="line">1.2 反汇编静态分析工具IDA &#x2F; 5</span><br><span class="line">1.3 反汇编引擎的工作原理 &#x2F; 11</span><br><span class="line">1.4 本章小结 &#x2F; 16</span><br><span class="line">第二部分 C++反汇编揭秘</span><br><span class="line">第2章 基本数据类型的表现形式 &#x2F; 18</span><br><span class="line">2.1 整数类型 &#x2F; 18</span><br><span class="line">2.1.1 无符号整数 &#x2F; 18</span><br><span class="line">2.1.2 有符号整数 &#x2F; 18</span><br><span class="line">2.2 浮点数类型 &#x2F; 20</span><br><span class="line">2.2.1 浮点数的编码方式 &#x2F; 21</span><br><span class="line">2.2.2 基本的浮点数指令 &#x2F; 23</span><br><span class="line">2.3 字符和字符串 &#x2F; 26</span><br><span class="line">2.3.1 字符的编码 &#x2F; 27</span><br><span class="line">2.3.2 字符串的存储方式 &#x2F; 28</span><br><span class="line">2.4 布尔类型 &#x2F; 29</span><br><span class="line">2.5 地址、指针和引用 &#x2F; 29</span><br><span class="line">2.5.1 指针和地址的区别 &#x2F; 30</span><br><span class="line">2.5.2 各类型指针的工作方式 &#x2F; 31</span><br><span class="line">2.5.3 引用 &#x2F; 34</span><br><span class="line">2.6 常量 &#x2F; 35</span><br><span class="line">2.6.1 常量的定义 &#x2F; 36</span><br><span class="line">2.6.2 #define和const的区别 &#x2F; 37</span><br><span class="line">2.7 本章小结 &#x2F; 38</span><br><span class="line">第3章 认识启动函数，找到用户入口 &#x2F; 40</span><br><span class="line">3.1 程序的真正入口 &#x2F; 40</span><br><span class="line">3.2 了解VC++ 6.0的启动函数 &#x2F; 40</span><br><span class="line">3.3 main函数的识别 &#x2F; 44</span><br><span class="line">3.4 本章小结 &#x2F; 46</span><br><span class="line">第4章 观察各种表达式的求值过程 &#x2F; 47</span><br><span class="line">4.1 算术运算和赋值 &#x2F; 47</span><br><span class="line">4.1.1 各种算术运算的工作形式 &#x2F; 47</span><br><span class="line">4.1.2 算术结果溢出 &#x2F; 82</span><br><span class="line">4.1.3 自增和自减 &#x2F; 83</span><br><span class="line">4.2 关系运算和逻辑运算 &#x2F; 85</span><br><span class="line">4.2.1 关系运算和条件跳转的对应 &#x2F; 85</span><br><span class="line">4.2.2 表达式短路 &#x2F; 86</span><br><span class="line">4.2.3 条件表达式 &#x2F; 88</span><br><span class="line">4.3 位运算 &#x2F; 92</span><br><span class="line">4.4 编译器使用的优化技巧 &#x2F; 94</span><br><span class="line">4.4.1 流水线优化规则 &#x2F; 97</span><br><span class="line">4.4.2 分支优化规则 &#x2F; 101</span><br><span class="line">4.4.3 高速缓存（cache）优化规则 &#x2F; 101</span><br><span class="line">4.5 一次算法逆向之旅 &#x2F; 102</span><br><span class="line">4.6 本章小结 &#x2F; 109</span><br><span class="line">第5章 流程控制语句的识别 &#x2F; 110</span><br><span class="line">5.1 if语句 &#x2F; 110</span><br><span class="line">5.2 if…else…语句 &#x2F; 112</span><br><span class="line">5.3 用if构成的多分支流程 &#x2F; 115</span><br><span class="line">5.4 switch的真相 &#x2F; 119</span><br><span class="line">5.5 难以构成跳转表的switch &#x2F; 128</span><br><span class="line">5.6 降低判定树的高度 &#x2F; 133</span><br><span class="line">5.7 do&#x2F;while&#x2F;for的比较 &#x2F; 137</span><br><span class="line">5.8 编译器对循环结构的优化 &#x2F; 143</span><br><span class="line">5.9 本章小结 &#x2F; 148</span><br><span class="line">第6章 函数的工作原理 &#x2F; 149</span><br><span class="line">6.1 栈帧的形成和关闭 &#x2F; 149</span><br><span class="line">6.2 各种调用方式的考察 &#x2F; 152</span><br><span class="line">6.3 使用ebp或esp寻址 &#x2F; 155</span><br><span class="line">6.4 函数的参数 &#x2F; 158</span><br><span class="line">6.5 函数的返回值 &#x2F; 160</span><br><span class="line">6.6 回顾 &#x2F; 163</span><br><span class="line">6.7 本章小结 &#x2F; 165</span><br><span class="line">第7章 变量在内存中的位置和访问方式 &#x2F; 166</span><br><span class="line">7.1 全局变量和局部变量的区别 &#x2F; 166</span><br><span class="line">7.2 局部静态变量的工作方式 &#x2F; 169</span><br><span class="line">7.3 堆变量 &#x2F; 173</span><br><span class="line">7.4 本章小结 &#x2F; 177</span><br><span class="line">第8章 数组和指针的寻址 &#x2F; 178</span><br><span class="line">8.1 数组在函数内 &#x2F; 178</span><br><span class="line">8.2 数组作为参数 &#x2F; 181</span><br><span class="line">8.3 数组作为返回值 &#x2F; 185</span><br><span class="line">8.4 下标寻址和指针寻址 &#x2F; 189</span><br><span class="line">8.5 多维数组 &#x2F; 193</span><br><span class="line">8.6 存放指针类型数据的数组 &#x2F; 199</span><br><span class="line">8.7 指向数组的指针变量 &#x2F; 201</span><br><span class="line">8.8 函数指针 &#x2F; 204</span><br><span class="line">8.9 本章小结 &#x2F; 206</span><br><span class="line">第9章 结构体和类 &#x2F; 207</span><br><span class="line">9.1 对象的内存布局 &#x2F; 207</span><br><span class="line">9.2 this指针 &#x2F; 212</span><br><span class="line">9.3 静态数据成员 &#x2F; 217</span><br><span class="line">9.4 对象作为函数参数 &#x2F; 219</span><br><span class="line">9.5 对象作为返回值 &#x2F; 226</span><br><span class="line">9.6 本章小结 &#x2F; 231</span><br><span class="line">第10章 关于构造函数和析构函数 &#x2F; 233</span><br><span class="line">10.1 构造函数的出现时机 &#x2F; 233</span><br><span class="line">10.2 每个对象都有默认的构造函数吗 &#x2F; 243</span><br><span class="line">10.3 析构函数的出现时机 &#x2F; 245</span><br><span class="line">10.4 本章小结 &#x2F; 254</span><br><span class="line">第11章 关于虚函数 &#x2F; 256</span><br><span class="line">11.1 虚函数的机制 &#x2F; 256</span><br><span class="line">11.2 虚函数的识别 &#x2F; 261</span><br><span class="line">11.3 本章小结 &#x2F; 268</span><br><span class="line">第12章 从内存角度看继承和多重继承 &#x2F; 269</span><br><span class="line">12.1 识别类和类之间的关系 &#x2F; 270</span><br><span class="line">12.2 多重继承   &#x2F; 292</span><br><span class="line">12.3 虚基类 &#x2F; 298</span><br><span class="line">12.4 菱形继承 &#x2F; 299</span><br><span class="line">12.5 本章小结 &#x2F; 307</span><br><span class="line">第13章 异常处理 &#x2F; 308</span><br><span class="line">13.1 异常处理的相关知识 &#x2F; 308</span><br><span class="line">13.2 异常类型为基本数据类型的处理流程 &#x2F; 314</span><br><span class="line">13.3 异常类型为对象的处理流程 &#x2F; 323</span><br><span class="line">13.4 识别异常处理 &#x2F; 329</span><br><span class="line">13.5 本章小结 &#x2F; 341</span><br><span class="line">第三部分 逆向分析技术应用</span><br><span class="line">第14章 PEiD的工作原理分析 &#x2F; 344</span><br><span class="line">14.1 开发环境的识别 &#x2F; 344</span><br><span class="line">14.2 开发环境的伪造 &#x2F; 353</span><br><span class="line">14.3 本章小结 &#x2F; 356</span><br><span class="line">第15章 “熊猫烧香”病毒逆向分析 &#x2F; 357</span><br><span class="line">15.1 调试环境配置 &#x2F; 357</span><br><span class="line">15.2 病毒程序初步分析 &#x2F; 358</span><br><span class="line">15.3 “熊猫烧香”的启动过程分析 &#x2F; 360</span><br><span class="line">15.4 “熊猫烧香”的自我保护分析 &#x2F; 366</span><br><span class="line">15.5 “熊猫烧香”的感染过程分析 &#x2F; 369</span><br><span class="line">15.6 本章小结 &#x2F; 379</span><br><span class="line">第16章 调试器OllyDBG的工作原理分析 &#x2F; 380</span><br><span class="line">16.1 INT3断点 &#x2F; 380</span><br><span class="line">16.2 内存断点 &#x2F; 385</span><br><span class="line">16.3 硬件断点 &#x2F; 390</span><br><span class="line">16.4 异常处理机制 &#x2F; 396</span><br><span class="line">16.5 加载调试程序 &#x2F; 402</span><br><span class="line">16.6 本章小结 &#x2F; 406</span><br><span class="line">第17章 反汇编代码的重建与编译 &#x2F; 407</span><br><span class="line">17.1 重建反汇编代码 &#x2F; 407</span><br><span class="line">17.2 编译重建后的反汇编代码 &#x2F; 410</span><br><span class="line">17.3 本章小结 &#x2F; 411</span><br><span class="line">参考文献 &#x2F; 412</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B005OGEL7I/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B005OGEL7I&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51febSBwXjL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop实战</title>
    <url>/2020/04/19/B005X5ORFQ/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Hadoop实战<br>作者信息： 作者: Chuck Lam [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Hadoop实战》纵情享受海量数据之美、揭开云计算的神秘面纱、深入分析，追本溯源。ApacheHadoop是一个NoSQL应用程序框架，在分布式集群中运行，它适合于处理大数据集。如果需要从数据中分析信息，那么Hadoop是你的最佳选择。《Hadoop实战》是一本深受读者好评的专著，旨在教会你如何以MapReduce方式编写程序，其中包含MapReduce编程中的最佳实践及设计模式。书中内容由浅入深，以几个简单的例子开始，继而转向Hadoop在较为复杂的数据分析中的应用.，此外，还介绍了StreamingAPI及Pig和Hive等工具。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分 Hadoop——一种分布式编程框架</span><br><span class="line">第1章 Hadoop简介 2</span><br><span class="line">1.1 为什么写《Hadoop 实战》 3</span><br><span class="line">1.2 什么是Hadoop 3</span><br><span class="line">1.3 了解分布式系统和Hadoop 4</span><br><span class="line">1.4 比较SQL数据库和Hadoop 5</span><br><span class="line">1.5 理解MapReduce 6</span><br><span class="line">1.5.1 动手扩展一个简单程序 7</span><br><span class="line">1.5.2 相同程序在MapReduce中的扩展 9</span><br><span class="line">1.6 用Hadoop统计单词——运行第一个程序 11</span><br><span class="line">1.7 Hadoop历史 15</span><br><span class="line">1.8 小结 16</span><br><span class="line">1.9 资源 16 </span><br><span class="line"></span><br><span class="line"> 第2章 初识Hadoop 17 2.1 Hadoop的构造模块 17 2.1.1 NameNode 17 2.1.2 DataNode 18 2.1.3 Secondary NameNode 19 2.1.4 JobTracker 19 2.1.5 TaskTracker 19 2.2 为Hadoop集群安装SSH 21 2.2.1 定义一个公共账号 21 2.2.2 验证SSH安装 21 2.2.3 生成SSH密钥对 21 2.2.4 将公钥分布并登录验证 22 2.3 运行Hadoop 22 2.3.1 本地(单机)模式 23 2.3.2 伪分布模式 24 2.3.3 全分布模式 25 2.4 基于Web的集群用户界面 28 2.5 小结 30</span><br><span class="line"></span><br><span class="line"> 第3章 Hadoop组件 31 3.1 HDFS文件操作 31 3.1.1 基本文件命令 32 3.1.2 编程读写HDFS 35 3.2 剖析MapReduce程序 37 3.2.1 Hadoop数据类型 39 3.2.2 Mapper 40 3.2.3 Reducer 41 3.2.4 Partitioner：重定向Mapper输出 41 3.2.5 Combiner：本地reduce 43 3.2.6 预定义mapper和Reducer类的单词计数 43 3.3 读和写 43 3.3.1 InputFormat 44 3.3.2 OutputFormat 49 3.4 小结 50</span><br><span class="line"></span><br><span class="line"> 第二部分 实战</span><br><span class="line"></span><br><span class="line"> 第4章 编写MapReduce基础程序 52 4.1 获得专利数据集 52 4.1.1 专利引用数据 53 4.1.2 专利描述数据 54 4.2 构建MapReduce程序的基础模板 55 4.3 计数 60 4.4 适应Hadoop API的改变 64 4.5 Hadoop的Streaming 67 4.5.1 通过Unix命令使用Streaming 68 4.5.2 通过脚本使用Streaming 69 4.5.3 用Streaming处理键&#x2F;值对 72 4.5.4 通过Aggregate包使用Streaming 75 4.6 使用combiner提升性能 80 4.7 温故知新 83 4.8 小结 84 4.9 更多资源 84</span><br><span class="line"></span><br><span class="line"> 第5章 高阶MapReduce 85 5.1 链接MapReduce作业 85 5.1.1 顺序链接MapReduce作业 85 5.1.2 具有复杂依赖的MapReduce链接 86 5.1.3 预处理和后处理阶段的链接 86 5.2 联结不同来源的数据 89 5.2.1 Reduce侧的联结 90 5.2.2 基于DistributedCache的复制联结 98 5.2.3 半联结：map侧过滤后在reduce侧联结 101 5.3 创建一个Bloom filter 102 5.3.1 Bloom filter做了什么 102 5.3.2 实现一个Bloom filter 104 5.3.3 Hadoop 0.20以上版本的Bloom filter 110 5.4 温故知新 110 5.5 小结 111 5.6 更多资源 112</span><br><span class="line"></span><br><span class="line"> 第6章 编程实践 113 6.1 开发MapReduce程序 113 6.1.1 本地模式 114 6.1.2 伪分布模式 118 6.2 生产集群上的监视和调试 123 6.2.1 计数器 123 6.2.2 跳过坏记录 125 6.2.3 用IsolationRunner重新运行出错的任务 128 6.3 性能调优 129 6.3.1 通过combiner来减少网络流量 129 6.3.2 减少输入数据量 129 6.3.3 使用压缩 129 6.3.4 重用JVM 132 6.3.5 根据猜测执行来运行 132 6.3.6 代码重构与算法重写 133 6.4 小结 134</span><br><span class="line"></span><br><span class="line"> 第7章 细则手册 135 7.1 向任务传递作业定制的参数 135 7.2 探查任务特定信息 137 7.3 划分为多个输出文件 138 7.4 以数据库作为输入输出 143 7.5 保持输出的顺序 145 7.6 小结 146</span><br><span class="line"></span><br><span class="line"> 第8章 管理Hadoop 147 8.1 为实际应用设置特定参数值 147 8.2 系统体检 149 8.3 权限设置 151 8.4 配额管理 151 8.5 启用回收站 152 8.6 删减DataNode 152 8.7 增加DataNode 153 8.8 管理NameNode和SNN 153 8.9 恢复失效的NameNode 155 8.10 感知网络布局和机架的设计 156 8.11 多用户作业的调度 157 8.11.1 多个JobTracker 158 8.11.2 公平调度器 158 8.12 小结 160</span><br><span class="line"></span><br><span class="line"> 第三部分 Hadoop也疯狂</span><br><span class="line"></span><br><span class="line"> 第9章 在云上运行Hadoop 162 9.1 Amazon Web Services简介 162 9.2 安装AWS 163 9.2.1 获得AWS身份认证凭据 164 9.2.2 获得命令行工具 166 9.2.3 准备SSH密钥对 168 9.3 在EC2上安装Hadoop 169 9.3.1 配置安全参数 169 9.3.2 配置集群类型 169 9.4 在EC2上运行MapReduce程序 171 9.4.1 将代码转移到Hadoop集群上 171 9.4.2 访问Hadoop集群上的数据 172 9.5 清空和关闭EC2实例 175 9.6 Amazon Elastic MapReduce和其他AWS服务 176 9.6.1 Amazon Elastic MapReduce 176 9.6.2 AWS导入&#x2F;导出 177 9.7 小结 177</span><br><span class="line"></span><br><span class="line"> 第10章 用Pig编程 178 10.1 像Pig一样思考 178 10.1.1 数据流语言 179 10.1.2 数据类型 179 10.1.3 用户定义函数 179 10.2 安装Pig 179 10.3 运行Pig 180 10.4 通过Grunt学习Pig Latin 182 10.5 谈谈Pig Latin 186 10.5.1 数据类型和schema 186 10.5.2 表达式和函数 187 10.5.3 关系型运算符 189 10.5.4 执行优化 196 10.6 用户定义函数 196 10.6.1 使用UDF 196 10.6.2 编写UDF 197 10.7 脚本 199 10.7.1 注释 199 10.7.2 参数替换 200 10.7.3 多查询执行 201 10.8 Pig实战——计算相似专利的例子 201 10.9 小结 206</span><br><span class="line"></span><br><span class="line"> 第11章 Hive及Hadoop群 207 11.1 Hive 207 11.1.1 安装与配置Hive 208 11.1.2 查询的示例 210 11.1.3 深入HiveQL 213 11.1.4 Hive小结 221 11.2 其他Hadoop相关的部分 221 11.2.1 HBase 221 11.2.2 ZooKeeper 221 11.2.3 Cascading 221 11.2.4 Cloudera 222 11.2.5 Katta 222 11.2.6 CloudBase 222 11.2.7 Aster Data和Greenplum 222 11.2.8 Hama和Mahout 223 11.2.9 search-hadoop.com 223 11.3 小结 223</span><br><span class="line"></span><br><span class="line"> 第12章 案例研究 224 12.1 转换《纽约时报》1100万个库存图片文档 224 12.2 挖掘中国移动的数据 225 12.3 在StumbleUpon推荐最佳网站 229 12.3.1 分布式StumbleUpon的开端 230 12.3.2 HBase和StumbleUpon 230 12.3.3 StumbleUpon上的更多Hadoop应用 236 12.4 搭建面向企业查询的分析系统——IBM的ES2项目 238 12.4.1 ES2系统结构 240 12.4.2 ES2爬虫 241 12.4.3 ES2分析 242 12.4.4 小结 249 12.4.5 参考文献 250</span><br><span class="line"></span><br><span class="line"> 附录A HDFS文件命令 251</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B005X5ORFQ/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B005X5ORFQ&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51lgP-hNN3L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>代码大全(第2版)</title>
    <url>/2020/04/19/B0061XKRXA/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 代码大全(第2版)<br>作者信息： 作者: 史蒂夫•迈克康奈尔 (Steve McConnell) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《代码大全(第2版)》中所论述的技术不仅填补了初级与高级编程实践之间的空白，而且也为程序员们提供了一个有关软件开发技术的信息来源。《代码大全(第2版)》对经验丰富的程序员、技术带头人、自学的程序员及没有太多编程经验的学生都是大有裨益的。可以说，只要您具有一定的编程基础，想成为一名优秀的程序员，阅读《代码大全(第2版)》都不会让您失望。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">鸣谢</span><br><span class="line">核对表目录</span><br><span class="line">表目录</span><br><span class="line">图目录</span><br><span class="line">第1部分 打好基础</span><br><span class="line">第1章 欢迎进入软件构建的世界</span><br><span class="line">1.1什么是软件构建</span><br><span class="line">1.2软件构建为何如此重要</span><br><span class="line">1.3如何阅读本书</span><br><span class="line">第2章 用隐喻来更充分地理解软件开发</span><br><span class="line">2.1隐喻的重要性</span><br><span class="line">2.2如何使用软件隐喻</span><br><span class="line">2.3常见的软件隐喻</span><br><span class="line">第3章 三思而后行：前期准备</span><br><span class="line">3.1前期准备的重要性</span><br><span class="line">3.2辨明你所从事的软件的类型</span><br><span class="line">3.3 问题定义的先决条件</span><br><span class="line">3.4需求的先决条件</span><br><span class="line">3.5架构的先决条件</span><br><span class="line">3.6花费在前期准备上的时间长度</span><br><span class="line">第4章 关键的“构建”决策</span><br><span class="line">4.1选择编程语言</span><br><span class="line">4.2编程约定</span><br><span class="line">4.3你在技术浪潮中的位置</span><br><span class="line">4.4选择主要的构建实践方法 </span><br><span class="line"></span><br><span class="line"> 第2部分 创建高质量的代码 第5章 软件构建中的设计 5.1设计中的挑战 5.2关键的设计概念 5.3 设计构造块：启发式方法 5.4 设计实践 5.5对流行的设计方法的评论 第6章 可以工作的类 6.1类的基础：抽象数据类型（ADTs） 6.2 良好的类接口 6.3有关设计和实现的问题 6.4创建类的原因 6.5与具体编程语言相关的问题 6.6超越类：包 第7章 高质量的子程序 7.1创建子程序的正当理由 7.2在子程序层上设计 7.3好的子程序名字 7.4子程序可以写多长 7.5如何使用子程序参数 7.6使用函数时要特别考虑的问题 7.7宏子程序和内联子程序 第8章 防御式编程 8.1保护程序免遭非法输入数据的破坏 8.2断言 8.3错误处理技术 8.4异常 8.5隔离程序，使之包容由错误造成的损害 8.6辅助调试的代码 8.7确定在产品代码中该保留多少防御式代码 8.8对防御式编程采取防御的姿态 第9章 伪代码编程过程 9.1创建类和子程序的步骤概述 …… 第3部分 变量 第4部分 语句 第5部分 代码改善 第6部分 系统考虑 第7部分 软件工艺 参考文献 索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0061XKRXA/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0061XKRXA&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51MWrJEKqEL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>编程语言实现模式</title>
    <url>/2020/04/19/B007HYMPBY/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 编程语言实现模式<br>作者信息： 作者: Terence Parr [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《编程语言实现模式》虽然不专门讨论如何设计编程语言，但读者在阅读的过程中将吸收丰富的相关知识。比较不同编程语言的特点、了解编程语言的发展历史是学习设计编程语言的好途径。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1部分 读取输入</span><br><span class="line">第1章 初探语言应用 3</span><br><span class="line">1.1 大局观 3</span><br><span class="line">1.2 模式概览 5</span><br><span class="line">1.3 深入浅出语言应用 9</span><br><span class="line">1.4 为语言应用选择合适的模式 17</span><br><span class="line">第2章 基本解析模式 21</span><br><span class="line">2.1 识别式子的结构 22</span><br><span class="line">2.2 构建递归下降语法解析器 24</span><br><span class="line">2.3 使用文法DSL来构建语法解析器 26</span><br><span class="line">2.4 词法单元和句子 27</span><br><span class="line">第3章 高阶解析模式 49</span><br><span class="line">3.1 利用任意多的向前看符号进行解析 50</span><br><span class="line">3.2 记忆式解析 52</span><br><span class="line">3.3 采用语义信息指导解析过程 52 </span><br><span class="line"></span><br><span class="line"> 第2部分 分析输入 第4章 从语法树构建中间表示 73 4.1 为什么要构建树 75 4.2 构建抽象语法树 77 4.3 简要介绍ANTLR 84 4.4 使用ANTLR文法构建AST 86 第5章 遍历并改写树形结构 101 5.1 遍历树以及访问顺序 102 5.2 封装访问节点的代码 105 5.3 根据文法自动生成访问者 107 5.4 将遍历与匹配解耦 110 第6章 记录并识别程序中的符号 131 6.1 收集程序实体的信息 132 6.2 根据作用域划分符号 134 6.3 解析符号 139 第7章 管理数据聚集的符号表 155 7.1 为结构体构建作用域树 156 7.2 为类构建作用域树 158 第8章 静态类型检查 181</span><br><span class="line"></span><br><span class="line"> 第3部分 解释执行 第9章 构建高级解释器 219 9.1 高级解释器存储系统的设计 220 9.2 高级解释器中的符号记录 222 9.3 处理指令 224 第10章 构建字节码解释器 239 10.1 设计字节码解释器 241 10.2 定义汇编语言语法 243 10.3 字节码机器的架构 245 10.4 如何深入 250</span><br><span class="line"></span><br><span class="line"> 第4部分 生成输出 第11章 语言的翻译 278 11.1 语法制导的翻译 280 11.2 基于规则的翻译 281 11.3 模型驱动的翻译 283 11.4 创建嵌套的输出模型 291 第12章 使用模板生成DSL 312 12.1 熟悉StringTemplate 313 12.2 StringTemplate的性质 316 12.2 从一个简单的输入模型生成模板 317 12.4 在输入模型不同的情况下复用模板 320 12.5 使用树文法来创建模板 323 12.6 对数据列表使用模板 330 12.7 编写可改变输出结果的翻译器 336 第13章 知识汇总 348 13.1 在蛋白质结构中查找模式 348 13.2 使用脚本构建三维场景 349 13.3 处理XML 350 13.4 读取通用的配置文件 352 13.5 对代码进行微调 353 13.6 为Java添加新的类型 354 13.7 美化源代码 355 13.8 编译为机器码 356 参考文献 359 索引 361</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B007HYMPBY/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B007HYMPBY&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51VWLJVHEeL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>大象 Thinking in UML(第2版)</title>
    <url>/2020/04/19/B007RSKFGM/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 大象 Thinking in UML(第2版)<br>作者信息： 作者: 谭云杰 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《大象:Thinking in UML(第2版)》是一本讲软件的分析、设计与建模的书；一本将晦涩的概念与项目的实践紧密结合的书；一本让您与似是而非的感觉做个了断的书；一本充满思想与智慧的书……字字珠玑，醍醐灌顶。从来没有一本书，带给软件开发人员如此醍醐灌顶的感受。软件江湖盛传的“UML第一书”，开发人员梦寐以求的“九阳真经”，真正助您打通软件开发“任督二脉”。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">大象希形</span><br><span class="line">再版序</span><br><span class="line">写给读者的话</span><br><span class="line">关于本书</span><br><span class="line">如何阅读本书</span><br><span class="line">免费下载资源使用说明</span><br><span class="line">Part I  你需要了解</span><br><span class="line">  第1章  为什么需要UML</span><br><span class="line">    1.1  面向过程还是面向对象</span><br><span class="line">    1.1.1  面向过程方法</span><br><span class="line">    1.1.2  面向过程的困难</span><br><span class="line">    1.1.3  面向对象方法</span><br><span class="line">    1.1.4  面向对象的困难</span><br><span class="line">    1.2  UML带来了什么</span><br><span class="line">    1.2.1  什么是UML</span><br><span class="line">    1.2.2  统一语言</span><br><span class="line">    1.2.3  可视化</span><br><span class="line">    1.2.4  从现实世界到业务模型</span><br><span class="line">    1.2.5  从业务模型到概念模型</span><br><span class="line">    1.2.6  从概念模型到设计模型</span><br><span class="line">    1.2.7  面向对象的困难解决了吗</span><br><span class="line">    1.3  统一过程简介</span><br><span class="line">    1.3.1  RUP是什么</span><br><span class="line">    1.3.2  RUP与UML</span><br><span class="line">    1.3.3  RUP与软件工程</span><br><span class="line">    1.3.4  RUP与最佳实践</span><br><span class="line">    1.3.5  RUP与本书</span><br><span class="line">  第2章  建模基础</span><br><span class="line">    2.1  建模</span><br><span class="line">    2.2  用例驱动</span><br><span class="line">    2.3  抽象层次</span><br><span class="line">    2.4  视图</span><br><span class="line">    2.5  对象分析方法</span><br><span class="line">Part II  在学习中思考</span><br><span class="line">  第3章  UML核心元素</span><br><span class="line">    3.1  版型</span><br><span class="line">    3.2  参与者</span><br><span class="line">    3.2.1  基本概念</span><br><span class="line">    3.2.2  发现参与者</span><br><span class="line">    3.2.3  业务主角</span><br><span class="line">    3.2.4  业务工人</span><br><span class="line">    3.2.5  参与者与涉众的关系</span><br><span class="line">    3.2.6  参与者与用户的关系</span><br><span class="line">    3.2.7  参与者与角色的关系</span><br><span class="line">    3.2.8  参与者的核心地位</span><br><span class="line">    3.2.9  检查点</span><br><span class="line">    3.3  用例</span><br><span class="line">    3.3.1  基本概念</span><br><span class="line">    3.3.2  用例的特征</span><br><span class="line">    3.3.3  用例的粒度</span><br><span class="line">    3.3.4  用例的获得</span><br><span class="line">    3.3.5  用例和功能的误区</span><br><span class="line">    3.3.6  目标和步骤的误区</span><br><span class="line">    3.3.7  用例粒度的误区</span><br><span class="line">    3.3.8  业务用例</span><br><span class="line">    3.3.9  业务用例实现</span><br><span class="line">    3.3.10  概念用例</span><br><span class="line">    3.3.11  系统用例</span><br><span class="line">    3.3.12  用例实现</span><br><span class="line">    3.4  边界</span><br><span class="line">    3.4.1  边界决定视界</span><br><span class="line">    3.4.2  边界决定抽象层次</span><br><span class="line">    3.4.3  灵活使用边界</span><br><span class="line">    3.5  业务实体</span><br><span class="line">    3.5.1  业务实体的属性</span><br><span class="line">    3.5.2  业务实体的方法</span><br><span class="line">    3.5.3  获取业务实体</span><br><span class="line">    3.6  包</span><br><span class="line">    3.7  分析类</span><br><span class="line">    3.7.1  边界类</span><br><span class="line">    3.7.2  控制类</span><br><span class="line">    3.7.3  实体类</span><br><span class="line">    3.7.4  分析类的三高</span><br><span class="line">    3.8  设计类</span><br><span class="line">    3.8.1  类</span><br><span class="line">    3.8.2  属性</span><br><span class="line">    3.8.3  方法</span><br><span class="line">    3.8.4  可见性</span><br><span class="line">    3.9  关系</span><br><span class="line">    3.9.1  关联关系（association）</span><br><span class="line">    3.9.2  依赖关系（dependency）</span><br><span class="line">    3.9.3  扩展关系（extends）</span><br><span class="line">    3.9.4  包含关系（include）</span><br><span class="line">    3.9.5  实现关系（realize）</span><br><span class="line">    3.9.6  精化关系（refine）</span><br><span class="line">    3.9.7  泛化关系（generalization）</span><br><span class="line">    3.9.8  聚合关系（aggregation）</span><br><span class="line">    3.9.9  组合关系（composition）</span><br><span class="line">    3.10  组件</span><br><span class="line">    3.10.1  完备性</span><br><span class="line">    3.10.2  独立性</span><br><span class="line">    3.10.3  逻辑性</span><br><span class="line">    3.10.4  透明性</span><br><span class="line">    3.10.5  使用组件</span><br><span class="line">    3.11  节点</span><br><span class="line">    3.11.1  分布式应用环境</span><br><span class="line">    3.11.2  多设备应用环境</span><br><span class="line">  第4章  UML核心视图</span><br><span class="line">    4.1  静态视图</span><br><span class="line">    4.1.1  用例图</span><br><span class="line">    4.1.2  类图</span><br><span class="line">    4.1.3  包图</span><br><span class="line">    4.2  动态视图</span><br><span class="line">    4.2.1  活动图</span><br><span class="line">    4.2.2  状态图</span><br><span class="line">    4.2.3  时序图</span><br><span class="line">    4.2.4  协作图</span><br><span class="line">  第5章  UML核心模型</span><br><span class="line">    5.1  用例模型概述</span><br><span class="line">    5.2  业务用例模型</span><br><span class="line">    5.2.1  业务用例模型主要内容</span><br><span class="line">    5.2.2  业务用例模型工件的取舍</span><br><span class="line">    5.2.3  何时使用业务用例模型</span><br><span class="line">    5.3  概念用例模型</span><br><span class="line">    5.3.1  概念用例模型的主要内容</span><br><span class="line">    5.3.2  获得概念用例</span><br><span class="line">    5.3.3  何时使用概念用例模型</span><br><span class="line">    5.4  系统用例模型</span><br><span class="line">    5.4.1  系统用例模型的主要内容</span><br><span class="line">    5.4.2  获得系统用例</span><br><span class="line">    5.5  领域模型</span><br><span class="line">    5.5.1  读者须知</span><br><span class="line">    5.5.2  基本概念</span><br><span class="line">    5.5.3  领域模型的主要内容</span><br><span class="line">    5.6  分析模型</span><br><span class="line">    5.6.1  如何使用分析模型</span><br><span class="line">    5.6.2  分析模型的主要内容</span><br><span class="line">    5.6.3  分析模型的意义</span><br><span class="line">    5.7  软件架构和框架</span><br><span class="line">    5.7.1  软件架构</span><br><span class="line">    5.7.2  软件框架</span><br><span class="line">    5.7.3  何时使用架构和框架</span><br><span class="line">    5.8  设计模型</span><br><span class="line">    5.8.1  设计模型的应用场合</span><br><span class="line">    5.8.2  设计模型的主要内容</span><br><span class="line">    5.8.3  从分析模型映射到设计模型</span><br><span class="line">    5.9  组件模型</span><br><span class="line">    5.9.1  何时使用组件模型</span><br><span class="line">    5.9.2  广义组件的用法</span><br><span class="line">    5.10  实施模型</span><br><span class="line">    何时使用实施模型</span><br><span class="line">  第6章  统一过程核心工作流简介</span><br><span class="line">    6.1  业务建模工作流程</span><br><span class="line">    6.1.1  工作流程</span><br><span class="line">    6.1.2  活动集和工件集</span><br><span class="line">    6.1.3  业务建模的目标和场景</span><br><span class="line">    6.2  系统建模工作流程</span><br><span class="line">    6.2.1  工作流程</span><br><span class="line">    6.2.2  活动集和工件集</span><br><span class="line">    6.2.3  系统建模的目标</span><br><span class="line">    6.3  分析设计建模工作流程</span><br><span class="line">    6.3.1  工作流程</span><br><span class="line">    6.3.2  活动集和工件集</span><br><span class="line">    6.3.3  分析设计的目标</span><br><span class="line">    6.3.4  推荐的分析设计工作流程简介</span><br><span class="line">    6.4  实施建模工作流程</span><br><span class="line">    6.4.1  工作流程</span><br><span class="line">    6.4.2  活动集和工件集</span><br><span class="line">    6.4.3  推荐的实施建模工作流程</span><br><span class="line">  第7章  迭代式软件生命周期</span><br><span class="line">Part III  在实践中思考</span><br><span class="line">  第8章  准备工作</span><br><span class="line">    8.1  案例说明</span><br><span class="line">    8.2  了解问题领域</span><br><span class="line">    8.2.1  了解业务概况</span><br><span class="line">    8.2.2  整理业务目标</span><br><span class="line">    8.3  做好涉众分析</span><br><span class="line">    8.3.1  什么是涉众</span><br><span class="line">    8.3.2  发现和定义涉众</span><br><span class="line">    8.3.3  涉众分析报告</span><br><span class="line">    8.4  规划业务范围</span><br><span class="line">    8.4.1  规划业务目标</span><br><span class="line">    8.4.2  规划涉众期望</span><br><span class="line">    8.5  整理好你的思路</span><br><span class="line">    8.5.1  划分优先级</span><br><span class="line">    8.5.2  规划需求层次</span><br><span class="line">    8.5.3  需求调研计划</span><br><span class="line">    8.6  客户访谈技巧</span><br><span class="line">    8.6.1  沟通的困难</span><br><span class="line">    8.6.2  沟通技巧</span><br><span class="line">    8.7  提给读者的问题</span><br><span class="line">  第9章  获取需求</span><br><span class="line">    9.1  定义边界</span><br><span class="line">    9.1.1  盘古开天——从混沌走向清晰</span><br><span class="line">    9.1.2  现在行动：定义边界</span><br><span class="line">    9.1.3  进一步讨论</span><br><span class="line">    9.1.4  提给读者的问题</span><br><span class="line">    9.2  发现主角</span><br><span class="line">    9.2.1  女娲造人——谁来掌管这个世界</span><br><span class="line">    9.2.2  现在行动：发现主角</span><br><span class="line">    9.2.3  进一步讨论</span><br><span class="line">    9.2.4  提给读者的问题</span><br><span class="line">    9.3  获取业务用例</span><br><span class="line">    9.3.1  炎黄之治——从愚昧走向文明</span><br><span class="line">    9.3.2  现在行动：获取业务用例</span><br><span class="line">    9.3.3  进一步讨论</span><br><span class="line">    9.3.4  提给读者的问题</span><br><span class="line">    9.4  业务建模</span><br><span class="line">    9.4.1  商鞅变法——强盛的必由之路</span><br><span class="line">    9.4.2  现在行动：建立业务模型</span><br><span class="line">    9.4.3  进一步讨论</span><br><span class="line">    9.4.4  提给读者的问题</span><br><span class="line">    9.5  领域建模</span><br><span class="line">    9.5.1  风火水土——寻找构成世界的基本元素</span><br><span class="line">    9.5.2  现在行动：建立领域模型</span><br><span class="line">    9.5.3  进一步讨论</span><br><span class="line">    9.5.4  提给读者的问题</span><br><span class="line">    9.6  提炼业务规则</span><br><span class="line">    9.6.1  牛顿的思考——揭穿苹果的秘密</span><br><span class="line">    9.6.2  现在行动：提炼业务规则</span><br><span class="line">    9.6.3  进一步讨论</span><br><span class="line">    9.6.4  提给读者的问题</span><br><span class="line">    9.7  获取非功能性需求</span><br><span class="line">    9.7.1  非物质需求——精神文明是不可缺少的</span><br><span class="line">    9.7.2  现在行动：获取非功能性需求</span><br><span class="line">    9.7.3  进一步讨论</span><br><span class="line">    9.7.4  提给读者的问题</span><br><span class="line">    9.8  主要成果物</span><br><span class="line">    提给读者的问题</span><br><span class="line">  第10章  需求分析</span><br><span class="line">    10.1  关键概念分析</span><br><span class="line">    10.1.1  阿基米德杠杆——找到撬动地球的支点</span><br><span class="line">    10.1.2  现在行动：建立概念模型</span><br><span class="line">    10.1.3  进一步讨论</span><br><span class="line">    10.1.4  提给读者的问题</span><br><span class="line">    10.2  业务架构</span><br><span class="line">    10.2.1  拼图游戏——我们也想造个世界</span><br><span class="line">    10.2.2  现在行动：建立业务架构</span><br><span class="line">    10.2.3  进一步讨论</span><br><span class="line">    10.2.4  提给读者的问题</span><br><span class="line">    10.3  系统原型</span><br><span class="line">  第11章  系统分析</span><br><span class="line">    11.1  确定系统用例</span><br><span class="line">    11.1.1  开始规划——确定新世界的万物</span><br><span class="line">    11.1.2  现在行动：确定系统用例</span><br><span class="line">    11.1.3  现在行动：描述系统用例</span><br><span class="line">    11.1.4  进一步讨论</span><br><span class="line">    11.1.5  提给读者的问题</span><br><span class="line">    11.2  分析业务规则</span><br><span class="line">    11.2.1  设定规则——没有规矩不成方圆</span><br><span class="line">    11.2.2  现在行动：分析业务规则</span><br><span class="line">    11.2.3  提给读者的问题</span><br><span class="line">    11.3  用例实现</span><br><span class="line">    11.3.1  绘制蓝图——世界将这样运行</span><br><span class="line">    11.3.2  现在行动：实现用例</span><br><span class="line">    11.3.3  进一步讨论</span><br><span class="line">    11.3.4  提给读者的问题</span><br><span class="line">    11.4  软件架构和框架</span><br><span class="line">    11.4.1  设计架构——新世界的骨架</span><br><span class="line">    11.4.2  什么是软件架构</span><br><span class="line">    11.4.3  什么是软件框架</span><br><span class="line">    11.4.4  软件架构的基本构成</span><br><span class="line">    11.4.5  应用软件架构</span><br><span class="line">    11.4.6  提给读者的问题</span><br><span class="line">    11.5  分析模型</span><br><span class="line">    11.5.1  设计功能零件——让世界初步运转起来</span><br><span class="line">    11.5.2  现在行动：建立分析模型</span><br><span class="line">    11.5.3  进一步讨论</span><br><span class="line">    11.5.4  提给读者的问题</span><br><span class="line">    11.6  组件模型</span><br><span class="line">    11.6.1  设计功能部件——构建世界的基础设施</span><br><span class="line">    11.6.2  现在行动：建立组件模型</span><br><span class="line">    11.6.3  进一步讨论</span><br><span class="line">    11.6.4  提给读者的问题</span><br><span class="line">    11.7  部署模型</span><br><span class="line">    11.7.1  安装零部件——组装一个新世界</span><br><span class="line">    11.7.2  现在行动：建立部署模型</span><br><span class="line">    11.7.3  提给读者的问题</span><br><span class="line">  第12章  系统设计</span><br><span class="line">    12.1  系统分析与系统设计的差别</span><br><span class="line">    12.2  设计模型</span><br><span class="line">    12.2.1  按图索骥——为新世界添砖加瓦</span><br><span class="line">    12.2.2  现在行动：将分析模型映射到设计模型</span><br><span class="line">    12.2.3  进一步讨论</span><br><span class="line">    12.2.4  提给读者的问题</span><br><span class="line">    12.3  接口设计</span><br><span class="line">    12.3.1  畅通无阻——构建四通八达的神经网络</span><br><span class="line">    12.3.2  现在行动：设计接口</span><br><span class="line">    12.3.3  进一步讨论</span><br><span class="line">    12.3.4  提给读者的问题</span><br><span class="line">    12.4  包设计</span><br><span class="line">    12.4.1  分工合作——组织有序世界才能更好</span><br><span class="line">    12.4.2  现在行动：设计包</span><br><span class="line">    12.4.3  进一步讨论</span><br><span class="line">    12.5  提给读者的问题</span><br><span class="line">  第13章  数据库设计</span><br><span class="line">    13.1  关公战秦琼——面向对象与关系模型之争</span><br><span class="line">    13.2  相辅相成——面向对象的数据库设计</span><br><span class="line">    13.3  平衡的艺术——数据库设计的方法和策略</span><br><span class="line">    13.3.1  OR-Mapping策略</span><br><span class="line">    13.3.2  对象—关系平衡策略</span><br><span class="line">    13.4  进一步讨论——数据库设计到底有多重要</span><br><span class="line">  第14章  开发</span><br><span class="line">    14.1  生成代码</span><br><span class="line">    14.1.1  现在行动：生成代码</span><br><span class="line">    14.1.2  进一步讨论</span><br><span class="line">    14.2  分工策略</span><br><span class="line">    14.2.1  纵向分工策略</span><br><span class="line">    14.2.2  横向分工策略</span><br><span class="line">    14.2.3  选择适合你的开发分工策略</span><br><span class="line">Part IV  在提炼中思考</span><br><span class="line">  第15章  测试</span><br><span class="line">    15.1  质量保证——新世界需要稳健运行</span><br><span class="line">    15.2  设计和开发测试例</span><br><span class="line">    15.3  提给读者的问题</span><br><span class="line">  第16章  理解用例的本质</span><br><span class="line">    16.1  用例是系统思维</span><br><span class="line">    16.2  用例是面向服务的</span><br><span class="line">    16.3  善用用例方法</span><br><span class="line">  第17章  理解用例驱动</span><br><span class="line">    17.1  用例与项目管理</span><br><span class="line">    17.2  用例与可扩展架构</span><br><span class="line">  第18章  用例驱动与领域驱动</span><br><span class="line">    18.1  用例驱动与领域驱动的差异</span><br><span class="line">    18.2  领域驱动的理想与现实</span><br><span class="line">    18.3  如何决定是否采用领域驱动方法</span><br><span class="line">  第19章  理解建模的抽象层次</span><br><span class="line">    19.1  再讨论抽象层次</span><br><span class="line">    19.1.1  层次高低问题</span><br><span class="line">    19.1.2  层次不交叉问题</span><br><span class="line">    19.2  如何决定抽象层次</span><br><span class="line">    19.3  抽象层次与UML建模的关系</span><br><span class="line">  第20章  划分子系统的问题</span><br><span class="line">    20.1  面向对象的子系统问题</span><br><span class="line">    20.2  UC矩阵还适用吗</span><br><span class="line">    20.3  如何划分子系统</span><br><span class="line">  第21章  学会使用系统边界</span><br><span class="line">    21.1  边界是面向对象的保障</span><br><span class="line">    21.2  利用边界来分析需求</span><br><span class="line">    21.2.1  边界分析示例一</span><br><span class="line">    21.2.2  边界分析示例二</span><br><span class="line">    21.3  边界意识决定设计好坏</span><br><span class="line">  第22章  学会从接口认知事物</span><br><span class="line">    22.1  怎样描述一件事物</span><br><span class="line">    22.2  接口是系统的灵魂</span><br><span class="line">  第23章  学会正确选择</span><br><span class="line">    23.1  屁股决定脑袋——学会综合权衡</span><br><span class="line">    23.2  理辩则明——学会改变视角</span><br><span class="line">  第24章  学会使用设计模式</span><br><span class="line">    24.1  如何学习设计模式</span><br><span class="line">    24.2  如何使用设计模式</span><br><span class="line">附录  UML视图常用元素参考</span><br><span class="line">图目录</span><br><span class="line">表目录</span><br><span class="line">后记</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B007RSKFGM/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B007RSKFGM&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51cu8gm4duL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习MongoDB</title>
    <url>/2020/04/19/B007CLAQTU/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 深入学习MongoDB<br>作者信息： 作者: Kristina Chodorow [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《深入学习MongoDB》适合所有MongoDB用户阅读参考。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MongoDB扩展技术</span><br><span class="line">第1章 欢迎来到分布式计算的世界</span><br><span class="line">第2章 理解分片</span><br><span class="line">2.1 分割数据</span><br><span class="line">2.1.1 分配数据</span><br><span class="line">2.1.2 如何创建块</span><br><span class="line">2.2 平衡</span><br><span class="line">2.3 mongos</span><br><span class="line">2.4 配置服务器</span><br><span class="line">2.5 集群的构造</span><br><span class="line">第3章 建立集群</span><br><span class="line">3.1 选择片键</span><br><span class="line">3.1.1 小基数片键</span><br><span class="line">3.1.2 升序片键</span><br><span class="line">3.1.3 随机片键</span><br><span class="line">3.1.4 好片键</span><br><span class="line">3.2 新老集合分片</span><br><span class="line">3.2.1 快速起步</span><br><span class="line">3.2.2 配置服务器</span><br><span class="line">3.2.3 mongos</span><br><span class="line">3.2.4 分片</span><br><span class="line">3.2.5 数据库和集合</span><br><span class="line">3.3 增减容量</span><br><span class="line">3.3.1 移除分片</span><br><span class="line">3.3.2 修改分片中的服务器</span><br><span class="line">第4章 使用集群</span><br><span class="line">4.1 查询</span><br><span class="line">4.2 为什么会这样</span><br><span class="line">4.2.1 计数</span><br><span class="line">4.2.2 唯一索引</span><br><span class="line">4.2.3 更新</span><br><span class="line">4.3 MapReduce</span><br><span class="line">第5章 管理</span><br><span class="line">5.1 使用命令行</span><br><span class="line">5.1.1 了解概况</span><br><span class="line">5.1.2 配置集合</span><br><span class="line">5.1.3 应该连接什么</span><br><span class="line">5.2 监控</span><br><span class="line">5.2.1 mongostat</span><br><span class="line">5.2.2 Web管理界面</span><br><span class="line">5.3 备份</span><br><span class="line">5.4 关于架构的建议</span><br><span class="line">5.4.1 创建应急站点</span><br><span class="line">5.4.2 挖护城河</span><br><span class="line">5.5 错误处理</span><br><span class="line">5.5.1 分片停机</span><br><span class="line">5.5.2 多数分片停机</span><br><span class="line">5.5.3 配置服务器停机</span><br><span class="line">5.5.4 mongos进程死掉</span><br><span class="line">5.5.5 其他注意事项</span><br><span class="line">第6章 学习资源</span><br><span class="line">MongoDB开发技巧50例</span><br><span class="line">第1章 应用设计技巧</span><br><span class="line">1.1 技巧1：速度和完整性的折中</span><br><span class="line">1.1.1 示例：网上购物车</span><br><span class="line">1.1.2 考虑因素</span><br><span class="line">1.2 技巧2：适应未来的数据要范式化</span><br><span class="line">1.3 技巧3：尽量单个查询获取数据</span><br><span class="line">1.3.1 示例：博客</span><br><span class="line">1.3.2 示例：相册</span><br><span class="line">1.4 技巧4：嵌入关联数据</span><br><span class="line">1.5 技巧5：嵌入时间点数据</span><br><span class="line">1.6 技巧6：不要嵌入不断增加的数据</span><br><span class="line">1.7 技巧7：预填充数据</span><br><span class="line">1.8 技巧8：尽可能预先分配空间</span><br><span class="line">1.9 技巧9：用数组存放要匿名访问的内嵌数据 </span><br><span class="line">1.10 技巧10：文档要自给自足</span><br><span class="line">1.11 技巧11：优先使用$操作符</span><br><span class="line">1.11.1 深入了解</span><br><span class="line">1.11.2 提高性能</span><br><span class="line">1.12 技巧12：随时聚合</span><br><span class="line">1.13 技巧13：编写代码处理数据完整性问题</span><br><span class="line">第2章 实现技巧</span><br><span class="line">2.1 技巧14：使用正确的类型</span><br><span class="line">2.2 技巧15：用简单唯一的id替换id 2.3 技巧16：不要用文档做id</span><br><span class="line">2.4 技巧17：不要用数据库引用</span><br><span class="line">2.5 技巧18：不要用GridFS处理小的二进制数据 </span><br><span class="line">2.6 技巧19：处理“无缝”故障切换</span><br><span class="line">2.7 技巧20：处理复制组失效及故障恢复</span><br><span class="line">第3章 优化技巧</span><br><span class="line">3.1 技巧21：尽可能减少磁盘访问</span><br><span class="line">3.2 技巧22：使用索引减少内存占用</span><br><span class="line">3.3 技巧23：不要到处使用索引</span><br><span class="line">3.4 技巧24：索引覆盖查询</span><br><span class="line">3.5 技巧25：使用复合索引加快多个查询</span><br><span class="line">3.6 技巧26：通过建立分级文档加速扫描</span><br><span class="line">3.7 技巧27：AND型查询要点</span><br><span class="line">3.8 技巧28：OR型查询要点</span><br><span class="line">第4章 数据安全性和一致性 </span><br><span class="line">4.1 技巧29：单机做日志，多机则复制</span><br><span class="line">4.2 技巧30：坚持使用复制或日志，或两者兼用</span><br><span class="line">4.3 技巧31：不要信任repair恢复的数据</span><br><span class="line">4.4 技巧32：getlasterror</span><br><span class="line">4.5 技巧33：开发过程中一定要使用安全写入</span><br><span class="line">4.6 技巧34：使用w参数 </span><br><span class="line">4.7 技巧35：一定要给w设置超时 </span><br><span class="line">4.8 技巧36：不要每次写入都调用fsync</span><br><span class="line">4.9 技巧37：崩溃之后正常启动</span><br><span class="line">4.10 技巧38：持久性服务器的瞬时备份</span><br><span class="line">第5章 管理技巧</span><br><span class="line">5.1 技巧39：手工清理块集合</span><br><span class="line">5.2 技巧40：用repair压缩数据库</span><br><span class="line">5.3 技巧41：不要改变复制组成员投票的权值</span><br><span class="line">5.4 技巧42：无活跃节点时可重置复制组 </span><br><span class="line">5.5 技巧43：不必指定——shardsvr和——configsvr参数 </span><br><span class="line">5.6 技巧44：开发时才用——notablescan </span><br><span class="line">5.7 技巧45：学习JavaScript</span><br><span class="line">5.8 技巧46：在shell中管理所有服务器和数据库</span><br><span class="line">5.9 技巧47：获得帮助</span><br><span class="line">5.10 技巧48：创建启动文件</span><br><span class="line">5.11 技巧49：自定义函数</span><br><span class="line">5.12 技巧50：使用单个连接读取自身写入</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B007CLAQTU/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B007CLAQTU&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51CgH0ZlvQL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>七周七语言 理解多种编程范型</title>
    <url>/2020/04/19/B008041DUY/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 七周七语言 理解多种编程范型<br>作者信息： 作者: 泰特(Tate B.A.) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《7周7语言:理解多种编程范型》适合从事程序设计工作的人员阅读。Bruce A. Tate是软件行业的一名老兵，他有一个宏伟目标：用一本书的篇幅切中要害地探索七种不同的语言。《七周七语言：理解多种编程范型》就是他的成果。书中介绍了Ruby、Io、Prolog、Scala、Erlang、Cloiure和Haskell这七种语言。关注每一门语言的精髓和特性，重点解决如下问题：这门语言的类型模型是什么。编程范型是什么。如何与其交互。有哪些决策构造和核心数据结构，有哪些独特的核心特性。在这个飞速发展的信息时代。程序员仅仅掌握甚至精通一门语言是远远不够的。了解多门语言蕴涵的思维方式。在编码中互相借鉴。再挑出一两门对自己口味的语言深入学习，这些已经成为在软件行业中安身立命之本。从这个意义上说。每个程序员都应该看看这本《七周七语言》。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目　录 </span><br><span class="line"></span><br><span class="line"> 第1章　简介　1 1.1　不走寻常路　1 1.2　语言　2 1.3　谁应该买这本书　4 1.3.1　学会如何学习　4 1.3.2　乱世英雄　4 1.4　谁不应该买这本书　5 1.4.1　超越语法　5 1.4.2　不是安装指南　6 1.4.3　不是编程参考　6 1.4.4　严格督促　6 1.5　最后一击　7</span><br><span class="line"></span><br><span class="line"> 第2章　Ruby　8 2.1　Ruby简史　9 2.2　第一天：找个保姆　10 2.2.1　快速起步　10 2.2.2　从命令行执行Ruby　10 2.2.3　Ruby的编程模型　11 2.2.4　判断　12 2.2.5　鸭子类型　15 2.2.6　第一天我们学到了什么　16 2.2.7　第一天自习　16 2.3　第二天：从天而降　17 2.3.1　定义函数　17 2.3.2　数组　17 2.3.3　散列表　19 2.3.4　代码块和yield　20 2.3.5　定义类　22 2.3.6　编写Mixin　25 2.3.7　模块、可枚举和集合　26 2.3.8　第二天我们学到了什么　27 2.3.9　第二天自习　28 2.4　第三天：重大改变　28 2.4.1　打开类　29 2.4.2　使用method_missing　30 2.4.3　模块　31 2.4.4　第三天我们学到了什么　35 2.4.5　第三天自习　35 2.5　趁热打铁　35 2.5.1　核心优势　35 2.5.2　不足之处　37 2.5.3　最后思考　37</span><br><span class="line"></span><br><span class="line"> 第3章　Io　38 3.1　Io简介　38 3.2　第一天：逃学吧，轻松一下　39 3.2.1　开场白　39 3.2.2　对象、原型和继承　40 3.2.3　方法　43 3.2.4　列表和映射　44 3.2.5　true、false、nil以及单例　46 3.2.6　Steve Dekorte访谈录　48 3.2.7　第一天我们学到了什么　49 3.2.8　第一天自习　50 3.3　第二天：香肠大王　50 3.3.1　条件和循环　51 3.3.2　运算符　52 3.3.3　消息　54 3.3.4　反射　56 3.3.5　第二天我们学到了什么　57 3.3.6　第二天自习　57 3.4　第三天：花车游行和各种奇妙经历　58 3.4.1　领域特定语言　58 3.4.2　Io的method_missing　60 3.4.3　并发　62 3.4.4　第三天我们学到了什么　64 3.4.5　第三天自习　64 3.5　趁热打铁　65 3.5.1　核心优势　65 3.5.2　不足之处　66 3.5.3　最后思考　66</span><br><span class="line"></span><br><span class="line"> 第4章　Prolog　67 4.1　关于Prolog　68 4.2　第一天：一名优秀的司机　68 4.2.1　基本概况　68 4.2.2　基本推论和变量　69 4.2.3　填空　70 4.2.4　合一，第一部分　73 4.2.5　实际应用中的Prolog　75 4.2.6　第一天我们学到了什么　77 4.2.7　第一天自习　77 4.3　第二天：离瓦普纳法官开演还有15分钟　78 4.3.1　递归　78 4.3.2　列表和元组　79 4.3.3　列表与数学运算　82 4.3.4　在两个方向上使用规则　83 4.3.5　第二天我们学到了什么　86 4.3.6　第二天自习　87 4.4　第三天：维加斯的爆发　87 4.4.1　解决数独问题　87 4.4.2　八皇后问题　91 4.4.3　第三天我们学到了什么　96 4.4.4　第三天自习　96 4.5　趁热打铁　96 4.5.1　核心优势　97 4.5.2　不足之处　97 4.5.3　最后思考　98</span><br><span class="line"></span><br><span class="line"> 第5章　Scala　99 5.1　关于Scala　99 5.1.1　与Java的密切关系　100 5.1.2　没有盲目崇拜　100 5.1.3　Martin Odersky访谈录　100 5.1.4　函数式编程与并发　101 5.2　第一天：山丘上的城堡　102 5.2.1　Scala 类型　102 5.2.2　表达式与条件　103 5.2.3　循环　105 5.2.4　范围与元组　107 5.2.5　Scala中的类　109 5.2.6　扩展类　111 5.2.7　第一天我们学到了什么　113 5.2.8　第一天自习　114 5.3　第二天：修剪灌木丛和其他新把戏　114 5.3.1　对比var和val　115 5.3.2　集合　115 5.3.3　集合与函数　119 5.3.4　第二天我们都学到了什么　124 5.3.5　第二天自习　124 5.4　第三天：剪断绒毛　125 5.4.1　XML　125 5.4.2　模式匹配　126 5.4.3　并发　128 5.4.4　实际中的并发　129 5.4.5　第三天我们学到了什么　132 5.4.6　第三天自习　132 5.5　趁热打铁　133 5.5.1　核心优势　133 5.5.2　不足之处　134 5.5.3　最后思考　135</span><br><span class="line"></span><br><span class="line"> 第6章　Erlang　136 6.1　Erlang简介　136 6.1.1　为并发量身打造　137 6.1.2　Joe Armstrong博士访谈录　138 6.2　第一天：以常人面目出现　139 6.2.1　新手上路　140 6.2.2　注释、变量和表达式　140 6.2.3　原子、列表和元组　141 6.2.4　模式匹配　142 6.2.5　函数　144 6.2.6　第一天我们学到了什么　147 6.2.7　第一天自习　147 6.3　第二天：改变结构　148 6.3.1　控制结构　148 6.3.2　匿名函数　150 6.3.3　列表和高阶函数　150 6.3.4　列表的一些高级概念　153 6.3.5　第二天我们学到了什么　156 6.3.6　第二天自习　157 6.4　第三天： 红药丸　157 6.4.1　基本并发原语　157 6.4.2　同步消息　160 6.4.3　链接进程以获得可靠性　162 6.4.4　第三天我们学到了什么　167 6.4.5　第三天自习　167 6.5　趁热打铁　167 6.5.1　核心优势　168 6.5.2　不足之处　169 6.5.3　最后思考　169</span><br><span class="line"></span><br><span class="line"> 第7章　Clojure　170 7.1　Clojure入门　170 7.1.1　一切皆Lisp　170 7.1.2　JVM　171 7.1.3　为并发更新　171 7.2　第一天：训练Luke　172 7.2.1　调用基本函数　172 7.2.2　字符串和字符　174 7.2.3　布尔值和表达式　175 7.2.4　列表、映射表、集合以及向量　176 7.2.5　定义函数　179 7.2.6　绑定　180 7.2.7　匿名函数　182 7.2.8　Rich Hickey访谈录　183 7.2.9　第一天我们学到了什么　184 7.2.10　第一天自习　185 7.3　第二天：Yoda与原力　185 7.3.1　用loop和recur递归　185 7.3.2　序列　186 7.3.3　延迟计算　189 7.3.4　defrecord和protocol　191 7.3.5　宏　193 7.3.6　第二天我们学到了什么　194 7.3.7　第二天自习　195 7.4　第三天：一瞥魔鬼　195 7.4.1　引用和事务内存　196 7.4.2　使用原子　197 7.4.3　使用代理　198 7.4.4　future　200 7.4.5　还差什么　200 7.4.6　第三天我们学到了什么　201 7.4.7　第三天自习　201 7.5　趁热打铁　201 7.5.1　Lisp悖论　202 7.5.2　核心优势　202 7.5.3　不足之处　203 7.5.4　最后思考　204</span><br><span class="line"></span><br><span class="line"> 第8章　Haskell　205 8.1　Haskell简介　205 8.2　第一天：逻辑　206 8.2.1　表达式和基本类型　206 8.2.2　函数　208 8.2.3　元组和列表　211 8.2.4　生成列表　214 8.2.5　Philip Wadler访谈录　217 8.2.6　第一天我们学到了什么　218 8.2.7　第一天自习　218 8.3　第二天：Spock的超凡力量　218 8.3.1　高阶函数　219 8.3.2　偏应用函数和柯里化　220 8.3.3　惰性求值　221 8.3.4　Simon Peyton-Jones访谈录　223 8.3.5　第二天我们学到了什么　224 8.3.6　第二天自习　225 8.4　第三天：心灵融合　226 8.4.1　类与类型　226 8.4.2　monad　231 8.4.3　第三天我们学到了什么　236 8.4.4　第三天自习　237 8.5　趁热打铁　237 8.5.1　核心优势　237 8.5.2　不足之处　238 8.5.3　最后思考　239</span><br><span class="line"></span><br><span class="line"> 第9章　落幕时分　240 9.1　编程模型　240 9.1.1　面向对象(Ruby、Scala)　241 9.1.2　原型编程(Io)　241 9.1.3　约束-逻辑编程(Prolog)　241 9.1.4　函数式编程(Scala、Erlang、Clojure、Haskell)　241 9.1.5　范型演进之路　242 9.2　并发　242 9.2.1　控制可变状态　243 9.2.2　Io、Erlang和Scala中的actor　243 9.2.3　future　243 9.2.4　事务型内存　243 9.3　编程结构　244 9.3.1　列表解析　244 9.3.2　monad　244 9.3.3　匹配　245 9.3.4　合一　246 9.4　发现自己的旋律　246</span><br><span class="line"></span><br><span class="line"> 附录　参考书目　247</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B008041DUY/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B008041DUY&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51v-5pZf8cL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员的职业素养</title>
    <url>/2020/04/19/B0098NRHHY/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 程序员的职业素养<br>作者信息： 作者: Robert C.Martin [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《程序员的职业素养》是编程大师 Robert C. Martin40余年编程生涯的心得体会, 讲解成为真正专业的程序员需要什么样的态度、原则，需要采取什么样的行动。Robert C. Martin以自己以及身边的同事走过的弯路、犯过的错误为例，意在为后来人引路，助其职业生涯迈上更高台阶。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 专业主义</span><br><span class="line">1.1 清楚你要什么</span><br><span class="line">1.2 担当责任</span><br><span class="line">1.3 首先，不行损害之事</span><br><span class="line">1.3.1 不要破坏软件功能</span><br><span class="line">1.3.2 不要破坏结构</span><br><span class="line">1.4 职业道德</span><br><span class="line">1.4.1 了解你的领域</span><br><span class="line">1.4.2 坚持学习</span><br><span class="line">1.4.3 练习</span><br><span class="line">1.4.4 合作</span><br><span class="line">1.4.5 辅导</span><br><span class="line">1.4.6 了解业务领域</span><br><span class="line">1.4.7 与雇主&#x2F;客户保持一致</span><br><span class="line">1.4.8 谦逊</span><br><span class="line">1.5 参考文献</span><br><span class="line">第2章 说“不”</span><br><span class="line">2.1对抗角色</span><br><span class="line">2.2高风险时刻</span><br><span class="line">2.3要有团队精神</span><br><span class="line">2.3.1试试看</span><br><span class="line">2.3.2消极对抗</span><br><span class="line">2.4说“是”的成本</span><br><span class="line">2.5如何写出好代码</span><br><span class="line">第3章说“是”</span><br><span class="line">3.1承诺用语</span><br><span class="line">3.1.1识别“缺乏承诺”的征兆</span><br><span class="line">3.1.2真正的承诺听起来是怎样的</span><br><span class="line">3.1.3 总结</span><br><span class="line">3.2学习如何说“是”</span><br><span class="line">3.2.1 “试试”的另一面</span><br><span class="line">3.2.2 坚守原则</span><br><span class="line">3.3结论</span><br><span class="line">第4章编码</span><br><span class="line">4.1做好准备</span><br><span class="line">4.1.1 凌晨3点写出的代码</span><br><span class="line">4.1.2焦虑时写下的代码</span><br><span class="line">4.2流态区</span><br><span class="line">4.2.1 音乐</span><br><span class="line">4.2.2 中断</span><br><span class="line">4.3 阻塞</span><br><span class="line">4.4调试</span><br><span class="line">4.5保持节奏</span><br><span class="line">4.5.1知道何时应该离开一会</span><br><span class="line">4.5.2开车回家路上</span><br><span class="line">4.5.3 洗澡</span><br><span class="line">4.6进度延迟</span><br><span class="line">4.6.1期望</span><br><span class="line">4.6.2盲目冲刺</span><br><span class="line">4.6.3加班加点</span><br><span class="line">4.6.4交付失误</span><br><span class="line">4.6.5定义“完成”</span><br><span class="line">4.7帮助</span><br><span class="line">4.7.1帮助他人</span><br><span class="line">4.7.2接受他人的帮助</span><br><span class="line">4.7.3 辅导</span><br><span class="line">4.8参考文献</span><br><span class="line">第5章测试驱动开发</span><br><span class="line">5.1此事已有定论</span><br><span class="line">5.2 TDD的三项法则</span><br><span class="line">5.3 TDD的优势</span><br><span class="line">5.3.1 确定性</span><br><span class="line">5.3.2缺陷注入率</span><br><span class="line">5.3.3 勇气</span><br><span class="line">5.3.4 文档</span><br><span class="line">5.3.5设计</span><br><span class="line">5.3.6、专业人士的选择</span><br><span class="line">5.4 TDD的局限</span><br><span class="line">5.5参考文献</span><br><span class="line">第6章练习</span><br><span class="line">6.1 引子</span><br><span class="line">6.1.1 10的22次方</span><br><span class="line">6.1.2转变</span><br><span class="line">6.2编程柔道场</span><br><span class="line">6.2.1 卡塔</span><br><span class="line">6.2.2瓦萨</span><br><span class="line">6.2.3 自由练习</span><br><span class="line">6.3 自身经验的拓展</span><br><span class="line">6.3.1 开源</span><br><span class="line">6.3.2 关于练习的职业道德</span><br><span class="line">6.4结论</span><br><span class="line">6.5参考文献</span><br><span class="line">第7章验收测试</span><br><span class="line">7.1需求的沟通</span><br><span class="line">7.1.1过早精细化</span><br><span class="line">7.1.2迟来的模糊性</span><br><span class="line">7.2验收测试</span><br><span class="line">7.2.1 “完成”的定义</span><br><span class="line">7.2.2 沟通</span><br><span class="line">7.2.3 自动化</span><br><span class="line">7.2.4额外工作</span><br><span class="line">7.2.5验收测试什么时候写，由谁来写</span><br><span class="line">7.2.6开发人员的角色</span><br><span class="line">7.2.7测试的协商与被动推进</span><br><span class="line">7.2.8验收测试和单元测试</span><br><span class="line">7.2.9 图形界面及其他复杂因素</span><br><span class="line">7.2.10持续集成</span><br><span class="line">7.3结论</span><br><span class="line">第8章测试策略</span><br><span class="line">8.1 QA应该找不到任何错误</span><br><span class="line">8.1.1 QA也是团队的一部分</span><br><span class="line">8.1.2需求规约定义者</span><br><span class="line">8.1.3特性描述者</span><br><span class="line">8.2自动化测试金字塔</span><br><span class="line">8.2.1 单元测试</span><br><span class="line">8.2.2组件测试</span><br><span class="line">8.2.3集成测试</span><br><span class="line">8.2.4 系统溺4试</span><br><span class="line">8.2.5人工探索式测试</span><br><span class="line">8.3结论</span><br><span class="line">8.4参考文献</span><br><span class="line">第9章时间管理</span><br><span class="line">9.1 会议</span><br><span class="line">9.1.1拒绝</span><br><span class="line">9.1.2 离席</span><br><span class="line">9.1.3确定议程与目标</span><br><span class="line">9.1.4立会</span><br><span class="line">9.1.5迭代计划会议</span><br><span class="line">9.1.6迭代回顾和DEM0展示</span><br><span class="line">9.1.7争论&#x2F;反对</span><br><span class="line">9.2注意力点数</span><br><span class="line">9.2.1 睡眠</span><br><span class="line">9.2.2咖啡因</span><br><span class="line">9.2.3恢复</span><br><span class="line">9.2.4肌肉注意力</span><br><span class="line">……</span><br><span class="line">第10章 预估</span><br><span class="line">第11章 压力</span><br><span class="line">第12章 协作</span><br><span class="line">第13章 团队与项目</span><br><span class="line">第14章 辅导、学徒期与技艺</span><br><span class="line">附录 工具</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0098NRHHY/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0098NRHHY&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51S1GaiY0DL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>职场</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏改变世界 游戏化如何让现实变得更美好</title>
    <url>/2020/04/19/B008FTJ2CK/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 游戏改变世界 游戏化如何让现实变得更美好<br>作者信息： 作者: 简•麦戈尼格尔 (Jane McGonigal) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《游戏改变世界:游戏化如何让现实变得更美好》作者简•麦戈尼格尔是著名未来学家，世界顶级未来趋势智库“未来学会”游戏研发总监，被《商业周刊》誉为“十大最重要创新人士之一”，被《快公司》誉为“全球百位创意商业人士之一”，被脱口秀女王奥普拉誉为“全球最令人惊叹的20位女性之一”，她的观点被《哈佛商业评论》誉为“最具突破性的观念”。简•麦戈尼格尔是TED大会新锐演讲者，受关注度超过比尔•盖茨，位居第16位；纽约客大会特邀演讲人，游戏开发者大会主讲人。《游戏改变世界:游戏化如何让现实变得更美好》首次探索了游戏化的力量，权威揭示了互联时代的未来趋势，颠覆了普通人对游戏的一切认知。游戏不是小孩子的玩意儿，不是时间杀手，不是让人自闭、上瘾、丧失活力的毒品，而是解决现实问题、改善生活质量、创造美好未来的利器。作者在书中指出：游戏可以弥补现实世界的不足和缺陷，重塑人类积极的未来。未来属于能够理解、设计并会玩游戏的那些人，而如果人们继续忽视游戏，就会错失良机、失去未来。《纽约时报》超级畅销书，全球50位最具影响力商业思想家之一、著名趋势专家、畅销书《驱动力》《全新思维》作者丹尼尔•平克，积极心理学之父、畅销书《真实的幸福》作者马丁•塞利格曼倾情推荐！知名IT评论人谢文、银海资本合伙人王煜全、顽石WiStone CEO吴刚、触控科技CocoaChina总经理陈昊芝、资深媒体人罗振宇、NTA创新传播机构创始人申音、知名经理人社会观察家王冠雄、i黑马联合发起人龙真重磅推荐！</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">引言 游戏，通往未来的线索 </span><br><span class="line"></span><br><span class="line"> 第一部分 游戏化，互联时代的重要趋势 第1章 提升人的幸福感 游戏是我们集中精力的大好机会，我们乐观向上地做着一件自己擅长并享受的事情。所有优秀的游戏都是艰苦工作。它是我们主动选择且享受其中的艰苦工作。而当我们从事自己喜欢的艰苦工作时，就点燃了头脑里的那根快乐雷管。 第2章 构建更美好的现实社会 游戏是最显而易见的心流来源，玩耍是出类拔萃的心流体验。自我激励、自我奖励的活动能让我们更幸福。更重要的是，它还证明，玩家玩游戏，并不是为了逃避现实生活。他们是在主动让现实生活变得更有价值。</span><br><span class="line"></span><br><span class="line"> 第二部分 游戏化的4大目标 第3章 更满意的工作 精心设计的游戏工作让人觉得更有生产力，因为它感觉起来更真实：反馈来得又强又快，影响明显而生动。对很多不喜欢自己的日常工作、觉得它没有什么直接影响的人而言，游戏里的工作提供了真正的奖励和满足感。 第4章 更有把握的成功 胜利往往终结乐趣，而失败维持乐趣。只要我们的失败有趣，我们就会继续尝试，并保持最终成功的希望。如果我们能为失败所激发，说不定能坚持更长时间，做更艰巨的工作，处理更复杂的挑战。成功的希望比成功本身更刺激。 第5章 更强的社会联系 我们越是更多地一起玩游戏，越是会产生有意识地创造全球社群的感觉。玩家并不只是想在游戏里赢，他们还肩负着更大的使命。他们的使命，就是成为宏伟事业的一部分。 第6章 更宏大的意义 要体验真正的意义，不必贡献出真正有价值的东西，必须得到做出贡献的机会。为生活增加意义的最佳途径，就是把自己的日常行动与一个宏伟的目标联系起来，我们需要机会来反映这一共同事业的宏伟规模。</span><br><span class="line"></span><br><span class="line"> 第三部分 游戏化的运作机制 第7章 全情投入当下：游戏化的参与机制 平行实境游戏不是为了逃避现实，而是为了从现实中得到更多。它让我们在不能或不愿进入虚拟环境时，也能轻松地产生我们渴望的内在奖励。它让我们不仅全情投入游戏生活，更全情投入现实生活。 第8章 实时反馈：游戏化的激励机制 玩家之所以能把几乎每一款游戏都越玩越好，是因为他们能够得到持续的反馈。这种瞬时的积极反馈让玩家更加努力，更成功地完成艰巨的挑战。把我们本来就喜欢的事情变得更像游戏值得一试，它能让我们做得更好，让我们把目光放得更为高远。 第9章 和陌生人结盟，创造更强大的社群：游戏化的团队机制 游戏把一群人的注意力集中在共同的目标上，它提醒我们：我们其实真心愿意与最陌生的陌生人分享。只要我们愿意，只要我们需要，就能够和别人建立关系。人再也没有理由在这个世上感到孤独，不管是在虚拟世界，还是在现实世界。 第10章 让幸福成为一种习惯：游戏化的持续性 不能让幸福知道我们来了，只能偷偷摸摸地从侧面包抄。少数强烈而令人难忘的幸福黑客活动体验，能扭转我们对事情的想法和做法。好的游戏具有强大的力量，能永远地改变你看待自己和自身能力的方式。</span><br><span class="line"></span><br><span class="line"> 第四部分 游戏化带给互联时代的现实价值 第11章 可持续参与式经济 在参与式经济中，我们竞争的不是“眼球”或“头脑份额”，而是脑力循环和心情份额。成功只能依靠进行更好、更具竞争力的动员，激励我们朝着集体目标做得更多、做得更久。而游戏能激发极端的努力，创建坚持到底、一起完成奇迹事业的社群。积极的情绪是参与带来的终极奖励。 第12章 伟大的人人时代 有人以为普通人在业余时间办不成什么大事，而游戏则帮助我们颠覆了他们的认识。我们是能够接触他人的人类，我们能够出现在他人的生活中，并为其带去不同。我们拥有社会力量，我们可以驾驭它们。社会参与游戏把我们变成了现实生活里的超级英雄。 第13章 认知盈余的红利 每一个玩了10000个小时游戏的年轻人，日后都能在游戏环境下实现非凡的成功。多人和在线游戏加强了我们建立、锻炼共享意向的能力。每当我们答应一起玩游戏，就是在实践人之为人的一项基本天赋。 第14章 超级合作者 游戏最有把握成为地球生命的下一种突破性结构。成为人类以来，我们几乎一直在玩各种精彩的游戏。团结一心，我们可以攻克一个兴许是最值得尝试、规模也最为庞大的障碍：利用游戏提高全球生活质量，为未来做好准备，让地球顺利进入下一个千年的全球性使命。</span><br><span class="line"></span><br><span class="line"> 结语 游戏化，重塑人类的文明</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B008FTJ2CK/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B008FTJ2CK&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51v4xEjNgmL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop实战(第2版)</title>
    <url>/2020/04/19/B009X25AI8/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Hadoop实战(第2版)<br>作者信息： 作者: 陆嘉恒 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Hadoop实战(第2版)》编辑推荐：第1版广受好评，第2版基于Hadoop及其相关技术最新版本撰写，从多角度做了全面的修订和补充。不仅详细讲解了新一代的Hadoop技术，而且全面介绍了Hive、HBase、Mahout、Pig、ZooKeeper、Avro、Chukwa等重要技术，是系统学习Hadoop技术的首选之作。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">第1章Hadoop简介1</span><br><span class="line">1.1什么是Hadoop2</span><br><span class="line">1.1.1Hadoop概述2</span><br><span class="line">1.1.2Hadoop的历史2</span><br><span class="line">1.1.3Hadoop的功能与作用2</span><br><span class="line">1.1.4Hadoop的优势3</span><br><span class="line">1.1.5Hadoop应用现状和发展趋势3</span><br><span class="line">1.2Hadoop项目及其结构3</span><br><span class="line">1.3Hadoop体系结构6</span><br><span class="line">1.4Hadoop与分布式开发7</span><br><span class="line">1.5Hadoop计算模型—MapReduce10</span><br><span class="line">1.6Hadoop数据管理10</span><br><span class="line">1.6.1HDFS的数据管理10</span><br><span class="line">1.6.2HBase的数据管理12</span><br><span class="line">1.6.3Hive的数据管理13</span><br><span class="line">1.7Hadoop集群安全策略15</span><br><span class="line">1.8本章小结17</span><br><span class="line">第2章Hadoop的安装与配置19</span><br><span class="line">2.1在Linux上安装与配置Hadoop20</span><br><span class="line">2.1.1安装JDK1.620</span><br><span class="line">2.1.2配置SSH免密码登录21</span><br><span class="line">2.1.3安装并运行Hadoop22</span><br><span class="line">2.2在MacOSX上安装与配置Hadoop24</span><br><span class="line">2.2.1安装Homebrew24</span><br><span class="line">2.2.2使用Homebrew安装Hadoop25</span><br><span class="line">2.2.3配置SSH和使用Hadoop25</span><br><span class="line">2.3在Windows上安装与配置Hadoop25</span><br><span class="line">2.3.1安装JDK1.6或更高版本25</span><br><span class="line">2.3.2安装Cygwin25</span><br><span class="line">2.3.3配置环境变量26</span><br><span class="line">2.3.4安装sshd服务26</span><br><span class="line">2.3.5启动sshd服务26</span><br><span class="line">2.3.6配置SSH免密码登录26</span><br><span class="line">2.3.7安装并运行Hadoop26</span><br><span class="line">2.4安装和配置Hadoop集群27</span><br><span class="line">2.4.1网络拓扑27</span><br><span class="line">2.4.2定义集群拓扑27</span><br><span class="line">2.4.3建立和安装Cluster28</span><br><span class="line">2.5日志分析及几个小技巧34</span><br><span class="line">2.6本章小结35</span><br><span class="line">第3章MapReduce计算模型36</span><br><span class="line">3.1为什么要用MapReduce37</span><br><span class="line">3.2MapReduce计算模型38</span><br><span class="line">3.2.1MapReduceJob38</span><br><span class="line">3.2.2Hadoop中的HelloWorld程序38</span><br><span class="line">3.2.3MapReduce的数据流和控制流46</span><br><span class="line">3.3MapReduce任务的优化47</span><br><span class="line">3.4Hadoop流49</span><br><span class="line">3.4.1Hadoop流的工作原理50</span><br><span class="line">3.4.2Hadoop流的命令51</span><br><span class="line">3.4.3两个例子52</span><br><span class="line">3.5HadoopPipes54</span><br><span class="line">3.6本章小结56</span><br><span class="line">第4章开发MapReduce应用程序57</span><br><span class="line">4.1系统参数的配置58</span><br><span class="line">4.2配置开发环境60</span><br><span class="line">4.3编写MapReduce程序60</span><br><span class="line">4.3.1Map处理60</span><br><span class="line">4.3.2Reduce处理61</span><br><span class="line">4.4本地测试62</span><br><span class="line">4.5运行MapReduce程序62</span><br><span class="line">4.5.1打包64</span><br><span class="line">4.5.2在本地模式下运行64</span><br><span class="line">4.5.3在集群上运行64</span><br><span class="line">4.6网络用户界面65</span><br><span class="line">4.6.1JobTracker页面65</span><br><span class="line">4.6.2工作页面65</span><br><span class="line">4.6.3返回结果66</span><br><span class="line">4.6.4任务页面67</span><br><span class="line">4.6.5任务细节页面67</span><br><span class="line">4.7性能调优68</span><br><span class="line">4.7.1输入采用大文件68</span><br><span class="line">4.7.2压缩文件68</span><br><span class="line">4.7.3过滤数据69</span><br><span class="line">4.7.4修改作业属性71</span><br><span class="line">4.8MapReduce工作流72</span><br><span class="line">4.8.1复杂的Map和Reduce函数72</span><br><span class="line">4.8.2MapReduceJob中全局共享数据74</span><br><span class="line">4.8.3链接MapReduceJob75</span><br><span class="line">4.9本章小结77</span><br><span class="line">第5章MapReduce应用案例79</span><br><span class="line">5.1单词计数80</span><br><span class="line">5.1.1实例描述80</span><br><span class="line">5.1.2设计思路80</span><br><span class="line">5.1.3程序代码81</span><br><span class="line">5.1.4代码解读82</span><br><span class="line">5.1.5程序执行83</span><br><span class="line">5.1.6代码结果83</span><br><span class="line">5.1.7代码数据流84</span><br><span class="line">5.2数据去重85</span><br><span class="line">5.2.1实例描述85</span><br><span class="line">5.2.2设计思路86</span><br><span class="line">5.2.3程序代码86</span><br><span class="line">5.3排序87</span><br><span class="line">5.3.1实例描述87</span><br><span class="line">5.3.2设计思路88</span><br><span class="line">5.3.3程序代码89</span><br><span class="line">5.4单表关联91</span><br><span class="line">5.4.1实例描述91</span><br><span class="line">5.4.2设计思路92</span><br><span class="line">5.4.3程序代码92</span><br><span class="line">5.5多表关联95</span><br><span class="line">5.5.1实例描述95</span><br><span class="line">5.5.2设计思路96</span><br><span class="line">5.5.3程序代码96</span><br><span class="line">5.6本章小结98</span><br><span class="line">第6章MapReduce工作机制99</span><br><span class="line">6.1MapReduce作业的执行流程100</span><br><span class="line">6.1.1MapReduce任务执行总流程100</span><br><span class="line">6.1.2提交作业101</span><br><span class="line">6.1.3初始化作业103</span><br><span class="line">6.1.4分配任务104</span><br><span class="line">6.1.5执行任务106</span><br><span class="line">6.1.6更新任务执行进度和状态107</span><br><span class="line">6.1.7完成作业108</span><br><span class="line">6.2错误处理机制108</span><br><span class="line">6.2.1硬件故障109</span><br><span class="line">6.2.2任务失败109</span><br><span class="line">6.3作业调度机制110</span><br><span class="line">6.4Shuffle和排序111</span><br><span class="line">6.4.1Map端111</span><br><span class="line">6.4.2Reduce端113</span><br><span class="line">6.4.3shuffle过程的优化114</span><br><span class="line">6.5任务执行114</span><br><span class="line">6.5.1推测式执行114</span><br><span class="line">6.5.2任务JVM重用115</span><br><span class="line">6.5.3跳过坏记录115</span><br><span class="line">6.5.4任务执行环境116</span><br><span class="line">6.6本章小结117</span><br><span class="line">第7章HadoopIO操作118</span><br><span class="line">7.1IO操作中的数据检查119</span><br><span class="line">7.2数据的压缩126</span><br><span class="line">7.2.1Hadoop对压缩工具的选择126</span><br><span class="line">7.2.2压缩分割和输入分割127</span><br><span class="line">7.2.3在MapReduce程序中使用压缩127</span><br><span class="line">7.3数据的IO中序列化操作128</span><br><span class="line">7.3.1Writable类128</span><br><span class="line">7.3.2实现自己的Hadoop数据类型137</span><br><span class="line">7.4针对Mapreduce的文件类139</span><br><span class="line">7.4.1SequenceFile类139</span><br><span class="line">7.4.2MapFile类144</span><br><span class="line">7.4.3ArrayFile、SetFile和BloomMapFile146</span><br><span class="line">7.5本章小结148</span><br><span class="line">第8章下一代MapReduce：YARN149</span><br><span class="line">8.1MapReduceV2设计需求150</span><br><span class="line">8.2MapReduceV2主要思想和架构151</span><br><span class="line">8.3MapReduceV2设计细节153</span><br><span class="line">8.4MapReduceV2优势156</span><br><span class="line">8.5本章小结156</span><br><span class="line">第9章HDFS详解157</span><br><span class="line">9.1Hadoop的文件系统158</span><br><span class="line">9.2HDFS简介160</span><br><span class="line">9.3HDFS体系结构161</span><br><span class="line">9.3.1HDFS的相关概念161</span><br><span class="line">9.3.2HDFS的体系结构162</span><br><span class="line">9.4HDFS的基本操作164</span><br><span class="line">9.4.1HDFS的命令行操作164</span><br><span class="line">9.4.2HDFS的Web界面165</span><br><span class="line">9.5HDFS常用JavaAPI详解166</span><br><span class="line">9.5.1使用HadoopURL读取数据166</span><br><span class="line">9.5.2使用FileSystemAPI读取数据167</span><br><span class="line">9.5.3创建目录169</span><br><span class="line">9.5.4写数据169</span><br><span class="line">9.5.5删除数据171</span><br><span class="line">9.5.6文件系统查询171</span><br><span class="line">9.6HDFS中的读写数据流175</span><br><span class="line">9.6.1文件的读取175</span><br><span class="line">9.6.2文件的写入176</span><br><span class="line">9.6.3一致性模型178</span><br><span class="line">9.7HDFS命令详解179</span><br><span class="line">9.7.1通过distcp进行并行复制179</span><br><span class="line">9.7.2HDFS的平衡180</span><br><span class="line">9.7.3使用Hadoop归档文件180</span><br><span class="line">9.7.4其他命令183</span><br><span class="line">9.8WebHDFS186</span><br><span class="line">9.8.1WebHDFS的配置186</span><br><span class="line">9.8.2WebHDFS命令186</span><br><span class="line">9.9本章小结190</span><br><span class="line">第10章Hadoop的管理191</span><br><span class="line">10.1HDFS文件结构192</span><br><span class="line">10.2Hadoop的状态监视和管理工具196</span><br><span class="line">10.2.1审计日志196</span><br><span class="line">10.2.2监控日志196</span><br><span class="line">10.2.3Metrics197</span><br><span class="line">10.2.4Java管理扩展199</span><br><span class="line">10.2.5Ganglia200</span><br><span class="line">10.2.6Hadoop管理命令202</span><br><span class="line">10.3Hadoop集群的维护206</span><br><span class="line">10.3.1安全模式206</span><br><span class="line">10.3.2Hadoop的备份207</span><br><span class="line">10.3.3Hadoop的节点管理208</span><br><span class="line">10.3.4系统升级210</span><br><span class="line">10.4本章小结212</span><br><span class="line">第11章Hive详解213</span><br><span class="line">11.1Hive简介214</span><br><span class="line">11.1.1Hive的数据存储214</span><br><span class="line">11.1.2Hive的元数据存储216</span><br><span class="line">11.2Hive的基本操作216</span><br><span class="line">11.2.1在集群上安装Hive216</span><br><span class="line">11.2.2配置MySQL存储Hive元数据218</span><br><span class="line">11.2.3配置Hive220</span><br><span class="line">11.3HiveQL详解221</span><br><span class="line">11.3.1数据定义（DDL）操作221</span><br><span class="line">11.3.2数据操作（DML）231</span><br><span class="line">11.3.3SQL操作233</span><br><span class="line">11.3.4HiveQL使用实例235</span><br><span class="line">11.4Hive网络（WebUI）接口237</span><br><span class="line">11.4.1Hive网络接口配置237</span><br><span class="line">11.4.2Hive网络接口操作实例238</span><br><span class="line">11.5Hive的JDBC接口241</span><br><span class="line">11.5.1Eclipse环境配置241</span><br><span class="line">11.5.2程序实例241</span><br><span class="line">11.6Hive的优化244</span><br><span class="line">11.7本章小结246</span><br><span class="line">第12章HBase详解247</span><br><span class="line">12.1HBase简介248</span><br><span class="line">12.2HBase的基本操作249</span><br><span class="line">12.2.1HBase的安装249</span><br><span class="line">12.2.2运行HBase253</span><br><span class="line">12.2.3HBaseShell255</span><br><span class="line">12.2.4HBase配置258</span><br><span class="line">12.3HBase体系结构260</span><br><span class="line">12.3.1HRegion260</span><br><span class="line">12.3.2HRegion服务器261</span><br><span class="line">12.3.3HBaseMaster服务器262</span><br><span class="line">12.3.4ROOT表和META表262</span><br><span class="line">12.3.5ZooKeeper263</span><br><span class="line">12.4HBase数据模型263</span><br><span class="line">12.4.1数据模型263</span><br><span class="line">12.4.2概念视图264</span><br><span class="line">12.4.3物理视图264</span><br><span class="line">12.5HBase与RDBMS265</span><br><span class="line">12.6HBase与HDFS266</span><br><span class="line">12.7HBase客户端266</span><br><span class="line">12.8JavaAPI267</span><br><span class="line">12.9HBase编程273</span><br><span class="line">12.9.1使用Eclipse开发HBase应用程序273</span><br><span class="line">12.9.2HBase编程275</span><br><span class="line">12.9.3HBase与MapReduce278</span><br><span class="line">12.10模式设计280</span><br><span class="line">12.10.1模式设计应遵循的原则280</span><br><span class="line">12.10.2学生表281</span><br><span class="line">12.10.3事件表282</span><br><span class="line">12.11本章小结283</span><br><span class="line">第13章Mahout详解284</span><br><span class="line">13.1Mahout简介285</span><br><span class="line">13.2Mahout的安装和配置285</span><br><span class="line">13.3MahoutAPI简介288</span><br><span class="line">13.4Mahout中的频繁模式挖掘290</span><br><span class="line">13.4.1什么是频繁模式挖掘290</span><br><span class="line">13.4.2Mahout中的频繁模式挖掘290</span><br><span class="line">13.5Mahout中的聚类和分类292</span><br><span class="line">13.5.1什么是聚类和分类292</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B009X25AI8/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B009X25AI8&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41T3S9xNdXL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>谁说菜鸟不会数据分析(入门篇)(全彩)</title>
    <url>/2020/04/19/B00AAHWURE/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 谁说菜鸟不会数据分析(入门篇)(全彩)<br>作者信息： 作者: 张文霖 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《谁说菜鸟不会数据分析(入门篇)(升级版)》有足够的魅力让你一口气读下去，在无形之中掌握数据分析的技能，提升职场竞争能力。这是一本有趣的数据分析书！</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 数据分析那些事儿</span><br><span class="line">1.1 数据分析是“神马”／14</span><br><span class="line">1.1.1 何谓数据分析／15</span><br><span class="line">1.1.2 数据分析的作用／16</span><br><span class="line">1.2 数据分析六步曲／17</span><br><span class="line">1.2.1 明确分析目的和思路／18</span><br><span class="line">1.2.2 数据收集／20</span><br><span class="line">1.2.3 数据处理／21</span><br><span class="line">1.2.4 数据分析／21</span><br><span class="line">1.2.5 数据展现／22</span><br><span class="line">1.2.6 报告撰写／23</span><br><span class="line">1.3 数据分析的三大误区／24</span><br><span class="line">1.4 数据分析师的职业发展／25</span><br><span class="line">1.4.1 数据分析的广阔前景／25</span><br><span class="line">1.4.2 数据分析师的职业要求／27</span><br><span class="line">1.4.3 数据分析师的基本素质／28</span><br><span class="line">1.5 几个常用指标和术语／32</span><br><span class="line">1.6 本章小结／36</span><br><span class="line">第2章 结构为王——确定分析思路</span><br><span class="line">2.1 数据分析方法论／38</span><br><span class="line">2.1.1 数据分析方法论与数据分析法的区别／38</span><br><span class="line">2.1.2 数据分析方法论的重要性／39</span><br><span class="line">2.2 常用的数据分析方法论／40</span><br><span class="line">2.2.1 PEST分析法／40</span><br><span class="line">2.2.2 5W2H分析法／43</span><br><span class="line">2.2.3 逻辑树分析法／44</span><br><span class="line">2.2.4 4P营销理论／45</span><br><span class="line">2.2.5 用户行为理论／47</span><br><span class="line">2.3 本章小结／48</span><br><span class="line">第3章 无米难为巧妇——数据准备</span><br><span class="line">3.1 理解数据／50</span><br><span class="line">3.1.1 字段与记录／51</span><br><span class="line">3.1.2 数据类型／52</span><br><span class="line">3.1.3 数据表／53</span><br><span class="line">3.2 数据来源／57</span><br><span class="line">3.2.1 导入数据／57</span><br><span class="line">3.2.2 问卷录入要求／63</span><br><span class="line">3.3 本章小结／65</span><br><span class="line">第4章 三心二意——数据处理</span><br><span class="line">4.1 何为数据处理／67</span><br><span class="line">4.1.1 “三心二意”处理数据／67</span><br><span class="line">4.1.2 数据处理的内容／69</span><br><span class="line">4.2 数据清洗／70</span><br><span class="line">4.2.1 重复数据的处理／71</span><br><span class="line">4.2.2 缺失数据处理／76</span><br><span class="line">4.2.3 检查数据逻辑错误／80</span><br><span class="line">4.3 数据加工／82</span><br><span class="line">4.3.1 数据抽取／82</span><br><span class="line">4.3.2 数据计算／87</span><br><span class="line">4.3.3 数据分组／91</span><br><span class="line">4.3.4 数据转换／92</span><br><span class="line">4.4 数据抽样／97</span><br><span class="line">4.5 本章小结／98</span><br><span class="line">第5章 工欲善其事必先利其器——数据分析</span><br><span class="line">5.1 数据分析方法／101</span><br><span class="line">5.1.1 对比分析法／102</span><br><span class="line">5.1.2 分组分析法／105</span><br><span class="line">5.1.3 结构分析法／106</span><br><span class="line">5.1.4 平均分析法／107</span><br><span class="line">5.1.5 交叉分析法／108</span><br><span class="line">5.1.6 综合评价分析法／109</span><br><span class="line">5.1.7 杜邦分析法／113</span><br><span class="line">5.1.8 漏斗图分析法／114</span><br><span class="line">5.1.9 矩阵关联分析法／115</span><br><span class="line">5.1.10 高级数据分析方法／120</span><br><span class="line">5.2 数据分析工具／121</span><br><span class="line">5.2.1 初识数据透视表／121</span><br><span class="line">5.2.2 创建数据透视表的三步法／122</span><br><span class="line">5.2.3 数据透视表分析实践／124</span><br><span class="line">5.2.4 数据透视表小技巧／130</span><br><span class="line">5.2.5 多选题分析／132</span><br><span class="line">5.3 本章小结／135</span><br><span class="line">第6章 给数据量体裁衣——数据展现</span><br><span class="line">6.1 揭开图表的真面目／138</span><br><span class="line">6.1.1 图表的作用／138</span><br><span class="line">6.1.2 经济适用图表有哪些／139</span><br><span class="line">6.1.3 通过关系选择图表／140</span><br><span class="line">6.1.4 图表制作五步法／145</span><br><span class="line">6.2 表格也疯狂／146</span><br><span class="line">6.2.1 突出显示单元格／146</span><br><span class="line">6.2.2 项目选取／147</span><br><span class="line">6.2.3 数据条／148</span><br><span class="line">6.2.4 图标集／149</span><br><span class="line">6.2.5 迷你图／150</span><br><span class="line">6.3 给图表换装／151</span><br><span class="line">6.3.1 平均线图／152</span><br><span class="line">6.3.2 双坐标图／153</span><br><span class="line">6.3.3 竖形折线图／156</span><br><span class="line">6.3.4 瀑布图／159</span><br><span class="line">6.3.5 帕累托图／160</span><br><span class="line">6.3.6 旋风图／165</span><br><span class="line">6.3.7 人口金字塔图／169</span><br><span class="line">6.3.8 漏斗图／171</span><br><span class="line">6.3.9 矩阵图（散点图）／173</span><br><span class="line">6.3.10 发展矩阵图／176</span><br><span class="line">6.3.11 改进难易矩阵（气泡图）／178</span><br><span class="line">6.4 本章小结／180</span><br><span class="line">第7章 专业化生存——图表可以更美的</span><br><span class="line">7.1 别让图表犯错／183</span><br><span class="line">7.1.1 让图表“五脏俱全”／183</span><br><span class="line">7.1.2 要注意的条条框框／185</span><br><span class="line">7.1.3 图表会说谎／196</span><br><span class="line">7.2 浓妆淡抹总相宜——图表美化／200</span><br><span class="line">7.2.1 图表美化的三原则／200</span><br><span class="line">7.2.2 略施粉黛——美化图表的技巧／203</span><br><span class="line">7.2.3 图表也好“色”／209</span><br><span class="line">7.3 如虎添翼的招儿／213</span><br><span class="line">7.3.1 我的图表模板／214</span><br><span class="line">7.3.2 快速制图／215</span><br><span class="line">7.3.3 添加标签小工具／216</span><br><span class="line">7.3.4 修剪超大值／218</span><br><span class="line">7.4 本章小结／220</span><br><span class="line">第8章 专业的报告——体现你的职场价值</span><br><span class="line">8.1 初识数据分析报告／222</span><br><span class="line">8.1.1 数据分析报告是什么／222</span><br><span class="line">8.1.2 数据分析报告的写作原则／222</span><br><span class="line">8.1.3 数据分析报告的作用／224</span><br><span class="line">8.1.4 数据分析报告的种类／225</span><br><span class="line">8.2 数据分析报告的结构／228</span><br><span class="line">8.2.1 标题页／228</span><br><span class="line">8.2.2 目录／230</span><br><span class="line">8.2.3 前言／231</span><br><span class="line">8.2.4 正文／233</span><br><span class="line">8.2.5 结论与建议／234</span><br><span class="line">8.2.6 附录／234</span><br><span class="line">8.3 撰写报告时的注意事项／235</span><br><span class="line">8.4 报告范例／236</span><br><span class="line">8.5 本章小结／244</span><br><span class="line">写在后面的Q／A</span><br><span class="line">附录A网络学习资源</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00AAHWURE/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00AAHWURE&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41rQ0U-afqL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>重构与模式(修订版)</title>
    <url>/2020/04/19/B00A9YD7A2/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 重构与模式(修订版)<br>作者信息： 作者: Joshua Kerievsky [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>讲述重构与设计模式两大热门技术，将两者有机结合，极具实战价值，业界专家学习和教授重构与模式亲身经历的结晶，《设计模式》作者Erich Gamma、Ralph Johnson和《重构》作者Martin Fowler联合推荐。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 本书的写作缘由 1</span><br><span class="line">1.1 过度设计 1</span><br><span class="line">1.2 模式万灵丹 2</span><br><span class="line">1.3 设计不足 2</span><br><span class="line">1.4 测试驱动开发和持续重构 3</span><br><span class="line">1.5 重构与模式 5</span><br><span class="line">1.6 演进式设计 6</span><br><span class="line">第2章 重构 7</span><br><span class="line">2.1 何谓重构 7</span><br><span class="line">2.2 重构的动机 8</span><br><span class="line">2.3 众目睽睽 9</span><br><span class="line">2.4 可读性好的代码 10</span><br><span class="line">2.5 保持清晰 11</span><br><span class="line">2.6 循序渐进 11</span><br><span class="line">2.7 设计欠账 12</span><br><span class="line">2.8 演变出新的架构 13</span><br><span class="line">2.9 复合重构与测试驱动的重构 13</span><br><span class="line">2.10 复合重构的优点 15</span><br><span class="line">2.11 重构工具 15</span><br><span class="line">第3章 模式 17</span><br><span class="line">3.1 何谓模式 17</span><br><span class="line">3.2 模式痴迷 18</span><br><span class="line">3.3 实现模式的方式不止一种 20</span><br><span class="line">3.4 通过重构实现、趋向和去除模式 22</span><br><span class="line">3.5 模式是否会使代码更加复杂 24</span><br><span class="line">3.6 模式知识 25</span><br><span class="line">3.7 使用模式的预先设计 26</span><br><span class="line">第4章 代码坏味 28</span><br><span class="line">4.1 重复代码（DuplicatedCode） 30</span><br><span class="line">4.2 过长函数（LongMethod） 30</span><br><span class="line">4.3 条件逻辑太复杂（ConditionalComplexity） 31</span><br><span class="line">4.4 基本类型偏执（PrimitiveObsession） 32</span><br><span class="line">4.5 不恰当的暴露（IndecentExposure） 32</span><br><span class="line">4.6 解决方案蔓延（SolutionSprawl） 33</span><br><span class="line">4.7 异曲同工的类（AlternativeClasseswithDifferentInterfaces） 33</span><br><span class="line">4.8 冗赘类（LazyClass） 33</span><br><span class="line">4.9 过大的类（LargeClass） 33</span><br><span class="line">4.10 分支语句（SwitchStatement） 34</span><br><span class="line">4.11 组合爆炸（CombinatorialExplosion） 34</span><br><span class="line">4.12 怪异解决方案（OddballSolution） 34</span><br><span class="line">第5章 模式导向的重构目录 36</span><br><span class="line">5.1 重构的格式 36</span><br><span class="line">5.2 本目录中引用的项目 37</span><br><span class="line">5.2.1 XMLBuilder 38</span><br><span class="line">5.2.2 HTMLParser 38</span><br><span class="line">5.2.3 贷款风险计算程序 39</span><br><span class="line">5.3 起点 39</span><br><span class="line">5.4 学习顺序 39</span><br><span class="line">第6章 创建 41</span><br><span class="line">6.1 用CreationMethod替换构造函数 43</span><br><span class="line">6.1.1 动机 43</span><br><span class="line">6.1.2 做法 45</span><br><span class="line">6.1.3 示例 45</span><br><span class="line">6.1.4 变体 49</span><br><span class="line">6.2 将创建知识搬移到Factory 51</span><br><span class="line">6.2.1 动机 51</span><br><span class="line">6.2.2 做法 54</span><br><span class="line">6.2.3 示例 55</span><br><span class="line">6.3 用Factory封装类 60</span><br><span class="line">6.3.1 动机 60</span><br><span class="line">6.3.2 做法 61</span><br><span class="line">6.3.3 示例 62</span><br><span class="line">6.3.4 变体 65</span><br><span class="line">6.4 用FactoryMethod引入多态创建 67</span><br><span class="line">6.4.1 动机 67</span><br><span class="line">6.4.2 做法 68</span><br><span class="line">6.4.3 示例 70</span><br><span class="line">6.5 用Builder封装Composite 74</span><br><span class="line">6.5.1 做法 76</span><br><span class="line">6.5.2 示例 77</span><br><span class="line">6.5.3 变体 87</span><br><span class="line">6.6 内联Singleton 90</span><br><span class="line">6.6.1 动机 90</span><br><span class="line">6.6.2 做法 92</span><br><span class="line">6.6.3 示例 93</span><br><span class="line">第7章 简化 96</span><br><span class="line">7.1 组合方法 97</span><br><span class="line">7.1.1 动机 97</span><br><span class="line">7.1.2 做法 99</span><br><span class="line">7.1.3 示例 99</span><br><span class="line">7.2 用Strategy替换条件逻辑 102</span><br><span class="line">7.2.1 动机 102</span><br><span class="line">7.2.2 做法 104</span><br><span class="line">7.2.3 示例 105</span><br><span class="line">7.3 将装饰功能搬移到Decorator 115</span><br><span class="line">7.3.1 动机 115</span><br><span class="line">7.3.2 做法 118</span><br><span class="line">7.3.3 示例 119</span><br><span class="line">7.4 用State替换状态改变条件语句 133</span><br><span class="line">7.4.1 动机 133</span><br><span class="line">7.4.2 做法 134</span><br><span class="line">7.4.3 示例 135</span><br><span class="line">7.5 用Composite替换隐含树 143</span><br><span class="line">7.5.1 动机 143</span><br><span class="line">7.5.2 做法 146</span><br><span class="line">7.5.3 示例 147</span><br><span class="line">7.6 用Command替换条件调度程序 155</span><br><span class="line">7.6.1 动机 155</span><br><span class="line">7.6.2 做法 157</span><br><span class="line">7.6.3 示例 158</span><br><span class="line">第8章 泛化 164</span><br><span class="line">8.1 形成TemplateMethod 165</span><br><span class="line">8.1.1 动机 166</span><br><span class="line">8.1.2 做法 167</span><br><span class="line">8.1.3 示例 167</span><br><span class="line">8.2 提取Composite 172</span><br><span class="line">8.2.1 动机 172</span><br><span class="line">8.2.2 做法 173</span><br><span class="line">8.2.3 示例 174</span><br><span class="line">8.3 用Composite替换一多之分 180</span><br><span class="line">8.3.1 动机 180</span><br><span class="line">8.3.2 做法 182</span><br><span class="line">8.3.3 示例 183</span><br><span class="line">8.4 用Observer替换硬编码的通知 190</span><br><span class="line">8.4.1 动机 190</span><br><span class="line">8.4.2 做法 191</span><br><span class="line">8.4.3 示例 192</span><br><span class="line">8.5 通过Adapter统一接口 199</span><br><span class="line">8.5.1 动机 199</span><br><span class="line">8.5.2 做法 200</span><br><span class="line">8.5.3 示例 201</span><br><span class="line">8.6 提取Adapter 208</span><br><span class="line">8.6.1 动机 208</span><br><span class="line">8.6.2 做法 210</span><br><span class="line">8.6.3 示例 210</span><br><span class="line">8.6.4 变体 216</span><br><span class="line">8.7 用Interpreter替换隐式语言 217</span><br><span class="line">8.7.1 动机 217</span><br><span class="line">8.7.2 做法 219</span><br><span class="line">8.7.3 示例 220</span><br><span class="line">第9章 保护 230</span><br><span class="line">9.1 用类替换类型代码 231</span><br><span class="line">9.1.1 动机 231</span><br><span class="line">9.1.2 做法 233</span><br><span class="line">9.1.3 示例 234</span><br><span class="line">9.2 用Singleton限制实例化 240</span><br><span class="line">9.2.1 动机 240</span><br><span class="line">9.2.2 做法 241</span><br><span class="line">9.2.3 示例 241</span><br><span class="line">9.3 引入NullObject 244</span><br><span class="line">9.3.1 动机 244</span><br><span class="line">9.3.2 做法 246</span><br><span class="line">9.3.3 示例 247</span><br><span class="line">第10章 聚集操作 252</span><br><span class="line">10.1 将聚集操作搬移到CollectingParameter 253</span><br><span class="line">10.1.1 动机 253</span><br><span class="line">10.1.2 做法 254</span><br><span class="line">10.1.3 示例 255</span><br><span class="line">10.2 将聚集操作搬移到Visitor 259</span><br><span class="line">10.2.1 动机 259</span><br><span class="line">10.2.2 做法 263</span><br><span class="line">10.2.3 示例 267</span><br><span class="line">第11章 实用重构 274</span><br><span class="line">11.1 链构造函数 275</span><br><span class="line">11.1.1 动机 275</span><br><span class="line">11.1.2 做法 276</span><br><span class="line">11.1.3 示例 276</span><br><span class="line">11.2 统一接口 278</span><br><span class="line">11.2.1 动机 278</span><br><span class="line">11.2.2 做法 279</span><br><span class="line">11.2.3 示例 279</span><br><span class="line">11.3 提取参数 280</span><br><span class="line">11.3.1 动机 280</span><br><span class="line">11.3.2 做法 280</span><br><span class="line">11.3.3 示例 281</span><br><span class="line">跋 282</span><br><span class="line">参考文献 283</span><br><span class="line">索引 286</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00A9YD7A2/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00A9YD7A2&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41hfVXEEXuL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论(原书第3版)</title>
    <url>/2020/04/19/B00AK7BYJY/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 算法导论(原书第3版)<br>作者信息： 作者: Thomas H.Cormen [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《算法导论(原书第3版)》编辑推荐：全球超过50万人阅读的算法圣经！算法标准教材，国内外1000余所高校采用。国内知名高校6位教授历时3年倾心翻译！</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">出版者的话</span><br><span class="line">译者序</span><br><span class="line">前言</span><br><span class="line">第一部分基础知识</span><br><span class="line">第1章算法在计算中的作用</span><br><span class="line">1.1算法</span><br><span class="line">1.2作为一种技术的算法</span><br><span class="line">思考题</span><br><span class="line">本章注记</span><br><span class="line">第2章算法基础</span><br><span class="line">2.1插入排序</span><br><span class="line">2.2分析算法</span><br><span class="line">2.3设计算法</span><br><span class="line">2.3.1分治法</span><br><span class="line">2.3.2分析分治算法</span><br><span class="line">思考题</span><br><span class="line">本章注记</span><br><span class="line">第3章函数的增长</span><br><span class="line">3.1渐近记号</span><br><span class="line">3.2标准记号与常用函数</span><br><span class="line">思考题</span><br><span class="line">本章注记</span><br><span class="line">第4章分治策略</span><br><span class="line">4.1最大子数组问题</span><br><span class="line">4.2矩阵乘法的Strassen算法</span><br><span class="line">4.3用代入法求解递归式</span><br><span class="line">4.4用递归树方法求解递归式</span><br><span class="line">4.5用主方法求解递归式</span><br><span class="line">4.6证明主定理</span><br><span class="line">4.6.1对6的幂证明主定理</span><br><span class="line">4.6.2向下取整和向上取整</span><br><span class="line">思考题</span><br><span class="line">本章注记</span><br><span class="line">第5章概率分析和随机算法</span><br><span class="line">5.1雇用问题</span><br><span class="line">5.2指示器随机变量</span><br><span class="line">5.3随机算法</span><br><span class="line">5.4概率分析和指示器随机变量的进一步使用 5.4.1生日悖论 5.4.2球与箱子 5.4.3特征序列 5.4.4在线雇用问题 思考题 本章注记 第二部分排序和顺序统计量 第6章堆排序 6.1堆 6.2维护堆的性质 6.3建堆 6.4堆排序算法 6.5优先队列 思考题 本章注记 第7章快速排序 7.1快速排序的描述 7.2快速排序的性能 7.3快速排序的随机化版本 7.4快速排序分析 7.4.1最坏情况分析 7.4.2期望运行时间 思考题 本章注记 第8章线性时间排序 8.1排序算法的下界 8.2计数排序 8.3基数排序 8.4桶排序 思考题 本章注记 第9章中位数和顺序统计量 9.1最小值和最大值 9.2期望为线性时间的选择算法 9.3最坏情况为线性时间的选择算法 思考题 本章注记 第三部分数据结构 第10章基本数据结构 10.1栈和队列 10.2链表 10.3指针和对象的实现 10.4有根树的表示 思考题 本章注记 第11章散列表 11.1直接寻址表 11.2散列表 11.3散列函数 11.3.1除法散列法 11.3.2乘法散列法 11.3.3全域散列法</span><br><span class="line">11.4开放寻址法</span><br><span class="line">11.5完全散列</span><br><span class="line">思考题</span><br><span class="line">本章注记</span><br><span class="line">第12章二叉搜索树</span><br><span class="line">12.1什么是二叉搜索树</span><br><span class="line">12.2查询二叉搜索树</span><br><span class="line">12.3插入和删除</span><br><span class="line">12.4随机构建二叉搜索树</span><br><span class="line">思考题</span><br><span class="line">本章注记</span><br><span class="line">第13章红黑树</span><br><span class="line">13.1红黑树的性质</span><br><span class="line">13.2旋转</span><br><span class="line">13.3插入</span><br><span class="line">13.4删除</span><br><span class="line">思考题</span><br><span class="line">本章注记</span><br><span class="line">第14章数据结构的扩张</span><br><span class="line">14.1动态顺序统计</span><br><span class="line">14.2如何扩张数据结构</span><br><span class="line">14.3区间树</span><br><span class="line">思考题</span><br><span class="line">本章注记</span><br><span class="line">第四部分高级设计和分析技术</span><br><span class="line">第15章动态规划</span><br><span class="line">15.1钢条切割</span><br><span class="line">15.2矩阵链乘法</span><br><span class="line">15.3动态规划原理</span><br><span class="line">15.4最长公共子序列</span><br><span class="line">15.5最优二叉搜索树</span><br><span class="line">思考题</span><br><span class="line">本章注记</span><br><span class="line">第16章贪心算法</span><br><span class="line">16.1活动选择问题</span><br><span class="line">16.2贪心算法原理</span><br><span class="line">16.3赫夫曼编码</span><br><span class="line">16.4拟阵和贪心算法 16.5用拟阵求解任务调度问题</span><br><span class="line">思考题</span><br><span class="line">本章注记</span><br><span class="line">第17章摊还分析</span><br><span class="line">17，1聚合分析</span><br><span class="line">17.2核算法</span><br><span class="line">17.3势能法</span><br><span class="line">17.4动态表</span><br><span class="line">17.4.1表扩张</span><br><span class="line">17.4.2表扩张和收缩</span><br><span class="line">思考题</span><br><span class="line">本章注记</span><br><span class="line">第五部分高级数据结构</span><br><span class="line">第18章B树</span><br><span class="line">18.1B树的定义</span><br><span class="line">18.2B树上的基本操作</span><br><span class="line">18.3从B树中删除关键字</span><br><span class="line">思考题</span><br><span class="line">本章注记</span><br><span class="line">第19章斐波那契堆</span><br><span class="line">19.1斐波那契堆结构</span><br><span class="line">19.2可合并堆操作</span><br><span class="line">19.3关键字减值和删除一个结点</span><br><span class="line">19.4最大度数的界</span><br><span class="line">思考题</span><br><span class="line">本章注记</span><br><span class="line">第20章van Emde Boas树</span><br><span class="line">20.1基本方法</span><br><span class="line">20.2递归结构</span><br><span class="line">20.2.1原型van Emde Boas结构</span><br><span class="line">20.2.2原型van Emde Boas结构上的操作</span><br><span class="line">20.3van Emde Boas树及其操作</span><br><span class="line">20.3.1van Emde Boas树</span><br><span class="line">20.3.2van Emde Boas树的操作</span><br><span class="line">思考题</span><br><span class="line">本章注记</span><br><span class="line">第21章用于不相交集合的数据结构</span><br><span class="line">21.1不相交集合的操作</span><br><span class="line">21.2不相交集合的链表表示</span><br><span class="line">21.3不相交集合森林</span><br><span class="line">21.4带路径压缩的按秩合并的分析 思考题 本章注记 第六部分图算法 第22章基本的图算法 22.1图的表示 22.2广度优先搜索 22.3深度优先搜索 22.4拓扑排序 22.5强连通分量 思考题 本章注记 第23章最小生成树 23.1最小生成树的形成 23.2Kruskal算法和Prim算法 思考题 本章注记 第24章单源最短路径 24.1Bellman—Ford算法 24.2有向无环图中的单源最短路径问题 24.3Dijkstra算法 24.4差分约束和最短路径 24.5最短路径性质的证明 思考题 本章注记 第25章所有结点对的最短路径问题 25.1最短路径和矩阵乘法 25.2Floyd—Warshall算法 25.3用于稀疏图的Johnson算法 思考题 本章注记 第26章最大流 26.1流网络 26.2Ford—Fulkerson方法 26.3最大二分匹配 26.4推送一重贴标签算法</span><br><span class="line">26.5前置重贴标签算法 思考题 本章注记 第七部分算法问题选编 第27章多线程算法 27.1动态多线程基础 27.2多线程矩阵乘法 27.3多线程归并排序 思考题 本章注记 第28章矩阵运算 28.1求解线性方程组 28.2矩阵求逆 28.3对称正定矩阵和最小二乘 逼近 思考题 本章注记 第29章线性规划 29.1标准型和松弛型 29.2将问题表达为线性规划 29.3单纯形算法 29.4对偶性 29.5初始基本可行解 思考题 本章注记 第30章多项式与快速傅里叶变换 30.1多项式的表示 30.2DFT与FFT 30.3高效FFT实现 思考题 本章注记 第31章数论算法 31.1基础数论概念 31.2最大公约数 31.3模运算 31.4求解模线性方程 31.5中国余数定理 31.6元素的幂 31.7RSA公钥加密系统 31.3素数的测试</span><br><span class="line">31.9整数的因子分解 思考题 本章注记 第32章字符串匹配 32.1朴素字符串匹配算法 32.2Rabin—Karp算法 32.3利用有限自动机进行字符串匹配 32.4Knuth—Morris—Pratt算法</span><br><span class="line">思考题</span><br><span class="line">本章注记</span><br><span class="line">第33章计算几何学</span><br><span class="line">33.1线段的性质</span><br><span class="line">33.2确定任意一对线段是否相交</span><br><span class="line">33.3寻找凸包</span><br><span class="line">33.4寻找最近点对</span><br><span class="line">思考题</span><br><span class="line">本章注记</span><br><span class="line">第34章NP完全性</span><br><span class="line">34.1多项式时间</span><br><span class="line">34.2多项式时间的验证</span><br><span class="line">34.3NP完全性与可归约性</span><br><span class="line">34.4NP完全性的证明</span><br><span class="line">34.5NP完全问题</span><br><span class="line">34.5.1团问题</span><br><span class="line">34.5.2顶点覆盖问题</span><br><span class="line">34.5.3哈密顿回路问题</span><br><span class="line">34.5.4旅行商问题</span><br><span class="line">34.5.5子集和问题</span><br><span class="line">思考题</span><br><span class="line">本章注记</span><br><span class="line">第35章近似算法</span><br><span class="line">35.1顶点覆盖问题</span><br><span class="line">35.2旅行商问题</span><br><span class="line">35.2.1满足三角不等式的旅行商问题</span><br><span class="line">35.2.2一般旅行商问题</span><br><span class="line">35.3集合覆盖问题</span><br><span class="line">35.4随机化和线性规划</span><br><span class="line">35.5子集和问题</span><br><span class="line">思考题</span><br><span class="line">本章注记</span><br><span class="line">第八部分附录：数学基础知识</span><br><span class="line">附录A求和</span><br><span class="line">A.1求和公式及其性质</span><br><span class="line">A.2确定求和时间的界</span><br><span class="line">思考题</span><br><span class="line">附录注记</span><br><span class="line">附录B集合等离散数学内容</span><br><span class="line">B.1集合</span><br><span class="line">B.2关系</span><br><span class="line">B.3函数</span><br><span class="line">B.4图</span><br><span class="line">B.5树</span><br><span class="line">B.5.1自由树</span><br><span class="line">B.5.2有根树和有序树</span><br><span class="line">B.5.3二叉树和位置树</span><br><span class="line">思考题</span><br><span class="line">附录注记</span><br><span class="line">附录C计数与概率</span><br><span class="line">C.1计数</span><br><span class="line">C.2概率</span><br><span class="line">C.3离散随机变量</span><br><span class="line">C.4几何分布与二项分布</span><br><span class="line">思考题</span><br><span class="line">附录注记</span><br><span class="line">附录D矩阵</span><br><span class="line">D.1矩阵与矩阵运算</span><br><span class="line">D.2矩阵的基本性质</span><br><span class="line">思考题</span><br><span class="line">附录注记</span><br><span class="line">参考文献</span><br><span class="line">索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00AK7BYJY/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00AK7BYJY&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51yWNzHYyUL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective MySQL之SQL语句最优化</title>
    <url>/2020/04/19/B00AYR34R0/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Effective MySQL之SQL语句最优化<br>作者信息： 作者: 布拉德福 (Ronald Bradford) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Effective MySQL之SQL语句最优化》提供了很多可以用于改进数据库和应用程序性能的最佳实践技巧，并对这些技巧做了详细的解释，希望能够通过一步步详细介绍SQL优化的方法，帮助读者分析和调优有问题的SQL语句。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章DBA五分钟速成</span><br><span class="line">1.1识别性能问题</span><br><span class="line">1.1.1寻找运行缓慢的SQL语句</span><br><span class="line">1.1.2确认低效查询</span><br><span class="line">1.2优化查询</span><br><span class="line">1.2.1不应该做的事情</span><br><span class="line">1.2.2确认优化</span><br><span class="line">1.2.3正确的方式</span><br><span class="line">1.2.4备选的解决方案</span><br><span class="line">1.2本章小结</span><br><span class="line">第2章基本的分析命令</span><br><span class="line">2.1 EXPLAIN命令</span><br><span class="line">2.1.1 EXPLAIN PARTITIONS命令</span><br><span class="line">2.1.2 EXPLAIN EXTENDED命令</span><br><span class="line">2.2 SHOW CREATE TABLE命令</span><br><span class="line">2.3 SHOW INDEXES命令</span><br><span class="line">2.4 SHOW TABLE STATUS命令</span><br><span class="line">2.5 SHOW STATUS命令</span><br><span class="line">2.6 SHOW VARIABLES命令</span><br><span class="line">2.7 INFORMATION SCHEMA</span><br><span class="line">2.8本章小结</span><br><span class="line">第3章深入理解MySQL的索引</span><br><span class="line">3.1示例表</span><br><span class="line">3.2 MySQL索引用法</span><br><span class="line">3.2.1数据完整性</span><br><span class="line">3.2.2优化数据访问</span><br><span class="line">3.2.3表连接</span><br><span class="line">3.2.4结果排序</span><br><span class="line">3.2.5聚合操作</span><br><span class="line">3.3关于存储引擎</span><br><span class="line">3.4索引专业术语</span><br><span class="line">3.5 MySQL索引类型</span><br><span class="line">3.5.1索引数据结构理论</span><br><span class="line">3.5.2 MySQL实现</span><br><span class="line">3.6 MySQL分区</span><br><span class="line">3.7本章小结</span><br><span class="line">第4章创建MySQL索引</span><br><span class="line">4.1本章范例中用到的表</span><br><span class="line">4.2 已有的索引</span><br><span class="line">4.3单列索引</span><br><span class="line">4.3.1创建单列索引的语法</span><br><span class="line">4.3.2利用索引限制查询读取的行数</span><br><span class="line">4.3.3使用索引连接表</span><br><span class="line">4.3.4理解索引的基数</span><br><span class="line">4.3.5使用索引进行模式匹配</span><br><span class="line">4.3.6选择唯一的行</span><br><span class="line">4.3.7结果排序</span><br><span class="line">4.4多列索引</span><br><span class="line">4.4.1确定使用何种索引</span><br><span class="line">4.4.2多列索引的语法</span><br><span class="line">4.4.3创建更好的索引</span><br><span class="line">4.4.4多个列上的索引</span><br><span class="line">4.4.5合并VWd—EKE和ORDER BY语句</span><br><span class="line">4.4.6 MySQL优化器的特性</span><br><span class="line">4.4.7查询提示</span><br><span class="line">4.4.8复杂查询</span><br><span class="line">4.5添加索引造成的影响</span><br><span class="line">4.5.1 DML影响</span><br><span class="line">4.5.2 DDL影响</span><br><span class="line">4.5.3磁盘空间影响</span><br><span class="line">4.6 MySQL的限制和不足</span><br><span class="line">4.6.1基于开销的优化器</span><br><span class="line">4.6.2指定QEP</span><br><span class="line">4.6.3索引的统计信息</span><br><span class="line">4.6.4基于函数的索引</span><br><span class="line">4.6.5一个表上的多个索引</span><br><span class="line">4.7本章小结</span><br><span class="line">第5章创建更好的MySQL索引</span><br><span class="line">5.1更好的索引</span><br><span class="line">5.1.1覆盖索引</span><br><span class="line">5.1.2存储引擎的含义</span><br><span class="line">5.1.3局部索引</span><br><span class="line">5.2本章小结</span><br><span class="line">第6章MySQL配置选项</span><br><span class="line">6.1 内存相关的系统变量</span><br><span class="line">6.1.1 key_buffer_size</span><br><span class="line">6.1.2命名码缓冲区</span><br><span class="line">6.1.3 innodb_buffer_pool_size</span><br><span class="line">6.1.4 innodb_additional_mem pool_size</span><br><span class="line">6.1.5 query_cache_size</span><br><span class="line">6.1.6 max_heap_tablesize</span><br><span class="line">6.1.7 trap_table size</span><br><span class="line">6.1.8 join_buffersize</span><br><span class="line">6.1.9 sort_buffer_size</span><br><span class="line">6.1.10 read_buffersize</span><br><span class="line">6.1.11 read_md_buffer_size</span><br><span class="line">6.2有关基础工具的变量</span><br><span class="line">6.2.1 slow_query_log</span><br><span class="line">6.2.2 slow query_log_file</span><br><span class="line">……</span><br><span class="line">第7章SQL的生命周期</span><br><span class="line">第8章性能优化之隐藏秘籍</span><br><span class="line">第9章MySQLEXPLAIN命令详解</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00AYR34R0/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00AYR34R0&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/513zQwzlD3L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能MySQL(第3版)</title>
    <url>/2020/04/19/B00C1W58DE/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 高性能MySQL(第3版)<br>作者信息： 作者: 施瓦茨 (Baron Schwartz) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>“只要你不敢以MySQL专家自诩，又岂敢错过这本神书？”“一言以蔽之，写得好，编排得好，需要参考时容易到爆！”“我可是从头到尾看了一遍上一版，可还是毫不犹豫拿起了这本《高性能MySQL（第3版）》，而且看完后一点都不后悔……”</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">推荐序</span><br><span class="line">前言</span><br><span class="line">第1章MySQL架构与历史1</span><br><span class="line">1.1MySQL逻辑架构1</span><br><span class="line">1.1.1连接管理与安全性2</span><br><span class="line">1.1.2优化与执行3</span><br><span class="line">1.2并发控制3</span><br><span class="line">1.2.1读写锁4</span><br><span class="line">1.2.2锁粒度4</span><br><span class="line">1.3事务6</span><br><span class="line">1.3.1隔离级别8</span><br><span class="line">1.3.2死锁9</span><br><span class="line">1.3.3事务日志10</span><br><span class="line">1.3.4MySQL中的事务10</span><br><span class="line">1.4多版本并发控制12</span><br><span class="line">1.5MySQL的存储引擎13</span><br><span class="line">1.5.1InnoDB存储引擎16</span><br><span class="line">1.5.2MyISAM存储引擎17</span><br><span class="line">1.5.3MySQL内建的其他存储引擎19</span><br><span class="line">1.5.4第三方存储引擎22</span><br><span class="line">1.5.5选择合适的引擎24</span><br><span class="line">1.5.6转换表的引擎27</span><br><span class="line">1.6MySQL时间线（Timeline）29</span><br><span class="line">1.7MySQL的开发模式32</span><br><span class="line">1.8总结33</span><br><span class="line">第2章MySQL基准测试35</span><br><span class="line">2.1为什么需要基准测试35</span><br><span class="line">2.2基准测试的策略37</span><br><span class="line">2.2.1测试何种指标38</span><br><span class="line">2.3基准测试方法40</span><br><span class="line">2.3.1设计和规划基准测试41</span><br><span class="line">2.3.2基准测试应该运行多长时间42</span><br><span class="line">2.3.3获取系统性能和状态43</span><br><span class="line">2.3.4获得准确的测试结果44</span><br><span class="line">2.3.5运行基准测试并分析结果46</span><br><span class="line">2.3.6绘图的重要性47</span><br><span class="line">2.4基准测试工具49</span><br><span class="line">2.4.1集成式测试工具49</span><br><span class="line">2.4.2单组件式测试工具50</span><br><span class="line">2.5基准测试案例52</span><br><span class="line">2.5.1http_load53</span><br><span class="line">2.5.2MySQL基准测试套件54</span><br><span class="line">2.5.3sysbench55</span><br><span class="line">2.5.4数据库测试套件中的dbt2TPC—C测试60</span><br><span class="line">2.5.5Percona的TPCC—MySQL测试工具63</span><br><span class="line">2.6总结65</span><br><span class="line">第3章服务器性能剖析67</span><br><span class="line">3.1性能优化简介67</span><br><span class="line">3.1.1通过性能剖析进行优化69</span><br><span class="line">3.1.2理解性能剖析71</span><br><span class="line">3.2对应用程序进行性能剖析72</span><br><span class="line">3.2.1测量PHP应用程序74</span><br><span class="line">3.3剖析MySQL查询77</span><br><span class="line">3.3.1剖析服务器负载77</span><br><span class="line">3.3.2剖析单条查询81</span><br><span class="line">3.3.3使用性能剖析87</span><br><span class="line">3.4诊断间歇性问题88</span><br><span class="line">3.4.1单条查询问题还是服务器问题89</span><br><span class="line">3.4.2捕获诊断数据93</span><br><span class="line">3.4.3一个诊断案例98</span><br><span class="line">3.5其他剖析工具106</span><br><span class="line">3.5.1使用USER_STATISTICS表106</span><br><span class="line">3.5.2使用strace107</span><br><span class="line">3.6总结108</span><br><span class="line">第4章Schema与数据类型优化111</span><br><span class="line">4.1选择优化的数据类型111</span><br><span class="line">4.1.1整数类型113</span><br><span class="line">4.1.2实数类型113</span><br><span class="line">4.1.3字符串类型114</span><br><span class="line">4.1.4日期和时间类型121</span><br><span class="line">4.1.5位数据类型123</span><br><span class="line">4.1.6选择标识符（identifier）125</span><br><span class="line">4.1.7特殊类型数据127</span><br><span class="line">4.2MySQLschema设计中的陷阱127</span><br><span class="line">4.3范式和反范式129</span><br><span class="line">4.3.1范式的优点和缺点130</span><br><span class="line">4.3.2反范式的优点和缺点130</span><br><span class="line">4.3.3混用范式化和反范式化131</span><br><span class="line">4.4缓存表和汇总表132</span><br><span class="line">4.4.1物化视图134</span><br><span class="line">4.4.2计数器表135</span><br><span class="line">4.5加快ALTERTABLE操作的速度136</span><br><span class="line">4.5.1只修改.frm文件137</span><br><span class="line">4.5.2快速创建MyISAM索引139</span><br><span class="line">4.6总结140</span><br><span class="line">第5章创建高性能的索引141</span><br><span class="line">5.1索引基础141</span><br><span class="line">5.1.1索引的类型142</span><br><span class="line">5.2索引的优点152</span><br><span class="line">5.3高性能的索引策略153</span><br><span class="line">5.3.1独立的列153</span><br><span class="line">5.3.2前缀索引和索引选择性153</span><br><span class="line">5.3.3多列索引157</span><br><span class="line">5.3.4选择合适的索引列顺序159</span><br><span class="line">5.3.5聚簇索引162</span><br><span class="line">5.3.6覆盖索引171</span><br><span class="line">5.3.7使用索引扫描来做排序175</span><br><span class="line">5.3.8压缩（前缀压缩）索引177</span><br><span class="line">5.3.9冗余和重复索引178</span><br><span class="line">5.3.10未使用的索引181</span><br><span class="line">5.3.11索引和锁181</span><br><span class="line">5.4索引案例学习183</span><br><span class="line">5.4.1支持多种过滤条件183</span><br><span class="line">5.4.2避免多个范围条件185</span><br><span class="line">5.4.3优化排序186</span><br><span class="line">5.5维护索引和表187</span><br><span class="line">5.5.1找到并修复损坏的表187</span><br><span class="line">5.5.2更新索引统计信息188</span><br><span class="line">5.5.3减少索引和数据的碎片190</span><br><span class="line">5.6总结192</span><br><span class="line">第6章查询性能优化195</span><br><span class="line">6.1为什么查询速度会慢195</span><br><span class="line">6.2慢查询基础：优化数据访问196</span><br><span class="line">6.2.1是否向服务器请求了不需要的数据196</span><br><span class="line">6.2.2MySQL是否在扫描额外的记录198</span><br><span class="line">6.3重构查询的方式201</span><br><span class="line">6.3.1一个复杂查询还是多个简单查询201</span><br><span class="line">6.3.2切分查询202</span><br><span class="line">6.3.3分解关联查询203</span><br><span class="line">6.4查询执行的基础204</span><br><span class="line">6.4.1MySQL客户端／服务器通信协议205</span><br><span class="line">6.4.2查询缓存208</span><br><span class="line">6.4.3查询优化处理208</span><br><span class="line">6.4.4查询执行引擎222</span><br><span class="line">6.4.5返回结果给客户端223</span><br><span class="line">6.5MySQL查询优化器的局限性223</span><br><span class="line">6.5.1关联子查询223</span><br><span class="line">6.5.2UNION的限制228</span><br><span class="line">6.5.3索引合并优化228</span><br><span class="line">6.5.4等值传递229</span><br><span class="line">6.5.5并行执行229</span><br><span class="line">6.5.6哈希关联229</span><br><span class="line">6.5.7松散索引扫描229</span><br><span class="line">6.5.8最大值和最小值优化231</span><br><span class="line">6.5.9在同一个表上查询和更新232</span><br><span class="line">6.6查询优化器的提示（hint）232</span><br><span class="line">6.7优化特定类型的查询236</span><br><span class="line">6.7.1优化COUNT（）查询236</span><br><span class="line">6.7.2优化关联查询239</span><br><span class="line">6.7.3优化子查询239</span><br><span class="line">6.7.4优化GROUPBY和DISTINCT239</span><br><span class="line">6.7.5优化LIMIT分页241</span><br><span class="line">6.7.6优化SQL_CALC_FOUND_ROWS243</span><br><span class="line">6.7.7优化UNION查询243</span><br><span class="line">6.7.8静态查询分析244</span><br><span class="line">6.7.9使用用户自定义变量244</span><br><span class="line">6.8案例学习251</span><br><span class="line">6.8.1使用MySQL构建一个队列表251</span><br><span class="line">6.8.2计算两点之间的距离254</span><br><span class="line">6.8.3使用用户自定义函数257</span><br><span class="line">6.9总结258</span><br><span class="line">第7章MySQL高级特性259</span><br><span class="line">7.1分区表259</span><br><span class="line">7.1.1分区表的原理260</span><br><span class="line">7.1.2分区表的类型261</span><br><span class="line">7.1.3如何使用分区表262</span><br><span class="line">7.1.4什么情况下会出问题263</span><br><span class="line">7.1.5查询优化266</span><br><span class="line">7.1.6合并表267</span><br><span class="line">7.2视图270</span><br><span class="line">7.2.1可更新视图272</span><br><span class="line">7.2.2视图对性能的影响273</span><br><span class="line">7.2.3视图的限制274</span><br><span class="line">7.3外键约束275</span><br><span class="line">7.4在MySQL内部存储代码276</span><br><span class="line">7.4.1存储过程和函数278</span><br><span class="line">7.4.2触发器279</span><br><span class="line">7.4.3事件281</span><br><span class="line">7.4.4在存储程序中保留注释283</span><br><span class="line">7.5游标283</span><br><span class="line">7.6绑定变量284</span><br><span class="line">7.6.1绑定变量的优化286</span><br><span class="line">7.6.2SQL接口的绑定变量286</span><br><span class="line">7.6.3绑定变量的限制288</span><br><span class="line">7.7用户自定义函数289</span><br><span class="line">7.8插件290</span><br><span class="line">7.9字符集和校对291</span><br><span class="line">7.9.1MySQL如何使用字符集292</span><br><span class="line">7.9.2选择字符集和校对规则295</span><br><span class="line">7.9.3字符集和校对规则如何影响查询296</span><br><span class="line">7.10全文索引299</span><br><span class="line">7.10.1自然语言的全文索引300</span><br><span class="line">7.10.2布尔全文索引302</span><br><span class="line">7.10.3MySQL5.1中全文索引的变化303</span><br><span class="line">7.10.4全文索引的限制和替代方案304</span><br><span class="line">7.10.5全文索引的配置和优化306</span><br><span class="line">7.11分布式（XA）事务307</span><br><span class="line">7.11.1内部XA事务307</span><br><span class="line">7.11.2外部XA事务308</span><br><span class="line">7.12查询缓存309</span><br><span class="line">7.12.1MySQL如何判断缓存命中309</span><br><span class="line">7.12.2查询缓存如何使用内存311</span><br><span class="line">7.12.3什么情况下查询缓存能发挥作用313</span><br><span class="line">7.12.4如何配置和维护查询缓存316</span><br><span class="line">7.12.5InnoDB和查询缓存319</span><br><span class="line">7.12.6通用查询缓存优化320</span><br><span class="line">7.12.7查询缓存的替代方案321</span><br><span class="line">7.13总结321</span><br><span class="line">……</span><br><span class="line">第8章优化服务器设置325</span><br><span class="line">第9章操作系统和硬件优化377</span><br><span class="line">第10章复制433</span><br><span class="line">第11章可扩展的MySQL501</span><br><span class="line">第12章高可用性543</span><br><span class="line">第13章云端的MySQL563</span><br><span class="line">第14章应用层优化577</span><br><span class="line">第15章备份与恢复593</span><br><span class="line">第16章MySQL用户工具635</span><br><span class="line">附录AMySQL分支与变种649</span><br><span class="line">附录BMySQL服务器状态655</span><br><span class="line">附录C大文件传输683</span><br><span class="line">附录DEXPLAIN687</span><br><span class="line">附录E锁的调试703</span><br><span class="line">附录F在MySQL上使用Sphinx713</span><br><span class="line">索引739</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00C1W58DE/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00C1W58DE&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51Q1ooQkQOL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵计算机科学丛书•具体数学 计算机科学基础(第2版)</title>
    <url>/2020/04/19/B00C4OM7V0/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 图灵计算机科学丛书•具体数学 计算机科学基础(第2版)<br>作者信息： 作者: 葛立恒 (Ronald L.Graham) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>顶级数学家和计算机科学家合著的经典著作被世界多所知名大学采纳为教材当代计算机科学方面的一部重要著作，TAOCP的前奏曲不仅讲述数学问题和技巧，更侧重教导解决问题的方法或平淡、或深刻、或严肃、或幽默的涂鸦，让你在轻松愉悦的心境下体会数学的美妙第二作者、图灵奖得主计算机科学泰斗Donald E. Knuth（高德纳）在接受图灵社区的访谈时如是说：“《具体数学》是一份‘纲领’，它的内容是我对于数学诸多方面应该如何教与学的思考。熟练掌握代数公式的基础技能，对我来说始终都是关键所在。这些内容在TAOCP里都有讨论，但只能是蜻蜓点水；在斯坦福大学的课程中，我得以深入更多的细节，而那些课程都被囊括在这本书中了。” 学习本书可以：1、学会怎样分析复杂问题：首先研究小的情形，然后加以推广求出数学表达式，找出其封闭形式并予以证明2、学会计算机科学中用到的数学知识及技巧，为学习计算机算法奠定坚固的数学基础3、挑战六大类500多道习题，锻炼你的数学思维能力</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 递归问题 1</span><br><span class="line">1.1 河内塔 1</span><br><span class="line">1.2 平面上的直线 4</span><br><span class="line">1.3 约瑟夫问题 7</span><br><span class="line">习题 14</span><br><span class="line">第2章 和式 18</span><br><span class="line">2.1 记号 18</span><br><span class="line">2.2 和式和递归式 21</span><br><span class="line">2.3 和式的处理 25</span><br><span class="line">2.4 多重和式 28</span><br><span class="line">2.5 一般性的方法 35</span><br><span class="line">2.6 有限微积分和无限微积分 39</span><br><span class="line">2.7 无限和式 47</span><br><span class="line">习题 52</span><br><span class="line">第3章 整值函数 56</span><br><span class="line">3.1 底和顶 56</span><br><span class="line">3.2 底和顶的应用 58</span><br><span class="line">3.3 底和顶的递归式 66</span><br><span class="line">3.4 mod：二元运算 68</span><br><span class="line">3.5 底和顶的和式 72</span><br><span class="line">习题 79</span><br><span class="line">第4章 数论 85</span><br><span class="line">4.1 整除性 85</span><br><span class="line">4.2 素数 88</span><br><span class="line">4.3 素数的例子 89</span><br><span class="line">4.4 阶乘的因子 93</span><br><span class="line">4.5 互素 96</span><br><span class="line">4.6 mod：同余关系 103</span><br><span class="line">4.7 独立剩余 105</span><br><span class="line">4.8 进一步的应用 107</span><br><span class="line">4.9 函数和函数 110</span><br><span class="line">习题 119</span><br><span class="line">第5章 二项式系数 126</span><br><span class="line">5.1 基本恒等式 126</span><br><span class="line">5.2 基本练习 143</span><br><span class="line">5.3 处理的技巧 154</span><br><span class="line">5.4 生成函数 164</span><br><span class="line">5.5 超几何函数 170</span><br><span class="line">5.6 超几何变换 180</span><br><span class="line">5.7 部分超几何和式 186</span><br><span class="line">5.8 机械求和法 191</span><br><span class="line">习题 202</span><br><span class="line">第6章 特殊的数 214</span><br><span class="line">6.1 斯特林数 214</span><br><span class="line">6.2 欧拉数 223</span><br><span class="line">6.3 调和数 228</span><br><span class="line">6.4 调和求和法 233</span><br><span class="line">6.5 伯努利数 237</span><br><span class="line">6.6 斐波那契数 244</span><br><span class="line">6.7 连项式 252</span><br><span class="line">习题 259</span><br><span class="line">第7章 生成函数 268</span><br><span class="line">7.1 多米诺理论与换零钱 268</span><br><span class="line">7.2 基本策略 277</span><br><span class="line">7.3 解递归式 282</span><br><span class="line">7.4 特殊的生成函数 294</span><br><span class="line">7.5 卷积 296</span><br><span class="line">7.6 指数生成函数 305</span><br><span class="line">7.7 狄利克雷生成函数 310</span><br><span class="line">习题 312</span><br><span class="line">第8章 离散概率 320</span><br><span class="line">8.1 定义 320</span><br><span class="line">8.2 均值和方差 325</span><br><span class="line">8.3 概率生成函数 331</span><br><span class="line">8.4 抛掷硬币 336</span><br><span class="line">8.5 散列法 344</span><br><span class="line">习题 357</span><br><span class="line">第9章 渐近式 367</span><br><span class="line">9.1 量的等级 368</span><br><span class="line">9.2 大O记号 370</span><br><span class="line">9.3 O运算规则 376</span><br><span class="line">9.4 两个渐近技巧 388</span><br><span class="line">9.5 欧拉求和公式 393</span><br><span class="line">9.6 最后的求和法 398</span><br><span class="line">习题 410</span><br><span class="line">附录A 习题答案 417</span><br><span class="line">附录B 参考文献 508</span><br><span class="line">附录C 习题贡献者 536</span><br><span class="line">译后记 541</span><br><span class="line">索引 543</span><br><span class="line">表索引 563</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00C4OM7V0/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00C4OM7V0&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/61eHslpB5PL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Nginx 模块开发与架构解析</title>
    <url>/2020/04/19/B00BXTR5O6/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 深入理解Nginx 模块开发与架构解析<br>作者信息： 作者: 陶辉 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《深入理解Nginx:模块开发与架构解析》由阿里巴巴资深Nginx专家撰写，透彻解析Nginx架构，详解Nginx模块开发方法和技巧。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前 言</span><br><span class="line">第一部分 Nginx能帮我们做什么</span><br><span class="line">第1章 研究Nginx前的准备工作／2</span><br><span class="line">1.1 Nginx是什么／2</span><br><span class="line">1.2 为什么选择Nginx／4</span><br><span class="line">1.3 准备工作／7</span><br><span class="line">1.3.1 Linux操作系统／7</span><br><span class="line">1.3.2 使用Nginx的必备软件／7</span><br><span class="line">1.3.3 磁盘目录／8</span><br><span class="line">1.3.4 Linux内核参数的优化／9</span><br><span class="line">1.3.5 获取Nginx源码／11</span><br><span class="line">1.4 编译安装Nginx／11</span><br><span class="line">1.5 configure详解／11</span><br><span class="line">1.5.1 configure的命令参数／12</span><br><span class="line">1.5.2 configure执行流程／18</span><br><span class="line">1.5.3 configure生成的文件／22</span><br><span class="line">1.6 Nginx的命令行控制／24</span><br><span class="line">1.7 小结／27</span><br><span class="line">第2章 Nginx的配置／28</span><br><span class="line">2.1 运行中的Nginx进程间的关系／28</span><br><span class="line">2.2 Nginx配置的通用语法／31</span><br><span class="line">2.2.1 块配置项／31</span><br><span class="line">2.2.2 配置项的语法格式／32</span><br><span class="line">2.2.3 配置项的注释／33</span><br><span class="line">2.2.4 配置项的单位／33</span><br><span class="line">2.2.5 在配置中使用变量／33</span><br><span class="line">2.3 Nginx服务的基本配置／34</span><br><span class="line">2.3.1 用于调试进程和定位问题的配置项／34</span><br><span class="line">2.3.2 正常运行的配置项／36</span><br><span class="line">2.3.3 优化性能的配置项／38</span><br><span class="line">2.3.4 事件类配置项／39</span><br><span class="line">2.4 用HTTP核心模块配置一个静态Web服务器／41</span><br><span class="line">2.4.1 虚拟主机与请求的分发／42</span><br><span class="line">2.4.2 文件路径的定义／45</span><br><span class="line">2.4.3 内存及磁盘资源的分配／48</span><br><span class="line">2.4.4 网络连接的设置／50</span><br><span class="line">2.4.5 MIME类型的设置／53</span><br><span class="line">2.4.6 对客户端请求的限制／54</span><br><span class="line">2.4.7 文件操作的优化／55</span><br><span class="line">2.4.8 对客户端请求的特殊处理／57</span><br><span class="line">2.4.9 ngx_http_core_module模块提供的变量／59</span><br><span class="line">2.5 用HTTPproxymodule配置一个反向代理服务器／60</span><br><span class="line">2.5.1 负载均衡的基本配置／62</span><br><span class="line">2.5.2 反向代理的基本配置／64</span><br><span class="line">2.6 小结／68</span><br><span class="line">第二部分 如何编写HTTP模块</span><br><span class="line">第3章 开发一个简单的HTTP模块／70</span><br><span class="line">3.1 如何调用HTTP模块／70</span><br><span class="line">3.2 准备工作／72</span><br><span class="line">3.2.1 整型的封装／72</span><br><span class="line">3.2.2 ngx_str_t数据结构／73</span><br><span class="line">3.2.3 ngx_list_t数据结构／73</span><br><span class="line">3.2.4 ngx_table_elt_t数据结构／77</span><br><span class="line">3.2.5 ngx_buf_t数据结构／77</span><br><span class="line">3.2.6 ngx_chain_t数据结构／79</span><br><span class="line">3.3 如何将自己的HTTP模块编译进Nginx／79</span><br><span class="line">3.3.1 config文件的写法／80</span><br><span class="line">3.3.2 利用configure脚本将定制的模块加入到Nginx中／80</span><br><span class="line">3.3.3 直接修改Makefile文件／84</span><br><span class="line">3.4 HTTP模块的数据结构／85</span><br><span class="line">3.5 定义自己的HTTP模块／88</span><br><span class="line">3.6 处理用户请求／92</span><br><span class="line">3.6.1 处理方法的返回值／92</span><br><span class="line">3.6.2 获取URI和参数／95</span><br><span class="line">3.6.3 获取HTTP头部／98</span><br><span class="line">3.6.4 获取HTTP包体／101</span><br><span class="line">3.7 发送响应／102</span><br><span class="line">3.7.1 发送HTTP头部／102</span><br><span class="line">3.7.2 将内存中的字符串作为包体发送／104</span><br><span class="line">3.7.3 经典的“HelloWorld”示例／106</span><br><span class="line">3.8 将磁盘文件作为包体发送／107</span><br><span class="line">3.8.1 如何发送磁盘中的文件／107</span><br><span class="line">3.8.2 清理文件句柄／110</span><br><span class="line">3.8.3 支持用户多线程下载和断点续传／111</span><br><span class="line">3.9 用C++语言编写HTTP模块／112</span><br><span class="line">3.9.1 编译方式的修改／112</span><br><span class="line">3.9.2 程序中的符号转换／114</span><br><span class="line">3.10 小结／114</span><br><span class="line">第4章 配置、error日志和请求上下文／115</span><br><span class="line">4.1 http配置项的使用场景／115</span><br><span class="line">4.2 怎样使用http配置／117</span><br><span class="line">4.2.1 分配用于保存配置参数的数据结构／117</span><br><span class="line">4.2.2 设定配置项的解析方式／119</span><br><span class="line">4.2.3 使用14种预设方法解析配置项／125</span><br><span class="line">4.2.4 自定义配置项处理方法／136</span><br><span class="line">4.2.5 合并配置项／137</span><br><span class="line">4.3 HTTP配置模型／140</span><br><span class="line">4.3.1 解析HTTP配置的流程／141</span><br><span class="line">4.3.2 HTTP配置模型的内存布局／144</span><br><span class="line">4.3.3 如何合并配置项／147</span><br><span class="line">4.3.4 预设配置项处理方法的工作原理／149</span><br><span class="line">4.4 error日志的用法／150</span><br><span class="line">4.5 请求的上下文／155</span><br><span class="line">4.5.1 上下文与全异步Web服务器的关系／155</span><br><span class="line">4.5.2 如何使用HTTP上下文／156</span><br><span class="line">4.5.3 HTTP框架如何维护上下文结构／157</span><br><span class="line">4.6 小结／158</span><br><span class="line">第5章 访问第三方服务／159</span><br><span class="line">5.1 upstream的使用方式／160</span><br><span class="line">5.1.1 ngx_http_upstream_t结构体／163</span><br><span class="line">5.1.2 设置upstream的限制性参数／164</span><br><span class="line">5.1.3 设置需要访问的第三方服务器地址／165</span><br><span class="line">5.1.4 设置回调方法／166</span><br><span class="line">5.1.5 如何启动upstream机制／166</span><br><span class="line">5.2 回调方法的执行场景／167</span><br><span class="line">5.2.1 create_request回调方法／167</span><br><span class="line">5.2.2 reinit_request回调方法／169</span><br><span class="line">5.2.3 finalize_request回调方法／170</span><br><span class="line">5.2.4 process_header回调方法／171</span><br><span class="line">5.2.5 rewrite_redirect回调方法／172</span><br><span class="line">5.2.6 input_filter_init与input_filter回调方法／172</span><br><span class="line">5.3 使用upstream的示例／173</span><br><span class="line">5.3.1 upstream的各种配置参数／174</span><br><span class="line">5.3.2 请求上下文／175</span><br><span class="line">5.3.3 在create_request方法中构造请求／176</span><br><span class="line">5.3.4 在process_header方法中解析包头／177</span><br><span class="line">5.3.5 在finalize_request方法中释放资源／180</span><br><span class="line">5.3.6 在ngx_http_mytest_handler方法中启动upstream／181</span><br><span class="line">5.4 subrequest的使用方式／183</span><br><span class="line">5.4.1 配置子请求的处理方式／183</span><br><span class="line">5.4.2 实现子请求处理完毕时的回调方法／184</span><br><span class="line">5.4.3 处理父请求被重新激活后的回调方法／185</span><br><span class="line">5.4.4 启动subrequest子请求／185</span><br><span class="line">5.5 subrequest执行过程中的主要场景／186</span><br><span class="line">5.5.1 如何启动subrequest／186</span><br><span class="line">5.5.2 如何转发多个子请求的响应包体／188</span><br><span class="line">5.5.3 子请求如何激活父请求／192</span><br><span class="line">5.6 subrequest使用的例子／193</span><br><span class="line">5.6.1 配置文件中子请求的设置／194</span><br><span class="line">5.6.2 请求上下文／194</span><br><span class="line">5.6.3 子请求结束时的处理方法／195</span><br><span class="line">5.6.4 父请求的回调方法／196</span><br><span class="line">5.6.5 启动subrequest／197</span><br><span class="line">5.7 小结／198</span><br><span class="line">第6章 开发一个简单的HTTP过滤模块／199</span><br><span class="line">6.1 过滤模块的意义／199</span><br><span class="line">6.2 过滤模块的调用顺序／200</span><br><span class="line">6.2.1 过滤链表是如何构成的／200</span><br><span class="line">6.2.2 过滤链表的顺序／203</span><br><span class="line">6.2.3 官方默认HTTP过滤模块的功能简介／204</span><br><span class="line">6.3 HTTP过滤模块的开发步骤／206</span><br><span class="line">6.4 HTTP过滤模块的简单例子／207</span><br><span class="line">6.4.1 如何编写config文件／208</span><br><span class="line">6.4.2 配置项和上下文／208</span><br><span class="line">6.4.3 定义HTTP过滤模块／210</span><br><span class="line">6.4.4 初始化HTTP过滤模块／211</span><br><span class="line">6.4.5 处理请求中的HTTP头部／212</span><br><span class="line">6.4.6 处理请求中的HTTP包体／213</span><br><span class="line">6.5 小结／214</span><br><span class="line">第7章 Nginx提供的高级数据结构／215</span><br><span class="line">7.1 Nginx提供的高级数据结构概述／215</span><br><span class="line">7.2 ngx_queue_t双向链表／217</span><br><span class="line">7.2.1 为什么设计ngx_queue_t双向链表／217</span><br><span class="line">7.2.2 双向链表的使用方法／217</span><br><span class="line">7.2.3 使用双向链表排序的例子／219</span><br><span class="line">7.2.4 双向链表是如何实现的／221</span><br><span class="line">7.3 ngx_array_t动态数组／222</span><br><span class="line">7.3.1 为什么设计ngx_array_t动态数组／223</span><br><span class="line">7.3.2 动态数组的使用方法／223</span><br><span class="line">7.3.3 使用动态数组的例子／225</span><br><span class="line">7.3.4 动态数组的扩容方式／226</span><br><span class="line">7.4 ngx_list_t单向链表／226</span><br><span class="line">7.5 ngx_rbtree_t红黑树／227</span><br><span class="line">7.5.1 为什么设计ngx_rbtree_t红黑树／227</span><br><span class="line">7.5.2 红黑树的特性／228</span><br><span class="line">7.5.3 红黑树的使用方法／230</span><br><span class="line">7.5.4 使用红黑树的简单例子／233</span><br><span class="line">7.5.5 如何自定义添加成员方法／234</span><br><span class="line">7.6 ngx_radix_tree_t基数树／236</span><br><span class="line">7.6.1 ngx_radix_tree_t基数树的原理／236</span><br><span class="line">7.6.2 基数树的使用方法／238</span><br><span class="line">7.6.3 使用基数树的例子／239</span><br><span class="line">7.7 支持通配符的散列表／240</span><br><span class="line">7.7.1 ngx_hash_t基本散列表／240</span><br><span class="line">7.7.2 支持通配符的散列表／243</span><br><span class="line">7.7.3 带通配符散列表的使用例子／250</span><br><span class="line">7.8 小结／254</span><br><span class="line">第三部分 深入Nginx</span><br><span class="line">第8章 Nginx基础架构／256</span><br><span class="line">8.1 Web服务器设计中的关键约束／256</span><br><span class="line">8.2 Nginx的架构设计／259</span><br><span class="line">8.2.1 优秀的模块化设计／259</span><br><span class="line">8.2.2 事件驱动架构／263</span><br><span class="line">8.2.3 请求的多阶段异步处理／264</span><br><span class="line">8.2.4 管理进程、多工作进程设计／267</span><br><span class="line">8.2.5 平台无关的代码实现／268</span><br><span class="line">8.2.6 内存池的设计／268</span><br><span class="line">8.2.7 使用统一管道过滤器模式的HTTP过滤模块／268</span><br><span class="line">8.2.8 其他一些用户模块／269</span><br><span class="line">8.3 Nginx框架中的核心结构体ngx_cycle_t／269</span><br><span class="line">8.3.1 ngx_listening_t结构体／269</span><br><span class="line">8.3.2 ngx_cycle_t结构体／271</span><br><span class="line">8.3.3 ngx_cycle_t支持的方法／273</span><br><span class="line">8.4 Nginx启动时框架的处理流程／275</span><br><span class="line">8.5 worker进程是如何工作的／278</span><br><span class="line">8.6 master进程是如何工作的／281</span><br><span class="line">8.7 小结／286</span><br><span class="line">第9章 事件模块／287</span><br><span class="line">9.1 事件处理框架概述／287</span><br><span class="line">9.2 Nginx事件的定义／290</span><br><span class="line">9.3 Nginx连接的定义／293</span><br><span class="line">9.3.1 被动连接／294</span><br><span class="line">9.3.2 主动连接／297</span><br><span class="line">9.3.3 ngx_connection_t连接池／298</span><br><span class="line">9.4 ngx_events_module核心模块／300</span><br><span class="line">9.4.1 如何管理所有事件模块的配置项／301</span><br><span class="line">9.4.2 管理事件模块／303</span><br><span class="line">9.5 ngx_event_core_module事件模块／305</span><br><span class="line">9.6 epoll事件驱动模块／310</span><br><span class="line">9.6.1 epoll的原理和用法／311</span><br><span class="line">9.6.2 如何使用epoll／313</span><br><span class="line">9.6.3 ngx_epoll_module模块的实现／315</span><br><span class="line">9.7 定时器事件／323</span><br><span class="line">9.7.1 缓存时间的管理／324</span><br><span class="line">9.7.2 缓存时间的精度／326</span><br><span class="line">9.7.3 定时器的实现／327</span><br><span class="line">9.8 事件驱动框架的处理流程／328</span><br><span class="line">9.8.1 如何建立新连接／329</span><br><span class="line">9.8.2 如何解决“惊群”问题／330</span><br><span class="line">9.8.3 如何实现负载均衡／333</span><br><span class="line">9.8.4 post事件队列／334</span><br><span class="line">9.8.5 ngx_process_events_and_timers流程／335</span><br><span class="line">9.9 文件的异步I／O／338</span><br><span class="line">9.9.1 Linux内核提供的文件异步I／O／339</span><br><span class="line">9.9.2 ngx_epoll_module模块中实现的针对文件的异步I／O／342</span><br><span class="line">9.10 小结／346</span><br><span class="line">第10章 HTTP框架的初始化／347</span><br><span class="line">10.1 HTTP框架概述／348</span><br><span class="line">10.2 管理HTTP模块的配置项／351</span><br><span class="line">10.2.1 管理main级别下的配置项／352</span><br><span class="line">10.2.2 管理server级别下的配置项／354</span><br><span class="line">10.2.3 管理location级别下的配置项／357</span><br><span class="line">10.2.4 不同级别配置项的合并／362</span><br><span class="line">10.3 监听端口的管理／367</span><br><span class="line">10.4 server的快速检索／369</span><br><span class="line">10.5 location的快速检索／371</span><br><span class="line">10.6 HTTP请求的11个处理阶段／372</span><br><span class="line">10.6.1 HTTP处理阶段的普适规则／374</span><br><span class="line">10.6.2 NGX_HTTP_POST_READ_PHASE阶段／376</span><br><span class="line">10.6.3 NGX_HTTP_SERVER_REWRITE_PHASE阶段／378</span><br><span class="line">10.6.4 NGX_HTTP_FIND_CONFIG_PHASE阶段／379</span><br><span class="line">10.6.5 NGX_HTTP_REWRITE_PHASE阶段／379</span><br><span class="line">10.6.6 NGX_HTTP_POST_REWRITE_PHASE阶段／379</span><br><span class="line">10.6.7 NGX_HTTP_PREACCESS_PHASE阶段／379</span><br><span class="line">10.6.8 NGX_HTTP_ACCESS_PHASE阶段／380</span><br><span class="line">10.6.9 NGX_HTTP_POST_ACCESS_PHASE阶段／380</span><br><span class="line">10.6.10 NGX_HTTP_TRY_FILES_PHASE阶段／381</span><br><span class="line">10.6.11 NGX_HTTP_CONTENT_PHASE阶段／381</span><br><span class="line">10.6.12 NGX_HTTP_LOG_PHASE阶段／382</span><br><span class="line">10.7 HTTP框架的初始化流程／383</span><br><span class="line">10.8 小结／385</span><br><span class="line">第11章 HTTP框架的执行流程／386</span><br><span class="line">11.1 HTTP框架执行流程概述／387</span><br><span class="line">11.2 新连接建立时的行为／388</span><br><span class="line">11.3 第一次可读事件的处理／390</span><br><span class="line">11.4 接收HTTP请求行／396</span><br><span class="line">11.5 接收HTTP头部／399</span><br><span class="line">11.6 处理HTTP请求／403</span><br><span class="line">11.6.1 ngx_http_core_generic_phase／409</span><br><span class="line">11.6.2 ngx_http_core_rewrite_phase／411</span><br><span class="line">11.6.3 ngx_http_core_access_phase／412</span><br><span class="line">11.6.4 ngx_http_core_content_phase／415</span><br><span class="line">11.7 subrequest与post请求／419</span><br><span class="line">11.8 处理HTTP包体／421</span><br><span class="line">11.8.1 接收包体／422</span><br><span class="line">11.8.2 放弃接收包体／429</span><br><span class="line">11.9 发送HTTP响应／433</span><br><span class="line">11.9.1 ngx_http_send_header／434</span><br><span class="line">11.9.2 ngx_http_output_filter／436</span><br><span class="line">11.9.3 ngx_http_writer／440</span><br><span class="line">11.10 结束HTTP请求／442</span><br><span class="line">11.10.1 ngx_http_close_connection／443</span><br><span class="line">11.10.2 ngx_http_free_request／444</span><br><span class="line">11.10.3 ngx_http_close_request／446</span><br><span class="line">11.10.4 ngx_http_finalize_connection／447</span><br><span class="line">11.10.5 ngx_http_terminate_request／447</span><br><span class="line">11.10.6 ngx_http_finalize_request／448</span><br><span class="line">11.11 小结／452</span><br><span class="line">第12章 upstream机制的设计与实现／453</span><br><span class="line">12.1 upstream机制概述／453</span><br><span class="line">12.1.1 设计目的／454</span><br><span class="line">12.1.2 ngx_http_upstream_t数据结构的意义／456</span><br><span class="line">12.1.3 ngx_http_upstream_conf_t配置结构体／459</span><br><span class="line">12.2 启动upstream／462</span><br><span class="line">12.3 与上游服务器建立连接／464</span><br><span class="line">12.4 发送请求到上游服务器／467</span><br><span class="line">12.5 接收上游服务器的响应头部／470</span><br><span class="line">12.5.1 应用层协议的两段划分方式／470</span><br><span class="line">12.5.2 处理包体的3种方式／471</span><br><span class="line">12.5.3 接收响应头部的流程／473</span><br><span class="line">12.6 不转发响应时的处理流程／476</span><br><span class="line">12.6.1 input_filter方法的设计／477</span><br><span class="line">12.6.2 默认的input_filter方法／478</span><br><span class="line">12.6.3 接收包体的流程／479</span><br><span class="line">12.7 以下游网速优先来转发响应／481</span><br><span class="line">12.7.1 转发响应的包头／482</span><br><span class="line">12.7.2 转发响应的包体／484</span><br><span class="line">12.8 以上游网速优先来转发响应／489</span><br><span class="line">12.8.1 ngx_event_pipe_t结构体的意义／489</span><br><span class="line">12.8.2 转发响应的包头／493</span><br><span class="line">12.8.3 转发响应的包体／495</span><br><span class="line">12.8.4 ngx_event_pipe_read_upstream方法／498</span><br><span class="line">12.8.5 ngx_event_pipe_write_to_downstream方法／502</span><br><span class="line">12.9 结束upstream请求／504</span><br><span class="line">12.10 小结／508</span><br><span class="line">第13章 邮件代理模块／509</span><br><span class="line">13.1 邮件代理服务器的功能／509</span><br><span class="line">13.2 邮件模块的处理框架／512</span><br><span class="line">13.2.1 一个请求的8个独立处理阶段／512</span><br><span class="line">13.2.2 邮件类模块的定义／514</span><br><span class="line">13.2.3 邮件框架的初始化／516</span><br><span class="line">13.3 初始化请求／517</span><br><span class="line">13.3.1 描述邮件请求的ngx_mail_session_t结构体／517</span><br><span class="line">13.3.2 初始化邮件请求的流程／519</span><br><span class="line">13.4 接收并解析客户端请求／520</span><br><span class="line">13.5 邮件认证／520</span><br><span class="line">13.5.1 ngx_mail_auth_http_ctx_t结构体／520</span><br><span class="line">13.5.2 与认证服务器建立连接／522</span><br><span class="line">13.5.3 发送请求到认证服务器／522</span><br><span class="line">13.5.4 接收并解析响应／525</span><br><span class="line">13.6 与上游邮件服务器间的认证交互／526</span><br><span class="line">13.6.1 ngx_mail_proxy_ctx_t结构体／526</span><br><span class="line">13.6.2 向上游邮件服务器发起连接／527</span><br><span class="line">13.6.3 与邮件服务器认证交互的过程／528</span><br><span class="line">13.7 透传上游邮件服务器与客户端间的流／530</span><br><span class="line">13.8 小结／535</span><br><span class="line">第14章 进程间的通信机制／536</span><br><span class="line">14.1 概述／536</span><br><span class="line">14.2 共享内存／536</span><br><span class="line">14.3 原子操作／541</span><br><span class="line">14.3.1 不支持原子库下的原子操作／541</span><br><span class="line">14.3.2 x86架构下的原子操作／542</span><br><span class="line">14.3.3 自旋锁／545</span><br><span class="line">14.4 Nginx频道／546</span><br><span class="line">14.5 信号／549</span><br><span class="line">14.6 信号量／551</span><br><span class="line">14.7 文件锁／553</span><br><span class="line">14.8 互斥锁／556</span><br><span class="line">14.8.1 文件锁实现的ngx_shmtx_t锁／558</span><br><span class="line">14.8.2 原子变量实现的ngx_shmtx_t锁／560</span><br><span class="line">14.9 小结／565</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00BXTR5O6/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00BXTR5O6&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/516r9ozoZTL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据:正在到来的数据革命,以及它如何改变政府、商业与我们的生活</title>
    <url>/2020/04/19/B00CBO13MW/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 大数据:正在到来的数据革命,以及它如何改变政府、商业与我们的生活<br>作者信息： 作者: 涂子沛 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《大数据:正在到来的数据革命,以及它如何改变政府、商业与我们的生活》编辑推荐：中国+美国，两国要人推荐，持续畅销，领跑大数据时代最好的书——中国高层人物汪洋+奥巴马总统大选亚裔事务顾问、美国华人全国委员会会长、凤凰卫视时事评论员薛海培+英特尔全球副总裁、中国区总裁杨叙+中国互联网发展的重要参与者、知名IT评论人谢文+中国房地产风云人物任志强+史学大家、匹兹堡大学历史系荣誉讲座教授许倬云+中美10大高校著名学者……<br>这里有“中国对手”——大数据浪潮，汹涌来袭。20世纪大萧条以来，美国作为世界强国的开放历史，数据技术浪潮的兴起过程，气势磅礴，波澜壮阔。真正读懂中国趋势，一定要先读懂美国。美国政府为什么能，中国到底缺什么？<br>这里有“中国建言”——哈佛大学商学院访问教授、全球顶尖的管理咨询大师达文波特，把脉经济，数据治国，专门为中国政经两界提示智库建言：“在很多领域，中国政府和中国的企业都有雄心勃勃的计划，这引起了全世界的关注，这些雄心和计划，现在应该拓展到大数据的领域。”<br>这里有“中国财富”——现代管理学之父德鲁克有言，预测未来最好的方法，就是去创造未来。商务智能、云计算、Facebook、推特、Web3.0、语义网……数据战争，就是未来之争！数据兴则企业兴，数据强则企业强！叫醒中国，超越中国模式的粗放式增长，迈向精细化的管理革命，大数据将是下一个社会发展阶段的“石油”和“金矿”。<br>这里有“中国致敬”——活着就为改变世界，只有偏执狂才能生存，不要以为乔布斯、盖茨、扎克伯格才这样。美国之为美国，还有坚持信息自由的新闻记者、发现摩尔定律的工程师、定义数据仓库的实业家、首倡普适计算的业余鼓手、鼓吹财政公开的民间活动家、倡导数据开放运动的青年学生，以及活跃在无数公民自治组织的普通个人。<br>这里有“中国问题”——回望中国，胡适批评“差不多先生”，黄仁宇求索“数目字管理”，我们的世界看起来雷打不动。大数据时代，挑战中国，摘不下“差不多先生”的文化标签，我们世界工厂还将是一个落后的100年！<br>这里有“中国乡愁”——大数据战略，重新洗牌全球格局：美国，再一次领跑世界；中国，却很可能再失良机而浑然不知！中国迷局如何解开？最具海归视野、近20年中美职业生涯的作者，从太平洋对面看到中美两国的差距，披露大量美国真实案例，最先为华文世界开启大数据重要话题，写成这本意在兴邦治国的战略之书，图文并茂，老百姓也看得懂。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">序言一大数据：为华文世界提出一个重要话题／许倬云</span><br><span class="line">序言二中国的雄心应该拓展到大数据领域／托马斯·H·达文波特</span><br><span class="line">序幕新总统的第一天</span><br><span class="line">一人一票：把“黑”人送进“白”宫</span><br><span class="line">大国新政：阳光是最好的防腐剂</span><br><span class="line">上篇帝国风云：得数据者得天下——美国的成功经验</span><br><span class="line">第一章历史争战《信息自由法》</span><br><span class="line">第四股力量：知情权的起点</span><br><span class="line">国会议员：孤独的战争</span><br><span class="line">白宫当家人：一个妥协者和机动者</span><br><span class="line">政府VS.社会：旧剧情重现新时代</span><br><span class="line">第二章数据帝国的兴起</span><br><span class="line">摩尔定律：全世界半个世纪的发展规律</span><br><span class="line">最小数据集：上升到立法高度的开路先锋</span><br><span class="line">民意几时有：选票催生的创新</span><br><span class="line">普适计算：计算机本身将从人们的视线中消失</span><br><span class="line">“大数据”战略：争夺全世界的下一个前沿</span><br><span class="line">第三章数据治国</span><br><span class="line">循“数”管理：平安大道怎样铺</span><br><span class="line">数据“验”平权：民权史上的碑石</span><br><span class="line">数据“打”假：最大的争议就是福利滥用</span><br><span class="line">CompStat：街头警察的创新传奇</span><br><span class="line">第四章商务智能的前世今生</span><br><span class="line">起源：从数据到知识的挑战和跨越</span><br><span class="line">结蛹：数据仓库之厚积薄发</span><br><span class="line">蚕动：联机分析之惊艳</span><br><span class="line">破茧：数据挖掘之智能生命的产生</span><br><span class="line">化蝶：数据可视化的华丽上演</span><br><span class="line">中篇法则博弈：大数据时代的发展与危机</span><br><span class="line">第五章帝国的法则</span><br><span class="line">收集法则：减负，为人民减负</span><br><span class="line">使用法则：隐私，文明社会的共识</span><br><span class="line">发布法则：免费，人民已经交税</span><br><span class="line">管理法则：质量，互联网时代的根本</span><br><span class="line">第六章《数据质量法》的困局</span><br><span class="line">产业界“俘虏”政府：数据背后的政经战争</span><br><span class="line">美式“旋转门”：权、名、利大串场</span><br><span class="line">“掺沙子”法案：国会对付总统的独门秘器</span><br><span class="line">环保“风险门”：公共利益常常无人代表</span><br><span class="line">集体行动的逻辑：人人都想“搭便车”</span><br><span class="line">三权之歧：什么是真正的“和谐”</span><br><span class="line">第七章全国隐私风波</span><br><span class="line">《一九八四》：零隐私的恐惧</span><br><span class="line">大数据就是“老大哥”：中央数据银行之争</span><br><span class="line">百年纠结：统一身份证</span><br><span class="line">“9·11”大拐点：以反恐的名义向左转</span><br><span class="line">万维信息触角计划：追踪恐怖分子的“数据脚印”</span><br><span class="line">6种改变政府的力量：山姆大叔大退让</span><br><span class="line">下篇公民故事：公民社会与数据互动之双赢时代</span><br><span class="line">第八章数据开放运动</span><br><span class="line">一个新的世界：从软件开源到数据开放</span><br><span class="line">总统的雄心：公共财政支出透明</span><br><span class="line">数据民主：印裔首席信息官的崛起</span><br><span class="line">Data.Gov：从旗舰初航到保“数”运动</span><br><span class="line">大众创新：航班延误之候机经济学</span><br><span class="line">第九章试金石：白宫访客记录</span><br><span class="line">总统在见谁：大医改中的“小”插曲</span><br><span class="line">全体美国人的房子：白宫</span><br><span class="line">步步妥协：总统与草根的对决</span><br><span class="line">从白宫安保到政治监督：执著的公民改变世界</span><br><span class="line">第十章矿难中的歌声和数据</span><br><span class="line">集体行动的号角：你站在哪一边</span><br><span class="line">可以避免的悲剧：数据揭示的全景式真相</span><br><span class="line">默认公开推定：和矿难赛跑的原则</span><br><span class="line">唯一的道路：民主时时都要“争”</span><br><span class="line">外篇天下趋势：大数据社会未来之世界走向</span><br><span class="line">第十一章大趋势</span><br><span class="line">数据权：大不列颠的硕果</span><br><span class="line">大合流：国际开放联盟</span><br><span class="line">云计算：新的航向</span><br><span class="line">再造互联网：从网页相连到数据相“联”</span><br><span class="line">第十二章大挑战</span><br><span class="line">逐鹿政坛：得数据者得天下</span><br><span class="line">数据竞争：企业赢之道</span><br><span class="line">下一波浪潮：从大数据到大社会</span><br><span class="line">第十三章大变革（2.0升级版新增）</span><br><span class="line">微学位：教育领域正在发生的革命</span><br><span class="line">大数据：再谈教育领域正在发生的革命</span><br><span class="line">微学校：三谈教育领域正在发生的革命</span><br><span class="line">尾声挑战中国：摘下“差不多先生”的文化标签</span><br><span class="line">大事记20世纪大萧条后美国信息开放、技术创新之路</span><br><span class="line">后记搭建“大数据”的世界</span><br><span class="line">建言中国如何应对大数据时代的挑战（2.0升级版新增）</span><br><span class="line">访谈大数据时代的“中国梦”（2.0升级版新增）</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00CBO13MW/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00CBO13MW&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41%2BQS6a5nUL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵程序设计丛书 图解TCP/IP(第5版)</title>
    <url>/2020/04/19/B00DMS9990/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 图灵程序设计丛书 图解TCP/IP(第5版)<br>作者信息： 作者: 竹下隆史 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《图解TCP/IP(第5版)》原版畅销36万册，是TCP/IP圣经级教材，268张图解轻松入门TCP/IP。这是一本图文并茂的网络管理技术书籍，旨在让广大读者理解TCP/IP的基本知识、掌握TCP/IP的基本技能。 《图解TCP/IP(第5版)》中讲解了网络基础知识、TCP/IP基础知识、数据链路、IP协议、IP协议相关技术、TCP与UDP、路由协议、应用协议、网络安全等内容，引导读者了解和掌握TCP/IP，营造一个安全的、使用放心的网络环境。《图解TCP/IP(第5版)》适合计算机网络的开发、管理人员阅读，也可作为大专院校相关专业的教学参考书。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 网络基础知识 1</span><br><span class="line">1.1 计算机网络出现的背景 2</span><br><span class="line">1.1.1 计算机的普及与多样化 2</span><br><span class="line">1.1.2 从独立模式到网络互连模式 2</span><br><span class="line">1.1.3 从计算机通信到信息通信 3</span><br><span class="line">1.1.4 计算机网络的作用 4</span><br><span class="line">1.2 计算机与网络发展的7个阶段 5</span><br><span class="line">1.2.1 批处理 5</span><br><span class="line">1.2.2 分时系统 5</span><br><span class="line">1.2.3 计算机之间的通信 6</span><br><span class="line">1.2.4 计算机网络的产生 7</span><br><span class="line">1.2.5 互联网的普及 8</span><br><span class="line">1.2.6 以互联网技术为中心的时代 9</span><br><span class="line">1.2.7 从“单纯建立连接”到“安全建立连接” 9</span><br><span class="line">1.2.8 手握金刚钻的TCP&#x2F;IP 10</span><br><span class="line">1.3 协议 11</span><br><span class="line">1.3.1 随处可见的协议 11</span><br><span class="line">1.3.2 协议的必要性 11</span><br><span class="line">1.3.3 协议如同人与人的对话 12</span><br><span class="line">1.3.4 计算机中的协议 13</span><br><span class="line">1.3.5 分组交换协议 14</span><br><span class="line">1.4 协议由谁规定 15</span><br><span class="line">1.4.1 计算机通信的诞生及其标准化 15</span><br><span class="line">1.4.2 协议的标准化 15</span><br><span class="line">1.5 协议分层与OSI参考模型 17</span><br><span class="line">1.5.1 协议的分层 17</span><br><span class="line">1.5.2 通过对话理解分层 17</span><br><span class="line">1.5.3 OSI参考模型 </span><br><span class="line">1.5.4 OSI参考模型中各个分层的作用 20</span><br><span class="line">1.6 OSI参考模型通信处理举例 22</span><br><span class="line">1.6.1 7层通信 22</span><br><span class="line">1.6.2 会话层以上的处理 22</span><br><span class="line">1.6.3 传输层以下的处理 25</span><br><span class="line">1.7 传输方式的分类 29</span><br><span class="line">1.7.1 面向有连接型与面向无连接型 29</span><br><span class="line">1.7.2 电路交换与分组交换 30</span><br><span class="line">1.7.3 根据接收端数量分类 32</span><br><span class="line">1.8 地址 34</span><br><span class="line">1.8.1 地址的唯一性 34</span><br><span class="line">1.8.2 地址的层次性 35</span><br><span class="line">1.9 网络的构成要素 37</span><br><span class="line">1.9.1 通信媒介与数据链路 37</span><br><span class="line">1.9.2 网卡 39</span><br><span class="line">1.9.3 中继器 39</span><br><span class="line">1.9.4 网桥&#x2F;2层交换机 40</span><br><span class="line">1.9.5 路由器&#x2F;3层交换机 42</span><br><span class="line">1.9.6 4～～7层交换机 42</span><br><span class="line">1.9.7 网关 43</span><br><span class="line">1.10 现代网络实态 45</span><br><span class="line">1.10.1 网络的构成 45</span><br><span class="line">1.10.2 互联网通信 47</span><br><span class="line">1.10.3 移动通信 47</span><br><span class="line">1.10.4 从信息发布者的角度看网络 49</span><br><span class="line">第2章 TCP&#x2F;IP基础知识 51</span><br><span class="line">2.1 TCP&#x2F;IP出现的背景及其历史 52</span><br><span class="line">2.1.1 从军用技术的应用谈起 52</span><br><span class="line">2.1.2 ARPANET的诞生 53</span><br><span class="line">2.1.3 TCP&#x2F;IP的诞生 53</span><br><span class="line">2.1.4 UNIX系统的普及与互联网的扩张 54</span><br><span class="line">2.1.5 商用互联网服务的启蒙 54</span><br><span class="line">2.2 TCP&#x2F;IP的标准化 55</span><br><span class="line">2.2.1 TCP&#x2F;IP的具体含义 55</span><br><span class="line">2.2.2 TCP&#x2F;IP标准化精髓 55</span><br><span class="line">2.2.3 TCP&#x2F;IP规范——RFC 56</span><br><span class="line">2.2.4 TCP&#x2F;IP的标准化流程 58</span><br><span class="line">2.2.5 RFC的获取方法 59</span><br><span class="line">2.3 互联网基础知识 61</span><br><span class="line">2.3.1 互联网定义 61</span><br><span class="line">2.3.2 互联网与TCP&#x2F;IP的关系 61</span><br><span class="line">2.3.3 互联网的结构 61</span><br><span class="line">2.3.4 ISP和区域网 62</span><br><span class="line">2.4 TCP&#x2F;IP协议分层模型 64</span><br><span class="line">2.4.1 TCP&#x2F;IP与OSI参考模型 64</span><br><span class="line">2.4.2 硬件（物理层） 64</span><br><span class="line">2.4.3 网络接口层（数据链路层） 65</span><br><span class="line">2.4.4 互联网层（网络层） 65</span><br><span class="line">2.4.5 传输层 66</span><br><span class="line">2.4.6 应用层（会话层以上的分层） 66</span><br><span class="line">2.5 TCP&#x2F;IP分层模型与通信示例 70</span><br><span class="line">2.5.1 数据包首部 70</span><br><span class="line">2.5.2 发送数据包 71</span><br><span class="line">2.5.3 经过数据链路的包 72</span><br><span class="line">2.5.4 数据包接收处理 73</span><br><span class="line">第3章 数据链路 75</span><br><span class="line">3.1 数据链路的作用 76</span><br><span class="line">3.2 数据链路相关技术 78</span><br><span class="line">3.2.1 MAC地址 78</span><br><span class="line">3.2.2 共享介质型网络 79</span><br><span class="line">3.2.3 非共享介质网络 82</span><br><span class="line">3.2.4 根据MAC地址转发 84</span><br><span class="line">3.2.5 环路检测技术 85</span><br><span class="line">3.2.6 VLAN 87</span><br><span class="line">3.3 以太网 89</span><br><span class="line">3.3.1 以太网连接形式 89</span><br><span class="line">3.3.2 以太网的分类 90</span><br><span class="line">3.3.3 以太网的历史 91</span><br><span class="line">3.3.4 以太网帧格式 92</span><br><span class="line">3.4 无线通信 96</span><br><span class="line">3.4.1 无线通信的种类 96</span><br><span class="line">3.4.2 IEEE802.11 96</span><br><span class="line">3.4.3 IEEE802.11b和IEEE802.11g 98</span><br><span class="line">3.4.4 IEEE802.11a 98</span><br><span class="line">3.4.5 IEEE802.11n 98</span><br><span class="line">3.4.6 使用无线LAN时的注意事项 99</span><br><span class="line">3.4.7 蓝牙 99</span><br><span class="line">3.4.8 WiMAX 99</span><br><span class="line">3.4.9 ZigBee 100</span><br><span class="line">3.5 PPP 101</span><br><span class="line">3.5.1 PPP定义 101</span><br><span class="line">3.5.2 LCP与NCP 101</span><br><span class="line">3.5.3 PPP的帧格式 102</span><br><span class="line">3.5.4 PPPoE 102</span><br><span class="line">3.6 其他数据链路 103</span><br><span class="line">3.6.1 ATM 103</span><br><span class="line">3.6.2 POS 106</span><br><span class="line">3.6.3 FDDI 106</span><br><span class="line">3.6.4 TokenRing 107</span><br><span class="line">3.6.5 100VG—AnyLAN 107</span><br><span class="line">3.6.6 光纤通道 107</span><br><span class="line">3.6.7 HIPPI 107</span><br><span class="line">3.6.8 IEEE1394 108</span><br><span class="line">3.6.9 HDMI 108</span><br><span class="line">3.6.10 iSCSI 108</span><br><span class="line">3.6.11 InfiniBand 108</span><br><span class="line">3.6.12 DOCSIS 108</span><br><span class="line">3.6.13 高速PLC 108</span><br><span class="line">3.7 公共网络110</span><br><span class="line">3.7.1 模拟电话线路 110</span><br><span class="line">3.7.2 移动通信服务 110</span><br><span class="line">3.7.3 ADSL 110</span><br><span class="line">3.7.4 FTTH 111</span><br><span class="line">3.7.5 有线电视 112</span><br><span class="line">3.7.6 专线 112</span><br><span class="line">3.7.7 VPN 113</span><br><span class="line">3.7.8 公共无线LAN 113</span><br><span class="line">3.7.9 其他公共无线通信服务 114</span><br><span class="line">第4章 IP协议 115</span><br><span class="line">4.1 IP即网际协议 116</span><br><span class="line">4.1.1 IP相当于OSI参考模型的第3层 116</span><br><span class="line">4.1.2 网络层与数据链路层的关系 116</span><br><span class="line">4.2 IP基础知识 118</span><br><span class="line">4.2.1 IP地址属于网络层地址 118</span><br><span class="line">4.2.2 路由控制 118</span><br><span class="line">4.2.3 数据链路的抽象化 121</span><br><span class="line">4.2.4 IP属于面向无连接型 122</span><br><span class="line">4.3 IP地址的基础知识 124</span><br><span class="line">4.3.1 IP地址的定义 124</span><br><span class="line">4.3.2 IP地址由网络和主机两部分标识组成 124</span><br><span class="line">4.3.3 IP地址的分类 126</span><br><span class="line">4.3.4 广播地址 127</span><br><span class="line">4.3.5 IP多播 128</span><br><span class="line">4.3.6 子网掩码 130</span><br><span class="line">4.3.7 CIDR与VLSM 132</span><br><span class="line">4.3.8 全局地址与私有地址 133</span><br><span class="line">4.3.9 全局地址由谁决定 133</span><br><span class="line">4.4 路由控制 137</span><br><span class="line">4.4.1 IP地址与路由控制 137</span><br><span class="line">4.4.2 路由控制表的聚合 138</span><br><span class="line">4.5 IP分割处理与再构成处理 140</span><br><span class="line">4.5.1 数据链路不同，MTU则相异 140</span><br><span class="line">4.5.2 IP报文的分片与重组 140</span><br><span class="line">4.5.3 路径MTU发现 141</span><br><span class="line">4.6 IPv6 144</span><br><span class="line">4.6.1 IPv6的必要性 144</span><br><span class="line">4.6.2 IPv6的特点 144</span><br><span class="line">4.6.3 IPv6中IP地址的标记方法 144</span><br><span class="line">4.6.4 IPv6地址的结构 145</span><br><span class="line">4.6.5 全局单播地址 146</span><br><span class="line">4.6.6 链路本地单播地址 147</span><br><span class="line">4.6.7 唯一本地地址 147</span><br><span class="line">4.6.8 IPv6分段处理 147</span><br><span class="line">4.7 IPv4首部 148</span><br><span class="line">4.8 IPv6首部格式 153</span><br><span class="line">第5章 IP协议相关技术 157</span><br><span class="line">5.1 仅凭IP无法完成通信 158</span><br><span class="line">5.2 DNS 159</span><br><span class="line">5.2.1 IP地址不便记忆 159</span><br><span class="line">5.2.2 DNS的产生 159</span><br><span class="line">5.2.3 域名的构成 160</span><br><span class="line">5.2.4 DNS查询 163</span><br><span class="line">5.2.5 DNS如同互联网中的分布式数据库 163</span><br><span class="line">5.3 ARP 165</span><br><span class="line">5.3.1 ARP概要 165</span><br><span class="line">5.3.2 ARP的工作机制 165</span><br><span class="line">5.3.3 IP地址和MAC地址缺一不可？ 166</span><br><span class="line">5.3.4 RARP 167</span><br><span class="line">5.3.5 代理ARP 168</span><br><span class="line">5.4 ICMP 169</span><br><span class="line">5.4.1 辅助IP的ICMP 169</span><br><span class="line">5.4.2 主要的ICMP消息 170</span><br><span class="line">5.4.3 其他ICMP消息 173</span><br><span class="line">5.4.4 ICMPv6 173</span><br><span class="line">5.5 DHCP 176</span><br><span class="line">5.5.1 DHCP实现即插即用 176</span><br><span class="line">5.5.2 DHCP的工作机制 176</span><br><span class="line">5.5.3 DHCP中继代理 177</span><br><span class="line">5.6 NAT 179</span><br><span class="line">5.6.1 NAT定义 179</span><br><span class="line">5.6.2 NAT的工作机制 179</span><br><span class="line">5.6.3 NAT—PT（NAPT—PT） 180</span><br><span class="line">5.6.4 NAT的潜在问题 181</span><br><span class="line">5.6.5 解决NAT的潜在问题与NAT穿越 181</span><br><span class="line">5.7 IP隧道 183</span><br><span class="line">5.8 其他IP相关技术 185</span><br><span class="line">5.8.1 IP多播相关技术 185</span><br><span class="line">5.8.2 IP任播 186</span><br><span class="line">5.8.3 通信质量控制 187</span><br><span class="line">5.8.4 显式拥塞通知 189</span><br><span class="line">5.8.5 MobileIP 190</span><br><span class="line">第6章 TCP与UDP 193</span><br><span class="line">6.1 传输层的作用 194</span><br><span class="line">6.1.1 传输层定义 194</span><br><span class="line">6.1.2 通信处理 195</span><br><span class="line">6.1.3 两种传输层协议TCP和UDP 195</span><br><span class="line">6.1.4 TCP与UDP区分 196</span><br><span class="line">6.2 端口号 197</span><br><span class="line">6.2.1 端口号定义 197</span><br><span class="line">6.2.2 根据端口号识别应用 197</span><br><span class="line">6.2.3 通过IP地址、端口号、协议号进行通信识别 197</span><br><span class="line">6.2.4 端口号如何确定 198</span><br><span class="line">6.2.5 端口号与协议 199</span><br><span class="line">6.3 UDP 202</span><br><span class="line">6.4 TCP 203</span><br><span class="line">6.4.1 TCP的特点及其目的 204</span><br><span class="line">6.4.2 通过序列号与确认应答提高可靠性 204</span><br><span class="line">6.4.3 重发超时如何确定 206</span><br><span class="line">6.4.4 连接管理 207</span><br><span class="line">6.4.5 TCP以段为单位发送数据 208</span><br><span class="line">6.4.6 利用窗口控制提高速度 209</span><br><span class="line">6.4.7 窗口控制与重发控制 211</span><br><span class="line">6.4.8 流控制 212</span><br><span class="line">6.4.9 拥塞控制 213</span><br><span class="line">6.4.10 提高网络利用率的规范 215</span><br><span class="line">6.4.11 使用TCP的应用 217</span><br><span class="line">6.5 其他传输层协议 218</span><br><span class="line">6.5.1 UDP—Lite 218</span><br><span class="line">6.5.2 SCTP 218</span><br><span class="line">6.5.3 DCCP 219</span><br><span class="line">6.6 UDP首部的格式 220</span><br><span class="line">6.7 TCP首部格式 222</span><br><span class="line">第7章 路由协议 227</span><br><span class="line">7.1 路由控制的定义 228</span><br><span class="line">7.1.1 IP地址与路由控制 228</span><br><span class="line">7.1.2 静态路由与动态路由 228</span><br><span class="line">7.1.3 动态路由的基础 229</span><br><span class="line">7.2 路由控制范围 230</span><br><span class="line">7.2.1 接入互联网的各种组织机构 230</span><br><span class="line">7.2.2 自治系统与路由协议 230</span><br><span class="line">7.2.3 IGP与EGP 231</span><br><span class="line">7.3 路由算法 232</span><br><span class="line">7.3.1 距离向量算法 232</span><br><span class="line">7.3.2 链路状态算法 232</span><br><span class="line">7.3.3 主要路由协议 233</span><br><span class="line">7.4 RIP 234</span><br><span class="line">7.4.1 广播路由控制信息 234</span><br><span class="line">7.4.2 根据距离向量确定路由 234</span><br><span class="line">7.4.3 使用子网掩码时的RIP处理 235</span><br><span class="line">7.4.4 RIP中路由变更时的处理 236</span><br><span class="line">7.4.5 RIP2 239</span><br><span class="line">7.5 OSPF 240</span><br><span class="line">7.5.1 OSPF是链路状态型路由协议 240</span><br><span class="line">7.5.2 OSPF基础知识 241</span><br><span class="line">7.5.3 OSPF工作原理概述 242</span><br><span class="line">7.5.4 将区域分层化进行细分管理 243</span><br><span class="line">7.6 BGP 245</span><br><span class="line">7.6.1 BGP与AS号 245</span><br><span class="line">7.6.2 BGP是路径向量协议 246</span><br><span class="line">7.7 MPLS 248</span><br><span class="line">7.7.1 MPLS的网络基本动作 249</span><br><span class="line">7.7.2 MPLS的优点 250</span><br><span class="line">第8章 应用协议 251</span><br><span class="line">8.1 应用层协议概要 252</span><br><span class="line">8.2 远程登录 253</span><br><span class="line">8.2.1 TELNET 253</span><br><span class="line">8.2.2 SSH 255</span><br><span class="line">8.3 文件传输 256</span><br><span class="line">8.4 电子邮件 260</span><br><span class="line">8.4.1 电子邮件的工作机制 260</span><br><span class="line">8.4.2 邮件地址 261</span><br><span class="line">8.4.3 MIME 262</span><br><span class="line">8.4.4 SMTP 263</span><br><span class="line">8.4.5 POP 265</span><br><span class="line">8.4.6 IMAP 267</span><br><span class="line">8.5 WWW 268</span><br><span class="line">8.5.1 互联网的蓬勃发展 268</span><br><span class="line">8.5.2 WWW基本概念 268</span><br><span class="line">8.5.3 URI 269</span><br><span class="line">8.5.4 HTML 270</span><br><span class="line">8.5.5 HTTP 272</span><br><span class="line">8.5.6 JavaScript、CGI、Cookie 274</span><br><span class="line">8.6 网络管理 276</span><br><span class="line">8.6.1 SNMP 276</span><br><span class="line">8.6.2 MIB 277</span><br><span class="line">8.6.3 RMON 278</span><br><span class="line">8.6.4 SNMP应用举例 278</span><br><span class="line">8.7 其他应用层协议 280</span><br><span class="line">8.7.1 多媒体通信实现技术 280</span><br><span class="line">8.7.2 P2P 283</span><br><span class="line">8.7.3 LDAP 283</span><br><span class="line">第9章 网络安全 285</span><br><span class="line">9.1 TCP&#x2F;IP与网络安全 286</span><br><span class="line">9.2 网络安全构成要素 287</span><br><span class="line">9.2.1 防火墙 287</span><br><span class="line">9.2.2 IDS（入侵检测系统） 288</span><br><span class="line">9.2.3 反病毒&#x2F;个人防火墙 288</span><br><span class="line">9.3 加密技术基础 290</span><br><span class="line">9.3.1 对称密码体制与公钥密码体制 290</span><br><span class="line">9.3.2 身份认证技术 291</span><br><span class="line">9.4 安全协议 293</span><br><span class="line">9.4.1 IPsec与VPN 293</span><br><span class="line">9.4.2 TLS&#x2F;SSL与HTTPS 294</span><br><span class="line">9.4.3 IEEE802.1X 294</span><br><span class="line">附录 297</span><br><span class="line">附1 互联网上便捷的资源 298</span><br><span class="line">附1.1 国际 298</span><br><span class="line">附1.2 日本 299</span><br><span class="line">附2 IP地址分类（A、B、C类）相关基础知识 300</span><br><span class="line">附2.1 A类 300</span><br><span class="line">附2.2 B类 300</span><br><span class="line">附2.3 C类 301</span><br><span class="line">附3 物理层 302</span><br><span class="line">附3.1 物理层相关基础知识 302</span><br><span class="line">附3.2 0&#x2F;1编码 302</span><br><span class="line">附4 传输介质相关基础知识 304</span><br><span class="line">附4.1 同轴电缆 304</span><br><span class="line">附4.2 双绞线 304</span><br><span class="line">附4.3 光纤电缆 306</span><br><span class="line">附4.4 无线 307</span><br><span class="line">附5 插页导图 309</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00DMS9990/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00DMS9990&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41aYu54xneL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员面试宝典(第4版)</title>
    <url>/2020/04/19/B00E3ENQNM/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 程序员面试宝典(第4版)<br>作者信息： 作者: 欧立奇 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>历经前３版不断完善，前后二十多次重印，数年各大图书排行榜顶尖荣耀！第4版在保留原书数据结构，程序设计等主干的基础上，大量地更新了程序面试题目，取材于2012年至2013年各大公司面试题，替换了原版的大量面试题，以反映自第 3版以来两年多的时间内所发生的变化。并且修正了两年多以来读者反馈的书中的一些错误和描述不当的地方，以帮助求职者们更好地处理一些新问题，新变化。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1部分求职过程</span><br><span class="line">第1章应聘求职2</span><br><span class="line">1.1渠道2</span><br><span class="line">1.2流程3</span><br><span class="line">第2章简历书写4</span><br><span class="line">2.1简历注意事项4</span><br><span class="line">2.2简历模板8</span><br><span class="line">第3章求职五步曲11</span><br><span class="line">3.1笔试11</span><br><span class="line">3.2电话面试14</span><br><span class="line">3.3面试15</span><br><span class="line">3.4签约16</span><br><span class="line">3.5违约20</span><br><span class="line">第4章职业生涯发展规划22</span><br><span class="line">4.1缺乏工作经验的应届毕业生22</span><br><span class="line">4.2更换工作的程序员们24</span><br><span class="line">4.3快乐的工作25</span><br><span class="line">第2部分C&#x2F;C++程序设计</span><br><span class="line">第5章程序设计基本概念29</span><br><span class="line">5.1赋值语句29</span><br><span class="line">5.2i++31</span><br><span class="line">5.3编程风格33</span><br><span class="line">5.4类型转换34</span><br><span class="line">5.5运算符问题38</span><br><span class="line">5.6a、b交换与比较40</span><br><span class="line">5.7C和C++的关系41</span><br><span class="line">5.8程序设计的其他问题42</span><br><span class="line">第6章预处理、const与sizeof44</span><br><span class="line">6.1宏定义44</span><br><span class="line">6.2const45</span><br><span class="line">6.3sizeof50</span><br><span class="line">6.4内联函数和宏定义61</span><br><span class="line">第7章指针与引用63</span><br><span class="line">7.1指针基本问题63</span><br><span class="line">7.2传递动态内存65</span><br><span class="line">7.3函数指针74</span><br><span class="line">7.4指针数组和数组指针76</span><br><span class="line">7.5迷途指针79</span><br><span class="line">7.6指针和句柄81</span><br><span class="line">7.7this指针83</span><br><span class="line">第8章循环、递归与概率86</span><br><span class="line">8.1递归基础知识86</span><br><span class="line">8.2典型递归问题89</span><br><span class="line">8.3循环与数组问题91</span><br><span class="line">8.4螺旋队列问题95</span><br><span class="line">8.5概率98</span><br><span class="line">第9章STL模板与容器100</span><br><span class="line">9.1向量容器101</span><br><span class="line">9.2泛型编程105</span><br><span class="line">9.3模板106</span><br><span class="line">第10章面向对象110</span><br><span class="line">10.1面向对象的基本概念110</span><br><span class="line">10.2类和结构113</span><br><span class="line">10.3成员变量114</span><br><span class="line">10.4构造函数和析构函数117</span><br><span class="line">10.5拷贝构造函数和赋值函数119</span><br><span class="line">10.6多态的概念124</span><br><span class="line">10.7友元127</span><br><span class="line">10.8异常129</span><br><span class="line">第11章继承与接口133</span><br><span class="line">11.1覆盖134</span><br><span class="line">11.2私有继承136</span><br><span class="line">11.3虚函数继承和虚继承141</span><br><span class="line">11.4多重继承145</span><br><span class="line">11.5检测并修改不适合的继承148</span><br><span class="line">11.6纯虚函数150</span><br><span class="line">11.7运算符重载与RTTI152</span><br><span class="line">第12章位运算与嵌入式编程160</span><br><span class="line">12.1位制转换160</span><br><span class="line">12.2嵌入式编程169</span><br><span class="line">12.3static176</span><br><span class="line">第3部分数据结构和设计模式</span><br><span class="line">第13章数据结构基础179</span><br><span class="line">13.1单链表179</span><br><span class="line">13.2双链表184</span><br><span class="line">13.3循环链表185</span><br><span class="line">13.4队列186</span><br><span class="line">13.5栈188</span><br><span class="line">13.6堆191</span><br><span class="line">13.7树、图、哈希表201</span><br><span class="line">13.8排序209</span><br><span class="line">13.9时间复杂度222</span><br><span class="line">第14章字符串229</span><br><span class="line">14.1整数字符串转化229</span><br><span class="line">14.2字符数组和strcpy230</span><br><span class="line">14.3数组初始化和数组越界234</span><br><span class="line">14.4数字流和数组声明236</span><br><span class="line">14.5字符串其他问题237</span><br><span class="line">14.6字符子串问题242</span><br><span class="line">第15章设计模式与软件测试244</span><br><span class="line">15.1设计模式245</span><br><span class="line">15.2软件测试基础251</span><br><span class="line">15.3黑盒测试253</span><br><span class="line">15.4白盒测试258</span><br><span class="line">第4部分操作系统、数据库和网络</span><br><span class="line">第16章操作系统265</span><br><span class="line">16.1进程265</span><br><span class="line">16.2线程270</span><br><span class="line">16.3内存管理276</span><br><span class="line">第17章数据库与SQL语言279</span><br><span class="line">17.1数据库理论279</span><br><span class="line">17.2SQL语言283</span><br><span class="line">17.3SQL语言客观题285</span><br><span class="line">17.4SQL语言主观题288</span><br><span class="line">第18章计算机网络及分布式系统294</span><br><span class="line">18.1网络结构294</span><br><span class="line">18.2网络协议问题296</span><br><span class="line">18.3网络安全问题298</span><br><span class="line">18.4网络其他问题300</span><br><span class="line">第5部分综合面试题</span><br><span class="line">第19章英语面试305</span><br><span class="line">19.1面试过程和技巧305</span><br><span class="line">19.2关于工作（AboutJob）307</span><br><span class="line">19.3关于个人（AboutPerson）310</span><br><span class="line">19.4关于未来（AboutFuture）312</span><br><span class="line">第20章电话面试314</span><br><span class="line">20.1电话面试之前的准备工作314</span><br><span class="line">20.2电话面试交流常见问题315</span><br><span class="line">第21章数字类题目分析324</span><br><span class="line">21.1数字规律类题目324</span><br><span class="line">21.2数字填充类题目327</span><br><span class="line">21.3数字运算类题目328</span><br><span class="line">21.4应用数学类题目329</span><br><span class="line">第22章图表类题目分析336</span><br><span class="line">22.1图形变换类题目336</span><br><span class="line">22.2表格分析类题目342</span><br><span class="line">第23章智力类题目分析344</span><br><span class="line">23.1推理类题目344</span><br><span class="line">23.2博弈论346</span><br><span class="line">23.3概率348</span><br><span class="line">第24章无领导小组讨论题目分析351</span><br><span class="line">24.1题目介绍351</span><br><span class="line">24.2无领导小组讨论特点351</span><br><span class="line">24.3无领导小组阶段分析353</span><br><span class="line">24.4无领导小组角色分析357</span><br><span class="line">24.5无领导小组评分标准分析361</span><br><span class="line">24.6群面实录362</span><br><span class="line">附录A面试经历总结366</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00E3ENQNM/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00E3ENQNM&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51lYhI3-3xL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>职场</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言(第3版)</title>
    <url>/2020/04/19/B00EYSPGYE/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 汇编语言(第3版)<br>作者信息： 作者: 王爽 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《汇编语言(第3版)》读者将沿着学习线索来学习一个个知识点，通过一个个检测点，被线索引入到一个个问题分析之中，并完成一个个实验，线索上的每一个教学节点都是后续内容的基础。每一个节点的信息量或难度，又只比前面的多一点，读者在每一步的学习中都会有一种有的放矢的感觉。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 基础知识</span><br><span class="line">1.1 机器语言</span><br><span class="line">1.2 汇编语言的产生</span><br><span class="line">1.3 汇编语言的组成</span><br><span class="line">1.4 存储器</span><br><span class="line">1.5 指令和数据</span><br><span class="line">1.6 存储单元</span><br><span class="line">1.7 CPU对存储器的读写</span><br><span class="line">1.8 地址总线</span><br><span class="line">1.9 数据总线</span><br><span class="line">1.10 控制总线</span><br><span class="line">1.11 内存地址空间（概述）</span><br><span class="line">1.12 主板</span><br><span class="line">1.13 接口卡</span><br><span class="line">1.14 各类存储器芯片</span><br><span class="line">1.15 内存地址空间</span><br><span class="line">第2章 寄存器</span><br><span class="line">2.1通用寄存器</span><br><span class="line">2.2字在寄存器中的存储</span><br><span class="line">2.3几条汇编指令</span><br><span class="line">2.4物理地址</span><br><span class="line">2.516位结构的CPU</span><br><span class="line">2.68086CPU给出物理地址的方法</span><br><span class="line">2.7“段地址×16+偏移地址&#x3D;物理地址”</span><br><span class="line">的本质含义</span><br><span class="line">2.8段的概念</span><br><span class="line">2.9段寄存器</span><br><span class="line">2.10CS和IP</span><br><span class="line">2.11修改CS、IP的指令</span><br><span class="line">2.12代码段</span><br><span class="line">实验1查看CPU和内存，用机器指令</span><br><span class="line">和汇编指令编程</span><br><span class="line">第3章寄存器（内存访问）</span><br><span class="line">3.1内存中字的存储</span><br><span class="line">3.2DS和（address）</span><br><span class="line">3.3字的传送</span><br><span class="line">3.4mov、add、sub指令</span><br><span class="line">3.5数据段</span><br><span class="line">3.6栈</span><br><span class="line">3.7CPU提供的栈机制</span><br><span class="line">3.8栈顶超界的问题</span><br><span class="line">3.9push、pop指令</span><br><span class="line">3.10栈段</span><br><span class="line">实验2用机器指令和汇编指令编程</span><br><span class="line">第4章第一个程序</span><br><span class="line">4.1一个源程序从写出到执行的过程</span><br><span class="line">4.2源程序</span><br><span class="line">4.3编辑源程序</span><br><span class="line">4.4编译</span><br><span class="line">4.5连接</span><br><span class="line">4.6以简化的方式进行编译和连接</span><br><span class="line">4.71.exe的执行</span><br><span class="line">4.8谁将可执行文件中的程序装载进入</span><br><span class="line">内存并使它运行？</span><br><span class="line">4.9程序执行过程的跟踪</span><br><span class="line">实验3编程、编译、连接、跟踪</span><br><span class="line">第5章（BX）和loop指令</span><br><span class="line">5.1（BX）</span><br><span class="line">5.2Loop指令</span><br><span class="line">5.3在Debug中跟踪用loop指令实现的</span><br><span class="line">循环程序</span><br><span class="line">5.4Debug和汇编编译器masm对指令的</span><br><span class="line">不同处理</span><br><span class="line">5.5loop和（bx）的联合应用</span><br><span class="line">5.6段前缀</span><br><span class="line">5.7一段安全的空间</span><br><span class="line">5.8段前缀的使用</span><br><span class="line">实验4（bx）和loop的使用</span><br><span class="line">第6章 包含多个段的程序</span><br><span class="line">6.1在代码段中使用数据</span><br><span class="line">6.2在代码段中使用栈</span><br><span class="line">6.3将数据、代码、栈放入不同的段</span><br><span class="line">实验5编写、调试具有多个段的程序</span><br><span class="line">第7章更灵活的定位内存地址的</span><br><span class="line">方法</span><br><span class="line">7.1anol和or指令</span><br><span class="line">7.2关于ASCII码</span><br><span class="line">7.3以字符形式给出的数据</span><br><span class="line">7.4大小写转换的问题</span><br><span class="line">7.5（bx+idata）</span><br><span class="line">7.6用（bx+idata）的方式进行数组的</span><br><span class="line">处理</span><br><span class="line">7.7SI和DI</span><br><span class="line">7.8（bx+si）和（bx+di）</span><br><span class="line">7.9（bx+si+idata）和（bx+di+idata）</span><br><span class="line">7.10不同的寻址方式的灵活应用</span><br><span class="line">实验6实践课程中的程序</span><br><span class="line">第8章数据处理的两个基本问题</span><br><span class="line">8.1bx、si、di和bp</span><br><span class="line">8.2机器指令处理的数据在什么地方</span><br><span class="line">8.3汇编语言中数据位置的表达</span><br><span class="line">8.4寻址方式</span><br><span class="line">8.5指令要处理的数据有多长</span><br><span class="line">8.6寻址方式的综合应用</span><br><span class="line">8.7div指令</span><br><span class="line">8.8伪指令dd</span><br><span class="line">8.9dup</span><br><span class="line">实验7寻址方式在结构化数据访问中的</span><br><span class="line">应用</span><br><span class="line">第9章转移指令的原理</span><br><span class="line">9.1操作符offset</span><br><span class="line">9.2jmp指令</span><br><span class="line">9.3依据位移进行转移的jmp指令</span><br><span class="line">9.4转移的目的地址在指令中的jmp</span><br><span class="line">指令</span><br><span class="line">9.5转移地址在寄存器中的jmp指令</span><br><span class="line">9.6转移地址在内存中的jmp指令</span><br><span class="line">9.7jcxz指令</span><br><span class="line">9.8loop指令</span><br><span class="line">9.9根据位移进行转移的意义</span><br><span class="line">9.10编译器对转移位移超界的检测</span><br><span class="line">实验8分析一个奇怪的程序</span><br><span class="line">实验9根据材料编程</span><br><span class="line">第10章CALL和RET指令</span><br><span class="line">10.1ret和retf</span><br><span class="line">10.2call指令</span><br><span class="line">10.3依据位移进行转移的call指令</span><br><span class="line">10.4转移的目的地址在指令中的call</span><br><span class="line">指令</span><br><span class="line">10.5转移地址在寄存器中的call指令</span><br><span class="line">10.6转移地址在内存中的call指令</span><br><span class="line">10.7call和ret的配合使用</span><br><span class="line">10.8mul指令</span><br><span class="line">10.9模块化程序设计</span><br><span class="line">10.10参数和结果传递的问题</span><br><span class="line">10.11批量数据的传递</span><br><span class="line">10.12寄存器冲突的问题</span><br><span class="line">实验10编写子程序</span><br><span class="line">课程设计1</span><br><span class="line">第11章标志寄存器</span><br><span class="line">11.1ZF标志</span><br><span class="line">11.2PF标志</span><br><span class="line">11.3SF标志</span><br><span class="line">11.4CF标志</span><br><span class="line">11.5OF标志</span><br><span class="line">11.6adc指令</span><br><span class="line">11.7sbb指令</span><br><span class="line">11.8cmp指令</span><br><span class="line">11.9检测比较结果的条件转移指令</span><br><span class="line">11.10DF标志和串传送指令</span><br><span class="line">11.11pushf和popf</span><br><span class="line">11.12标志寄存器在Debug中的表示</span><br><span class="line">实验11编写子程序</span><br><span class="line">第12章内中断</span><br><span class="line">12.1内中断的产生</span><br><span class="line">12.2中断处理程序</span><br><span class="line">12.3中断向量表</span><br><span class="line">12.4中断过程</span><br><span class="line">12.5中断处理程序和iret指令</span><br><span class="line">12.6除法错误中断的处理</span><br><span class="line">12.7编程处理0号中断</span><br><span class="line">12.8安装</span><br><span class="line">12.9do0</span><br><span class="line">12.10设置中断向量</span><br><span class="line">12.11单步中断</span><br><span class="line">12.12响应中断的特殊情况</span><br><span class="line">实验12编写0号中断的处理程序</span><br><span class="line">第13章int指令</span><br><span class="line">13.1int指令</span><br><span class="line">13.2编写供应用程序调用的</span><br><span class="line">中断例程</span><br><span class="line">13.3对int、iret和栈的深入理解</span><br><span class="line">13.4BIOS和DOS所提供的</span><br><span class="line">中断例程</span><br><span class="line">13.5BIOS和DOS中断例程的</span><br><span class="line">安装过程</span><br><span class="line">13.6BIOS中断例程应用</span><br><span class="line">13.7DOS中断例程应用</span><br><span class="line">实验13编写、应用中断例程</span><br><span class="line">第14章端口</span><br><span class="line">14.1端口的读写</span><br><span class="line">14.2CMOS RAM芯片</span><br><span class="line">14.3shl和shr指令</span><br><span class="line">14.4CMOS RAM中存储的时间信息</span><br><span class="line">实验14访问CMOS RAM</span><br><span class="line">第15章外中断</span><br><span class="line">15.1接口芯片和端口</span><br><span class="line">15.2外中断信息</span><br><span class="line">15.3PC机键盘的处理过程</span><br><span class="line">15.4编写int 9中断例程</span><br><span class="line">15.5安装新的int 9中断例程</span><br><span class="line">实验15安装新的int 9中断例程</span><br><span class="line">第16章直接定址表</span><br><span class="line">16.1描述了单元长度的标号</span><br><span class="line">16.2在其他段中使用数据标号</span><br><span class="line">16_3直接定址表</span><br><span class="line">16.4程序入口地址的直接定址表</span><br><span class="line">实验16编写包含多个功能子程序的</span><br><span class="line">中断例程</span><br><span class="line">第17章使用BIOS进行键盘输入</span><br><span class="line">和磁盘读写</span><br><span class="line">17.1int 9中断例程对键盘输入的处理</span><br><span class="line">17.2使用int 16h中断例程读取</span><br><span class="line">键盘缓冲区</span><br><span class="line">17.3字符串的输入</span><br><span class="line">17.4应用int 13h中断例程对磁盘</span><br><span class="line">进行读写</span><br><span class="line">实验17编写包含多个功能子程序的</span><br><span class="line">中断例程</span><br><span class="line">课程设计2</span><br><span class="line">综合研究</span><br><span class="line">研究试验1搭建一个精简的C语言</span><br><span class="line">开发环境</span><br><span class="line">研究试验2使用寄存器</span><br><span class="line">研究试验3使用内存空间</span><br><span class="line">研究试验4不用main函数编程</span><br><span class="line">研究试验5函数如何接收不定数量的</span><br><span class="line">参数</span><br><span class="line">附注</span><br><span class="line">附注1Intel系列微处理器的3种工作</span><br><span class="line">模式</span><br><span class="line">附注2补码</span><br><span class="line">附注3汇编编译器（masm.exe）对jmp的</span><br><span class="line">相关处理</span><br><span class="line">附注4用栈传递参数</span><br><span class="line">附注5公式证明</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00EYSPGYE/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00EYSPGYE&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51rsDyZ7AyL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>测试驱动开发 实战与模式解析</title>
    <url>/2020/04/19/B00EYV9KLG/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 测试驱动开发 实战与模式解析<br>作者信息： 作者: 肯特·贝克 (Kent Beck) [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>软件工程领域泰斗、极限编程之父Kent Beck力作，荣获第14届Jolt大奖，畅销不衰     不仅以案例的形式生动地呈现了测试驱动开发的原则和方法，而且详尽地阐述了测试驱动开发的模式和最佳实践</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">译者序</span><br><span class="line">前言</span><br><span class="line">致谢</span><br><span class="line">引言</span><br><span class="line">第一部分 货币实例</span><br><span class="line">第1章 多币种货币实例2</span><br><span class="line">第2章 简并对象9</span><br><span class="line">第3章 定义相等性12</span><br><span class="line">第4章 实例变量私有化16</span><br><span class="line">第5章 法郎的自白19</span><br><span class="line">第6章 相等性再定义22</span><br><span class="line">第7章 美元和法郎27</span><br><span class="line">第8章 制造对象29</span><br><span class="line">第9章 正在进行的times方法33</span><br><span class="line">第10章 有趣的times方法38</span><br><span class="line">第11章 万恶之源43</span><br><span class="line">第12章 总算谈到加法了46</span><br><span class="line">第13章 到达我们的预期51</span><br><span class="line">第14章 变化56</span><br><span class="line">第15章 多币种货币61</span><br><span class="line">第16章 总算谈到抽象了65</span><br><span class="line">第17章 货币回顾69</span><br><span class="line">第二部分 xUnit实例</span><br><span class="line">第18章 走进xUnit76</span><br><span class="line">第19章 设置主线81</span><br><span class="line">第20章 后续的清理85</span><br><span class="line">第21章 计数89</span><br><span class="line">第22章 处理未通过的用例92</span><br><span class="line">第23章 好美妙的测试套件95</span><br><span class="line">第24章 xUnit回顾101</span><br><span class="line">第三部分 测试驱动开发的模式</span><br><span class="line">第25章 测试驱动开发模式104</span><br><span class="line">第26章 红条模式113</span><br><span class="line">第27章 测试模式121</span><br><span class="line">第28章 绿条模式128</span><br><span class="line">第29章 xUnit框架下的模式133</span><br><span class="line">第30章 设计模式141</span><br><span class="line">第31章 重构155</span><br><span class="line">第32章 掌握测试驱动开发165</span><br><span class="line">附录A 影响图178</span><br><span class="line">附录B 斐波那契数列181</span><br><span class="line">后记184</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00EYV9KLG/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00EYV9KLG&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51xQ2yWMziL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>线上幽灵 世界头号黑客米特尼克自传</title>
    <url>/2020/04/19/B00H6ZOIDC/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 线上幽灵 世界头号黑客米特尼克自传<br>作者信息： 作者: 米特尼克 (Kevin Mitnick) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《线上幽灵:世界头号黑客米特尼克自传》 斯诺登事件后，安全问题上升为全民关注的问题：有心的读者完全可以从中洞悉一名顶级黑客的“攻击”思路，知己知彼，百战不殆，更好地做好防护！《线上幽灵:世界头号黑客米特尼克自传》有特殊的阅读体验，胆小慎入！《线上幽灵:世界头号黑客米特尼克自传》是米特尼克迄今唯一一部自传。精彩、惊险的经历堪称一部现代版的江洋大盗真人秀！好莱坞甚至以他的故事为蓝本，拍摄了电影《战争游戏》。米特尼克天生魔力，少年时便游走在网络世界中，如入无人之地，入侵众多大公司机密数据库。政府、企业、民间均视其为“线上幽灵”，谈虎色变。而FBI即便动用了大量人力物力，追踪多年，设下各类圈套，安排众多线人，仍被米特尼克一一识破，轻松逃脱……米特尼克甚至一度改名换姓，在FBI的眼皮子底下过上了白领的幸福小资生活。《线上幽灵:界头号黑客米特尼克自传》并不仅仅是一个精彩的故事，它还是一扇窗户。透过它，我们可以了解一个怪才如何不断突破能力、法律、现实、网络的边界；可以看到一个我们以为“安全”的社会中所存在的种种问题；甚至可以一窥政府机构的技术手段和行动能力，还可以思考能力与责任、兴趣与道德的冲突，更真实地感受到技术的双刃剑特性。你可以把它当成案头消遣，在字里行间与米特尼克一起踏上逃亡之旅，体验惊心动魄的“猫捉老鼠”游戏，与他一起经历各类大案要案，感受亲情，友情，爱情，甚至“敌情”。你也可以去更深地解读，尝试了解这名头号黑客的思维方式，理解他的各种选择，并以此来检视自己的思考方式。兴许，就在“亲临其境”中，你会陡然发现：眼见不为实，世界非你所想象！</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">震撼好评5</span><br><span class="line">译者序｜翻译缘起8</span><br><span class="line">译者序｜中文版夺旗赛谜题11</span><br><span class="line">推荐序@苹果联合创始人沃兹20</span><br><span class="line">自序@凯文米特尼克22</span><br><span class="line">黑客轨迹｜影集25</span><br><span class="line">第一篇成长</span><br><span class="line">第一回生命开始的地方2</span><br><span class="line">第二回我只是来参观的6</span><br><span class="line">第三回原罪17</span><br><span class="line">第四回脱逃大师28</span><br><span class="line">第五回所有的电话线路都是我的36</span><br><span class="line">第六回爱43</span><br><span class="line">第七回闪婚50</span><br><span class="line">第八回卢瑟博士58</span><br><span class="line">第九回凯文米特尼克优惠计划76</span><br><span class="line">第十回神秘黑客82</span><br><span class="line">第二篇埃里克</span><br><span class="line">第十一回谋杀嫌疑88</span><br><span class="line">第十二回无处藏身92</span><br><span class="line">第十三回电话监听器100</span><br><span class="line">第十四回你监听我，我监听你104</span><br><span class="line">第十五回你们是怎么搞到这个的114</span><br><span class="line">第十六回搞砸埃里克的私人派对119</span><br><span class="line">第十七回揭开内幕122</span><br><span class="line">第十八回通信流量分析130</span><br><span class="line">第十九回露出狐狸尾巴135</span><br><span class="line">第二十回反向敲诈140</span><br><span class="line">第二十一回猫和老鼠144</span><br><span class="line">第二十二回侦查工作150</span><br><span class="line">第二十三回遭遇搜查159</span><br><span class="line">第二十四回人间蒸发166</span><br><span class="line">第三篇逃亡</span><br><span class="line">第二十五回哈里胡迪尼174</span><br><span class="line">第二十六回私家侦探181</span><br><span class="line">第二十七回Sun，我来了189</span><br><span class="line">第二十八回奖杯猎人198</span><br><span class="line">第二十九回启程出发210</span><br><span class="line">第三十回傻眼222</span><br><span class="line">第三十一回天空中的眼睛229</span><br><span class="line">第三十二回西雅图不眠夜242</span><br><span class="line">第四篇旧的不去，新的不来</span><br><span class="line">第三十三回与下村勉的决战256</span><br><span class="line">第三十四回隐藏在“圣经”带262</span><br><span class="line">第三十五回游戏结束274</span><br><span class="line">第三十六回一个只有FBI的情人节279</span><br><span class="line">第三十七回羔羊的胜利285</span><br><span class="line">第三十八回余波：命运逆转302</span><br><span class="line">致谢310</span><br><span class="line">采访凯文米特尼克316</span><br><span class="line">由凯文的故事引发的</span><br><span class="line">保护电脑安全的10个小贴士320</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00H6ZOIDC/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00H6ZOIDC&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51bvrdYjpKL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title>软件定义网络(英文)</title>
    <url>/2020/04/19/B00H8VUHD4/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 软件定义网络(英文)<br>作者信息： 作者: 纳多 (Thomas D. Nadeau) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>软件定义网络（SDN）是由软件定义、驱动，并且可编程的网络，可作为SDN的全面、权威指南，详细讲解了SDN的新兴定义、协议和标准。两位资深的网络工程师在书中为读者讲解了构建软件定义网络（即使用软件在应用和底层网络设施之间进行双向通信）所必需的知识。■ “软件定义网络”这一新兴技术的第一书；■ 探究OpenFlow模型和集中网络控制的当前进展；■ 剖析分布式控制和集中控制，包括数据平面生成；■ 详解商业控制器和开源控制器的结构和功能；■ 学习网络可编程性的现有技术；■ 探究以桌面为中心的模型到高度分布式模型在内的现代数据中心；■ 网络功能虚拟化和服务链的连接实例；■ 构建和维护SDN网络拓扑；■ 探究用于控制器、应用和生态系统的理想SDN框架。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Table of Contents</span><br><span class="line">Foreword by David Meyer ix</span><br><span class="line">Foreword by David Ward xi</span><br><span class="line">Prefacex vii</span><br><span class="line">1.Introduction</span><br><span class="line">2.Centralized and Distributed Control and Data Planes</span><br><span class="line">Introduction</span><br><span class="line">Evolution versus Revolution</span><br><span class="line">What Do They Do?</span><br><span class="line">The Control Plane</span><br><span class="line">Data Plane</span><br><span class="line">Moving Information Between Planes</span><br><span class="line">Why Can Separation Be Important?</span><br><span class="line">Distributed Control Planes</span><br><span class="line">IP and MPLS</span><br><span class="line">Creating the IP Underlay</span><br><span class="line">Convergence Time</span><br><span class="line">Load Balancing</span><br><span class="line">High Availability</span><br><span class="line">Creating the MPLS Overlay</span><br><span class="line">Replication</span><br><span class="line">Centralized Control Planes</span><br><span class="line">Logical Versus Literal</span><br><span class="line">ATM&#x2F;LANE</span><br><span class="line">Route Servers</span><br><span class="line">Conclusions</span><br><span class="line">3.OpenFlow</span><br><span class="line">Introduction</span><br><span class="line">Wire Protocol</span><br><span class="line">Replication</span><br><span class="line">FAWG (Forwarding Abstraction Workgroup)</span><br><span class="line">Config and Extensibility</span><br><span class="line">Architecture</span><br><span class="line">Hybrid Approaches</span><br><span class="line">Ships in the Night</span><br><span class="line">Dual Function Switches</span><br><span class="line">Conclusions</span><br><span class="line">4.SDN Controllers</span><br><span class="line">Introduction</span><br><span class="line">General Concepts</span><br><span class="line">VMware</span><br><span class="line">Nicira</span><br><span class="line">VMware&#x2F;Nicira</span><br><span class="line">OpenFlow-Related</span><br><span class="line">Mininet</span><br><span class="line">NOX&#x2F;POX</span><br><span class="line">Trema</span><br><span class="line">Ryu</span><br><span class="line">Big Switch Networks&#x2F;Floodlight</span><br><span class="line">Layer 3 Centric</span><br><span class="line">L3VPN</span><br><span class="line">Path Computation Element Server</span><br><span class="line">Plexxi</span><br><span class="line">Plexxi Affinity</span><br><span class="line">Cisco OnePK</span><br><span class="line">Relationship to the Idealized SDN Framework</span><br><span class="line">Conclusions</span><br><span class="line">5.Network Programmability</span><br><span class="line">Introduction</span><br><span class="line">The Management Interface</span><br><span class="line">The Application-Network Divide</span><br><span class="line">The Command-Line Interface</span><br><span class="line">NETCONF and NETMOD</span><br><span class="line">SNMP</span><br><span class="line">Modern Programmatic Interfaces</span><br><span class="line">Publish and Subscribe Interfaces</span><br><span class="line">XMPP</span><br><span class="line">Google’s Protocol Buffers</span><br><span class="line">Thrift</span><br><span class="line">JSON</span><br><span class="line">I2RS</span><br><span class="line">Modern Orchestration</span><br><span class="line">OpenStack</span><br><span class="line">CloudStack</span><br><span class="line">Puppet</span><br><span class="line">Conclusions</span><br><span class="line">6.Data Center Concepts and Construct</span><br><span class="line">Introduction</span><br><span class="line">The Multitenant Data Center</span><br><span class="line">The Virtualized Multitenant Data Center</span><br><span class="line">Orchestration</span><br><span class="line">Connecting a Tenant to the Internet&#x2F;VPN</span><br><span class="line">Virtual Machine Migration and Elasticity</span><br><span class="line">Data Center Interconnect (DCI)</span><br><span class="line">Fallacies of Data Center Distributed Computing</span><br><span class="line">Data Center Distributed Computing Pitfalls to Consider</span><br><span class="line">SDN Solutions for the Data Center Network</span><br><span class="line">The Network Underlay</span><br><span class="line">VLANs</span><br><span class="line">EVPN</span><br><span class="line">Locator ID Split (LISP)</span><br><span class="line">VxLan</span><br><span class="line">NVGRE</span><br><span class="line">OpenFlow</span><br><span class="line">Network Overlays</span><br><span class="line">Network Overlay Types</span><br><span class="line">Conclusions</span><br><span class="line">7.Network Function Virtualization</span><br><span class="line">Introduction</span><br><span class="line">Virtualization and Data Plane I&#x2F;O</span><br><span class="line">Data Plane I&#x2F;O</span><br><span class="line">I&#x2F;O Summary</span><br><span class="line">Services Engineered Path</span><br><span class="line">Service Locations and Chaining</span><br><span class="line">Metadata</span><br><span class="line">An Application Level Approach</span><br><span class="line">Scale</span><br><span class="line">NFV at ETSI</span><br><span class="line">Non-ETSI NFV Work</span><br><span class="line">Middlebox Studies</span><br><span class="line">Embrane&#x2F;LineRate</span><br><span class="line">Platform Virtualization</span><br><span class="line">Conclusions</span><br><span class="line">8.Network Topology and Topological Information Abstraction</span><br><span class="line">Introduction</span><br><span class="line">Network Topology</span><br><span class="line">Traditional Methods</span><br><span class="line">LLDP</span><br><span class="line">BGP-TE&#x2F;LS</span><br><span class="line">BGP-LS with PCE</span><br><span class="line">ALTO</span><br><span class="line">BGP-LS and PCE Interaction with ALTO</span><br><span class="line">I2RS Topology</span><br><span class="line">Conclusions</span><br><span class="line">9.Building an SDN Framework</span><br><span class="line">Introduction</span><br><span class="line">Build Code First; Ask Questions Later…</span><br><span class="line">The Juniper SDN Framework</span><br><span class="line">IETF SDN Framework(s)</span><br><span class="line">SDN(P)</span><br><span class="line">ABNO</span><br><span class="line">Open Daylight Controller&#x2F;Framework</span><br><span class="line">API</span><br><span class="line">High Availability and State Storage</span><br><span class="line">Analytics</span><br><span class="line">Policy</span><br><span class="line">Conclusions</span><br><span class="line">10.Use Cases for Bandwidth Scheduling, Manipulation, and lendaring</span><br><span class="line">Introduction</span><br><span class="line">Bandwidth Calendaring</span><br><span class="line">Base Topology and Fundamental Concepts</span><br><span class="line">OpenFlow and PCE Topologies</span><br><span class="line">Example Configuration</span><br><span class="line">OpenFlow Provisioned Example</span><br><span class="line">Enhancing the Controller</span><br><span class="line">Overlay Example Using PCE Provisioning</span><br><span class="line">Expanding Your Reach: Barbarians at the Gate</span><br><span class="line">Big Data and Application Hyper-Virtualization for Instant CSPF</span><br><span class="line">Expanding Topology</span><br><span class="line">Conclusions</span><br><span class="line">……</span><br><span class="line">11.Use Cases for Data Center Overlays, Big Data, and Network Function Virtualization</span><br><span class="line">12.Use Cases for Input Traffic Monitoring, Classification, and Triggered Actions</span><br><span class="line">13.Final Thoughts and Conclusions</span><br><span class="line">Index</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00H8VUHD4/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00H8VUHD4&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51wDwOacExL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB权威指南(第2版)</title>
    <url>/2020/04/19/B00HLX035Q/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： MongoDB权威指南(第2版)<br>作者信息： 作者: 霍多罗夫 (Kristina Chodorow) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>上一版广受好评，新版本在此基础上大幅扩充，内容更加全面、深入MongoDB项目组成员倾力打造MongoDB基础知识、进阶内容、高级管理任务一应俱全</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">序</span><br><span class="line">前言</span><br><span class="line">第一部分 MongoDB介绍</span><br><span class="line">第1章 MongoDB简介 3</span><br><span class="line">1.1 易于使用 3</span><br><span class="line">1.2 易于扩展 4</span><br><span class="line">1.3 丰富的功能 4</span><br><span class="line">1.4 卓越的性能 5</span><br><span class="line">1.5 小结 5</span><br><span class="line">第2章 MongoDB基础知识 7</span><br><span class="line">2.1 文档 7</span><br><span class="line">2.2 集合 8</span><br><span class="line">2.2.1 动态模式 8</span><br><span class="line">2.2.2 命名 9</span><br><span class="line">2.3 数据库 10</span><br><span class="line">2.4 启动MongoDB 11</span><br><span class="line">2.5 MongoDBshell简介 12</span><br><span class="line">2.5.1 运行shell 12</span><br><span class="line">2.5.2 MongoDB客户端 13</span><br><span class="line">2.5.3 shell中的基本操作 14</span><br><span class="line">2.6 数据类型 16</span><br><span class="line">2.6.1 基本数据类型 16</span><br><span class="line">2.6.2 日期 18</span><br><span class="line">2.6.3 数组 18</span><br><span class="line">2.6.4 内嵌文档 19</span><br><span class="line">2.6.5 id和ObjectId 20 2.7 使用MongoDBshell 21 2.7.1 shell小贴士 22 2.7.2 使用shell执行脚本 23 2.7.3 创建mongorc.js文件 25 2.7.4 定制shell提示 26 2.7.5 编辑复合变量 26 2.7.6 集合命名注意事项 27 第3章 创建、更新和删除文档 29 3.1 插入并保存文档 29 3.1.1 批量插入 29 3.1.2 插入校验 30 3.2 删除文档 31 3.3 更新文档 32 3.3.1 文档替换 32 3.3.2 使用修改器 34 3.3.3 upsert 45 3.3.4 更新多个文档 47 3.3.5 返回被更新的文档 48 3.4 写入安全机制 50 第4章 查询 53 4.1 find简介 53 4.1.1 指定需要返回的键 54 4.1.2 限制 55 4.2 查询条件 55 4.2.1 查询条件 55 4.2.2 OR查询 56 4.2.3 $not 57 4.2.4 条件语义 57 4.3 特定类型的查询 58 4.3.1 null 58 4.3.2 正则表达式 59 4.3.3 查询数组 59 4.3.4 查询内嵌文档 64 4.4 $where查询 65 4.5 游标 67 4.5.1 limit、skip和sort 69 4.5.2 避免使用skip略过大量结果 70 4.5.3 高级查询选项 72 4.5.4 获取一致结果 73 4.5.5 游标生命周期 75 4.6 数据库命令 75 第二部分 设计应用 第5章 索引 81 5.1 索引简介 81 5.1.1 复合索引简介 84 5.1.2 使用复合索引 90 5.1.3 $操作符如何使用索引 91 5.1.4 索引对象和数组 96 5.1.5 索引基数 98 5.2 使用explain（）和hint（） 98 5.3 何时不应该使用索引 103 5.4 索引类型 104 5.4.1 唯一索引 104 5.4.2 稀疏索引 106 5.5 索引管理 107 5.5.1 标识索引 108 5.5.2 修改索引 108 第6章 特殊的索引和集合 111 6.1 固定集合 111 6.1.1 创建固定集合 113 6.1.2 自然排序 113 6.1.3 循环游标 115 6.1.4 没有id索引的集合 115</span><br><span class="line">6.2 TTL索引 116</span><br><span class="line">6.3 全文本索引 116</span><br><span class="line">6.3.1 搜索语法 119</span><br><span class="line">6.3.2 优化全文本搜索 120</span><br><span class="line">6.3.3 在其他语言中搜索 121</span><br><span class="line">6.4 地理空间索引 121</span><br><span class="line">6.4.1 地理空间查询的类型 122</span><br><span class="line">6.4.2 复合地理空间索引 123</span><br><span class="line">6.4.3 2d索引 123</span><br><span class="line">6.5 使用GridFS存储文件 125</span><br><span class="line">6.5.1 GridFS入门 126</span><br><span class="line">6.5.2 在MongoDB驱动程序中使用GridFS 126</span><br><span class="line">6.5.3 揭开GridFS的面纱 127</span><br><span class="line">第7章 聚合 129</span><br><span class="line">7.1 聚合框架 129</span><br><span class="line">7.2 管道操作符 131</span><br><span class="line">7.2.1 $match 132</span><br><span class="line">7.2.2 $project 132</span><br><span class="line">7.2.3 $group 137</span><br><span class="line">7.2.4 $unwind 140</span><br><span class="line">7.2.5 $sort 141</span><br><span class="line">7.2.6 $limit 142</span><br><span class="line">7.2.7 $skip 142</span><br><span class="line">7.2.8 使用管道 142</span><br><span class="line">7.3 MapReduce 143</span><br><span class="line">7.3.1 示例1：找出集合中的所有键 143</span><br><span class="line">7.3.2 示例2：网页分类 145</span><br><span class="line">7.3.3 MongoDB和MapReduce 146</span><br><span class="line">7.4 聚合命令 148</span><br><span class="line">7.4.1 count 149</span><br><span class="line">7.4.2 distinct 149</span><br><span class="line">7.4.3 group 150</span><br><span class="line">第8章 应用程序设计 155</span><br><span class="line">8.1 范式化与反范式化 155</span><br><span class="line">8.1.1 数据表示的例子 156</span><br><span class="line">8.1.2 基数 159</span><br><span class="line">8.1.3 好友、粉丝，以及其他的麻烦事项 160</span><br><span class="line">8.2 优化数据操作 162</span><br><span class="line">8.2.1 优化文档增长 162</span><br><span class="line">8.2.2 删除旧数据 164</span><br><span class="line">8.3 数据库和集合的设计 164</span><br><span class="line">8.4 一致性管理 165</span><br><span class="line">8.5 模式迁移 166</span><br><span class="line">8.6 不适合使用MongoDB的场景 167</span><br><span class="line">第三部分 复制</span><br><span class="line">第9章 创建副本集 171</span><br><span class="line">9.1 复制简介 171</span><br><span class="line">9.2 建立副本集 172</span><br><span class="line">9.3 配置副本集 176</span><br><span class="line">9.3.1 rs辅助函数 178</span><br><span class="line">9.3.2 网络注意事项 178</span><br><span class="line">9.4 修改副本集配置 178</span><br><span class="line">9.5 设计副本集 180</span><br><span class="line">9.6 成员配置选项 184</span><br><span class="line">9.6.1 选举仲裁者 184</span><br><span class="line">9.6.2 优先级 185</span><br><span class="line">9.6.3 隐藏成员 186</span><br><span class="line">9.6.4 延迟备份节点 187</span><br><span class="line">9.6.5 创建索引 187</span><br><span class="line">第10章 副本集的组成 189</span><br><span class="line">10.1 同步 189</span><br><span class="line">10.1.1 初始化同步 190</span><br><span class="line">10.1.2 处理陈旧数据 193</span><br><span class="line">10.2 心跳 193</span><br><span class="line">10.3 选举 195</span><br><span class="line">10.4 回滚 195</span><br><span class="line">第11章 从应用程序连接副本集 201</span><br><span class="line">11.1 客户端到副本集的连接 201</span><br><span class="line">11.2 等待写入复制 202</span><br><span class="line">11.2.1 可能导致错误的原因 203</span><br><span class="line">11.2.2 其他值 204</span><br><span class="line">11.3 自定义复制保证规则 204</span><br><span class="line">11.3.1 保证复制到每个数据中心的一台服务器上 204</span><br><span class="line">11.3.2 保证写操作被复制到可见节点中的“大多数” 206</span><br><span class="line">11.3.3 创建其他规则 206</span><br><span class="line">11.4 将读请求发送到备份节点 207</span><br><span class="line">11.4.1 出于一致性考虑 207</span><br><span class="line">11.4.2 出于负载的考虑 208</span><br><span class="line">11.4.3 何时可以从备份节点读取数据 208</span><br><span class="line">第12章 管理 211</span><br><span class="line">12.1 以单机模式启动成员 211</span><br><span class="line">12.2 副本集配置 212</span><br><span class="line">12.2.1 创建副本集 212</span><br><span class="line">12.2.2 修改副本集成员 213</span><br><span class="line">12.2.3 创建比较大的副本集 213</span><br><span class="line">12.2.4 强制重新配置 214</span><br><span class="line">12.3 修改成员状态 215</span><br><span class="line">12.3.1 把主节点变为备份节点 215</span><br><span class="line">12.3.2 阻止选举 215</span><br><span class="line">12.3.3 使用维护模式 215</span><br><span class="line">12.4 监控复制 216</span><br><span class="line">12.4.1 获取状态 216</span><br><span class="line">12.4.2 复制图谱 218</span><br><span class="line">12.4.3 复制循环 220</span><br><span class="line">12.4.4 禁用复制链 220</span><br><span class="line">12.4.5 计算延迟 221</span><br><span class="line">12.4.6 调整oplog大小 222</span><br><span class="line">12.4.7 从延迟备份节点中恢复 223</span><br><span class="line">12.4.8 创建索引 224</span><br><span class="line">12.4.9 在预算有限的情况下进行复制 225</span><br><span class="line">12.4.10 主节点如何跟踪延迟 226</span><br><span class="line">12.5 主从模式 227</span><br><span class="line">12.5.1 从主从模式切换到副本集模式 228</span><br><span class="line">12.5.2 让副本集模仿主从模式的行为 228</span><br><span class="line">第四部分 分片</span><br><span class="line">第13章 分片 233</span><br><span class="line">13.1 分片简介 233</span><br><span class="line">13.2 理解集群的组件 234</span><br><span class="line">13.3 快速建立一个简单的集群 235</span><br><span class="line">第14章 配置分片 243</span><br><span class="line">14.1 何时分片 243</span><br><span class="line">14.2 启动服务器 244</span><br><span class="line">14.2.1 配置服务器 244</span><br><span class="line">14.2.2 mongos进程 245</span><br><span class="line">14.2.3 将副本集转换为分片 245</span><br><span class="line">14.2.4 增加集群容量 247</span><br><span class="line">14.2.5 数据分片 247</span><br><span class="line">14.3 MongoDB如何追踪集群数据 248</span><br><span class="line">14.3.1 块范围 249</span><br><span class="line">14.3.2 拆分块 250</span><br><span class="line">14.4 均衡器 254</span><br><span class="line">第15章 选择片键 257</span><br><span class="line">15.1 检查使用情况 257</span><br><span class="line">15.2 数据分发 258</span><br><span class="line">15.2.1 升序片键 258</span><br><span class="line">15.2.2 随机分发的片键 261</span><br><span class="line">15.2.3 基于位置的片键 262</span><br><span class="line">15.3 片键策略 263</span><br><span class="line">15.3.1 散列片键 264</span><br><span class="line">15.3.2 GridFS的散列片键 265</span><br><span class="line">15.3.3 流水策略 266</span><br><span class="line">15.3.4 多热点 267</span><br><span class="line">15.4 片键规则和指导方针 270</span><br><span class="line">15.4.1 片键限制 270</span><br><span class="line">15.4.2 片键的势 270</span><br><span class="line">15.5 控制数据分发 270</span><br><span class="line">15.5.1 对多个数据库和集合使用一个集群 270</span><br><span class="line">15.5.2 手动分片 272</span><br><span class="line">第16章 分片管理 275</span><br><span class="line">16.1 检查集群状态 275</span><br><span class="line">16.1.1 使用sh.status查看集群摘要信息 275</span><br><span class="line">16.1.2 检查配置信息 277</span><br><span class="line">16.2 查看网络连接 282</span><br><span class="line">16.2.1 查看连接统计 283</span><br><span class="line">16.2.2 限制连接数量 283</span><br><span class="line">16.3 服务器管理 285</span><br><span class="line">16.3.1 添加服务器 285</span><br><span class="line">16.3.2 修改分片的服务器 285</span><br><span class="line">16.3.3 删除分片 286</span><br><span class="line">16.3.4 修改配置服务器 288</span><br><span class="line">16.4 数据均衡 289</span><br><span class="line">16.4.1 均衡器 289</span><br><span class="line">16.4.2 修改块大小 290</span><br><span class="line">16.4.3 移动块 290</span><br><span class="line">16.4.4 特大块 292</span><br><span class="line">16.4.5 刷新配置 295</span><br><span class="line">第五部分 应用管理</span><br><span class="line">第17章 了解应用的动态 299</span><br><span class="line">17.1 了解正在进行的操作 299</span><br><span class="line">17.1.1 寻找有问题的操作 301</span><br><span class="line">17.1.2 终止操作的执行 301</span><br><span class="line">17.1.3 假象 302</span><br><span class="line">17.1.4 避免幽灵操作 302</span><br><span class="line">17.2 使用系统分析器 303</span><br><span class="line">17.3 计算空间消耗 305</span><br><span class="line">17.3.1 文档 305</span><br><span class="line">17.3.2 集合 305</span><br><span class="line">17.3.3 数据库 306</span><br><span class="line">17.4 使用mongotop和monogostat 307</span><br><span class="line">第18章 数据管理 311</span><br><span class="line">18.1 配置身份验证 311</span><br><span class="line">18.1.1 身份验证基本原理 312</span><br><span class="line">18.1.2 配置身份验证 313</span><br><span class="line">18.1.3 身份验证的工作原理 314</span><br><span class="line">18.2 建立和删除索引 315</span><br><span class="line">18.2.1 在独立的服务器上建立索引 315</span><br><span class="line">18.2.2 在副本集上建立索引 315</span><br><span class="line">18.2.3 在分片集群上建立索引 316</span><br><span class="line">18.2.4 删除索引 316</span><br><span class="line">18.2.5 注意内存溢出杀手 316</span><br><span class="line">18.3 预热数据 317</span><br><span class="line">18.3.1 将数据库移至内存 317</span><br><span class="line">18.3.2 将集合移至内存 318</span><br><span class="line">18.3.3 自定义预热 318</span><br><span class="line">18.4 压缩数据 320</span><br><span class="line">18.5 移动集合 321</span><br><span class="line">18.6 预分配数据文件 322</span><br><span class="line">第19章 持久性 323</span><br><span class="line">19.1 日记系统的用途 323</span><br><span class="line">19.1.1 批量提交写入操作 324</span><br><span class="line">19.1.2 设定提交时间间隔 325</span><br><span class="line">19.2 关闭日记系统 325</span><br><span class="line">19.2.1 替换数据文件 325</span><br><span class="line">19.2.2 修复数据文件 326</span><br><span class="line">19.2.3 关于mongod.lock文件 326</span><br><span class="line">19.2.4 隐蔽的异常退出 327</span><br><span class="line">19.3 MongoDB无法保证的事项 327</span><br><span class="line">19.4 检验数据损坏 327</span><br><span class="line">19.5 副本集中的持久性 329</span><br><span class="line">第六部分 服务器管理</span><br><span class="line">第20章 启动和停止MongoDB 333</span><br><span class="line">20.1 从命令行启动 333</span><br><span class="line">20.2 停止MongoDB 336</span><br><span class="line">20.3 安全性 337</span><br><span class="line">20.3.1 数据加密 338</span><br><span class="line">20.3.2 SSL安全连接 338</span><br><span class="line">20.4 日志 338</span><br><span class="line">第21章 监控MongoDB 341</span><br><span class="line">21.1 监控内存使用状况 341</span><br><span class="line">21.1.1 有关电脑内存的介绍 341</span><br><span class="line">21.1.2 跟踪监测内存使用状况 342</span><br><span class="line">21.1.3 跟踪监测缺页中断 343</span><br><span class="line">21.1.4 减少索引树的脱靶次数 345</span><br><span class="line">21.1.5 IO延迟 345</span><br><span class="line">21.1.6 跟踪监测后台刷新平均时间 346</span><br><span class="line">21.2 计算工作集的大小 347</span><br><span class="line">21.3 跟踪监测性能状况 349</span><br><span class="line">21.4 监控副本集 352</span><br><span class="line">第22章 备份 355</span><br><span class="line">22.1 对服务器进行备份 355</span><br><span class="line">22.1.1 文件系统快照 355</span><br><span class="line">22.1.2 复制数据文件 356</span><br><span class="line">22.1.3 使用mongodump 357</span><br><span class="line">22.2 对副本集进行备份 359</span><br><span class="line">22.3 对分片集群进行备份 360</span><br><span class="line">22.3.1 备份和恢复整个集群 360</span><br><span class="line">22.3.2 备份和恢复单独的分片 360</span><br><span class="line">22.4 使用mongooplog进行增量备份 361</span><br><span class="line">第23章 部署MongoDB 363</span><br><span class="line">23.1 设计系统结构 363</span><br><span class="line">23.1.1 选择存储介质 363</span><br><span class="line">23.1.2 推荐的RAID配置 367</span><br><span class="line">23.1.3 CPU 368</span><br><span class="line">23.1.4 选择操作系统 368</span><br><span class="line">23.1.5 交换空间 369</span><br><span class="line">23.1.6 文件系统 369</span><br><span class="line">23.2 虚拟化 370</span><br><span class="line">23.2.1 禁止内存过度分配 370</span><br><span class="line">23.2.2 神秘的内存 370</span><br><span class="line">23.2.3 处理网络磁盘的IO问题 371</span><br><span class="line">23.2.4 使用非网络磁盘 372</span><br><span class="line">23.3 系统配置 372</span><br><span class="line">23.3.1 禁用NUMA 372</span><br><span class="line">23.3.2 更智能地预读取数据 375</span><br><span class="line">23.3.3 禁用大内存页面 376</span><br><span class="line">23.3.4 选择一种磁盘调度算法 377</span><br><span class="line">23.3.5 不要记录访问时间 377</span><br><span class="line">23.3.6 修改限制 378</span><br><span class="line">23.4 网络配置 379</span><br><span class="line">23.5 系统管理 381</span><br><span class="line">23.5.1 时钟同步 381</span><br><span class="line">23.5.2 OOMKiller 381</span><br><span class="line">23.5.3 关闭定期任务 382</span><br><span class="line">附录A 安装MongoDB 383</span><br><span class="line">附录B 深入MongoDB 387</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00HLX035Q/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00HLX035Q&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/518fJU-ijYL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>大规模并行处理器编程实战(第2版)</title>
    <url>/2020/04/19/B00HFID4QW/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 大规模并行处理器编程实战(第2版)<br>作者信息： 作者: 柯克 (Kirk D.B. ) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>ACM SIGGRAPH计算机图形成就奖得主、美国国家工程院院士、NVIDIA院士、CUDA技术的创始人之一David B. Kirk最新作品，全面更新了并行编程方法和技术的内容，掌握并行计算思维和并行编程技巧，本书就“购”了</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章  引言 1</span><br><span class="line">1.1  异构并行计算 2</span><br><span class="line">1.2  现代GPU的体系结构 6</span><br><span class="line">1.3  为什么需要更高的速度和并行化 8</span><br><span class="line">1.4  应用程序的加速 9</span><br><span class="line">1.5  并行编程语言和模型 11</span><br><span class="line">1.6  本书的总体目标 12</span><br><span class="line">1.7  本书的组织结构 13</span><br><span class="line">参考文献 16</span><br><span class="line">第2章  GPU计算的发展历程 19</span><br><span class="line">2.1  图形流水线的发展 19</span><br><span class="line">2.1.1  固定功能的图形流水线时代 20</span><br><span class="line">2.1.2  可编程实时图形流水线的发展 23</span><br><span class="line">2.1.3  图形与计算结合的处理器 25</span><br><span class="line">2.2  GPGPU：一个中间步骤 27</span><br><span class="line">2.3  GPU计算 28</span><br><span class="line">2.3.1  可扩展的GPU 29</span><br><span class="line">2.3.2  发展近况 29</span><br><span class="line">2.3.3  未来发展趋势 30</span><br><span class="line">参考文献与课外阅读 30</span><br><span class="line">第3章  CUDA简介 35</span><br><span class="line">3.1  数据并行性 36</span><br><span class="line">3.2  CUDA的程序结构 37</span><br><span class="line">3.3  向量加法kernel函数 39</span><br><span class="line">3.4  设备全局存储器与数据传输 41</span><br><span class="line">3.5  kernel函数与线程 46</span><br><span class="line">3.6  小结 50</span><br><span class="line">3.6.1  函数声明 50</span><br><span class="line">3.6.2  启动kernel函数 50</span><br><span class="line">3.6.3  预定义变量 51</span><br><span class="line">3.6.4  运行时API 51</span><br><span class="line">3.7  习题 51</span><br><span class="line">参考文献 53</span><br><span class="line">第4章  数据并行执行模型 55</span><br><span class="line">4.1  CUDA的线程组织 56</span><br><span class="line">4.2  线程与多维数据的映射 59</span><br><span class="line">4.3  矩阵乘法——一个更加复杂的kernel函数 65</span><br><span class="line">4.4  线程同步和透明的可扩展性 70</span><br><span class="line">4.5  线程块的资源分配 73</span><br><span class="line">4.6  查询设备属性 74</span><br><span class="line">4.7  线程调度和容许时延 75</span><br><span class="line">4.8  小结 78</span><br><span class="line">4.9  习题 79</span><br><span class="line">第5章  CUDA存储器 81</span><br><span class="line">5.1  存储器访问效率的重要性 82</span><br><span class="line">5.2  CUDA设备存储器的类型 83</span><br><span class="line">5.3  减少全局存储器流量的一种策略 89</span><br><span class="line">5.4  分块矩阵乘法的kernel函数 93</span><br><span class="line">5.5  存储器——限制并行性的一个因素 98</span><br><span class="line">5.6  小结 100</span><br><span class="line">5.7  习题 101</span><br><span class="line">第6章  性能优化 103</span><br><span class="line">6.1  WARP和线程执行 104</span><br><span class="line">6.2  全局存储器的带宽 111</span><br><span class="line">6.3  执行资源的动态划分 118</span><br><span class="line">6.4  指令混合和线程粒度 120</span><br><span class="line">6.5  小结 121</span><br><span class="line">6.6  习题 121</span><br><span class="line">参考文献 124</span><br><span class="line">第7章  浮点运算 127</span><br><span class="line">7.1  浮点格式 128</span><br><span class="line">7.1.1  M的规范化表示 128</span><br><span class="line">7.1.2  E的余码表示 129</span><br><span class="line">7.2  能表示的数 130</span><br><span class="line">7.3  特殊的位模式与IEEE格式中的精度 134</span><br><span class="line">7.4  算术运算的准确度和舍入 135</span><br><span class="line">7.5  算法的优化 136</span><br><span class="line">7.6  数值稳定性 137</span><br><span class="line">7.7  小结 141</span><br><span class="line">7.8  习题 141</span><br><span class="line">参考文献 142</span><br><span class="line">第8章  并行模式：卷积 143</span><br><span class="line">8.1  背景 144</span><br><span class="line">8.2  一个基本算法：一维并行卷积 148</span><br><span class="line">8.3  常数存储器和高速缓存 149</span><br><span class="line">8.4  使用光环元素的分块一维卷积 153</span><br><span class="line">8.5  一个更简单的分块一维卷积——通用高速缓存 158</span><br><span class="line">8.6  小结 160</span><br><span class="line">8.7  习题 161</span><br><span class="line">第9章  并行模式：前缀和 163</span><br><span class="line">9.1  背景 164</span><br><span class="line">9.2  简单并行扫描 165</span><br><span class="line">9.3  考虑工作效率 169</span><br><span class="line">9.4  工作高效的并行扫描 170</span><br><span class="line">9.5  任意输入长度的并行扫描 174</span><br><span class="line">9.6  小结 177</span><br><span class="line">9.7  习题 177</span><br><span class="line">参考文献 178</span><br><span class="line">第10章  并行模式：稀疏矩阵-向量乘法 179</span><br><span class="line">10.1  背景 180</span><br><span class="line">10.2  使用CSR格式的并行SpMV 183</span><br><span class="line">10.3  填充与转置 184</span><br><span class="line">10.4  用混合方法来控制填充 186</span><br><span class="line">10.5  通过排序和划分来规则化 189</span><br><span class="line">10.6  小结 191</span><br><span class="line">10.7  习题 191</span><br><span class="line">参考文献 192</span><br><span class="line">第11章  应用案例研究：高级MRI重构 193</span><br><span class="line">11.1  应用背景 194</span><br><span class="line">11.2  迭代重构 197</span><br><span class="line">11.3  计算FHD 198</span><br><span class="line">11.4  最终评估 214</span><br><span class="line">11.5  习题 217</span><br><span class="line">参考文献 218</span><br><span class="line">第12章  应用案例研究：分子可视化和分析 219</span><br><span class="line">12.1  应用背景 220</span><br><span class="line">12.2  kernel函数简单的实现方案 221</span><br><span class="line">12.3  线程粒度调节 225</span><br><span class="line">12.4  存储器合并 227</span><br><span class="line">12.5  小结 230</span><br><span class="line">12.6  习题 231</span><br><span class="line">参考文献 232</span><br><span class="line">第13章  并行编程和计算思想 233</span><br><span class="line">13.1  并行计算的目标 234</span><br><span class="line">13.2  问题分解 235</span><br><span class="line">13.3  算法选择 238</span><br><span class="line">13.4  计算思想 243</span><br><span class="line">13.5  小结 244</span><br><span class="line">13.6  习题 244</span><br><span class="line">参考文献 244</span><br><span class="line">第14章  OpenCL简介 245</span><br><span class="line">14.1  背景 246</span><br><span class="line">14.2  数据并行性模型 247</span><br><span class="line">14.3  设备的体系结构 249</span><br><span class="line">14.4  kernel函数 250</span><br><span class="line">14.5  设备管理和启动kernel 251</span><br><span class="line">14.6  OpenCL中的静电势图谱 254</span><br><span class="line">14.7  小结 258</span><br><span class="line">14.8  习题 258</span><br><span class="line">参考文献 259</span><br><span class="line">第15章  OpenACC并行编程 261</span><br><span class="line">15.1  OpenACC与CUDA C的比较 261</span><br><span class="line">15.2  执行模型 263</span><br><span class="line">15.3  存储器模型 265</span><br><span class="line">15.4  基本的OpenACC程序 266</span><br><span class="line">15.4.1  并行构造 266</span><br><span class="line">15.4.2  循环构造 267</span><br><span class="line">15.4.3  kernels构造 272</span><br><span class="line">15.4.4  数据管理 275</span><br><span class="line">15.4.5  数据构造 276</span><br><span class="line">15.4.6  异步计算和数据传输 278</span><br><span class="line">15.5  OpenACC的发展方向 279</span><br><span class="line">15.6  习题 280</span><br><span class="line">第16章  Thrust：一个面向效率的CUDA编程库 281</span><br><span class="line">16.1  背景简介 282</span><br><span class="line">16.2  动机 284</span><br><span class="line">16.3  Thrust的基本特性 284</span><br><span class="line">16.3.1  迭代器和内存空间 286</span><br><span class="line">16.3.2  互操作性 286</span><br><span class="line">16.4  泛型编程 288</span><br><span class="line">16.5  抽象的益处 290</span><br><span class="line">16.5.1  编程效率 290</span><br><span class="line">16.5.2  鲁棒性 291</span><br><span class="line">16.5.3  真实性能 291</span><br><span class="line">16.6  最佳范例 293</span><br><span class="line">16.6.1  融合 293</span><br><span class="line">16.6.2  数组结构体 294</span><br><span class="line">16.6.3  隐式范围 296</span><br><span class="line">16.7  习题 297</span><br><span class="line">参考文献 298</span><br><span class="line">第17章  CUDA FORTRAN 299</span><br><span class="line">17.1  CUDA FORTRAN和CUDA C的区别 300</span><br><span class="line">17.2  第一个CUDA FORTRAN程序 301</span><br><span class="line">17.3  CUDA FORTRAN中的多维数组 303</span><br><span class="line">17.4  用通用接口重载主机&#x2F;设备端例程 304</span><br><span class="line">17.5  通过iso_c_binding调用CUDA C 307</span><br><span class="line">17.6  kernel循环指令和归约操作 309</span><br><span class="line">17.7  动态共享存储器 310</span><br><span class="line">17.8  异步数据传输 311</span><br><span class="line">17.9  编译和性能剖析 316</span><br><span class="line">17.10  在CUDA FORTRAN中调用Thrust 317</span><br><span class="line">17.11  习题 321</span><br><span class="line">第18章  C++ AMP简介 323</span><br><span class="line">18.1  C++ AMP核心特性 324</span><br><span class="line">18.2  C++ AMP执行模式详解 329</span><br><span class="line">18.2.1  显式和隐式的数据复制 330</span><br><span class="line">18.2.2  异步操作 331</span><br><span class="line">18.2.3  本节小结 333</span><br><span class="line">18.3  加速器管理 333</span><br><span class="line">18.4  分块执行 335</span><br><span class="line">18.5  C++ AMP图形特性 338</span><br><span class="line">18.6  小结 340</span><br><span class="line">18.7  习题 341</span><br><span class="line">第19章  异构集群编程 343</span><br><span class="line">19.1  背景简介 344</span><br><span class="line">19.2  运行示例 344</span><br><span class="line">19.3  MPI基础 346</span><br><span class="line">19.4  MPI点对点通信模型 348</span><br><span class="line">19.5  重叠计算和通信 355</span><br><span class="line">19.6  MPI集合通信模型 362</span><br><span class="line">19.7  小结 363</span><br><span class="line">19.8  习题 363</span><br><span class="line">参考文献 364</span><br><span class="line">第20章  CUDA动态并行 365</span><br><span class="line">20.1  背景 366</span><br><span class="line">20.2  动态并行简介 367</span><br><span class="line">20.3  重要细节 368</span><br><span class="line">20.3.1  启动环境变量设置 369</span><br><span class="line">20.3.2  API错误和启动失败 369</span><br><span class="line">20.3.3  事件 369</span><br><span class="line">20.3.4  流 369</span><br><span class="line">20.3.5  同步范围 370</span><br><span class="line">20.4  内存可见性 371</span><br><span class="line">20.4.1  全局内存 371</span><br><span class="line">20.4.2  零拷贝内存 371</span><br><span class="line">20.4.3  常量内存 371</span><br><span class="line">20.4.4  局部内存 371</span><br><span class="line">20.4.5  共享内存 372</span><br><span class="line">20.4.6  纹理内存 372</span><br><span class="line">20.5  一个简单示例 373</span><br><span class="line">20.6  运行时限制 376</span><br><span class="line">20.6.1  内存占用 376</span><br><span class="line">20.6.2  嵌套深度 376</span><br><span class="line">20.6.3  内存分配和生存周期 376</span><br><span class="line">20.6.4  ECC错误 377</span><br><span class="line">20.6.5  流 377</span><br><span class="line">20.6.6  事件 377</span><br><span class="line">20.6.7  启动池 377</span><br><span class="line">20.7  一个更复杂的示例 378</span><br><span class="line">20.7.1  线性贝塞尔曲线 378</span><br><span class="line">20.7.2  二次贝塞尔曲线 378</span><br><span class="line">20.7.3  贝塞尔曲线计算(非动态并行版本) 378</span><br><span class="line">20.7.4  贝塞尔曲线计算(使用动态并行) 381</span><br><span class="line">20.8  小结 384</span><br><span class="line">参考文献 384</span><br><span class="line">第21章  结论与展望 385</span><br><span class="line">21.1  重点回顾 385</span><br><span class="line">21.2  存储器模型的演变 386</span><br><span class="line">21.2.1  大型虚拟和物理地址空间 386</span><br><span class="line">21.2.2  统一的设备存储空间 388</span><br><span class="line">21.2.3  可配置的缓存和暂时存储器 388</span><br><span class="line">21.2.4  提高原子操作的速度 389</span><br><span class="line">21.2.5  提高全局内存的访问速度 389</span><br><span class="line">21.3  kernel函数执行控制过程的演变 389</span><br><span class="line">21.3.1  kernel函数内部的函数调用 389</span><br><span class="line">21.3.2  kernel函数中的异常处理 390</span><br><span class="line">21.3.3  多个kernel函数的同步执行 390</span><br><span class="line">21.3.4  可中断的kernel函数 391</span><br><span class="line">21.4  内核的性能 391</span><br><span class="line">21.4.1  双精度的速度 391</span><br><span class="line">21.4.2  更好的控制流效率 392</span><br><span class="line">21.5  编程环境 392</span><br><span class="line">21.6  美好前景 392</span><br><span class="line">参考文献 393</span><br><span class="line">附录A  矩阵乘法主机版的源代码 395</span><br><span class="line">附录B  GPU的计算能力 407</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00HFID4QW/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00HFID4QW&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51tgi35XFoL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop基础教程</title>
    <url>/2020/04/19/B00HLX04IC/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Hadoop基础教程<br>作者信息： 作者: 特金顿 (Garry Turkington) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>揭开了Hadoop的神秘面纱，它着重讲解了如何应用Hadoop和相关技术搭建工作系统并完成任务。在读者明白这些内容之后，又介绍了如何使用云服务完成相同任务。从Hadoop的基本概念和初始设置入手，讲述了如何开发Hadoop程序，如何在数据规模增长的时候维持系统运行，涵盖了有效使用Hadoop处理实际问题所需用到的全部知识。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 绪论 1</span><br><span class="line">1.1 大数据处理 1</span><br><span class="line">1.1.1 数据的价值 2</span><br><span class="line">1.1.2 受众较少 2</span><br><span class="line">1.1.3 一种不同的方法 4</span><br><span class="line">1.1.4 Hadoop 7</span><br><span class="line">1.2 基于Amazon Web Services的云计算 12</span><br><span class="line">1.2.1 云太多了 12</span><br><span class="line">1.2.2 第三种方法 12</span><br><span class="line">1.2.3 不同类型的成本 12</span><br><span class="line">1.2.4 AWS：Amazon的弹性架构 13</span><br><span class="line">1.2.5 本书内容 14</span><br><span class="line">1.3 小结 15</span><br><span class="line">第2章 安装并运行Hadoop 16</span><br><span class="line">2.1 基于本地Ubuntu主机的Hadoop系统 16</span><br><span class="line">2.2 实践环节：检查是否已安装JDK 17</span><br><span class="line">2.3 实践环节：下载Hadoop 18</span><br><span class="line">2.4 实践环节：安装SSH 19</span><br><span class="line">2.5 实践环节：使用Hadoop计算圆周率 20</span><br><span class="line">2.6 实践环节：配置伪分布式模式 22</span><br><span class="line">2.7 实践环节：修改HDFS的根目录 24</span><br><span class="line">2.8 实践环节：格式化NameNode 25</span><br><span class="line">2.9 实践环节：启动Hadoop 26</span><br><span class="line">2.10 实践环节：使用HDFS 27</span><br><span class="line">2.11 实践环节：MapReduce的经典入门程序——字数统计 28</span><br><span class="line">2.12 使用弹性MapReduce 33</span><br><span class="line">2.13 实践环节：使用管理控制台在EMR运行WordCount 34</span><br><span class="line">2.13.1 使用EMR的其他方式 41</span><br><span class="line">2.13.2 AWS生态系统 42</span><br><span class="line">2.14 本地Hadoop与EMRHadoop的对比 42</span><br><span class="line">2.15 小结 43</span><br><span class="line">第3章 理解MapReduce 44</span><br><span class="line">3.1 键值对 44</span><br><span class="line">3.1.1 具体含义 44</span><br><span class="line">3.1.2 为什么采用键／值数据 45</span><br><span class="line">3.1.3 MapReduce作为一系列键／值变换 46</span><br><span class="line">3.2 MapReduce的HadoopJavaAPI 47</span><br><span class="line">3.3 编写MapReduce程序 50</span><br><span class="line">3.4 实践环节：设置classpath 50</span><br><span class="line">3.5 实践环节：实现WordCount 51</span><br><span class="line">3.6 实践环节：构建JAR文件 53</span><br><span class="line">3.7 实践环节：在本地Hadoop集群运行WordCount 54</span><br><span class="line">3.8 实践环节：在EMR上运行WordCount 54</span><br><span class="line">3.8.1 0.20之前版本的JavaMapReduceAPI 56</span><br><span class="line">3.8.2 Hadoop提供的mapper和reducer实现 57</span><br><span class="line">3.9 实践环节：WordCount的简易方法 58</span><br><span class="line">3.10 查看WordCount的运行全貌 59</span><br><span class="line">3.10.1 启动 59</span><br><span class="line">3.10.2 将输入分块 59</span><br><span class="line">3.10.3 任务分配 60</span><br><span class="line">3.10.4 任务启动 60</span><br><span class="line">3.10.5 不断监视JobTracker 60</span><br><span class="line">3.10.6 mapper的输入 61</span><br><span class="line">3.10.7 mapper的执行 61</span><br><span class="line">3.10.8 mapper的输出和reducer的输入 61</span><br><span class="line">3.10.9 分块 62</span><br><span class="line">3.10.10 可选分块函数 62</span><br><span class="line">3.10.11 reducer类的输入 62</span><br><span class="line">3.10.12 reducer类的执行 63</span><br><span class="line">3.10.13 reducer类的输出 63</span><br><span class="line">3.10.14 关机 63</span><br><span class="line">3.10.15 这就是MapReduce的全部 64</span><br><span class="line">3.10.16 也许缺了combiner 64</span><br><span class="line">3.11 实践环节：使用combiner编写WordCount 64</span><br><span class="line">3.12 实践环节：更正使用combiner的WordCount 65</span><br><span class="line">3.13 Hadoop专有数据类型 67</span><br><span class="line">3.13.1 Writable和Writable—Comparable接口 67</span><br><span class="line">3.13.2 wrapper类介绍 68</span><br><span class="line">3.14 实践环节：使用Writable包装类 69</span><br><span class="line">3.15 输入／输出 71</span><br><span class="line">3.15.1 文件、split和记录 71</span><br><span class="line">3.15.2 InputFormat和RecordReader 71</span><br><span class="line">3.15.3 Hadoop提供的InputFormat 72</span><br><span class="line">3.15.4 Hadoop提供的RecordReader 73</span><br><span class="line">3.15.5 OutputFormat和Record—Writer 73</span><br><span class="line">3.15.6 Hadoop提供的OutputFormat 73</span><br><span class="line">3.15.7 别忘了Sequencefiles 74</span><br><span class="line">3.16 小结 74</span><br><span class="line">第4章 开发MapReduce程序 75</span><br><span class="line">4.1 使用非Java语言操作Hadoop 75</span><br><span class="line">4.1.1 HadoopStreaming工作原理 76</span><br><span class="line">4.1.2 使用HadoopStreaming的原因 76</span><br><span class="line">4.2 实践环节：使用Streaming实现Word—Count 76</span><br><span class="line">4.3 分析大数据集 79</span><br><span class="line">4.3.1 获取UFO目击事件数据集 79</span><br><span class="line">4.3.2 了解数据集 80</span><br><span class="line">4.4 实践环节：统计汇总UFO数据 80</span><br><span class="line">4.5 实践环节：统计形状数据 82</span><br><span class="line">4.6 实践环节：找出目击事件的持续时间与UFO形状的关系 84</span><br><span class="line">4.7 实践环节：在命令行中执行形状／时间分析 87</span><br><span class="line">4.8 实践环节：使用ChainMapper进行字段验证／分析 88</span><br><span class="line">4.9 实践环节：使用DistributedCache改进地点输出 93</span><br><span class="line">4.10 计数器、状态和其他输出 96</span><br><span class="line">4.11 实践环节：创建计数器、任务状态和写入日志 96</span><br><span class="line">4.12 小结 102</span><br><span class="line">第5章 高级MapReduce技术 103</span><br><span class="line">5.1 初级、高级还是中级 103</span><br><span class="line">5.2 多数据源联结 103</span><br><span class="line">5.2.1 不适合执行联结操作的情况 104</span><br><span class="line">5.2.2 map端联结与reduce端联结的对比 104</span><br><span class="line">5.2.3 匹配账户与销售信息 105</span><br><span class="line">5.3 实践环节：使用MultipleInputs实现reduce端联结 105</span><br><span class="line">5.3.1 实现map端联结 109</span><br><span class="line">5.3.2 是否进行联结 112</span><br><span class="line">5.4 图算法 112</span><br><span class="line">5.4.1 Graph101 112</span><br><span class="line">5.4.2 图和MapReduce 112</span><br><span class="line">5.4.3 图的表示方法 113</span><br><span class="line">5.5 实践环节：图的表示 114</span><br><span class="line">5.6 实践环节：创建源代码 115</span><br><span class="line">5.7 实践环节：第一次运行作业 119</span><br><span class="line">5.8 实践环节：第二次运行作业 120</span><br><span class="line">5.9 实践环节：第三次运行作业 121</span><br><span class="line">5.10 实践环节：第四次也是最后一次运行作业 122</span><br><span class="line">5.10.1 运行多个作业 124</span><br><span class="line">5.10.2 关于图的终极思考 124</span><br><span class="line">5.11 使用语言无关的数据结构 124</span><br><span class="line">5.11.1 候选技术 124</span><br><span class="line">5.11.2 Avro简介 125</span><br><span class="line">5.12 实践环节：获取并安装Avro 125</span><br><span class="line">5.13 实践环节：定义模式 126</span><br><span class="line">5.14 实践环节：使用Ruby创建Avro源数据 127</span><br><span class="line">5.15 实践环节：使用Java语言编程操作Avro数据 128</span><br><span class="line">5.16 实践环节：在MapReduce中统计UFO形状 130</span><br><span class="line">5.17 实践环节：使用Ruby检查输出数据 134</span><br><span class="line">5.18 实践环节：使用Java检查输出数据 135</span><br><span class="line">5.19 小结 137</span><br><span class="line">第6章 故障处理 138</span><br><span class="line">6.1 故障 138</span><br><span class="line">6.1.1 拥抱故障 138</span><br><span class="line">6.1.2 至少不怕出现故障 139</span><br><span class="line">6.1.3 严禁模仿 139</span><br><span class="line">6.1.4 故障类型 139</span><br><span class="line">6.1.5 Hadoop节点故障 139</span><br><span class="line">6.2 实践环节：杀死DataNode进程 141</span><br><span class="line">6.3 实践环节：复制因子的作用 144</span><br><span class="line">6.4 实践环节：故意造成数据块丢失 146</span><br><span class="line">6.5 实践环节：杀死TaskTracker进程 149</span><br><span class="line">6.6 实践环节：杀死JobTracker 153</span><br><span class="line">6.7 实践环节：杀死NameNode进程 154</span><br><span class="line">6.8 实践环节：引发任务故障 160</span><br><span class="line">6.9 数据原因造成的任务故障 163</span><br><span class="line">6.10 实践环节：使用skip模式处理异常数据 164</span><br><span class="line">6.11 小结 169</span><br><span class="line">第7章 系统运行与维护 170</span><br><span class="line">7.1 关于EMR的说明 170</span><br><span class="line">7.2 Hadoop配置属性 171</span><br><span class="line">7.3 实践环节：浏览默认属性 171</span><br><span class="line">7.3.1 附加的属性元素 172</span><br><span class="line">7.3.2 默认存储位置 172</span><br><span class="line">7.3.3 设置Hadoop属性的几种方式 173</span><br><span class="line">7.4 集群设置 174</span><br><span class="line">7.4.1 为集群配备多少台主机 174</span><br><span class="line">7.4.2 特殊节点的需求 176</span><br><span class="line">7.4.3 不同类型的存储系统 177</span><br><span class="line">7.4.4 Hadoop的网络配置 178</span><br><span class="line">7.5 实践环节：查看默认的机柜配置 180</span><br><span class="line">7.6 实践环节：报告每台主机所在机柜 180</span><br><span class="line">7.7 集群访问控制 183</span><br><span class="line">7.8 实践环节：展示Hadoop的默认安全机制 183</span><br><span class="line">7.9 管理NameNode 187</span><br><span class="line">7.10 实践环节：为fsimage文件新增一个存储路径 188</span><br><span class="line">7.11 实践环节：迁移到新的NameNode主机 190</span><br><span class="line">7.12 管理HDFS 192</span><br><span class="line">7.12.1 数据写入位置 192</span><br><span class="line">7.12.2 使用平衡器 193</span><br><span class="line">7.13 MapReduce管理 193</span><br><span class="line">7.13.1 通过命令行管理作业 193</span><br><span class="line">7.13.2 作业优先级和作业调度 194</span><br><span class="line">7.14 实践环节：修改作业优先级并结束作业运行 194</span><br><span class="line">7.15 扩展集群规模 197</span><br><span class="line">7.15.1 提升本地Hadoop集群的计算能力 197</span><br><span class="line">7.15.2 提升EMR作业流的计算能力 198</span><br><span class="line">7.16 小结 198</span><br><span class="line">第8章 Hive：数据的关系视图 200</span><br><span class="line">8.1 Hive概述 200</span><br><span class="line">8.1.1 为什么使用Hive 200</span><br><span class="line">8.1.2 感谢Facebook 201</span><br><span class="line">8.2 设置Hive 201</span><br><span class="line">8.2.1 准备工作 201</span><br><span class="line">8.2.2 下载Hive 202</span><br><span class="line">8.3 实践环节：安装Hive 202</span><br><span class="line">8.4 使用Hive 203</span><br><span class="line">8.5 实践环节：创建UFO数据表 204</span><br><span class="line">8.6 实践环节：在表中插入数据 206</span><br><span class="line">8.7 实践环节：验证表 208</span><br><span class="line">8.8 实践环节：用正确的列分隔符重定义表 210</span><br><span class="line">8.9 实践环节：基于现有文件创建表 212</span><br><span class="line">8.10 实践环节：执行联结操作 214</span><br><span class="line">8.11 实践环节：使用视图 216</span><br><span class="line">8.12 实践环节：导出查询结果 219</span><br><span class="line">8.13 实践环节：制作UFO目击事件分区表 221</span><br><span class="line">8.13.1 分桶、归并和排序 224</span><br><span class="line">8.13.2 用户自定义函数 225</span><br><span class="line">8.14 实践环节：新增用户自定义函数 225</span><br><span class="line">8.14.1 是否进行预处理 228</span><br><span class="line">8.14.2 Hive和Pig的对比 229</span><br><span class="line">8.14.3 未提到的内容 229</span><br><span class="line">8.15 基于AmazonWebServices的Hive 230</span><br><span class="line">8.16 实践环节：在EMR上分析UFO数据 230</span><br><span class="line">8.16.1 在开发过程中使用交互式作业流 235</span><br><span class="line">8.16.2 与其他AWS产品的集成 236</span><br><span class="line">8.17 小结 236</span><br><span class="line">第9章 与关系数据库协同工作 238</span><br><span class="line">9.1 常见数据路径 238</span><br><span class="line">9.1.1 Hadoop用于存储档案 238</span><br><span class="line">9.1.2 使用Hadoop进行数据预处理 239</span><br><span class="line">9.1.3 使用Hadoop作为数据输入工具 239</span><br><span class="line">9.1.4 数据循环 240</span><br><span class="line">9.2 配置MySQL 240</span><br><span class="line">9.3 实践环节：安装并设置MySQL 240</span><br><span class="line">9.4 实践环节：配置MySQL允许远程连接 243</span><br><span class="line">9.5 实践环节：建立员工数据库 245</span><br><span class="line">9.6 把数据导入Hadoop 246</span><br><span class="line">9.6.1 使用MySQL工具手工导入 246</span><br><span class="line">9.6.2 在mapper中访问数据库 246</span><br><span class="line">9.6.3 更好的方法：使用Sqoop 247</span><br><span class="line">9.7 实践环节：下载并配置Sqoop 247</span><br><span class="line">9.8 实践环节：把MySQL的数据导入HDFS 249</span><br><span class="line">9.9 实践环节：把MySQL数据导出到Hive 253</span><br><span class="line">9.10 实践环节：有选择性的导入数据 255</span><br><span class="line">9.11 实践环节：使用数据类型映射 257</span><br><span class="line">9.12 实践环节：通过原始查询导入数据 258</span><br><span class="line">9.13 从Hadoop导出数据 261</span><br><span class="line">9.13.1 在reducer中把数据写入关系数据库 261</span><br><span class="line">9.13.2 利用reducer输出SQL数据文件 262</span><br><span class="line">9.13.3 仍是最好的方法 262</span><br><span class="line">9.14 实践环节：把Hadoop数据导入MySQL 262</span><br><span class="line">9.15 实践环节：把Hive数据导入MySQL 265</span><br><span class="line">9.16 实践环节：改进mapper并重新运行数据导出命令 267</span><br><span class="line">9.17 在AWS上使用Sqoop 269</span><br><span class="line">9.18 小结 270</span><br><span class="line">第10章 使用Flume收集数据 271</span><br><span class="line">10.1 关于AWS的说明 271</span><br><span class="line">10.2 无处不在的数据 271</span><br><span class="line">10.2.1 数据类别 272</span><br><span class="line">10.2.2 把网络流量导入Hadoop 272</span><br><span class="line">10.3 实践环节：把网络服务器数据导入Hadoop 272</span><br><span class="line">10.3.1 把文件导入Hadoop 273</span><br><span class="line">10.3.2 潜在的问题 273</span><br><span class="line">10.4 ApacheFlume简介 274</span><br><span class="line">10.5 实践环节：安装并配置Flume 275</span><br><span class="line">10.6 实践环节：把网络流量存入日志文件 277</span><br><span class="line">10.7 实践环节：把日志输出到控制台 279</span><br><span class="line">10.8 实践环节：把命令的执行结果写入平面文件 281</span><br><span class="line">10.9 实践环节：把远程文件数据写入本地平面文件 283</span><br><span class="line">10.9.1 信源、信宿和信道 284</span><br><span class="line">10.9.2 Flume配置文件 286</span><br><span class="line">10.9.3 一切都以事件为核心 287</span><br><span class="line">10.10 实践环节：把网络数据写入HDFS 287</span><br><span class="line">10.11 实践环节：加入时间戳 289</span><br><span class="line">10.12 实践环节：多层Flume网络 292</span><br><span class="line">10.13 实践环节：把事件写入多个信宿 294</span><br><span class="line">10.13.1 选择器的类型 295</span><br><span class="line">10.13.2 信宿故障处理 295</span><br><span class="line">10.13.3 使用简单元件搭建复杂系统 296</span><br><span class="line">10.14 更高的视角 297</span><br><span class="line">10.14.1 数据的生命周期 297</span><br><span class="line">10.14.2 集结数据 297</span><br><span class="line">10.14.3 调度 297</span><br><span class="line">10.15 小结 298</span><br><span class="line">第11章 展望未来 299</span><br><span class="line">11.1 全书回顾 299</span><br><span class="line">11.2 即将到来的Hadoop变革 300</span><br><span class="line">11.3 其他版本的Hadoop软件包 300</span><br><span class="line">11.4 其他Apache项目 303</span><br><span class="line">11.4.1 HBase 303</span><br><span class="line">11.4.2 Oozie 303</span><br><span class="line">11.4.3 Whir 304</span><br><span class="line">11.4.4 Mahout 304</span><br><span class="line">11.4.5 MRUnit 305</span><br><span class="line">11.5 其他程序设计模式 305</span><br><span class="line">11.5.1 Pig 305</span><br><span class="line">11.5.2 Cascading 305</span><br><span class="line">11.6 AWS资源 306</span><br><span class="line">11.6.1 在EMR上使用HBase 306</span><br><span class="line">11.6.2 SimpleDB 306</span><br><span class="line">11.6.3 DynamoDB 306</span><br><span class="line">11.7 获取信息的渠道 307</span><br><span class="line">11.7.1 源代码 307</span><br><span class="line">11.7.2 邮件列表和论坛 307</span><br><span class="line">11.7.3 LinkedIn群组 307</span><br><span class="line">11.7.4 Hadoop用户群 307</span><br><span class="line">11.7.5 会议 308</span><br><span class="line">11.8 小结 308</span><br><span class="line">随堂测验答案 309</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00HLX04IC/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00HLX04IC&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51HxY8k9ADL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏引擎架构</title>
    <url>/2020/04/19/B00HY8SIX2/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 游戏引擎架构<br>作者信息： 作者: 杰森.格雷戈瑞 (Jason Gregory) [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>迈向现代游戏之路完美入口，业界万众企盼，隆重推荐！《游戏引擎架构》由游戏界传奇人物云风及“天天爱消除”团队倾情作序推荐，既是游戏工作者必读Bible，对其他IT从业者也不无裨益。內容包括：- 游戏开发中的大规模C++软件架构- 游戏编程所需的数学- 供调试、源代码控制及性能剖析的游戏开发工具- 引擎基础系统、渲染、碰撞、物理、角色动画、游戏世界对象模型等引擎子系统- 多平台游戏引擎- 多处理器环境下的游戏编程- 工作管道及游戏资产数据库</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">推荐序1 iii</span><br><span class="line">推荐序2 v</span><br><span class="line">译序 vii</span><br><span class="line">序言 xvii</span><br><span class="line">前言 xix</span><br><span class="line">致谢 xxi</span><br><span class="line">第一部分  基础 1</span><br><span class="line">第1章  导论 3</span><br><span class="line">1.1 典型游戏团队的结构 4</span><br><span class="line">1.2 游戏是什么 7</span><br><span class="line">1.3 游戏引擎是什么 10</span><br><span class="line">1.4 不同游戏类型中的引擎差异 11</span><br><span class="line">1.5 游戏引擎概观 22</span><br><span class="line">1.6 运行时引擎架构 27</span><br><span class="line">1.7 工具及资产管道 46</span><br><span class="line">第2章  专业工具 53</span><br><span class="line">2.1 版本控制 53</span><br><span class="line">2.2 微软Visual Studio 61</span><br><span class="line">2.3 剖析工具 78</span><br><span class="line">2.4 内存泄漏和损坏检测 79</span><br><span class="line">2.5 其他工具 80</span><br><span class="line">第3章  游戏软件工程基础 83</span><br><span class="line">3.1 重温C++及最佳实践 83</span><br><span class="line">3.2 C&#x2F;C++的数据、代码及内存 90</span><br><span class="line">3.3 捕捉及处理错误 118</span><br><span class="line">第4章  游戏所需的三维数学 125</span><br><span class="line">4.1 在二维中解决三维问题 125</span><br><span class="line">4.2 点和矢量 125</span><br><span class="line">4.3 矩阵 139</span><br><span class="line">4.4 四元数 156</span><br><span class="line">4.5 比较各种旋转表达方式 164</span><br><span class="line">4.6 其他数学对象 168</span><br><span class="line">4.7 硬件加速的SIMD运算 173</span><br><span class="line">4.8 产生随机数 180</span><br><span class="line">第二部分  低阶引擎系统 183</span><br><span class="line">第5章  游戏支持系统 185</span><br><span class="line">5.1 子系统的启动和终止 185</span><br><span class="line">5.2 内存管理 193</span><br><span class="line">5.3 容器 208</span><br><span class="line">5.4 字符串 225</span><br><span class="line">5.5 引擎配置 234</span><br><span class="line">第6章  资源及文件系统 241</span><br><span class="line">6.1 文件系统 241</span><br><span class="line">6.2 资源管理器 251</span><br><span class="line">第7章  游戏循环及实时模拟 277</span><br><span class="line">7.1 渲染循环 277</span><br><span class="line">7.2 游戏循环 278</span><br><span class="line">7.3 游戏循环的架构风格 280</span><br><span class="line">7.4 抽象时间线 283</span><br><span class="line">7.5 测量及处理时间 285</span><br><span class="line">7.6 多处理器的游戏循环 296</span><br><span class="line">7.7 网络多人游戏循环 304</span><br><span class="line">第8章  人体学接口设备（HID） 309</span><br><span class="line">8.1 各种人体学接口设备 309</span><br><span class="line">8.2 人体学接口设备的接口技术 311</span><br><span class="line">8.3 输入类型 312</span><br><span class="line">8.4 输出类型 316</span><br><span class="line">8.5 游戏引擎的人体学接口设备系统 318</span><br><span class="line">8.6 人体学接口设备使用实践 332</span><br><span class="line">第9章  调试及开发工具 333</span><br><span class="line">9.1 日志及跟踪 333</span><br><span class="line">9.2 调试用的绘图功能 337</span><br><span class="line">9.3 游戏内置菜单 344</span><br><span class="line">9.4 游戏内置主控台 347</span><br><span class="line">9.5 调试用摄像机和游戏暂停 348</span><br><span class="line">9.6 作弊 348</span><br><span class="line">9.7 屏幕截图及录像 349</span><br><span class="line">9.8 游戏内置性能剖析 349</span><br><span class="line">9.9 游戏内置的内存统计和泄漏检测 356</span><br><span class="line">第三部分  图形及动画 359</span><br><span class="line">第10章  渲染引擎 361</span><br><span class="line">10.1 采用深度缓冲的三角形光栅化基础 361</span><br><span class="line">10.2 渲染管道 404</span><br><span class="line">10.3 高级光照及全局光照 426</span><br><span class="line">10.4 视觉效果和覆盖层 438</span><br><span class="line">10.5 延伸阅读 446</span><br><span class="line">第11章  动画系统 447</span><br><span class="line">11.1 角色动画的类型 447</span><br><span class="line">11.2 骨骼 452</span><br><span class="line">11.3 姿势 454</span><br><span class="line">11.4 动画片段 459</span><br><span class="line">11.5 蒙皮及生成矩阵调色板 471</span><br><span class="line">11.6 动画混合 476</span><br><span class="line">11.7 后期处理 493</span><br><span class="line">11.8 压缩技术 496</span><br><span class="line">11.9 动画系统架构 501</span><br><span class="line">11.10 动画管道 502</span><br><span class="line">11.11 动作状态机 515</span><br><span class="line">11.12 动画控制器 535</span><br><span class="line">第12章  碰撞及刚体动力学 537</span><br><span class="line">12.1 你想在游戏中加入物理吗 537</span><br><span class="line">12.2 碰撞&#x2F;物理中间件 542</span><br><span class="line">12.3 碰撞检测系统 544</span><br><span class="line">12.4 刚体动力学 569</span><br><span class="line">12.5 整合物理引擎至游戏 601</span><br><span class="line">12.6 展望：高级物理功能 616</span><br><span class="line">第四部分  游戏性 617</span><br><span class="line">第13章  游戏性系统简介 619</span><br><span class="line">13.1 剖析游戏世界 619</span><br><span class="line">13.2 实现动态元素：游戏对象 623</span><br><span class="line">13.3 数据驱动游戏引擎 626</span><br><span class="line">13.4 游戏世界编辑器 627</span><br><span class="line">第14章  运行时游戏性基础系统 637</span><br><span class="line">14.1 游戏性基础系统的组件 637</span><br><span class="line">14.2 各种运行时对象模型架构 640</span><br><span class="line">14.3 世界组块的数据格式 657</span><br><span class="line">14.4 游戏世界的加载和串流 663</span><br><span class="line">14.5 对象引用与世界查询 670</span><br><span class="line">14.6 实时更新游戏对象 676</span><br><span class="line">14.7 事件与消息泵 690</span><br><span class="line">14.8 脚本 707</span><br><span class="line">14.9 高层次的游戏流程 726</span><br><span class="line">第五部分  总结 727</span><br><span class="line">第15章  还有更多内容吗 729</span><br><span class="line">15.1 一些未谈及的引擎系统 729</span><br><span class="line">15.2 游戏性系统 730</span><br><span class="line">参考文献 733</span><br><span class="line">中文索引 737</span><br><span class="line">英文索引 755</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00HY8SIX2/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00HY8SIX2&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51lRGtmK8mL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>数学之美(第二版)</title>
    <url>/2020/04/19/B00P6OJ09C/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 数学之美(第二版)<br>作者信息： 作者: 吴军 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>获奖畅销书《数学之美》第一版荣获国家图书馆第八届文津图书奖<br>第一版入选广电总局“2014年向全国青少年推荐百种优秀图书书目”，荣获2012-2013年度全行业优秀畅销书<br>信息领域大学生必读好书，央视新闻推荐的学科敲门砖<br>《浪潮之巅》、《文明之光》作者吴军博士最新力作，李开复作序推荐，Google黑板报百万点击！<br>新版增加了大数据和机器学习等最新内容，以满足人们对当下技术的学习需求；同时，根据专家和读者的反馈更正了错漏，并更新了部分内容</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一版读者赞誉</span><br><span class="line">第二版出版说明</span><br><span class="line">第一版序言</span><br><span class="line">第二版序言</span><br><span class="line">第二版前言</span><br><span class="line">第1章 文字和语言 vs 数字和信息 1</span><br><span class="line">1 信息</span><br><span class="line">2 文字和数字</span><br><span class="line">3 文字和语言背后的数学</span><br><span class="line">4 小结</span><br><span class="line">第2章 自然语言处理——从规则到统计 15</span><br><span class="line">1 机器智能</span><br><span class="line">2 从规则到统计</span><br><span class="line">3 小结</span><br><span class="line">第3章 统计语言模型 27</span><br><span class="line">1 用数学的方法描述语言规律</span><br><span class="line">2 延伸阅读：统计语言模型的工程诀窍</span><br><span class="line">3 小结</span><br><span class="line">第4章 谈谈分词 41</span><br><span class="line">1 中文分词方法的演变</span><br><span class="line">2 延伸阅读：如何衡量分词的结果</span><br><span class="line">3 小结</span><br><span class="line">第5章 隐含马尔可夫模型 50</span><br><span class="line">1 通信模型</span><br><span class="line">2 隐含马尔可夫模型</span><br><span class="line">3 延伸阅读：隐含马尔可夫模型的训练</span><br><span class="line">4 小结</span><br><span class="line">第6章 信息的度量和作用 60</span><br><span class="line">1 信息熵</span><br><span class="line">2 信息的作用</span><br><span class="line">3 互信息</span><br><span class="line">4 延伸阅读：相对熵</span><br><span class="line">5 小结</span><br><span class="line">第7章 贾里尼克和现代语言处理 72</span><br><span class="line">1 早年生活</span><br><span class="line">2 从水门事件到莫妮卡·莱温斯基</span><br><span class="line">3 一位老人的奇迹</span><br><span class="line">第8章 简单之美——布尔代数和搜索引擎 82</span><br><span class="line">1 布尔代数</span><br><span class="line">2 索引</span><br><span class="line">3 小结</span><br><span class="line">第9章 图论和网络爬虫 89</span><br><span class="line">1 图论</span><br><span class="line">2 网络爬虫</span><br><span class="line">3 延伸阅读：图论的两点补充说明</span><br><span class="line">4 小结</span><br><span class="line">第10章 PageRank——Google的民主表决式网页排名技术 98</span><br><span class="line">1 PageRank 算法的原理</span><br><span class="line">2 延伸阅读：PageRank的计算方法</span><br><span class="line">3 小结</span><br><span class="line">第11章 如何确定网页和查询的相关性 104</span><br><span class="line">1 搜索关键词权重的科学度量TF—IDF</span><br><span class="line">2 延伸阅读：TF—IDF的信息论依据</span><br><span class="line">3 小结</span><br><span class="line">第12章 有限状态机和动态规划——地图与本地搜索的核心技术 111</span><br><span class="line">1 地址分析和有限状态机</span><br><span class="line">2 全球导航和动态规划</span><br><span class="line">3 延伸阅读：有限状态传感器</span><br><span class="line">4 小结</span><br><span class="line">第13章 Google AK—47的设计者——阿米特·辛格博士 121</span><br><span class="line">第14章 余弦定理和新闻的分类 127</span><br><span class="line">1 新闻的特征向量</span><br><span class="line">2 向量距离的度量</span><br><span class="line">3 延伸阅读：计算向量余弦的技巧</span><br><span class="line">4 小结</span><br><span class="line">第15章 矩阵运算和文本处理中的两个分类问题 136</span><br><span class="line">1 文本和词汇的矩阵</span><br><span class="line">2 延伸阅读：奇异值分解的方法和应用场景</span><br><span class="line">3 小结</span><br><span class="line">第16章 信息指纹及其应用 142</span><br><span class="line">1 信息指纹</span><br><span class="line">2 信息指纹的用途</span><br><span class="line">3 延伸阅读：信息指纹的重复性和相似哈希</span><br><span class="line">4 小结</span><br><span class="line">第17章 由电视剧《暗算》所想到的——谈谈密码学的数学原理 153</span><br><span class="line">1 密码学的自发时代</span><br><span class="line">2 信息论时代的密码学</span><br><span class="line">3 小结</span><br><span class="line">第18章 闪光的不一定是金子——谈谈搜索引擎反作弊问题和搜索结果的权威性问题 162</span><br><span class="line">1 搜索引擎的反作弊</span><br><span class="line">2 搜索结果的权威性</span><br><span class="line">3 小结</span><br><span class="line">第19章 谈谈数学模型的重要性 171</span><br><span class="line">第20章 不要把鸡蛋放到一个篮子里——谈谈最大熵模型 177</span><br><span class="line">1 最大熵原理和最大熵模型</span><br><span class="line">2 延伸阅读：最大熵模型的训练</span><br><span class="line">3 小结</span><br><span class="line">第21章 拼音输入法的数学原理 186</span><br><span class="line">1 输入法与编码</span><br><span class="line">2 输入一个汉字需要敲多少个键——谈谈香农第一定理</span><br><span class="line">3 拼音转汉字的算法</span><br><span class="line">4 延伸阅读：个性化的语言模型</span><br><span class="line">5 小结</span><br><span class="line">第22章 自然语言处理的教父马库斯和他的优秀弟子们 197</span><br><span class="line">1 教父马库斯</span><br><span class="line">2 从宾夕法尼亚大学走出的精英们</span><br><span class="line">第23章 布隆过滤器 204</span><br><span class="line">1 布隆过滤器的原理</span><br><span class="line">2 延伸阅读：布隆过滤器的误识别问题</span><br><span class="line">3 小结</span><br><span class="line">第24章 马尔可夫链的扩展——贝叶斯网络 209</span><br><span class="line">1 贝叶斯网络</span><br><span class="line">2 贝叶斯网络在词分类中的应用</span><br><span class="line">3 延伸阅读：贝叶斯网络的训练</span><br><span class="line">4 小结</span><br><span class="line">第25章 条件随机场、文法分析及其他 217</span><br><span class="line">1 文法分析——计算机算法的演变</span><br><span class="line">2 条件随机场</span><br><span class="line">3 条件随机场在其他领域的应用</span><br><span class="line">4 小结</span><br><span class="line">第26章 维特比和他的维特比算法 227</span><br><span class="line">1 维特比算法</span><br><span class="line">2 CDMA技术——3G移动通信的基础</span><br><span class="line">3 小结</span><br><span class="line">第27章 上帝的算法——期望最大化算法 238</span><br><span class="line">1 文本的自收敛分类</span><br><span class="line">2 延伸阅读：期望最大化和收敛的必然性</span><br><span class="line">3 小结</span><br><span class="line">第28章 逻辑回归和搜索广告 244</span><br><span class="line">1 搜索广告的发展</span><br><span class="line">2 逻辑回归模型</span><br><span class="line">3 小结</span><br><span class="line">第29章 各个击破算法和Google云计算的基础 249</span><br><span class="line">1 分治算法的原理</span><br><span class="line">2 从分治算法到MapReduce</span><br><span class="line">3 小结</span><br><span class="line">第30章 Google大脑和人工神经网络 254</span><br><span class="line">1 人工神经网络</span><br><span class="line">2 训练人工神经网络</span><br><span class="line">3 人工神经网络与贝叶斯网络的关系</span><br><span class="line">4 延伸阅读：Google大脑</span><br><span class="line">5 小结</span><br><span class="line">第31章 大数据的威力——谈谈数据的重要性 273</span><br><span class="line">1 数据的重要性</span><br><span class="line">2 数据的统计和信息技术</span><br><span class="line">3 为什么需要大数据</span><br><span class="line">4 小结</span><br><span class="line">附录 计算复杂度 295</span><br><span class="line">第二版后记 299</span><br><span class="line">索引 302</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00P6OJ09C/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00P6OJ09C&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/61lq4dHf25L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB之父 教你编程</title>
    <url>/2020/04/19/B00ISKO4DS/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： MATLAB之父 教你编程<br>作者信息： 作者: Cleve Moler [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《MATLAB 之父：编程实践》是克利夫（Cleve）继《MATLAB 数值分析与科学计算―― 基于MATLAB（修订版）》（Numerical Computing with MATLAB）之后所独立编写的第二本关于MATLAB 应用的书籍，主要是面向高中或大学低年级的读者，目的是想通过实验的方法将MATLAB 语言介绍给广大的初学者，为大家提供一系列在应用数学、科学计算和MATLAB 编程中有代表性的非常实用且有深刻数学意义的实验案例，从而帮助学习人员加深产品认知并有效提高工程应用能力。此书电子首稿于2008 年完成并在过去的5 年里，进行了陆陆续续的精心修订，这次是该书的首个中文版。《MATLAB 之父：编程实践》一书的英文原版行文生动，案例新颖，处处体现数学之美，字里行间更无不反映出作者的奇思妙想，风趣易懂，每个实验案例的解答都充斥着一种探求式的好奇精神。强烈的好奇心，是克利夫给人留下的最深印象，大到人文历史风土人情，小到会议讲座礼尚往来，他都保持着一种童真般的好奇。这种强烈的好奇心也可以从这本书涉猎广泛的内容中得到体会―― 矩阵、历法、谷歌网页排名、音乐、天体运行、分形图、生命进化、数独等等包罗万象。这些精彩的内容连同生动文笔都在薛定宇老师的译本中得到了很好的体现。薛老师自己的书在读者中享有很高声誉，我最早拜读的就是他写的自动控制领域经典的教材《控制系统计算机辅助设计―― MATLAB 语言与应用》，结构严谨，思维缜密，内容翔实。这种风格在此书中文版的翻译中与原文达到了奇妙融合，使读者在领略克利夫的独特思路时逻辑清晰，而且兴趣盎然，一定是一次非常愉快的阅读体验。《MATLAB 之父：编程实践》是北京航空航天大学出版社与迈斯沃克公司在图书合作方面的一个杰作，是迈斯沃克公司近两年中国图书计划中最重要的一个项目。《MATLAB之父：编程实践》一书也获得国内最大的MATLAB/Simulink技术交流平台——MATLAB中文论坛的鼎力推荐,MATLAB中文论坛的“MATLAB读书频道”为本书提供了专门版块供读者交流，以期共同进步。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">写在前面i</span><br><span class="line">译者的话iii</span><br><span class="line">前言v</span><br><span class="line">第1章迭代（Iteration） 1</span><br><span class="line">第2章斐波那契数（Fibonacci Numbers） 15</span><br><span class="line">第3章日历与时钟（Calendars and Clocks） 29</span><br><span class="line">第4章矩阵（Matrices） 39</span><br><span class="line">第5章线性方程组（Linear Equations） 53</span><br><span class="line">第6章蕨型叶分形（Fractal Fern） 63</span><br><span class="line">第7章谷歌的网页排名值（Google PageRank） 71</span><br><span class="line">第8章指数函数（Exponential Function） 85</span><br><span class="line">第9章T 形积木（T Puzzle） 99</span><br><span class="line">第10章幻方问题（Magic Squares） 107</span><br><span class="line">第11章井字棋的魅力（TicTacToe Magic） 123</span><br><span class="line">第12章生命游戏（Game of Life） 131</span><br><span class="line">第13章曼德勃罗集（Mandelbrot Set） 141</span><br><span class="line">第14章数独（Sudoku） 159</span><br><span class="line">第15章常微分方程（Ordinary Differential Equations） 173</span><br><span class="line">第16章捕食者与猎物模型（Predator–Prey Model） 185</span><br><span class="line">第17章轨道（Orbits） 191</span><br><span class="line">第18章浅水方程（Shallow Water Equations） 207</span><br><span class="line">第19章摩尔斯电码（Morse Code） 211</span><br><span class="line">第20章音乐（Music） 227</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00ISKO4DS/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00ISKO4DS&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/414fV1u%2BXnL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>PPT,要你好看</title>
    <url>/2020/04/19/B010176244/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： PPT,要你好看<br>作者信息： 作者: 杨臻 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>PPT是现代职场必备工具之一，它让人又爱又恨，因为PPT有助于观点有效表达与展示，加深听众理解，但制作一份优秀的PPT又是件让人抓狂的事。这本书将让你不再抓狂，书中不仅列举了大量优秀实例，同时涵盖全面的PPT设计基础知识，更有各种操作技巧及设计思路的探讨。菜鸟们可作为基础入门及提升用，高手们可用来温故知新，查缺补漏，开拓PPT制作思路。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章</span><br><span class="line">演示初心／1</span><br><span class="line">1.1 为什么要做PPT？／2</span><br><span class="line">1.2 PPT的四堂理论课／4</span><br><span class="line">1.3 如何成为PPT高手／7</span><br><span class="line">第2章</span><br><span class="line">制图概要／9</span><br><span class="line">2.1 急速熟悉PowerPoint2010／10</span><br><span class="line">2.2 PowerPoint的五个制图功能／15</span><br><span class="line">2.3 PPT的三大制图技巧／27</span><br><span class="line">2.4 PPT图示制作基础／34</span><br><span class="line">第3章</span><br><span class="line">字体气质／38</span><br><span class="line">3.1 文字的缺点及优点／39</span><br><span class="line">3.2 文字的三要素／39</span><br><span class="line">3.3 字体的选择／45</span><br><span class="line">第4章</span><br><span class="line">图像力量／55</span><br><span class="line">4.1 图片的作用／56</span><br><span class="line">4.2 图片的用法／57</span><br><span class="line">4.3 图片选择的雷区／60</span><br><span class="line">4.4 苹果公司怎样用图片／66</span><br><span class="line">4.5 图片的格式分类／69</span><br><span class="line">4.6 图片的搜索／71</span><br><span class="line">4.7 图片的基本处理／73</span><br><span class="line">4.8 图片的高阶处理／76</span><br><span class="line">4.9 多图安排的注意事项／78</span><br><span class="line">4.10图文混排／79</span><br><span class="line">目录0528.indd82015／6／412：16：06</span><br><span class="line">第5章</span><br><span class="line">图表魔术／82</span><br><span class="line">5.1 表格和图表的四个基本要求／83</span><br><span class="line">5.2 表格的设计／86</span><br><span class="line">5.3 图表的基本构成／89</span><br><span class="line">5.4 选择正确的图表／90</span><br><span class="line">5.5 图表的制作／94</span><br><span class="line">5.6 几种经典图表／98</span><br><span class="line">5.7 图表的美化／101</span><br><span class="line">5.8 图表的真相／104</span><br><span class="line">5.9 启发图表制作的5个站点／107</span><br><span class="line">第6章</span><br><span class="line">图示表达／109</span><br><span class="line">6.1 图示制作的三大误区／110</span><br><span class="line">6.2 基本关系的图示化／112</span><br><span class="line">6.3 复杂关系的图示化／125</span><br><span class="line">6.4 图示的美化／126</span><br><span class="line">第7章</span><br><span class="line">解密动画／130</span><br><span class="line">7.1 动画的作用／131</span><br><span class="line">7.2 动画的要求／131</span><br><span class="line">7.3 动画的三种类型／132</span><br><span class="line">7.4 动画的基本设置／132</span><br><span class="line">7.5 基本动画解析／136</span><br><span class="line">7.6 动画的扩展／140</span><br><span class="line">7.7 辅助动画技巧／147</span><br><span class="line">7.8 页面切换动画／151</span><br><span class="line">7.9 音频与视频／154</span><br><span class="line">第8章</span><br><span class="line">排版语言／158</span><br><span class="line">8.1 要事第一／159</span><br><span class="line">8.2 选择版式／160</span><br><span class="line">8.3 组织信息／163</span><br><span class="line">8.4 锦上添花／172</span><br><span class="line">8.5 化静为动／178</span><br><span class="line">8.6 视线操控／181</span><br><span class="line">8.7 统一风格／184</span><br><span class="line">第9章</span><br><span class="line">色彩感觉／187</span><br><span class="line">9.1 定义颜色／188</span><br><span class="line">9.2 色彩的感受／189</span><br><span class="line">9.3 色彩的性格／191</span><br><span class="line">9.4 色轮／195</span><br><span class="line">9.5 配色方法／198</span><br><span class="line">9.6 配色的捷径／202</span><br><span class="line">第10章</span><br><span class="line">模板速成／204</span><br><span class="line">10.1 模板的构成／205</span><br><span class="line">10.2 创建模板／206</span><br><span class="line">10.3 封面设计／207</span><br><span class="line">10.4 内容页设计／212</span><br><span class="line">10.5 导航系统／215</span><br><span class="line">第11章</span><br><span class="line">保存发布／219</span><br><span class="line">11.1 文件的格式／220</span><br><span class="line">11.2 兼容性问题／221</span><br><span class="line">11.3 演示文稿的保护／222</span><br><span class="line">11.4 使用“演示者”视图／223</span><br><span class="line">11.5 遥控演示PPT／224</span><br><span class="line">11.6 录制幻灯片演示／225</span><br><span class="line">附录A PowerPoint快捷键大全／227</span><br><span class="line">附录B 字体的分类／228</span><br><span class="line">附录C 图表／230</span><br><span class="line">附录D 图示汇总／233</span><br><span class="line">附录E PowerPoint2003／2010动画对照表／236</span><br><span class="line">附录F 达人们都是怎么找图的／237</span><br><span class="line">附录G PPT原创博客推荐／239</span><br><span class="line">附录H 其他一些应该知道的网站／241</span><br><span class="line">鸣谢／242</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B010176244/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B010176244&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41QDpaphKTL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>梦断代码</title>
    <url>/2020/04/19/dreamingincode/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 梦断代码<br>作者信息： 作者: Scott Rosenberg [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>软件乃是人类自以为最有把握，实则最难掌控的技术。《梦断代码》作者罗森伯格对osaf主持的chandler项目进行田野调查，跟踪经年，试图借由chandler项目的开发过程揭示软件开发中的一些根本性大问题。<br>《梦断代码》是讲一事，也是讲百千事；是写一软件，也是写百千软件；是写一群人，也是写百千万人。任何一个在软件领域稍有经验的技术人员看完《梦断代码》，必掩卷长叹：做软件难。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">《梦断代码》</span><br><span class="line">第0章 软件时间 &#x2F; 1</span><br><span class="line">第1章 死定了[2003年7月] &#x2F; 11</span><br><span class="line">第2章 agenda之魂[1968年～2001年] &#x2F; 31</span><br><span class="line">第3章 原型与python[2001年～2002年11月] &#x2F; 53</span><br><span class="line">第4章 乐高王国[2002年11月～2003年8月] &#x2F; 77</span><br><span class="line">第5章 管束奇客和狗[2003年4月～8月] &#x2F; 107</span><br><span class="line">第6章 搞掂设计方案[2003年7月～11月] &#x2F; 133</span><br><span class="line">第7章 细节视图[2004年1月～5月] &#x2F; 161</span><br><span class="line">第8章 白板上的即时贴[2004年6月～10月] &#x2F; 191</span><br><span class="line">第9章 方法 &#x2F; 217</span><br><span class="line">第10章 工程师和艺术家 &#x2F; 249</span><br><span class="line">第11章 通往狗食版之路[2004年11月～2005年11月] &#x2F; 285</span><br><span class="line">尾声 长赌 [2005年～2029年及以后] &#x2F; 317</span><br><span class="line">译后记 &#x2F; 327</span><br><span class="line">附录a 专有名词对译表 &#x2F; 330</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B0057932F4/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0057932F4&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/515myoy81xL._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员的数学</title>
    <url>/2020/04/19/cheng-xu-yuan-de-shu-xue/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 程序员的数学<br>作者信息： 作者: 结城浩 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《程序员的数学》日本版重印14次，面向程序员介绍编程中常用的数学知识，培养初级程序员的数学思维，从基础入手，引导读者深入理解编程中的数学方法和思路，即使没有编程知识也能看懂。<br>《程序员的数学》适合程序设计人员以及编程和数学爱好者阅读。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章 0的故事——无即是有</span><br><span class="line">本章学习内容</span><br><span class="line">小学一年级的回忆</span><br><span class="line">10进制计数法</span><br><span class="line">什么是10进制计数法</span><br><span class="line">分解2503</span><br><span class="line">2进制计数法</span><br><span class="line">什么是2进制计数法</span><br><span class="line">分解1100</span><br><span class="line">基数转换</span><br><span class="line">计算机中为什么采用2进制计数法</span><br><span class="line">按位计数法</span><br><span class="line">什么是按位计数法</span><br><span class="line">不使用按位计数法的罗马数字</span><br><span class="line">指数法则</span><br><span class="line">10的0次方是什么</span><br><span class="line">10—1是什么</span><br><span class="line">规则的扩展</span><br><span class="line">对20进行思考</span><br><span class="line">2—1是什么</span><br><span class="line">0所起的作用</span><br><span class="line">0的作用：占位</span><br><span class="line">0的作用：统一标准，简化规则</span><br><span class="line">日常生活中的0</span><br><span class="line">人类的极限和构造的发现</span><br><span class="line">重温历史进程</span><br><span class="line">为了超越人类的极限</span><br><span class="line">本章小结</span><br><span class="line">第2章 逻辑——真与假的二元世界</span><br><span class="line">本章学习内容</span><br><span class="line">为何逻辑如此重要</span><br><span class="line">逻辑是消除歧义的工具</span><br><span class="line">致对逻辑持否定意见的读者</span><br><span class="line">乘车费用问题——兼顾完整性和排他性</span><br><span class="line">车费规则</span><br><span class="line">命题及其真假</span><br><span class="line">有没有“遗漏”</span><br><span class="line">有没有“重复”</span><br><span class="line">画一根数轴辅助思考</span><br><span class="line">注意边界值</span><br><span class="line">兼顾完整性和排他性</span><br><span class="line">使用if语句分解问题</span><br><span class="line">逻辑的基本是两个分支</span><br><span class="line">建立复杂命题</span><br><span class="line">逻辑非——不是A</span><br><span class="line">逻辑与——A并且B</span><br><span class="line">逻辑或——A或者B</span><br><span class="line">异或——A或者B（但不都满足）</span><br><span class="line">相等——A和B等</span><br><span class="line">蕴涵——若A则B</span><br><span class="line">囊括所有了吗</span><br><span class="line">德•摩根定律</span><br><span class="line">德•摩根定律是什么</span><br><span class="line">对偶性</span><br><span class="line">卡诺图</span><br><span class="line">二灯游戏</span><br><span class="line">首先借助逻辑表达式进行思考</span><br><span class="line">学习使用卡诺图</span><br><span class="line">三灯游戏</span><br><span class="line">包含未定义的逻辑</span><br><span class="line">带条件的逻辑与（&amp;&amp;）</span><br><span class="line">带条件的逻辑或（||）</span><br><span class="line">三值逻辑中的否定（！）</span><br><span class="line">三值逻辑的德？摩根定律</span><br><span class="line">囊括所有了吗</span><br><span class="line">本章小结</span><br><span class="line">第3章 余数——周期性和分组</span><br><span class="line">本章学习内容</span><br><span class="line">星期数的思考题（1）</span><br><span class="line">思考题（100天以后是星期几）</span><br><span class="line">思考题答案</span><br><span class="line">运用余数思考</span><br><span class="line">余数的力量——将较大的数字除一次就能分组</span><br><span class="line">星期数的思考题（2）</span><br><span class="line">思考题（10100天以后是星期几）</span><br><span class="line">提示：可以直接计算吗</span><br><span class="line">思考题答案</span><br><span class="line">发现规律</span><br><span class="line">直观地把握规律</span><br><span class="line">乘方的思考题</span><br><span class="line">思考题（1234567987654321）</span><br><span class="line">提示：通过试算找出规律</span><br><span class="line">思考题答案</span><br><span class="line">回顾：规律和余数的关系</span><br><span class="line">通过黑白棋通信</span><br><span class="line">思考题</span><br><span class="line">提示</span><br><span class="line">思考题答案</span><br><span class="line">奇偶校验</span><br><span class="line">奇偶校验位将数字分为两个集合</span><br><span class="line">寻找恋人的思考题</span><br><span class="line">思考题（寻找恋人）</span><br><span class="line">提示：先试算较小的数</span><br><span class="line">思考题答案</span><br><span class="line">回顾</span><br><span class="line">铺设草席的思考题</span><br><span class="line">思考题（在房间里铺设草席）</span><br><span class="line">提示：先计算一下草席数</span><br><span class="line">思考题答案</span><br><span class="line">回顾</span><br><span class="line">一笔画的思考题</span><br><span class="line">思考题（哥尼斯堡七桥问题）</span><br><span class="line">提示：试算一下</span><br><span class="line">提示：考虑简化一下</span><br><span class="line">提示：考虑入口和出口</span><br><span class="line">思考题答案</span><br><span class="line">奇偶校验</span><br><span class="line">本章小结</span><br><span class="line">第4章 数学归纳法——如何征服无穷数列</span><br><span class="line">本章学习内容</span><br><span class="line">高斯求和</span><br><span class="line">思考题（存钱罐里的钱）</span><br><span class="line">思考一下</span><br><span class="line">小高斯的解答</span><br><span class="line">讨论一下小高斯的解答</span><br><span class="line">归纳</span><br><span class="line">数学归纳法——如何征服无穷数列</span><br><span class="line">0以上的整数的断言</span><br><span class="line">高斯的断言</span><br><span class="line">什么是数学归纳法</span><br><span class="line">试着征服无穷数列</span><br><span class="line">用数学归纳法证明高斯的断言</span><br><span class="line">求出奇数的和——数学归纳法实例</span><br><span class="line">奇数的和</span><br><span class="line">通过数学归纳法证明</span><br><span class="line">图形化说明</span><br><span class="line">黑白棋思考题——错误的数学归纳法</span><br><span class="line">思考题（黑白棋子的颜色）</span><br><span class="line">提示：不要为图所惑</span><br><span class="line">思考题答案</span><br><span class="line">编程和数学归纳法</span><br><span class="line">通过循环表示数学归纳法</span><br><span class="line">循环不变式</span><br><span class="line">本章小结</span><br><span class="line">第5章 排列组合——解决计数问题的方法</span><br><span class="line">本章学习内容</span><br><span class="line">计数——与整数的对应关系</span><br><span class="line">何谓计数</span><br><span class="line">注意“遗漏”和“重复”</span><br><span class="line">植树问题——不要忘记0</span><br><span class="line">植树问题思考题</span><br><span class="line">加法法则</span><br><span class="line">加法法则</span><br><span class="line">乘法法则</span><br><span class="line">乘法法则</span><br><span class="line">置换</span><br><span class="line">置换</span><br><span class="line">归纳一下</span><br><span class="line">思考题（扑克牌的摆法）</span><br><span class="line">排列</span><br><span class="line">排列</span><br><span class="line">归纳一下</span><br><span class="line">树形图——能够认清本质吗</span><br><span class="line">组合</span><br><span class="line">组合</span><br><span class="line">归纳一下</span><br><span class="line">置换、排列、组合的关系</span><br><span class="line">思考题练习</span><br><span class="line">重复组合</span><br><span class="line">也要善于运用逻辑</span><br><span class="line">本章小结</span><br><span class="line">第6章 递归——自己定义自己</span><br><span class="line">本章学习内容</span><br><span class="line">汉诺塔</span><br><span class="line">思考题（汉诺塔）</span><br><span class="line">提示：先从小汉诺塔着手</span><br><span class="line">思考题答案</span><br><span class="line">求出解析式</span><br><span class="line">解出汉诺塔的程序</span><br><span class="line">找出递归结构</span><br><span class="line">再谈阶乘</span><br><span class="line">阶乘的递归定义</span><br><span class="line">思考题（和的定义）</span><br><span class="line">递归和归纳</span><br><span class="line">斐波那契数列</span><br><span class="line">思考题（不断繁殖的动物）</span><br><span class="line">斐波那契数列</span><br><span class="line">帕斯卡三角形</span><br><span class="line">什么是帕斯卡三角形</span><br><span class="line">递归定义组合数</span><br><span class="line">组合的数学理论解释</span><br><span class="line">递归图形</span><br><span class="line">以递归形式画树</span><br><span class="line">实际作图</span><br><span class="line">谢尔平斯基三角形</span><br><span class="line">本章小结</span><br><span class="line">第7章 指数爆炸——如何解决复杂问题</span><br><span class="line">本章学习内容</span><br><span class="line">什么是指数爆炸</span><br><span class="line">思考题（折纸问题）</span><br><span class="line">指数爆炸</span><br><span class="line">倍数游戏——指数爆炸引发的难题</span><br><span class="line">程序的设置选项</span><br><span class="line">不能认为是“有限的”就不假思索</span><br><span class="line">二分法查找——利用指数爆炸进行查找</span><br><span class="line">寻找犯人的思考题</span><br><span class="line">提示：先思考人数较少的情况</span><br><span class="line">思考题答案</span><br><span class="line">找出递归结构以及递推公式</span><br><span class="line">二分法查找和指数爆炸</span><br><span class="line">对数——掌握指数爆炸的工具</span><br><span class="line">什么是对数</span><br><span class="line">对数和乘方的关系</span><br><span class="line">以2为底的对数</span><br><span class="line">以2为底的对数练习</span><br><span class="line">对数图表</span><br><span class="line">指数法则和对数</span><br><span class="line">对数和计算尺</span><br><span class="line">密码——利用指数爆炸加密</span><br><span class="line">暴力破解法</span><br><span class="line">字长和安全性的关系</span><br><span class="line">如何处理指数爆炸</span><br><span class="line">理解问题空间的大小</span><br><span class="line">四种处理方法</span><br><span class="line">本章小结</span><br><span class="line">第8章 不可解问题——不可解的数、无法编写的程序</span><br><span class="line">本章学习内容</span><br><span class="line">反证法</span><br><span class="line">什么是反证法</span><br><span class="line">质数思考题</span><br><span class="line">反证法的注意事项</span><br><span class="line">可数</span><br><span class="line">什么是可数</span><br><span class="line">可数集合的例子</span><br><span class="line">有没有不可数的集合</span><br><span class="line">对角论证法</span><br><span class="line">所有整数数列的集合是不可数的</span><br><span class="line">所有实数的集合是不可数的</span><br><span class="line">所有函数的集合也是不可数的</span><br><span class="line">不可解问题</span><br><span class="line">什么是不可解问题</span><br><span class="line">存在不可解问题</span><br><span class="line">思考题</span><br><span class="line">停机问题</span><br><span class="line">停机</span><br><span class="line">处理程序的程序</span><br><span class="line">什么是停机问题</span><br><span class="line">停机问题的证明</span><br><span class="line">写给尚未理解的读者</span><br><span class="line">不可解问题有很多</span><br><span class="line">本章小结</span><br><span class="line">第9章 什么是程序员的数学——总结篇</span><br><span class="line">本章学习内容</span><br><span class="line">何为解决问题</span><br><span class="line">认清模式，进行抽象化</span><br><span class="line">由不擅长催生出的智慧</span><br><span class="line">幻想法则</span><br><span class="line">程序员的数学</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00A4H3JJS/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00A4H3JJS&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41YKsbbth5L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Google软件测试之道（英文）</title>
    <url>/2020/04/19/googleruan-jian-ce-shi-zhi-dao/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Google软件测试之道（英文）<br>作者信息： 作者: 惠特克 [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Google软件测试之道》抓住了Google做测试的本质，抓住了Google测试这个时代最复杂软件的精华。《Google软件测试之道》适合开发人员、测试人员、测试管理人员使用，也适合大中专院校相关专业师生的学习用书，以及培训学校的教材。本书可以作为任何从事软件测试人员到达目标的指南。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章Google软件测试介绍</span><br><span class="line">1.1质量不等于测试</span><br><span class="line">1.2角色</span><br><span class="line">1.2.1软件开发工程师（SWE）</span><br><span class="line">1.2.2软件测试开发工程师（SET）</span><br><span class="line">1.2.3测试工程师（TE）</span><br><span class="line">1.3组织结构</span><br><span class="line">1.4爬、走、跑</span><br><span class="line">1.5测试类型</span><br><span class="line">第2章软件测试开发工程师</span><br><span class="line">2.1SET的工作</span><br><span class="line">2.1.1开发和测试流程</span><br><span class="line">2.1.2SET究竟是谁</span><br><span class="line">2.1.3项目的早期阶段</span><br><span class="line">2.1.4团队结构</span><br><span class="line">2.1.5设计文档</span><br><span class="line">2.1.6接口与协议</span><br><span class="line">2.1.7自动化计划</span><br><span class="line">2.1.8可测试性</span><br><span class="line">2.1.9SET的工作流程：一个实例</span><br><span class="line">2.1.10测试执行</span><br><span class="line">2.1.11测试大小的定义</span><br><span class="line">2.1.12测试规模在共享测试平台中的使用</span><br><span class="line">2.1.13测试规模的益处</span><br><span class="line">2.1.14测试运行要求</span><br><span class="line">2.2测试认证</span><br><span class="line">2.3SET的招聘</span><br><span class="line">2.4与工具开发工程师TedMao的访谈</span><br><span class="line">2.5与WebDriver的创建者SimonStewart的对话</span><br><span class="line">第3章测试工程师</span><br><span class="line">3.1一种面向用户的测试角色</span><br><span class="line">3.2测试工程师的工作</span><br><span class="line">3.2.1测试计划</span><br><span class="line">3.2.2风险</span><br><span class="line">3.2.3测试用例的生命周期</span><br><span class="line">3.2.4bug的生命周期</span><br><span class="line">3.2.5TE的招聘</span><br><span class="line">3.2.6Google的测试领导和管理工作</span><br><span class="line">3.2.7维护模式的测试（MaintenanceModeTesting）</span><br><span class="line">3.2.8质量机器人（QualityBot）实验</span><br><span class="line">3.2.9BITE实验</span><br><span class="line">3.2.10GoogleTestAnalytics</span><br><span class="line">3.2.11零成本测试流程</span><br><span class="line">3.2.12外部供应商</span><br><span class="line">3.3与GoogleDocs测试工程师林赛·韦伯斯特（LindsayWebster）的访谈</span><br><span class="line">3.4与YouTube测试工程师安普·周（AppleChow）的访谈</span><br><span class="line">第4章测试工程经理</span><br><span class="line">4.1测试工程经理的工作</span><br><span class="line">4.2获得项目和人员</span><br><span class="line">4.3影响力</span><br><span class="line">4.4Gmail测试工程经理AnkitMehta的访谈</span><br><span class="line">4.5Android测试工程经理HungDang的访谈</span><br><span class="line">4.6Chrome测试工程经理JoelHynoski的访谈</span><br><span class="line">4.7测试总监</span><br><span class="line">4.8搜索和地理信息测试总监SheltonMar的访谈</span><br><span class="line">4.9工程工具总监AshishKumar的访谈</span><br><span class="line">4.10印度Google测试总监SujaySahni访谈</span><br><span class="line">4.11工程经理BradGreen访谈</span><br><span class="line">4.12JamesWhittaker访谈</span><br><span class="line">第5章Google软件测试改进</span><br><span class="line">5.1Google流程中的致命缺陷</span><br><span class="line">5.2SET的未来</span><br><span class="line">5.3TE的未来</span><br><span class="line">5.4测试总监和经理的未来</span><br><span class="line">5.5未来的测试基础设施</span><br><span class="line">5.6结论</span><br><span class="line">附录AChromeOS测试计划</span><br><span class="line">A.1测试主题概述</span><br><span class="line">A.2风险分析</span><br><span class="line">A.3每次构建版本的基线测试</span><br><span class="line">A.4最新可测试版本（LastKnownGood，LKG）的每日测试</span><br><span class="line">A.5发布版本测试</span><br><span class="line">A.6手工测试与自动化测试</span><br><span class="line">A.7开发和测试的质量关注点</span><br><span class="line">A.8发布通道</span><br><span class="line">A.9用户输入</span><br><span class="line">A.10测试用例库</span><br><span class="line">A.11测试仪表盘</span><br><span class="line">A.12虚拟化</span><br><span class="line">A.13性能</span><br><span class="line">A.14压力、长时运行和稳定性测试</span><br><span class="line">A.15测试执行框架（Autotest）</span><br><span class="line">A.16OEM厂商</span><br><span class="line">A.17硬件实验田</span><br><span class="line">A.18端到端测试自动化集群</span><br><span class="line">A.19测试浏览器的应用管理器</span><br><span class="line">A.20浏览器的可测试性</span><br><span class="line">A.21硬件</span><br><span class="line">A.22时间线</span><br><span class="line">A.23主要的测试驱动力</span><br><span class="line">A.24相关文档</span><br><span class="line">附录BChrome的漫游测试</span><br><span class="line">B.1购物漫游</span><br><span class="line">B.2学生漫游</span><br><span class="line">B.3国际长途电话漫游</span><br><span class="line">B.4地标漫游</span><br><span class="line">B.5通宵漫游</span><br><span class="line">B.6公务漫游测试</span><br><span class="line">B.7危险地带漫游</span><br><span class="line">B.8个性化漫游</span><br><span class="line">附录C有关工具和代码的博客文章</span><br><span class="line">C.1使用BITE从bug和冗余的工作中解脱出来</span><br><span class="line">C.2发布QualityBot</span><br><span class="line">C.3RPF：Google的录制回放框架</span><br><span class="line">C.4Google测试分析系统（GoogleTestAnalytics）——现在开源了</span><br><span class="line">附录D术语表</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00FH36R6G/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00FH36R6G&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51860F9X9pL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP权威指南</title>
    <url>/2020/04/19/http-the-definitive-guide/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： HTTP权威指南<br>作者信息： 作者: 吉尔利 [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《HTTP权威指南》由古尔利所著，本书详细解释了HTTP协议，包括它是如何工作的，如何用它来开发基于Web的应用程序，同时还探讨了HTTP有效工作所依赖的所有其他核心因特网技术。尽管HTTP是本书的中心内容，但本书的本质是理解Web的工作原理，以及如何将这些知识应用到Web编程和管理之中，主要涵盖HTTP的技术运作方式、产生动机、性能和目标以及一些相关技术问题。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一部分 HTTP：Web的基础</span><br><span class="line">第1章 HTTP概述</span><br><span class="line">1.1 HTTP——因特网的多媒体信使</span><br><span class="line">1.2 Web客户端和服务器</span><br><span class="line">1.3资源</span><br><span class="line">1.3.1媒体类型</span><br><span class="line">1.3.2 UIU</span><br><span class="line">1.3.3 URL</span><br><span class="line">1.3.4 URN</span><br><span class="line">1.4事务</span><br><span class="line">1.4.1 方法</span><br><span class="line">1.4.2状态码</span><br><span class="line">1.4.3 Web页面中可以包含多个对象</span><br><span class="line">1.5报文</span><br><span class="line">1.6连接</span><br><span class="line">1.6.1 TCMP</span><br><span class="line">1.6.2连接、IP地址及端口号</span><br><span class="line">1.6.3 一个使用Telnet的实例</span><br><span class="line">1.7协议版本</span><br><span class="line">1.8 Web的结构组件</span><br><span class="line">1.8.1 代理</span><br><span class="line">1.8.2缓存</span><br><span class="line">1.8.3 网关</span><br><span class="line">1.8.4隧道</span><br><span class="line">1.8.5 Agent代理</span><br><span class="line">1.9起始部分的结束语</span><br><span class="line">1.10更多信息</span><br><span class="line">1.10.1 HTTP协议信息</span><br><span class="line">1.10.2历史透视</span><br><span class="line">1.10.3其他万维网信息</span><br><span class="line">第2章URL与资源</span><br><span class="line">2.1浏览因特网资源</span><br><span class="line">2.2 URL的语法</span><br><span class="line">2.2.1方案——使用什么协议</span><br><span class="line">2.2.2主机与端口</span><br><span class="line">2.2.3 用户名和密码</span><br><span class="line">2.2.4路径</span><br><span class="line">2.2.5 参数</span><br><span class="line">2.2.6查询字符串</span><br><span class="line">2.2.7片段</span><br><span class="line">2.3 URL快捷方式</span><br><span class="line">2.3.1相对UPL</span><br><span class="line">2.3.2 自动扩展URL</span><br><span class="line">2.4各种令人头疼的字符</span><br><span class="line">2.4.1 URL字符集</span><br><span class="line">2.4.2编码机制</span><br><span class="line">2.4.3字符限制</span><br><span class="line">2.4.4另外一点说明</span><br><span class="line">2.5方案的世界</span><br><span class="line">2.6未来展望</span><br><span class="line">2.7更多信息</span><br><span class="line">第3章HTTP报文</span><br><span class="line">3.1报文流</span><br><span class="line">3.1.1报文流入源端服务器</span><br><span class="line">3.1.2报文向下游流动</span><br><span class="line">3.2报文的组成部分</span><br><span class="line">3.2.1报文的语法</span><br><span class="line">3.2.2起始行</span><br><span class="line">3.2.3 首部</span><br><span class="line">3.2.4实体的主体部分</span><br><span class="line">3.2.5版本0.9的报文</span><br><span class="line">3.3方法</span><br><span class="line">3.3.1安全方法</span><br><span class="line">3.3.2 GET</span><br><span class="line">3.3.3 HEAD</span><br><span class="line">3.3.4 PUT</span><br><span class="line">3.3.5 POST</span><br><span class="line">3.3.6 TRACE</span><br><span class="line">3.3.7 OPTIONS</span><br><span class="line">3.3.8 DELETE</span><br><span class="line">3.3.9扩展方法</span><br><span class="line">3.4状态码</span><br><span class="line">3.4.1 100～199——信息性状态码</span><br><span class="line">3.4.2 200～299——成功状态码</span><br><span class="line">3.4.3 300～399——重定向状态码</span><br><span class="line">3.4.4 400～499——客户端错误状态码</span><br><span class="line">3.4.5 500～599——服务器错误状态码</span><br><span class="line">3.5首部</span><br><span class="line">3.5.1 通用首部</span><br><span class="line">3.5.2请求首部</span><br><span class="line">3.5.3响应首部</span><br><span class="line">3.5.4实体首部</span><br><span class="line">3.6更多信息</span><br><span class="line">4章连接管理</span><br><span class="line">4.1 TCP连接</span><br><span class="line">4.1.1 TCP的可靠数据管道</span><br><span class="line">4.1.2 TCP流是分段的、由IP分组传送</span><br><span class="line">4.1.3保持TCP连接持续不断地运行</span><br><span class="line">4.1.4用TCP套接字编程</span><br><span class="line">4.2对TCP性能的考虑</span><br><span class="line">4.2.1 HTTP事务的时延</span><br><span class="line">4.2.2性能聚焦区域</span><br><span class="line">4.2.3 TCP连接的握手时延</span><br><span class="line">4.2.4延迟确认</span><br><span class="line">4.2.5 TCP慢启动</span><br><span class="line">4.2.6 Nagle算法与TCP—NODELAY</span><br><span class="line">4.2.7 TIME WAIT累积与端口耗尽</span><br><span class="line">4.3 HTTP连接的处理</span><br><span class="line">4.3.1常被误解的Connection首部</span><br><span class="line">4.3.2串行事务处理时延</span><br><span class="line">4.4并行连接</span><br><span class="line">4.4.1 并行连接可能会提高页面的加载速度</span><br><span class="line">4.4.2并行连接不一定更快</span><br><span class="line">……</span><br><span class="line">第二部分 HTTP结构</span><br><span class="line">第5章 Web服务器</span><br><span class="line">第6章 代理</span><br><span class="line">第7章 缓存</span><br><span class="line">第8章 集成点：网关、隧道及中继</span><br><span class="line">第9章 Web机器人</span><br><span class="line">第10章 HTTP—NG</span><br><span class="line">第三部分 识别、认证与安全</span><br><span class="line">第11章 客户端识别与cookie机制</span><br><span class="line">第12章 基本认证机制</span><br><span class="line">第13章 摘要认证</span><br><span class="line">第14章 安全HTTP</span><br><span class="line">第四部分 实体、编码和国际化</span><br><span class="line">第15章 实体和编码</span><br><span class="line">第16章 国际化</span><br><span class="line">第17章 内容协商与转码</span><br><span class="line">第五部分 内容发布与分发</span><br><span class="line">第18章 Web主机托管</span><br><span class="line">第19章 发布系统</span><br><span class="line">第20章 重定向与负载均衡</span><br><span class="line">第21章 日志记录与使用情况跟踪</span><br><span class="line">第六部分 附录</span><br><span class="line">附录A URI方案</span><br><span class="line">附录B HTTP状态码</span><br><span class="line">附录C HTTP首部参考</span><br><span class="line">附录D MIME类型</span><br><span class="line">附录E Base—64编码</span><br><span class="line">附录F 摘要认证</span><br><span class="line">附录G 语言标记</span><br><span class="line">附录H MIME字符集注册表</span><br><span class="line">索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B008XFDQ14/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B008XFDQ14&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51ZPCOIw4HL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Metasploit渗透测试魔鬼训练营</title>
    <url>/2020/04/19/metasploitshen-tou-ce-shi-mo-gui-xun-lian-ying/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Metasploit渗透测试魔鬼训练营<br>作者信息： 作者: 诸葛建伟 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《Metasploit渗透测试魔鬼训练营》是Metasploit渗透测试领域难得的经典佳作，由国内信息安全领域的资深Metasploit渗透测试专家领衔撰写。内容系统、广泛、有深度，不仅详细讲解了Metasploit渗透测试的技术、流程、方法和技巧，而且深刻揭示了渗透测试平台背后蕴含的思想。<br>　　书中虚拟了两家安全公司，所有内容都围绕这两家安全公司在多个角度的多次“对战”展开，颇具趣味性和可读性。很多知识点都配有案例解析，更重要的是每章还有精心设计的“魔鬼训练营实践作业”，充分体现了“实践，实践，再实践”的宗旨。<br>　　《Metasploit渗透测试魔鬼训练营》采用了第二人称的独特视角，让读者跟随“你”一起参加魔鬼训练营，并经历一次极具挑战性的渗透测试任务考验。你的渗透测试之旅包括10段精彩的旅程。<br>　　全书共10章。第1章对渗透测试和Metasploit进行了系统介绍，首先介绍了渗透测试的分类、方法、流程、过程环节等，然后介绍了Metasploit的功能、结构和基本的使用方法。第2章详细演示了渗透测试实验环境的搭建。第3章讲解了情报收集技术。第4章讲解了Web应用渗透技术。第5章讲解了网络服务的渗透攻击技术。第6章讲解了客户端的渗透攻击技术。第7章讲解了社会工程学的技术框架和若干个社会工程学攻击案例。第8章讲解了针对笔记本电脑、智能手机等各种类型移动设备的渗透测试技术。第9章讲解了Metasploit中功能最为强大的攻击载荷模块Meterpreter的原理与应用。第10章，魔鬼训练营活动大结局，本章发起了一个“黑.客夺旗竞赛”实战项目，目的是进一步提高读者的实战能力。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言</span><br><span class="line">致谢</span><br><span class="line">第1章　魔鬼训练营——初识Metasploit</span><br><span class="line">1.1　什么是渗透测试</span><br><span class="line">1.1.1　渗透测试的起源与定义</span><br><span class="line">1.1.2　渗透测试的分类</span><br><span class="line">1.1.3　渗透测试方法与流程</span><br><span class="line">1.1.4　渗透测试过程环节</span><br><span class="line">1.2　漏洞分析与利用</span><br><span class="line">1.2.1　安全漏洞生命周期</span><br><span class="line">1.2.2　安全漏洞披露方式</span><br><span class="line">1.2.3　安全漏洞公共资源库</span><br><span class="line">1.3　渗透测试神器Metasploit</span><br><span class="line">1.3.1　诞生与发展</span><br><span class="line">1.3.2　渗透测试框架软件</span><br><span class="line">1.3.3　漏洞研究与渗透代码开发平台</span><br><span class="line">1.3.4　安全技术集成开发与应用环境</span><br><span class="line">1.4　Metasploit结构剖析</span><br><span class="line">1.4.1　Metasploit体系框架</span><br><span class="line">1.4.2　辅助模块</span><br><span class="line">1.4.3　渗透攻击模块</span><br><span class="line">1.4.4　攻击载荷模块</span><br><span class="line">1.4.5　空指令模块</span><br><span class="line">1.4.6　编码器模块</span><br><span class="line">1.4.7　后渗透攻击模块</span><br><span class="line">1.5　安装Metasploit软件</span><br><span class="line">1.5.1　在Back Track上使用和更新Metasploit</span><br><span class="line">1.5.2　在Windows操作系统上安装Metasploit</span><br><span class="line">1.5.3　在Linux操作系统上安装Metasploit</span><br><span class="line">1.6　了解Metasploit的使用接口</span><br><span class="line">1.6.1　msfgui图形化界面工具</span><br><span class="line">1.6.2　msfconsole控制台终端</span><br><span class="line">1.6.3　msfcli命令行程序</span><br><span class="line">1.7　小结</span><br><span class="line">1.8　魔鬼训练营实践作业</span><br><span class="line">第2章　赛宁VS.定V——渗透测试实验环境</span><br><span class="line">2.1　定V公司的网络环境拓扑</span><br><span class="line">2.1.1　渗透测试实验环境拓扑结构</span><br><span class="line">2.1.2　攻击机环境</span><br><span class="line">2.1.3　靶机环境</span><br><span class="line">2.1.4　分析环境</span><br><span class="line">2.2　渗透测试实验环境的搭建</span><br><span class="line">2.2.1　虚拟环境部署</span><br><span class="line">2.2.2　网络环境配置</span><br><span class="line">2.2.3　虚拟机镜像配置</span><br><span class="line">2.3　小结</span><br><span class="line">2.4　魔鬼训练营实践作业</span><br><span class="line">第3章　揭开“战争迷雾”——情报搜集技术</span><br><span class="line">3.1　外围信息搜集</span><br><span class="line">3.1.1　通过DNS和IP地址挖掘目标网络信息</span><br><span class="line">3.1.2　通过搜索引擎进行信息搜集</span><br><span class="line">3.1.3　对定V公司网络进行外围信息搜集</span><br><span class="line">3.2　主机探测与端口扫描</span><br><span class="line">3.2.1　活跃主机扫描</span><br><span class="line">3.2.2　操作系统辨识</span><br><span class="line">3.2.3　端口扫描与服务类型探测</span><br><span class="line">3.2.4　Back Track 5的Autoscan功能</span><br><span class="line">3.2.5　探测扫描结果分析</span><br><span class="line">3.3　服务扫描与查点</span><br><span class="line">3.3.1　常见的网络服务扫描</span><br><span class="line">3.3.2　口令猜测与嗅探</span><br><span class="line">3.4　网络漏洞扫描</span><br><span class="line">3.4.1　漏洞扫描原理与漏洞扫描器</span><br><span class="line">3.4.2　OpenVAS漏洞扫描器</span><br><span class="line">3.4.3　查找特定服务漏洞</span><br><span class="line">3.4.4　漏洞扫描结果分析</span><br><span class="line">3.5　渗透测试信息数据库与共享</span><br><span class="line">3.5.1　使用渗透测试信息数据库的优势</span><br><span class="line">3.5.2　Metasploit的数据库支持</span><br><span class="line">3.5.3　在Metasploit中使用PostgreSQL</span><br><span class="line">3.5.4　Nmap与渗透测试数据库</span><br><span class="line">3.5.5　OpenVAS与渗透测试数据库</span><br><span class="line">3.5.6　共享你的渗透测试信息数据库</span><br><span class="line">3.6　小结</span><br><span class="line">3.7　魔鬼训练营实践作业</span><br><span class="line">第4章　突破定V门户——Web应用渗透技术</span><br><span class="line">4.1　Web应用渗透技术基础知识</span><br><span class="line">4.1.1　为什么进行Web应用渗透攻击</span><br><span class="line">4.1.2　Web应用攻击的发展趋势</span><br><span class="line">4.1.3　OWASP Web漏洞TOP 10</span><br><span class="line">4.1.4　近期Web应用攻击典型案例</span><br><span class="line">4.1.5　基于Metasploit框架的Web应用渗透技术</span><br><span class="line">4.2　Web应用漏洞扫描探测</span><br><span class="line">4.2.1　开源Web应用漏洞扫描工具</span><br><span class="line">4.2.2　扫描神器W3AF</span><br><span class="line">4.2.3　SQL注入漏洞探测</span><br><span class="line">4.2.4　XSS漏洞探测</span><br><span class="line">4.2.5　Web应用程序漏洞探测</span><br><span class="line">4.3　Web应用程序渗透测试</span><br><span class="line">4.3.1　SQL注入实例分析</span><br><span class="line">4.3.2　跨站攻击实例分析</span><br><span class="line">4.3.3　命令注入实例分析</span><br><span class="line">4.3.4　文件包含和文件上传漏洞</span><br><span class="line">4.4　小结</span><br><span class="line">4.5　魔鬼训练营实践作业</span><br><span class="line">第5章　定V门大敞，哥要进内网——网络服务渗透攻击</span><br><span class="line">5.1　内存攻防技术</span><br><span class="line">5.1.1　缓冲区溢出漏洞机理</span><br><span class="line">5.1.2　栈溢出利用原理</span><br><span class="line">5.1.3　堆溢出利用原理</span><br><span class="line">5.1.4　缓冲区溢出利用的限制条件</span><br><span class="line">5.1.5　攻防两端的对抗博弈</span><br><span class="line">5.2　网络服务渗透攻击面</span><br><span class="line">5.2.1　针对Windows系统自带的网络服务渗透攻击</span><br><span class="line">5.2.2　针对Windows操作系统上微软网络服务的渗透攻击</span><br><span class="line">5.2.3　针对Windows操作系统上第三方网络服务的渗透攻击</span><br><span class="line">5.2.4　针对工业控制系统服务软件的渗透攻击</span><br><span class="line">5.3　Windows服务渗透攻击实战案例——MS08-067安全漏洞</span><br><span class="line">5.3.1　威名远扬的超级大漏洞MS08-067</span><br><span class="line">5.3.2　MS08-067漏洞渗透攻击原理及过程</span><br><span class="line">5.3.3　MS08-067漏洞渗透攻击模块源代码解析</span><br><span class="line">5.3.4　MS08-067安全漏洞机理分析</span><br><span class="line">5.4　第三方网络服务渗透攻击实战案例——Oracle数据库</span><br><span class="line">5.4.1　Oracle数据库的“蚁穴”</span><br><span class="line">5.4.2　Oracle渗透利用模块源代码解析</span><br><span class="line">5.4.3　Oracle漏洞渗透攻击过程</span><br><span class="line">5.4.4　Oracle安全漏洞利用机理</span><br><span class="line">5.5　工业控制系统服务渗透攻击实战案例——亚控科技KingView</span><br><span class="line">5.5.1　中国厂商SCADA软件遭国外黑客盯梢</span><br><span class="line">5.5.2　KingView 6.53 HistorySvr渗透攻击代码解析</span><br><span class="line">5.5.3　KingView 6.53漏洞渗透攻击测试过程</span><br><span class="line">5.5.4　KingView堆溢出安全漏洞原理分析</span><br><span class="line">5.6　Linux系统服务渗透攻击实战案例——Samba安全漏洞</span><br><span class="line">5.6.1　Linux与Windows之间的差异</span><br><span class="line">5.6.2　Linux系统服务渗透攻击原理</span><br><span class="line">5.6.3　Samba安全漏洞描述与攻击模块解析</span><br><span class="line">5.6.4　Samba渗透攻击过程</span><br><span class="line">5.6.5　Samba安全漏洞原理分析</span><br><span class="line">5.7　小结</span><br><span class="line">5.8　魔鬼训练营实践作业</span><br><span class="line">第6章　定V网络主宰者——客户端渗透攻击</span><br><span class="line">6.1　客户端渗透攻击基础知识</span><br><span class="line">6.1.1　客户端渗透攻击的特点</span><br><span class="line">6.1.2　客户端渗透攻击的发展和趋势</span><br><span class="line">6.1.3　安全防护机制</span><br><span class="line">6.2　针对浏览器的渗透攻击</span><br><span class="line">6.2.1　浏览器渗透攻击面</span><br><span class="line">6.2.2　堆喷射利用方式</span><br><span class="line">6.2.3　MSF中自动化浏览器攻击</span><br><span class="line">6.3　浏览器渗透攻击实例——MS11-050安全漏洞</span><br><span class="line">6.3.1　MS11-050漏洞渗透攻击过程</span><br><span class="line">6.3.2　MS11-050漏洞渗透攻击源码解析与机理分析</span><br><span class="line">6.4　第三方插件渗透攻击实战案例——再探亚控科技KingView</span><br><span class="line">6.4.1　移植KingView渗透攻击代码</span><br><span class="line">6.4.2　KingView渗透攻击过程</span><br><span class="line">6.4.3　KingView安全漏洞机理分析</span><br><span class="line">6.5　针对应用软件的渗透攻击</span><br><span class="line">6.5.1　应用软件渗透攻击机理</span><br><span class="line">6.5.2　内存攻击技术ROP的实现</span><br><span class="line">6.5.3　MSF中的自动化fileformat攻击</span><br><span class="line">6.6　针对Office软件的渗透攻击实例——MS10-087安全漏洞</span><br><span class="line">6.6.1　MS10-087渗透测试过程</span><br><span class="line">6.6.2　MS10-087漏洞渗透攻击模块源代码解析</span><br><span class="line">6.6.3　MS10-087漏洞原理分析</span><br><span class="line">6.6.4　MS10-087漏洞利用原理</span><br><span class="line">6.6.5　文件格式分析</span><br><span class="line">6.7　Adobe阅读器渗透攻击实战案例——加急的项目进展报告</span><br><span class="line">6.7.1　Adobe渗透测试过程</span><br><span class="line">6.7.2　Adobe渗透攻击模块解析与机理分析</span><br><span class="line">6.7.3　Adobe漏洞利用原理</span><br><span class="line">6.8　小结</span><br><span class="line">6.9　魔鬼训练营实践作业</span><br><span class="line">第7章　甜言蜜语背后的危险——社会工程学</span><br><span class="line">7.1　社会工程学的前世今生</span><br><span class="line">7.1.1　什么是社会工程学攻击</span><br><span class="line">7.1.2　社会工程学攻击的基本形式</span><br><span class="line">7.1.3　社交网站社会工程学攻击案例</span><br><span class="line">7.2　社会工程学技术框架</span><br><span class="line">7.2.1　信息搜集</span><br><span class="line">7.2.2　诱导</span><br><span class="line">7.2.3　托辞</span><br><span class="line">7.2.4　心理影响</span><br><span class="line">7.3　社会工程学攻击案例——伪装木马</span><br><span class="line">7.3.1　伪装木马的主要方法与传播途径</span><br><span class="line">7.3.2　伪装木马社会工程学攻击策划</span><br><span class="line">7.3.3　木马程序的制作</span><br><span class="line">7.3.4　伪装木马的“免杀”处理</span><br><span class="line">7.3.5　伪装木马社会工程学的实施过程</span><br><span class="line">7.3.6　伪装木马社会工程学攻击案例总结</span><br><span class="line">7.4　针对性社会工程学攻击案例——网站钓鱼</span><br><span class="line">7.4.1　社会工程学攻击工具包SET</span><br><span class="line">7.4.2　网站钓鱼社会工程学攻击策划</span><br><span class="line">7.4.3　钓鱼网站的制作</span><br><span class="line">7.4.4　网站钓鱼社会工程学的实施过程</span><br><span class="line">7.4.5　网站钓鱼社会工程学攻击案例总结</span><br><span class="line">7.5　针对性社会工程学攻击案例——邮件钓鱼</span><br><span class="line">7.5.1　邮件钓鱼社会工程学攻击策划</span><br><span class="line">7.5.2　使用SET工具集完成邮件钓鱼</span><br><span class="line">7.5.3　针对性邮件钓鱼社会工程学攻击案例总结</span><br><span class="line">7.6　U盘社会工程学攻击案例——Hacksaw攻击</span><br><span class="line">7.6.1　U盘社会工程学攻击策划</span><br><span class="line">7.6.2　U盘攻击原理</span><br><span class="line">7.6.3　制作Hacksaw U盘</span><br><span class="line">7.6.4　U盘社会工程学攻击的实施过程</span><br><span class="line">7.6.5　U盘攻击社会工程学攻击案例总结</span><br><span class="line">7.7　小结</span><br><span class="line">7.8　魔鬼训练营实践作业</span><br><span class="line">第8章　刀无形、剑无影——移动环境渗透测试</span><br><span class="line">8.1　移动的Metasploit渗透测试平台</span><br><span class="line">8.1.1　什么是BYOD</span><br><span class="line">8.1.2　下载安装Metasploit</span><br><span class="line">8.1.3　在iPad上手动安装Metasploit</span><br><span class="line">8.2　无线网络渗透测试技巧</span><br><span class="line">8.2.1　无线网络口令破解</span><br><span class="line">8.2.2　破解无线AP的管理密码</span><br><span class="line">8.2.3　无线AP漏洞利用渗透攻击</span><br><span class="line">8.3　无线网络客户端攻击案例——上网笔记本电脑</span><br><span class="line">8.3.1　配置假冒AP</span><br><span class="line">8.3.2　加载karma.rc资源文件</span><br><span class="line">8.3.3　移动上网笔记本渗透攻击实施过程</span><br><span class="line">8.3.4　移动上网笔记本渗透攻击案例总结</span><br><span class="line">8.4　移动环境渗透攻击案例——智能手机</span><br><span class="line">8.4.1　BYOD设备的特点</span><br><span class="line">8.4.2　苹果iOS设备渗透攻击</span><br><span class="line">8.4.3　Android智能手机的渗透攻击</span><br><span class="line">8.4.4　Android平台Metasploit渗透攻击模块的移植</span><br><span class="line">8.5　小结</span><br><span class="line">8.6　魔鬼训练营实践作业</span><br><span class="line">第9章　俘获定V之心——强大的Meterpreter</span><br><span class="line">9.1　再探Metasploit攻击载荷模块</span><br><span class="line">9.1.1　典型的攻击载荷模块</span><br><span class="line">9.1.2　如何使用攻击载荷模块</span><br><span class="line">9.1.3　meterpreter的技术优势</span><br><span class="line">9.2　Meterpreter命令详解</span><br><span class="line">9.2.1　基本命令</span><br><span class="line">9.2.2　文件系统命令</span><br><span class="line">9.2.3　网络命令</span><br><span class="line">9.2.4　系统命令</span><br><span class="line">9.3　后渗透攻击模块</span><br><span class="line">9.3.1　为什么引入后渗透攻击模块</span><br><span class="line">9.3.2　各操作系统平台分布情况</span><br><span class="line">9.3.3　后渗透攻击模块的使用方法</span><br><span class="line">9.4　Meterpreter在定V渗透测试中的应用</span><br><span class="line">9.4.1　植入后门实施远程控制</span><br><span class="line">9.4.2　权限提升</span><br><span class="line">9.4.3　信息窃取</span><br><span class="line">9.4.4　口令攫取和利用</span><br><span class="line">9.4.5　内网拓展</span><br><span class="line">9.4.6　掩踪灭迹</span><br><span class="line">9.5　小结</span><br><span class="line">9.6　魔鬼训练营实践作业</span><br><span class="line">第10章　群狼出山——黑客夺旗竞赛实战</span><br><span class="line">10.1　黑客夺旗竞赛的由来</span><br><span class="line">10.2　让我们来玩玩“地下产业链”</span><br><span class="line">10.2.1　“洗钱”的竞赛场景分析</span><br><span class="line">10.2.2　“洗钱”规则</span><br><span class="line">10.2.3　竞赛准备与任务分工</span><br><span class="line">10.3　CTF竞赛现场</span><br><span class="line">10.3.1　解题“打黑钱”</span><br><span class="line">10.3.2　GameBox扫描与漏洞分析</span><br><span class="line">10.3.3　渗透Web应用服务</span><br><span class="line">10.3.4　渗透二进制服务程序</span><br><span class="line">10.3.5　疯狂“洗钱”</span><br><span class="line">10.3.6　力不从心的防御</span><br><span class="line">10.4　CTF竞赛结果</span><br><span class="line">10.5　魔鬼训练营大结局</span><br><span class="line">10.6　魔鬼训练营实践作业</span><br><span class="line">附录A　如何撰写渗透测试报告</span><br><span class="line">附录B　参考与进一步阅读</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00EZKA07O/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00EZKA07O&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/414kDomwOSL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL必知必会</title>
    <url>/2020/04/19/mysqlbi-zhi-bi-hui/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： MySQL必知必会<br>作者信息： 作者: 福塔 [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《MySQL必知必会》是经典畅销书《SQL必知必会》之后，作者应众多读者的请求编写的，专门针对MySQL用户。《MySQL必知必会》中继承了《MySQL必知必会》的优点，没有过多阐述数据库基础理论，而是紧贴实战需要，直接从数据检索开始，逐步深入各种复杂的内容，包括联结的使用、子查询、正则表达式和基于全文本的搜索、存储过程、游标、触发器、表约束，等等。通过《MySQL必知必会》，读者能够掌握扎实的基本功，迅速成为MySQL高手。<br>《SQL必知必会》作者新作、Amazon全五星评价、学习与参考皆宜。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1章　了解SQL</span><br><span class="line">1.1　数据库基础</span><br><span class="line">1.1.1　什么是数据库</span><br><span class="line">1.1.2　表</span><br><span class="line">1.1.3　列和数据类型</span><br><span class="line">1.1.4　行</span><br><span class="line">1.1.5　主键</span><br><span class="line">1.2　什么是SQL</span><br><span class="line">1.3　动手实践</span><br><span class="line">1.4　小结 </span><br><span class="line"></span><br><span class="line"> 第2章　MySQL简介 2.1　什么是MySQL 2.1.1　客户机-服务器软件 2.1.2　MySQL版本 2.2　MySQL工具 2.2.1　mysql命令行实用程序 2.2.2　MySQL Adminis-trator 2.2.3　MySQL Query Browser 2.3　小结</span><br><span class="line"></span><br><span class="line"> 第3章　使用MySQL 3.1　连接 3.2　选择数据库 3.3　了解数据库和表 3.4　小结</span><br><span class="line"></span><br><span class="line"> 第4章　检索数据 4.1　SELECT语句 4.2　检索单个列 4.3　检索多个列 4.4　检索所有列 4.5　检索不同的行 4.6　限制结果 4.7　使用完全限定的表名 4.8　小结</span><br><span class="line"></span><br><span class="line"> 第5章　排序检索数据 5.1　排序数据 5.2　按多个列排序 5.3　指定排序方向 5.4　小结</span><br><span class="line"></span><br><span class="line"> 第6章　过滤数据 6.1　使用WHERE子句 6.2　WHERE子句操作符 6.2.1　检查单个值 6.2.2　不匹配检查 6.2.3　范围值检查 6.2.4　空值检查 6.3　小结</span><br><span class="line"></span><br><span class="line"> 第7章　数据过滤 7.1　组合WHERE子句 7.1.1　AND操作符 7.1.2　OR操作符 7.1.3　计算次序 7.2　IN操作符 7.3　NOT操作符 7.4　小结</span><br><span class="line"></span><br><span class="line"> 第8章　用通配符进行过滤 8.1　LIKE操作符 8.1.1　百分号（%）通配符 8.1.2　下划线（_）通配符 8.2　使用通配符的技巧 8.3　小结</span><br><span class="line"></span><br><span class="line"> 第9章　用正则表达式进行搜索 9.1　正则表达式介绍 9.2　使用MySQL正则表达式 9.2.1　基本字符匹配 9.2.2　进行OR匹配 9.2.3　匹配几个字符之一 9.2.4　匹配范围 9.2.5　匹配特殊字符 9.2.6　匹配字符类 9.2.7　匹配多个实例 9.2.8　定位符 9.3　小结</span><br><span class="line"></span><br><span class="line"> 第10章　创建计算字段 10.1　计算字段 10.2　拼接字段 10.3　执行算术计算 10.4　小结</span><br><span class="line"></span><br><span class="line"> 第11章　使用数据处理函数 11.1　函数 11.2　使用函数 11.2.1　文本处理函数 11.2.2　日期和时间处理函数 11.2.3　数值处理函数 11.3　小结</span><br><span class="line"></span><br><span class="line"> 第12章　汇总数据 12.1　聚集函数 12.1.1　AVG（）函数 12.1.2　COUNT（）函数 12.1.3　MAX（）函数 12.1.4　MIN（）函数 12.1.5　SUM（）函数 12.2　聚集不同值 12.3　组合聚集函数 12.4　小结</span><br><span class="line"></span><br><span class="line"> 第13章　分组数据 13.1　数据分组 13.2　创建分组 13.3　过滤分组 13.4　分组和排序 13.5　SELECT子句顺序 13.6　小结</span><br><span class="line"></span><br><span class="line"> 第14章　使用子查询 14.1　子查询 14.2　利用子查询进行过滤 14.3　作为计算字段使用子查询 14.4　小结</span><br><span class="line"></span><br><span class="line"> 第15章　联结表 15.1　联结 15.1.1　关系表 15.1.2　为什么要使用联结 15.2　创建联结 15.2.1　WHERE子句的重要性 15.2.2　内部联结 15.2.3　联结多个表 15.3　小结</span><br><span class="line"></span><br><span class="line"> 第16章　创建高级联结 16.1　使用表别名 16.2　使用不同类型的联结 16.2.1　自联结 16.2.2　自然联结 16.2.3　外部联结 16.3　使用带聚集函数的联结 16.4　使用联结和联结条件 16.5　小结</span><br><span class="line"></span><br><span class="line"> 第17章　组合查询 17.1　组合查询 17.2　创建组合查询 17.2.1　使用UNION 17.2.2　UNION规则 17.2.3　包含或取消重复的行 17.2.4　对组合查询结果排序 17.3　小结</span><br><span class="line"></span><br><span class="line"> 第18章　全文本搜索 18.1　理解全文本搜索 18.2　使用全文本搜索 18.2.1　启用全文本搜索支持 18.2.2　进行全文本搜索 18.2.3　使用查询扩展 18.2.4　布尔文本搜索 18.2.5　全文本搜索的使用说明 18.3　小结</span><br><span class="line"></span><br><span class="line"> 第19章　插入数据 19.1　数据插入 19.2　插入完整的行 19.3　插入多个行 19.4　插入检索出的数据 19.5　小结</span><br><span class="line"></span><br><span class="line"> 第20章　更新和删除数据 20.1　更新数据 20.2　删除数据 20.3　更新和删除的指导原则 20.4　小结</span><br><span class="line"></span><br><span class="line"> 第21章　创建和操纵表 21.1　创建表 21.1.1　表创建基础 21.1.2　使用NULL值 21.1.3　主键再介绍 21.1.4　使用AUTO_　INCREMENT 21.1.5　指定默认值 21.1.6　引擎类型 21.2　更新表 21.3　删除表 21.4　重命名表 21.5　小结</span><br><span class="line"></span><br><span class="line"> 第22章　使用视图 22.1　视图 22.1.1　为什么使用视图 22.1.2　视图的规则和限制 22.2　使用视图 22.2.1　利用视图简化复杂的联结 22.2.2　用视图重新格式化检索出的数据 22.2.3　用视图过滤不想要的数据 22.2.4　使用视图与计算字段 22.2.5　更新视图 22.3　小结</span><br><span class="line"></span><br><span class="line"> 第23章　使用存储过程 23.1　存储过程 23.2　为什么要使用存储过程 23.3　使用存储过程 23.3.1　执行存储过程 23.3.2　创建存储过程 23.3.3　删除存储过程 23.3.4　使用参数 23.3.5　建立智能存储过程 23.3.6　检查存储过程 23.4　小结</span><br><span class="line"></span><br><span class="line"> 第24章　使用游标 24.1　游标 24.2　使用游标 24.2.1　创建游标 24.2.2　打开和关闭游标 24.2.3　使用游标数据 24.3　小结</span><br><span class="line"></span><br><span class="line"> 第25章　使用触发器 25.1　触发器 25.2　创建触发器 25.3　删除触发器 25.4　使用触发器 25.4.1　INSERT触发器 25.4.2　DELETE触发器 25.4.3　UPDATE触发器 25.4.4　关于触发器的进一步介绍 25.5　小结</span><br><span class="line"></span><br><span class="line"> 第26章　管理事务处理 26.1　事务处理 26.2　控制事务处理 26.2.1　使用ROLLBACK 26.2.2　使用COMMIT 26.2.3　使用保留点 26.2.4　更改默认的提交行为 26.3　小结</span><br><span class="line"></span><br><span class="line"> 第27章　全球化和本地化 27.1　字符集和校对顺序 27.2　使用字符集和校对顺序 27.3　小结</span><br><span class="line"></span><br><span class="line"> 第28章　安全管理 28.1　访问控制 28.2　管理用户 28.2.1　创建用户账号 28.2.2　删除用户账号 28.2.3　设置访问权限 28.2.4　更改口令 28.3　小结</span><br><span class="line"></span><br><span class="line"> 第29章　数据库维护 29.1　备份数据 29.2　进行数据库维护 29.3　诊断启动问题 29.4　查看日志文件 29.5　小结</span><br><span class="line"></span><br><span class="line"> 第30章　改善性能 30.1　改善性能 30.2　小结 附录A　MySQL入门 附录B　样例表 附录C　MySQL语句的语法 附录D　MySQL数据类型 附录E　MySQL保留字 索引</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001NMTX9S/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001NMTX9S&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/41KrEoGyuPL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式:可复用面向对象软件的基础</title>
    <url>/2020/04/19/she-ji-mo-shi-ke-fu-yong-mian-xiang-dui-xiang-ruan-jian-de-ji-chu/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： 设计模式:可复用面向对象软件的基础<br>作者信息： 作者: Erich Gamma [ 中文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>《设计模式:可复用面向对象软件的基础》是引导读者走出软件设计迷宫的指路明灯，凝聚了软件开发界几十年设计经验的结晶。四位顶尖的面向对象领域专家精心选取了最具价值的设计实践，加以分类整理和命名，并用简洁而易于重用的形式表达出来。本书已经成为面向对象技术人员的圣经和词典，书中定义的23个模式逐渐成为开发界技术交流所必备的基础知识和语汇。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">序言</span><br><span class="line">前言</span><br><span class="line">读者指南</span><br><span class="line">第一章 引言</span><br><span class="line">1.1 什么是设计模式</span><br><span class="line">1.2 Smalltalk MVC中的设计模式</span><br><span class="line">1.3 描述设计模式</span><br><span class="line">1.4 设计模式的编目</span><br><span class="line">1.5 组织编目</span><br><span class="line">1.6 设计模式怎样解决设计问题</span><br><span class="line">1.7 怎样选择设计模式</span><br><span class="line">1.8 怎样使用设计模式</span><br><span class="line">第二章 实例研究：设计一个文档编辑器</span><br><span class="line">2.1 设计问题</span><br><span class="line">2.2 文档结构</span><br><span class="line">2.3 格式化</span><br><span class="line">2.4 修饰用户界面</span><br><span class="line">2.5 支持多种视感标准</span><br><span class="line">2.6 支持多种窗口系统</span><br><span class="line">2.7 用户操作</span><br><span class="line">2.8 拼写检查和断字处理</span><br><span class="line">2.9 小结</span><br><span class="line">第三章 创建型模式</span><br><span class="line">3.1 ABSTRACT FACTORY（抽象工厂）——对象创建型模式</span><br><span class="line">3.2 BUILDER（生成器）——对象创建型模式</span><br><span class="line">3.3 FACTORY METHOD（工厂方法）——对象创建型模式</span><br><span class="line">3.4 PROTOTYPE（原型）——对象创建型模式</span><br><span class="line">3.5 SINGLETON（单件）——对象创建型模式</span><br><span class="line">第四章 结构型模式</span><br><span class="line">4.1 ADAPTER（适配器）——对象结构型模式</span><br><span class="line">4.2 BRIDGE（桥接）——对象结构型模式</span><br><span class="line">4.3 COMPOSITE（组成）——对象结构型模式</span><br><span class="line">4.4 DECORATOR（装饰）——对象结构型模式</span><br><span class="line">4.5 FACADE（外观）——对象结构型模式</span><br><span class="line">4.6 FLYWEIGHT（享元）——对象结构型模式</span><br><span class="line">4.7 PROXY（代理）——对象结构型模式</span><br><span class="line">4.8 结构型模式的讨论</span><br><span class="line">第五章 行为模式</span><br><span class="line">5.1 CHAIN OF RESPONSIBIL ITY（职责链）——对象行为型模式</span><br><span class="line">5.2 COMMAND（命令）——对象行为型模式</span><br><span class="line">5.3 INTERPRETER（解释器）——类行为型模式</span><br><span class="line">5.4 ITERATOR（迭代器）——对象行为型模式</span><br><span class="line">5.5 MEDIATOR（中介者）——对象行为型模式</span><br><span class="line">5.6 MEMENTO（备忘录）——对象行为型模式</span><br><span class="line">5.7 OBSERVER（观察者）——对象行为型模式</span><br><span class="line">5.8 STATE（状态）——对象行为型模式</span><br><span class="line">5.9 STRATEGY（策略）——对象行为型模式</span><br><span class="line">5.10 TEMPLATE METHOD（模板方法）——类行为型模式</span><br><span class="line">5.11 VISITOR（访问者）——对象行为型模式</span><br><span class="line">5.12 行为模式的讨论</span><br><span class="line">第六章 结论</span><br><span class="line">6.1 设计模式将带来什么</span><br><span class="line">6.2 一套通用的设计词汇</span><br><span class="line">6.3 书写文档和学习的辅助手段</span><br><span class="line">6.4 现有方法的一种补充</span><br><span class="line">6.5 重构的目标</span><br><span class="line">6.6 本书简史</span><br><span class="line">6.7 模式界</span><br><span class="line">6.8 Alexander的模式语言</span><br><span class="line">6.9 软件中的模式</span><br><span class="line">6.10 邀请参与</span><br><span class="line">6.11 临别感想</span><br><span class="line">附录A 词汇表</span><br><span class="line">附录B 图示符号指南</span><br><span class="line">附录C 基本类</span><br><span class="line">参考文献</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B001130JN8/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B001130JN8&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51EMEzFDfXL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>NoSQL精粹（英文）</title>
    <url>/2020/04/19/nosqljing-cui/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： NoSQL精粹（英文）<br>作者信息： 作者: 塞得拉吉 [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>世界级软件开发大师和软件开发“教父”Martin Fowler与Jolt生产效率大奖图书作者Pramod J. Sadalage最新力作，权威性毋庸置疑<br>全方位比较关系型数据库与NoSQL数据库的异同，详细讲解4大主流NoSQL数据库的优劣势、用法和适用场合，深入探讨实现NoSQL数据库系统的各种细节</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">译者序</span><br><span class="line">前言</span><br><span class="line">第一部分 概念</span><br><span class="line">第1章 为什么使用NoSQL2</span><br><span class="line">1.1 关系型数据库的价值3</span><br><span class="line">1.1.1 获取持久化数据3</span><br><span class="line">1.1.2 并发3</span><br><span class="line">1.1.3 集成4</span><br><span class="line">1.1.4 近乎标准的模型4</span><br><span class="line">1.2 阻抗失谐4</span><br><span class="line">1.3 “应用程序数据库”与“集成数据库”6</span><br><span class="line">1.4 蜂拥而来的集群8</span><br><span class="line">1.5 NoSQL登场9</span><br><span class="line">1.6 要点13</span><br><span class="line">第2章 聚合数据模型15</span><br><span class="line">2.1 聚合16</span><br><span class="line">2.1.1 关系模型与聚合模型示例16</span><br><span class="line">2.1.2 面向聚合的影响20</span><br><span class="line">2.2 键值数据模型与文档数据模型22</span><br><span class="line">2.3 列族存储23</span><br><span class="line">2.4 面向聚合数据库总结25</span><br><span class="line">2.5 延伸阅读26</span><br><span class="line">2.6 要点26</span><br><span class="line">第3章 数据模型详解27</span><br><span class="line">3.1 关系28</span><br><span class="line">3.2 图数据库29</span><br><span class="line">3.3 无模式数据库31</span><br><span class="line">3.4 物化视图33</span><br><span class="line">3.5 构建数据存取模型34</span><br><span class="line">3.6 要点39</span><br><span class="line">第4章 分布式模型40</span><br><span class="line">4.1 单一服务器41</span><br><span class="line">4.2 分片41</span><br><span class="line">4.3 主从复制43</span><br><span class="line">4.4 对等复制45</span><br><span class="line">4.5 结合“分片”与“复制”技术47</span><br><span class="line">4.6 要点48</span><br><span class="line">第5章 一致性49</span><br><span class="line">5.1 更新一致性50</span><br><span class="line">5.2 读取一致性51</span><br><span class="line">5.3 放宽“一致性”约束55</span><br><span class="line">5.4 放宽“持久性”约束60</span><br><span class="line">5.5 仲裁62</span><br><span class="line">5.6 延伸阅读63</span><br><span class="line">5.7 要点64</span><br><span class="line">第6章 版本戳65</span><br><span class="line">6.1 “商业事务”与“系统事务”66</span><br><span class="line">6.2 在多节点环境中生成版本戳68</span><br><span class="line">6.3 要点70</span><br><span class="line">第7章 映射—化简71</span><br><span class="line">7.1 基本“映射—化简”72</span><br><span class="line">7.2 分区与归并73</span><br><span class="line">7.3 组合“映射—化简”计算76</span><br><span class="line">7.3.1 举例说明两阶段“映射—化简”77</span><br><span class="line">7.3.2 增量式“映射—化简”80</span><br><span class="line">7.4 延伸阅读81</span><br><span class="line">7.5 要点81</span><br><span class="line">第二部分 实现</span><br><span class="line">第8章 键值数据库84</span><br><span class="line">8.1 何谓“键值数据库”85</span><br><span class="line">8.2 键值数据库特性86</span><br><span class="line">8.2.1 一致性86</span><br><span class="line">8.2.2 事务87</span><br><span class="line">8.2.3 查询功能87</span><br><span class="line">8.2.4 数据结构89</span><br><span class="line">8.2.5 可扩展性89</span><br><span class="line">8.3 适用案例90</span><br><span class="line">8.3.1 存放会话信息90</span><br><span class="line">8.3.2 用户配置信息90</span><br><span class="line">8.3.3 购物车数据90</span><br><span class="line">8.4 不适用场合90</span><br><span class="line">8.4.1 数据间关系90</span><br><span class="line">8.4.2 含有多项操作的事务91</span><br><span class="line">8.4.3 查询数据91</span><br><span class="line">8.4.4 操作关键字集合91</span><br><span class="line">第9章 文档数据库92</span><br><span class="line">9.1 何谓文档数据库93</span><br><span class="line">9.2 特性94</span><br><span class="line">9.2.1 一致性94</span><br><span class="line">9.2.2 事务95</span><br><span class="line">9.2.3 可用性96</span><br><span class="line">9.2.4 查询功能97</span><br><span class="line">9.2.5 可扩展性99</span><br><span class="line">9.3 适用案例100</span><br><span class="line">9.3.1 事件记录100</span><br><span class="line">9.3.2 内容管理系统及博客平台101</span><br><span class="line">9.3.3 网站分析与实时分析101</span><br><span class="line">9.3.4 电子商务应用程序101</span><br><span class="line">9.4 不适用场合101</span><br><span class="line">9.4.1 包含多项操作的复杂事务101</span><br><span class="line">9.4.2 查询持续变化的聚合结构101</span><br><span class="line">第10章 列族数据库102</span><br><span class="line">10.1 何谓列族数据库103</span><br><span class="line">10.2 特性103</span><br><span class="line">10.2.1 一致性105</span><br><span class="line">10.2.2 事务107</span><br><span class="line">10.2.3 可用性107</span><br><span class="line">10.2.4 查询功能108</span><br><span class="line">10.2.5 可扩展性110</span><br><span class="line">10.3 适用案例110</span><br><span class="line">10.3.1 事件记录110</span><br><span class="line">10.3.2 内容管理系统与博客平台111</span><br><span class="line">10.3.3 计数器111</span><br><span class="line">10.3.4 限期使用111</span><br><span class="line">10.4 不适用场合112</span><br><span class="line">第11章 图数据库113</span><br><span class="line">11.1 何谓图数据库114</span><br><span class="line">11.2 特性115</span><br><span class="line">11.2.1 一致性116</span><br><span class="line">11.2.2 事务117</span><br><span class="line">11.2.3 可用性117</span><br><span class="line">11.2.4 查询功能118</span><br><span class="line">11.2.5 可扩展性121</span><br><span class="line">11.3 适用案例122</span><br><span class="line">11.3.1 互联数据122</span><br><span class="line">11.3.2 安排运输路线、分派货物和基于位置的服务123</span><br><span class="line">11.3.3 推荐引擎123</span><br><span class="line">11.4 不适用场合123</span><br><span class="line">第12章 模式迁移124</span><br><span class="line">12.1 模式变更125</span><br><span class="line">12.2 变更关系型数据库的模式125</span><br><span class="line">12.2.1 迁移全新项目126</span><br><span class="line">12.2.2 迁移既有项目127</span><br><span class="line">12.3 变更NoSQL数据库的模式129</span><br><span class="line">12.3.1 增量迁移131</span><br><span class="line">12.3.2 迁移图数据库的模式132</span><br><span class="line">12.3.3 改变聚合结构132</span><br><span class="line">12.4 延伸阅读133</span><br><span class="line">12.5 要点133</span><br><span class="line">第13章 混合持久化134</span><br><span class="line">13.1 各异的数据存储需求135</span><br><span class="line">13.2 混用各类数据库135</span><br><span class="line">13.3 将直接数据库操作封装为服务137</span><br><span class="line">13.4 扩展数据库以增强其功能138</span><br><span class="line">13.5 选用合适的数据库技术139</span><br><span class="line">13.6 企业使用混合持久化技术时的考量139</span><br><span class="line">13.7 部署复杂度140</span><br><span class="line">13.8 要点140</span><br><span class="line">第14章 超越NoSQL141</span><br><span class="line">14.1 文件系统142</span><br><span class="line">14.2 事件溯源142</span><br><span class="line">14.3 内存映像145</span><br><span class="line">14.4 版本控制146</span><br><span class="line">14.5 XML数据库146</span><br><span class="line">14.6 对象数据库147</span><br><span class="line">14.7 要点147</span><br><span class="line">第15章 选择合适的数据库148</span><br><span class="line">15.1 程序员的工作效率149</span><br><span class="line">15.2 数据访问性能150</span><br><span class="line">15.3 继续沿用默认的关系型数据库151</span><br><span class="line">15.4 抽离数据库策略以降低风险152</span><br><span class="line">15.5 要点153</span><br><span class="line">15.6 结语153</span><br><span class="line">参考资料154</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/B00EEQ2GPS/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B00EEQ2GPS&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51gSQI5N-PL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU28_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Rootkit:系统灰色地带的潜伏者(英文)</title>
    <url>/2020/04/19/the-rootkit-arsenal-escape-and-evasion-in-the-dark-corners-of-the-system/</url>
    <content><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>名称： Rootkit:系统灰色地带的潜伏者(英文)<br>作者信息： 作者: Bill Blunden [ 英文 pdf ]</p>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>While forensic analysis has proven to be a valuable investigative tool in the field of computer security, utilizing anti-forensic technology makes it possible to maintain a covert operational foothold for extended periods, even in a high-security environment. Adopting an approach that favors full disclosure, the updated Second Edition of The Rootkit Arsenal presents the most accessible, timely, and complete coverage of forensic countermeasures. This book covers more topics, in greater depth, than any other currently available. In doing so the author forges through the murky back alleys of the Internet, shedding light on material that has traditionally been poorly documented, partially documented, or intentionally undocumented. The range of topics presented includes how to: -Evade post-mortem analysis -Frustrate attempts to reverse engineer your command &amp; control modules -Defeat live incident response -Undermine the process of memory analysis -Modify subsystem internals to feed misinformation to the outside -Entrench your code in fortified regions of execution -Design and implement covert channels -Unearth new avenues of attack</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Part I  Foundation</span><br><span class="line">Chapter 1  Empty Cup Mind</span><br><span class="line">Chapter 2  Anti-Forensics Overview</span><br><span class="line">Chapter 3  Hardware Briefing</span><br><span class="line">Chapter 4  System Software Briefing</span><br><span class="line">Chapter 5  Tools of the Trade</span><br><span class="line">Chapter 6  Life in Kernel Space</span><br><span class="line">Part II  Post-Mortem</span><br><span class="line">Chapter 7  Defeating Disk Analysis</span><br><span class="line">Chapter 8  Foiling Executable Analysis</span><br><span class="line">Part III  Live Response</span><br><span class="line">Chapter 9  Defeating Live Response</span><br><span class="line">Chapter 10  Shellcode</span><br><span class="line">Chapter 11  Modifying Call Tables</span><br><span class="line">Chapter 12  Modifying Code</span><br><span class="line">Chapter 13  Modifying Objects Kernel</span><br><span class="line">Chapter 14  Covert Channels</span><br><span class="line">Chapter 15  Going Out-of-Band</span><br><span class="line">Part IV  Summation</span><br><span class="line">Chapter 16  The Tao of Rootkits</span><br></pre></td></tr></table></figure>


<h1 id="亚马逊链接"><a href="#亚马逊链接" class="headerlink" title="亚马逊链接"></a>亚马逊链接</h1><p><a href="http://www.amazon.cn/gp/product/144962636X/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=144962636X&linkCode=as2&tag=bringmeluck-23" target="_blank" rel="noopener"><img src="http://ec4.images-amazon.com/images/I/51ohd5tbf0L._SL500_AA300_.jpg"/></a></p>
]]></content>
      <tags>
        <tag>信息安全</tag>
      </tags>
  </entry>
</search>
